<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>C Pointers Dynamic Memory Allocation with Pointers</title>
<link rel='shortcut icon' href='https://readbytes.github.io/images/favicon.ico'>
<link href="https://fonts.googleapis.com/css2?family=Merriweather&display=swap" rel="stylesheet" />
<link href="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet" />
<script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/prism.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/codemirror.min.css" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/codemirror.min.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/theme/dracula.min.css"><style>
html {scroll-behavior: smooth;}  
body {font-family: 'Merriweather', serif;;margin: 0;padding: 2rem 1rem;font-size: 15px;line-height: 1.5;transition: background-color 0.3s, color 0.3s;}
.container {max-width: 750px;margin: 0 auto;padding: 1rem 2rem;}
.light-mode {background-color: #f8f7f5;color: #333;} 
.dark-mode {background-color: #121212;color: #e0e0e0;}
a { text-decoration: none;transition: color 0.2s;}
a:hover {text-decoration: underline;}
.light-mode a {color: #555;}
.dark-mode a {color: #aaa;}
</style><style>
.related-book-list {display: flex;flex-wrap: wrap;gap: 20px;}
.related-books {margin-top: 40px;}
.related-books h2 {font-size: 22px;margin-bottom: 20px;border-bottom: 2px solid #eee;padding-bottom: 8px;}
.light-mode .related-books h2 {color: #333;border-color: #eee;}
.dark-mode .related-books h2 {color: #ddd;border-color: #333;}
</style><style>
.book-cover {width: 130px;height: 180px;font-family: Arial, sans-serif;position: relative;overflow: hidden;box-shadow: 2px 2px 4px rgba(0,0,0,0.1);}
.book-cover-bottom-stripe {position: absolute;bottom: 0;left: 0;height: 5px;width: 100%;}
.book-cover-title {position: absolute;width: 100%;text-align: center;font-weight: bold;}
.book-cover-icon {position: absolute;left: 50%;transform: translateX(-50%);display: flex;align-items: center;justify-content: center;}
.book-cover-author {position: absolute;bottom: 10px;width: 100%;text-align: center;font-size: 8px;color: #333;}
</style><style>
.book-title-toc {font-size: 32px;font-weight: bold; }
.book-subtitle-toc {font-size: 18px;margin-top: 8px;font-style: italic;}
.book-header {text-align: center;margin-bottom: 40px;}

.toc-container {border-radius: 10px;padding: 30px;margin-bottom: 40px;box-shadow: 0 8px 20px rgba(0,0,0,0.05);}
h1 {font-size: 24px;text-align: center;margin-bottom: 30px;letter-spacing: 1px;padding-bottom: 10px;}
.toc-list,.toc-section-list {list-style: none;padding: 0;margin: 0;}
.toc-section-list {padding-left: 18px;margin-top: 6px;margin-bottom: 20px; }
.toc-chapter {padding: 20px 0;}
.chapter-title,.toc-section {display: flex;justify-content: space-between;padding-top: 4px;}
.chapter-title {font-size: 17px;font-weight: bold;}
.chapter-page,.section-page {font-style: italic;}
 
 
.light-mode .book-title-toc,.light-mode .chapter-title,.light-mode .book-name {color: #222;}
.light-mode .book-subtitle-toc,.light-mode .book-sub,.light-mode .chapter-page,.light-mode .section-page {color: #666;}
.light-mode .toc-container { background: #fff;border: 1px solid #ddd;}
.light-mode h1 {border-bottom: 2px solid #eee;color: #222;}
.light-mode .toc-section {  color: #444;}

.light-mode .book-cover { border: 1px solid #ccc;box-shadow: 0 6px 12px rgba(0, 0, 0, 0.15);}
.light-mode .book-title,.light-mode .series-name {color: #fff;}
.light-mode .book-subtitle,.light-mode .book-footer {color: #aaa;}

.dark-mode .book-title-toc,.dark-mode .chapter-title,.dark-mode .book-name {color: #f5f5f5;}
.dark-mode .book-subtitle-toc,.dark-mode .book-sub,.dark-mode .chapter-page,.dark-mode .section-page {color: #aaa;}
.dark-mode .toc-container {background: #1e1e1e;border: 1px solid #444;}

.dark-mode h1 {border-bottom: 2px solid #333;color: #eee;}
.dark-mode .toc-section {color: #bbb;}

.dark-mode .related-books h2 {color: #ddd;border-bottom: 2px solid #333;}
.dark-mode .book-title,.dark-mode .series-name {color: #fff;}
.dark-mode .book-subtitle,.dark-mode .book-footer {color: #bbb;}
.dark-mode .toc-section {color: #ddd;}

@media (max-width: 600px) {
  .chapter-title,
  .toc-section {
    flex-direction: column;
    align-items: flex-start;
  }

  .chapter-page,
  .section-page {
    margin-top: 4px;
  }
}

</style><style>
.light-mode .container {box-shadow: 0 0 15px rgba(0,0,0,0.1);}
.dark-mode .container {box-shadow: 0 0 15px rgba(255, 255, 255, 0.05);}

h1, h2, h3 {font-weight: 600;margin-top: 2.5rem;margin-bottom: 1rem;line-height: 1.2;}
h1 { font-size: 1.8rem; }
h2 { font-size: 1.4rem; }
h3 { font-size: 1.2rem; }

table {width: 100%;border-collapse: collapse;font-family: sans-serif;font-size: 1em;margin: 1em 0;}
th, td {padding: 0.6em 1em;text-align: left;border: 1px solid;}
tr:nth-child(even) {  background-color: inherit;}
tr:hover { background-color: inherit;}

code {color: #d35400;}

.chapter-navi-section {display: flex;justify-content: space-between;align-items: center;padding-bottom: 10px;padding-top: 10px;}
.nav-link {color: inherit;text-decoration: none;opacity: 0.5;transition: opacity 0.3s ease, text-decoration 0.3s ease;}
.nav-link:hover {opacity: 0.9;text-decoration: underline;}
.prev { text-align: left; }
.toc-link { text-align: center; }
.next { text-align: right; }

.download-section {display: flex;align-items: center;justify-content: center;gap: 2rem;padding: 2rem 1rem;max-width: 600px;margin: 3rem auto;border-radius: 12px;box-shadow: 0 4px 10px rgba(0,0,0,0.05);}
.download-info h2 {margin: 0 0 0.5rem;font-size: 1.2rem;}
.format-label {margin: 0 0 0.5rem;font-size: 0.95rem;}
.download-buttons {display: flex;gap: 1rem;}
.download-button {background-color: #4A90E2;color: white;padding: 0.5em 1.2em;border-radius: 25px;font-size: 0.95rem;text-decoration: none;transition: background-color 0.3s ease;}
.download-button:hover {background-color: #357ABD;}

.code-block {position: relative;margin-bottom: 1em;}
.copy-button {background: transparent;color: white;position: absolute;top: 8px;right: 8px;border: none;padding: 4px 8px;font-size: 12px;border-radius: 4px;cursor: pointer;z-index: 1;}
.copy-button:hover {background-color: #0056b3;}

.snippet-container {overflow: hidden;}
.snippet-header {padding: 0.75rem 1rem;cursor: pointer;font-size: 1rem;background-color: #eeeeee;color:  #111111; border-radius: 8px;cursor: pointer;box-shadow: 0 4px 6px rgba(0,0,0,0.1); }
.snippet-body {display: none;font-family: monospace;}
.snippet-container.open .snippet-body {display: block;}

.CodeMirror {border: 2px solid #ccc;border-radius: 4px;resize: vertical;}

.light-mode .format-label {color: #888;}
.light-mode th {background-color: #f2f2f2;}
.light-mode tr:nth-child(even) {background-color: #fafafa;}
.light-mode tr:hover {background-color: #e6f7ff;}

.dark-mode .snippet-header {background-color: #333;color:  #ddd; }
.dark-mode .format-label {color: #aaa;}
.dark-mode th {background-color: #333;color: #fff;}
.dark-mode td {border-color: #444;}
.dark-mode tr:nth-child(even) {background-color: #2a2a2a;}
.dark-mode tr:hover {background-color: #2c3e50;}


.button-group-run-edit {display: flex;width: 100%;gap: 1rem;}
.button-run-edit {flex: 1;padding: 1rem;font-size: 1rem;font-weight: 600;border: none;border-radius: 8px;cursor: pointer;transition: background 0.3s, color 0.3s;}

.light-mode .button-run-edit {background-color: #f0f0f0;color: #222;box-shadow: 0 0 10px rgba(0, 0, 0, 0.05);}
.light-mode .button-run-edit:hover {background-color: #e0e0e0;}

.dark-mode .button-run-edit {background-color: #2a2a2a;color: #f5f5f5;box-shadow: 0 0 10px rgba(255, 255, 255, 0.05);}
.dark-mode .button-run-edit:hover {background-color: #3a3a3a;}

button { padding: 0.5em 1em; background: green; color: white; border: none; cursor: pointer; }
button:hover { background: #1e7e34; }
.result_iframe { width:99%; margin-top: 1em;  resize: both;background-color: #515b63;border:1px solid #ccc;}   

.dialog-backdrop {position: fixed;top: 0;left: 0;width: 100vw;height: 100vh;background: rgba(0,0,0,0.5);display: none;justify-content: center;align-items: center;z-index: 10;}
.dialog {background: #90979e;padding: 20px;width: 90vw;height: 80vh;border-radius: 8px;box-shadow: 0 0 20px rgba(0,0,0,0.3);display: flex;flex-direction: column;}
.dialog-content {display: flex;gap: 20px;margin-top: 10px;height: calc(100% - 40px);}
.editor-container, .preview-container {flex: 1;height: 100%;max-height: 100%;overflow: hidden; }
.result_iframe_dialog {width: 100%;height: 100%;resize: both;border:1px solid #ccc;overflow: auto; }   
.CodeMirror {width: 100% !important;height: 100% !important;}
</style>
</head>
<body>
<script>const mode = localStorage.getItem('mode') || 'light';document.documentElement.classList.add(`${mode}-mode`);</script>  
<div class="container"><div class = "chapter-navi-section">
<a href="c-pointers-pointers-to-pointers-and-multilevel-indirection.htm" class="nav-button prev">←</a>
<a href='c-pointers.htm#dynamic-memory-allocation-with-pointers' class="nav-button toc-link">Index</a>
<a href="c-pointers-structures-and-pointers.htm" class="nav-button next">→</a>
</div>
<div class='book-header'><h1 class='book-title-toc' id = 'top'>Dynamic Memory Allocation with Pointers</h1><h3 class='book-subtitle-toc'>C Pointers</h3></div><h2 id='introduction-to-malloc-calloc-realloc-and-free'>6.1 Introduction to <code>malloc()</code>, <code>calloc()</code>, <code>realloc()</code>, and <code>free()</code></h2><p>In C, most memory management is <strong>manual</strong>, meaning you have full control over when memory is allocated and freed. This allows for powerful, efficient programs—but also means you must manage memory <strong>carefully</strong> to avoid errors like memory leaks or segmentation faults.</p><p>This section introduces the four key functions used for <strong>dynamic memory allocation</strong> in C:</p><ul>
 <li><code>malloc()</code> — Allocate memory</li>
 <li><code>calloc()</code> — Allocate and zero-initialize memory</li>
 <li><code>realloc()</code> — Resize previously allocated memory</li>
 <li><code>free()</code> — Deallocate memory</li>
</ul><h3 id="why-use-dynamic-memory-allocation">Why Use Dynamic Memory Allocation?</h3><p>Dynamic memory allocation is useful when:</p><ul>
 <li>You don’t know the required size of data at compile time.</li>
 <li>You want to allocate memory based on user input or file data.</li>
 <li>You’re building flexible data structures (e.g., linked lists, trees, resizable arrays).</li>
</ul><h3 id="malloc-memory-allocation"><code>malloc()</code> Memory Allocation</h3><p><code>malloc()</code> stands for <strong>memory allocation</strong>. It allocates a specified number of bytes and returns a pointer to the beginning of the block.</p><h3 id="syntax">Syntax:</h3><div class="code-block">
 <button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-c">void *malloc(size_t size);</code></pre>
</div><h3 id="example">Example:</h3><div class="code-block">
 <button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-c">int *arr = malloc(5 * sizeof(int));  // Allocates memory for 5 integers
if (arr == NULL) {
    printf("Memory allocation failed\n");
}</code></pre>
</div><ul>
 <li>Returns <code>NULL</code> if the allocation fails.</li>
 <li>Memory is <strong>uninitialized</strong>—may contain garbage values.</li>
</ul><h3 id="calloc-contiguous-allocation-zero-initialized"><code>calloc()</code> Contiguous Allocation (Zero-Initialized)</h3><p><code>calloc()</code> allocates memory like <code>malloc()</code>, but also <strong>initializes all bytes to zero</strong>.</p><h3 id="syntax">Syntax:</h3><div class="code-block">
 <button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-c">void *calloc(size_t num_elements, size_t element_size);</code></pre>
</div><h3 id="example">Example:</h3><div class="code-block">
 <button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-c">int *arr = calloc(5, sizeof(int));  // Allocates and zeros memory for 5 ints</code></pre>
</div><ul>
 <li>Useful when you want to ensure memory starts with zero values.</li>
 <li>Returns <code>NULL</code> on failure.</li>
</ul><h3 id="realloc-resize-memory"><code>realloc()</code> Resize Memory</h3><p><code>realloc()</code> changes the size of a memory block previously allocated with <code>malloc()</code> or <code>calloc()</code>. It may move the block to a new location.</p><h3 id="syntax">Syntax:</h3><div class="code-block">
 <button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-c">void *realloc(void *ptr, size_t new_size);</code></pre>
</div><h3 id="example">Example:</h3><div class="code-block">
 <button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-c">int *arr = malloc(3 * sizeof(int));
// ... use arr ...
arr = realloc(arr, 6 * sizeof(int));  // Resize to hold 6 ints</code></pre>
</div><ul>
 <li>Contents are preserved up to the smaller of the old or new size.</li>
 <li>If moved, the original block is freed automatically.</li>
 <li>Returns <code>NULL</code> on failure (old block is not freed if this happens).</li>
</ul><h3 id="free-deallocation"><code>free()</code> Deallocation</h3><p>When you're done with dynamically allocated memory, use <code>free()</code> to release it back to the system.</p><h3 id="syntax">Syntax:</h3><div class="code-block">
 <button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-c">void free(void *ptr);</code></pre>
</div><h3 id="example">Example:</h3><div class="code-block">
 <button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-c">free(arr);
arr = NULL;  // Good practice to avoid dangling pointer</code></pre>
</div><ul>
 <li>Never <code>free()</code> memory that was not allocated with <code>malloc</code>, <code>calloc</code>, or <code>realloc</code>.</li>
 <li>Always set the pointer to <code>NULL</code> after freeing it to prevent accidental use.</li>
</ul><h3 id="summary-table">Summary Table</h3><table>
 <thead>
  <tr>
   <th>Function</th>
   <th>Purpose</th>
   <th>Initializes Memory?</th>
   <th>Returns <code>NULL</code> on Failure?</th>
  </tr>
 </thead>
 <tbody>
  <tr>
   <td><code>malloc</code></td>
   <td>Allocate memory</td>
   <td>❌ No</td>
   <td>✅ Yes</td>
  </tr>
  <tr>
   <td><code>calloc</code></td>
   <td>Allocate and zero memory</td>
   <td>✅ Yes</td>
   <td>✅ Yes</td>
  </tr>
  <tr>
   <td><code>realloc</code></td>
   <td>Resize allocated memory</td>
   <td>❌ No</td>
   <td>✅ Yes</td>
  </tr>
  <tr>
   <td><code>free</code></td>
   <td>Release allocated memory</td>
   <td>N/A</td>
   <td>N/A</td>
  </tr>
 </tbody>
</table><h3 id="good-practices">Good Practices</h3><ul>
 <li>Always check if the returned pointer is <code>NULL</code>.</li>
 <li>Use <code>sizeof(type)</code> for correct allocation size.</li>
 <li>Set pointers to <code>NULL</code> after freeing them.</li>
 <li>Don’t <code>free()</code> memory more than once (double free).</li>
 <li>Use <code>calloc()</code> when zero-initialization is needed.</li>
</ul><h3 id="example-putting-it-all-together">Example: Putting It All Together</h3><div class="code-block">
 <button class="copy-button" onclick="copyCode(this)">📋</button>
 <pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main() {
    int n = 5;

    // Allocate memory using calloc (zero-initialized)
    int *arr = calloc(n, sizeof(int));
    if (arr == NULL) {
        printf("Memory allocation failed\n");
        return 1;
    }

    // Modify the array
    for (int i = 0; i &lt; n; i++) {
        arr[i] = i + 1;
    }

    // Resize the array
    arr = realloc(arr, 10 * sizeof(int));
    if (arr == NULL) {
        printf("Reallocation failed\n");
        return 1;
    }

    // Add more values
    for (int i = 5; i &lt; 10; i++) {
        arr[i] = (i + 1) * 10;
    }

    // Print the array
    for (int i = 0; i &lt; 10; i++) {
        printf("%d ", arr[i]);
    }
    printf("\n");

    // Free memory
    free(arr);
    arr = NULL;

    return 0;
}</code></pre>
</div><h3 id="summary">Summary</h3><p>Dynamic memory functions in C let you create flexible, resizable, and efficient programs:</p><ul>
 <li>Use <code>malloc()</code> for basic allocation.</li>
 <li>Use <code>calloc()</code> when zero-initialization is needed.</li>
 <li>Use <code>realloc()</code> to resize blocks dynamically.</li>
 <li>Always <code>free()</code> allocated memory when done.</li>
</ul><div class = "chapter-navi-section">
<a href="#top" class="nav-button prev">↑</a>
<a href='c-pointers.htm#dynamic-memory-allocation-with-pointers' class="nav-button toc-link">Index</a>
<a href="#bottom" class="nav-button next">↓</a>
</div>
<h2 id='allocating-and-managing-memory-at-runtime'>6.2 Allocating and Managing Memory at Runtime</h2><p>In C, <strong>runtime memory allocation</strong> allows you to reserve memory while the program is running—rather than fixing memory sizes at compile time. This enables creation of flexible, data-driven applications that can handle variable input sizes, dynamic data structures, and real-time memory management.</p><p>This section walks through how to:</p><ul>
 <li>Allocate memory using <code>malloc()</code> and <code>calloc()</code></li>
 <li>Store addresses in pointers</li>
 <li>Check allocation success</li>
 <li>Manage the memory lifecycle</li>
 <li>Work with dynamically allocated <strong>single variables</strong> and <strong>arrays</strong></li>
</ul><h3 id="why-allocate-memory-at-runtime">Why Allocate Memory at Runtime?</h3><p>Compile-time allocation (e.g., <code>int arr[100];</code>) fixes memory size regardless of actual needs. In contrast, <strong>runtime allocation</strong> allows:</p><ul>
 <li>Creating arrays of size based on user input</li>
 <li>Dynamically expanding or shrinking data structures</li>
 <li>Managing memory more efficiently in long-running or resource-limited applications</li>
</ul><h3 id="allocating-a-single-variable-dynamically">Allocating a Single Variable Dynamically</h3><p>To dynamically allocate a single variable:</p><div class="code-block">
 <button class="copy-button" onclick="copyCode(this)">📋</button>
 <pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main() {
    int *ptr = malloc(sizeof(int));  // Allocate memory for one int

    if (ptr == NULL) {
        printf("Memory allocation failed\n");
        return 1;
    }

    *ptr = 42;  // Assign value
    printf("Value: %d\n", *ptr);

    free(ptr);  // Free memory
    return 0;
}</code></pre>
</div><h3 id="key-points">Key Points:</h3><ul>
 <li><code>malloc(sizeof(int))</code> allocates memory for one integer.</li>
 <li>The result of <code>malloc()</code> must be <strong>cast</strong> in C++ but not in C.</li>
 <li>Always <strong>check if the pointer is NULL</strong> before use.</li>
</ul><h3 id="allocating-an-array-dynamically">Allocating an Array Dynamically</h3><p>You can allocate memory for an array based on a variable size:</p><div class="code-block">
 <button class="copy-button" onclick="copyCode(this)">📋</button>
 <pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main() {
    int n;
    printf("Enter number of elements: ");
    scanf("%d", &amp;n);

    int *arr = malloc(n * sizeof(int));  // Allocate array

    if (arr == NULL) {
        printf("Allocation failed.\n");
        return 1;
    }

    // Initialize and print array
    for (int i = 0; i &lt; n; i++) {
        arr[i] = i + 1;
        printf("%d ", arr[i]);
    }

    free(arr);  // Free memory
    return 0;
}</code></pre>
</div><h3 id="alternative-with-calloc">Alternative with <code>calloc()</code>:</h3><div class="code-block">
 <button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-c">int *arr = calloc(n, sizeof(int));  // Allocates and zero-initializes</code></pre>
</div><h3 id="managing-memory-lifecycle">Managing Memory Lifecycle</h3><p>Properly managing dynamically allocated memory includes:</p><table>
 <thead>
  <tr>
   <th>Stage</th>
   <th>What to Do</th>
  </tr>
 </thead>
 <tbody>
  <tr>
   <td>Allocation</td>
   <td>Use <code>malloc()</code> / <code>calloc()</code></td>
  </tr>
  <tr>
   <td>Check allocation success</td>
   <td>Verify pointer is not <code>NULL</code></td>
  </tr>
  <tr>
   <td>Use memory</td>
   <td>Assign values, read/write safely</td>
  </tr>
  <tr>
   <td>Deallocation</td>
   <td>Call <code>free(ptr)</code> once you're done</td>
  </tr>
  <tr>
   <td>Cleanup</td>
   <td>Set pointer to <code>NULL</code> to avoid reuse</td>
  </tr>
 </tbody>
</table><h3 id="modifying-allocated-memory">Modifying Allocated Memory</h3><p>Example: Resizing a dynamic array</p><div class="code-block">
 <button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-c">int *arr = malloc(5 * sizeof(int));
arr = realloc(arr, 10 * sizeof(int));  // Resize to 10 elements</code></pre>
</div><p>Always check the result of <code>realloc()</code> in case it fails:</p><div class="code-block">
 <button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-c">int *temp = realloc(arr, new_size * sizeof(int));
if (temp != NULL) {
    arr = temp;
} else {
    // Handle failure gracefully
}</code></pre>
</div><h3 id="common-pitfalls">Common Pitfalls</h3><ul>
 <li><strong>Using memory without checking for NULL</strong> can cause segmentation faults.</li>
 <li><strong>Forgetting to <code>free()</code></strong> leads to <strong>memory leaks</strong>.</li>
 <li><strong>Double-freeing memory</strong> results in undefined behavior.</li>
 <li><strong>Dangling pointers</strong>: Accessing memory after <code>free()</code>.</li>
</ul><h3 id="best-practices">Best Practices</h3><ul>
 <li>Always initialize pointers: <code>int *ptr = NULL;</code></li>
 <li>Always check return values of <code>malloc()</code>, <code>calloc()</code>, and <code>realloc()</code></li>
 <li>Call <code>free()</code> as soon as you're done using memory</li>
 <li>Use tools like Valgrind (on Linux) to detect memory leaks</li>
</ul><h3 id="summary">Summary</h3><ul>
 <li>Use <code>malloc()</code> or <code>calloc()</code> to allocate memory at runtime.</li>
 <li>Store the returned pointer and always check for <code>NULL</code>.</li>
 <li>Dynamically allocate memory for both single values and arrays.</li>
 <li>Remember to <code>free()</code> all allocated memory to avoid leaks.</li>
</ul><div class = "chapter-navi-section">
<a href="#top" class="nav-button prev">↑</a>
<a href='c-pointers.htm#dynamic-memory-allocation-with-pointers' class="nav-button toc-link">Index</a>
<a href="#bottom" class="nav-button next">↓</a>
</div>
<h2 id='handling-memory-leaks-and-errors'>6.3 Handling Memory Leaks and Errors</h2><p>Dynamic memory allocation in C gives you powerful control over memory usage, but with that control comes responsibility. Without proper management, bugs like <strong>memory leaks</strong>, <strong>double frees</strong>, and <strong>dangling pointers</strong> can cause programs to crash, slow down, or behave unpredictably.</p><p>This section explains <strong>common memory errors</strong>, how to <strong>detect them</strong>, and how to <strong>avoid them</strong> using best practices and tools.</p><h3 id="common-dynamic-memory-errors">Common Dynamic Memory Errors</h3><h4 id="memory-leaks">Memory Leaks</h4><p>A memory leak occurs when dynamically allocated memory is never freed. This wastes memory and can exhaust system resources over time.</p><p><strong>Example:</strong></p><div class="code-block">
 <button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-c">int *ptr = malloc(100 * sizeof(int));
// Forgot to free(ptr); → memory leak</code></pre>
</div><h4 id="how-to-avoid">How to Avoid:</h4><ul>
 <li>Always <code>free()</code> memory when it’s no longer needed.</li>
 <li>Use consistent naming and organization to track allocations.</li>
</ul><h4 id="double-free">Double Free</h4><p>Calling <code>free()</code> more than once on the same pointer leads to undefined behavior. This can crash your program or corrupt the heap.</p><p><strong>Example:</strong></p><div class="code-block">
 <button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-c">int *ptr = malloc(sizeof(int));
free(ptr);
free(ptr);  // ❌ dangerous!</code></pre>
</div><h4 id="how-to-avoid">How to Avoid:</h4><ul>
 <li><p>After freeing a pointer, <strong>set it to <code>NULL</code></strong>:</p>
  <div class="code-block">
   <button class="copy-button" onclick="copyCode(this)">▯</button>
   <pre><code class="language-c">free(ptr);
ptr = NULL;</code></pre>
  </div></li>
 <li><p>Always check if a pointer is <code>NULL</code> before freeing:</p>
  <div class="code-block">
   <button class="copy-button" onclick="copyCode(this)">▯</button>
   <pre><code class="language-c">if (ptr != NULL) {
    free(ptr);
    ptr = NULL;
}</code></pre>
  </div></li>
</ul><h4 id="dangling-pointer">Dangling Pointer</h4><p>A dangling pointer occurs when a pointer still references memory that has already been freed.</p><p><strong>Example:</strong></p><div class="code-block">
 <button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-c">int *ptr = malloc(sizeof(int));
free(ptr);
// Still using ptr here is invalid: ptr is dangling
*ptr = 10;  // ❌ crash or undefined behavior</code></pre>
</div><h4 id="how-to-avoid">How to Avoid:</h4><ul>
 <li>Set pointers to <code>NULL</code> after freeing them.</li>
 <li>Avoid accessing memory after <code>free()</code>.</li>
</ul><h3 id="debugging-memory-issues">Debugging Memory Issues</h3><p>Even careful programmers make mistakes. Tools can help you <strong>detect</strong> and <strong>debug</strong> memory problems.</p><h3 id="valgrind-linux-macos">Valgrind (Linux/macOS)</h3><p>Valgrind is a powerful tool to find:</p><ul>
 <li>Memory leaks</li>
 <li>Use of uninitialized memory</li>
 <li>Accessing freed memory</li>
</ul><p><strong>Compile your program with debug symbols:</strong></p><div class="code-block">
 <button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-bash">gcc -g your_program.c -o your_program</code></pre>
</div><p><strong>Run with Valgrind:</strong></p><div class="code-block">
 <button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-bash">valgrind --leak-check=full ./your_program</code></pre>
</div><p><strong>Output sample:</strong></p><div class="code-block">
 <button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-bash">==1234== 100 bytes in 1 blocks are definitely lost in loss record 1 of 1</code></pre>
</div><p>Valgrind will point you to the line where memory was allocated and not freed.</p><h3 id="other-debugging-techniques">Other Debugging Techniques</h3><ul>
 <li><strong>Use print statements</strong> to track allocations and deallocations.</li>
 <li><strong>Maintain a record</strong> (e.g., comments or logs) of every allocation and <code>free()</code>.</li>
 <li><strong>Use custom wrappers</strong> around <code>malloc()</code> and <code>free()</code> for logging.</li>
</ul><h3 id="best-practices-to-prevent-memory-errors">Best Practices to Prevent Memory Errors</h3><table>
 <thead>
  <tr>
   <th>Practice</th>
   <th>Benefit</th>
  </tr>
 </thead>
 <tbody>
  <tr>
   <td>Check if <code>malloc()</code>/<code>calloc()</code> returns <code>NULL</code></td>
   <td>Prevents null dereference crashes</td>
  </tr>
  <tr>
   <td>Free all allocated memory</td>
   <td>Prevents memory leaks</td>
  </tr>
  <tr>
   <td>Set pointers to <code>NULL</code> after <code>free()</code></td>
   <td>Prevents dangling pointers</td>
  </tr>
  <tr>
   <td>Avoid freeing memory twice</td>
   <td>Prevents heap corruption</td>
  </tr>
  <tr>
   <td>Use tools like Valgrind</td>
   <td>Detects leaks and invalid memory use</td>
  </tr>
 </tbody>
</table><h3 id="safe-memory-management-pattern">Safe Memory Management Pattern</h3><div class="code-block">
 <button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-c">int *ptr = malloc(10 * sizeof(int));
if (ptr == NULL) {
    // Handle allocation failure
}

// Use ptr...

free(ptr);
ptr = NULL;  // Safe: avoids dangling pointer and double free</code></pre>
</div><h3 id="summary">Summary</h3><p>Dynamic memory bugs can be hard to find, but understanding and avoiding them is essential for writing safe, reliable C programs:</p><ul>
 <li><strong>Memory leaks</strong> waste memory and degrade performance.</li>
 <li><strong>Double frees</strong> and <strong>dangling pointers</strong> can cause crashes and unpredictable behavior.</li>
 <li>Tools like <strong>Valgrind</strong> help detect and debug memory problems.</li>
 <li>Following <strong>safe coding practices</strong> and freeing memory responsibly will keep your programs efficient and stable.</li>
</ul><div class = "chapter-navi-section">
<a href="#top" class="nav-button prev">↑</a>
<a href='c-pointers.htm#dynamic-memory-allocation-with-pointers' class="nav-button toc-link">Index</a>
<a href="#bottom" class="nav-button next">↓</a>
</div>
<h2 id='examples-dynamic-arrays-linked-list-node-allocation'>6.4 Examples: Dynamic Arrays, Linked List Node Allocation</h2><p>Dynamic memory allocation is a cornerstone of flexible and efficient data structure management in C. In this section, we explore two key use cases:</p><ul>
 <li>Creating and resizing <strong>dynamic arrays</strong></li>
 <li>Allocating and managing <strong>linked list nodes</strong></li>
</ul><p>You’ll learn how to use <code>malloc()</code>, <code>realloc()</code>, and <code>free()</code> with pointers to build scalable structures at runtime.</p><h3 id="example-1-dynamic-array-creation-and-resizing">Example 1: Dynamic Array Creation and Resizing</h3><p>Dynamic arrays let you allocate space as needed and grow as required.</p><h3 id="allocate-and-initialize-a-dynamic-array">Allocate and Initialize a Dynamic Array</h3><div class="code-block">
 <button class="copy-button" onclick="copyCode(this)">📋</button>
 <pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main() {
    int n = 5;
    int *arr = malloc(n * sizeof(int));

    if (arr == NULL) {
        printf("Memory allocation failed\n");
        return 1;
    }

    // Initialize and print
    for (int i = 0; i &lt; n; i++) {
        arr[i] = (i + 1) * 10;
        printf("%d ", arr[i]);
    }

    free(arr);  // Clean up
    return 0;
}</code></pre>
</div><h3 id="resize-the-array-using-realloc">Resize the Array Using <code>realloc()</code></h3><div class="code-block">
 <button class="copy-button" onclick="copyCode(this)">📋</button>
 <pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main() {
    int n = 5;
    int *arr = malloc(n * sizeof(int));
    if (arr == NULL) return 1;

    for (int i = 0; i &lt; n; i++) {
        arr[i] = i + 1;
    }

    // Resize to 10 elements
    int *temp = realloc(arr, 10 * sizeof(int));
    if (temp == NULL) {
        printf("Reallocation failed\n");
        free(arr);
        return 1;
    }
    arr = temp;

    // Initialize new elements
    for (int i = 5; i &lt; 10; i++) {
        arr[i] = (i + 1) * 10;
    }

    // Print all elements
    for (int i = 0; i &lt; 10; i++) {
        printf("%d ", arr[i]);
    }

    free(arr);
    return 0;
}</code></pre>
</div><p>✅ <strong>What to learn here</strong>:</p><ul>
 <li>Always check if <code>malloc()</code> or <code>realloc()</code> succeeds.</li>
 <li>Initialize newly added memory manually after <code>realloc()</code>.</li>
</ul><h3 id="example-2-linked-list-node-allocation-and-insertion">Example 2: Linked List Node Allocation and Insertion</h3><p>Linked lists use pointers to dynamically chain together nodes at runtime.</p><h3 id="define-a-node-structure">Define a Node Structure</h3><div class="code-block">
 <button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-c">struct Node {
    int data;
    struct Node *next;
};</code></pre>
</div><h3 id="insert-a-node-at-the-beginning">Insert a Node at the Beginning</h3><div class="code-block">
 <button class="copy-button" onclick="copyCode(this)">📋</button>
 <pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

struct Node {
    int data;
    struct Node *next;
};

void insertAtHead(struct Node **head, int value) {
    struct Node *newNode = malloc(sizeof(struct Node));
    if (newNode == NULL) {
        printf("Memory allocation failed\n");
        return;
    }

    newNode-&gt;data = value;
    newNode-&gt;next = *head;  // Link to previous head
    *head = newNode;        // New head
}

void printList(struct Node *head) {
    while (head != NULL) {
        printf("%d -&gt; ", head-&gt;data);
        head = head-&gt;next;
    }
    printf("NULL\n");
}

void freeList(struct Node *head) {
    struct Node *temp;
    while (head != NULL) {
        temp = head;
        head = head-&gt;next;
        free(temp);
    }
}

int main() {
    struct Node *head = NULL;

    insertAtHead(&amp;head, 10);
    insertAtHead(&amp;head, 20);
    insertAtHead(&amp;head, 30);

    printList(head);  // Output: 30 -&gt; 20 -&gt; 10 -&gt; NULL

    freeList(head);   // Clean up
    return 0;
}</code></pre>
</div><p>✅ <strong>What to learn here</strong>:</p><ul>
 <li>Each node is created using <code>malloc()</code> and linked to the list.</li>
 <li>The head pointer is updated using a double pointer (<code>struct Node **head</code>) to reflect changes outside the function.</li>
 <li>Memory is freed using <code>free()</code> in a loop.</li>
</ul><h3 id="summary">Summary</h3><table>
 <thead>
  <tr>
   <th>Example</th>
   <th>What It Demonstrates</th>
  </tr>
 </thead>
 <tbody>
  <tr>
   <td>Dynamic Array</td>
   <td>Allocating and resizing arrays with <code>malloc</code>/<code>realloc</code></td>
  </tr>
  <tr>
   <td>Linked List</td>
   <td>Creating and linking nodes using pointers</td>
  </tr>
 </tbody>
</table><p>Key takeaways:</p><ul>
 <li>Use <code>malloc()</code> to create dynamic structures.</li>
 <li>Use <code>realloc()</code> to resize dynamically allocated arrays safely.</li>
 <li>Free every dynamically allocated block with <code>free()</code> to avoid leaks.</li>
 <li>Manage pointer assignments carefully to maintain structure integrity.</li>
</ul><div class = "chapter-navi-section">
<a href="c-pointers-pointers-to-pointers-and-multilevel-indirection.htm" class="nav-button prev">←</a>
<a href='c-pointers.htm#dynamic-memory-allocation-with-pointers' class="nav-button toc-link">Index</a>
<a href="c-pointers-structures-and-pointers.htm" class="nav-button next">→</a>
</div>
<section class="download-section">
  <div class="book-cover" style="background-color: #f9f6f1;border: 1px solid #ccc;"> 
    <div class="book-cover-title" style="font-size: 22px;color: #333;top: 20px;">C Pointers</div>
    <div class="book-cover-author">readbytes</div>
    <div class="book-cover-bottom-stripe" style="background-color: #333;"></div>
    <img class="book-cover-icon" style="width: 90px;height: 90px;top: 70px;" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFoAAABaCAYAAAA4qEECAAAD5ElEQVR4Xu2dwYoUVxhGr7hQn0F8AyH4Cq5cCwFxk2cQ3GXR1TK+QN5AssnWrRsfwWR0LbhJxKXoIhBQK2Olb5/v1tdV0/fHOPwHDtj/PbdudYHOuKpSkiRJkovFUP744qevvuSyZSin1d5TLlvGs85/7re553OzO3DfJXDPRd97bobylxy49HC2tZvylvkem/Je9uz8wHyPTfmzsWeng23toXs+Ch5GHWypgy11sKUOtjQMHkQdbKmDLXWwpQ62NAweRB1sqYMtdbClDrY0DB5EHWypgy11sKUOtjQMHkQdbKmDLXWwpQ62NAweRB1sqYMtdbClDrY0DB5EHWypgy11sKUOtjQMHkQdbKmDLXWwpQ62NAweRB1sqYMtdbClDrY0SZIkSZI18CdpGqMM0hhlkMYogzRGGaQxyiCNUQZpjDJIY5RBGqMM0hhlkMYogzRGGaQxyiCNUQZpjDJIY5RBT5fAPfO+W7xvabe2PUYZ9HQpQ7kjeynh+lzLNbqmPUYZ9NR/iYcH1uevdagnXJ/8pVxZ1PVQBj1d8iUmfi7XZW3ns+pKO7TTc3t0PZRBT5d8ibVNDTvXsxnKr0waTT9l0NMlX2Ji/GvMNTZDeYrP/0hbr9ecp+mpDHp66EscWh/dlgfS1LCv14fypPrz3ar5u5rXvV6rlzLo6Rq4t3WNafZjuSyz1p6zB31J2pr9Xq/VSxn0dAlDuSr7WtfYltfN+fj79dye8UHvf/4dn9nr+b2UQU9rlszpo/LDbFczt8YHTbTXe+ilDHpaU8+35adq/lj2tfY75vZND7p1raF8lDVep6cy6GnNmrVW4xjK8+Y+/6Bbvd5DL2XQ0xqujb8FTGzKfVl/UK5Ve180rWmdWz/oobz5b74p92Z63mM/ZdDTGq4dWndrkyflRrPZzeoHPf6bf+tfeZ3WNXorg57WcO3M29X6zebeuf+UaHfSmO0/6Dl3va71UgY9reGaa1qzOVvtxKb8Jn1L7o9QBmmMMkhjlEEaowzSGGWQxiiDNEYZpDHKII1RBmmMMkhjlEEaowzSGGWQxiiDNEYZpDHKII0xSZIkSZI18CcpdbClDrbUwZY62NIweBB1sKUOttTBljrY0jB4EHWwpQ621MGWOtjSMHgQdbClDrbUwZY62NIweBB1sKUOttTBljrY0jB4EHWwpQ621MGWOtjSMHgQdbClDrbUwZY62NIweBB1sKUOttTBljrY0jB4EHWwpQ621MGWOtjSMKJeSjZe13HMS8m23+NLyUZ44JIbnuCei773aPZfpLjuJYzbI17CeNyLI+tzX3HZsn/uuntOkiRJ/vd8BnnbnC2TD9qmAAAAAElFTkSuQmCC"/>
  </div>
  <div class="download-info">
    <h2 id='bottom'>Download This Ebook</h2>
    <p class="format-label">Available formats:</p>
    <div class="download-buttons">
      <a href="c-pointers.pdf" class="download-button">📄 PDF</a>
      <a href="c-pointers.epub" class="download-button">📘 EPUB</a>
    </div>
  </div>
</section><div class='related-books'>
<h2>C Introduction Books</h2>
<div class='related-book-list'>
<a href="c-for-beginners.htm">
<div class="book-cover" style="background-color: #f9f6f1;border: 1px solid #ccc;"> 
    <div class="book-cover-title" style="font-size: 18px;color: #333;top: 20px;">C for Beginners</div>
    <div class="book-cover-author">readbytes</div>
    <div class="book-cover-bottom-stripe" style="background-color: #333;"></div>
    <img class="book-cover-icon" style="width: 90px;height: 90px;top: 70px;" src="data:image/png;base64,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"/>
  </div>
</a>


<a href="c-pointers.htm">
<div class="book-cover" style="background-color: #f9f6f1;border: 1px solid #ccc;"> 
    <div class="book-cover-title" style="font-size: 22px;color: #333;top: 20px;">C Pointers</div>
    <div class="book-cover-author">readbytes</div>
    <div class="book-cover-bottom-stripe" style="background-color: #333;"></div>
    <img class="book-cover-icon" style="width: 90px;height: 90px;top: 70px;" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFoAAABaCAYAAAA4qEECAAAD5ElEQVR4Xu2dwYoUVxhGr7hQn0F8AyH4Cq5cCwFxk2cQ3GXR1TK+QN5AssnWrRsfwWR0LbhJxKXoIhBQK2Olb5/v1tdV0/fHOPwHDtj/PbdudYHOuKpSkiRJkovFUP744qevvuSyZSin1d5TLlvGs85/7re553OzO3DfJXDPRd97bobylxy49HC2tZvylvkem/Je9uz8wHyPTfmzsWeng23toXs+Ch5GHWypgy11sKUOtjQMHkQdbKmDLXWwpQ62NAweRB1sqYMtdbClDrY0DB5EHWypgy11sKUOtjQMHkQdbKmDLXWwpQ62NAweRB1sqYMtdbClDrY0DB5EHWypgy11sKUOtjQMHkQdbKmDLXWwpQ62NAweRB1sqYMtdbClDrY0SZIkSZI18CdpGqMM0hhlkMYogzRGGaQxyiCNUQZpjDJIY5RBGqMM0hhlkMYogzRGGaQxyiCNUQZpjDJIY5RBT5fAPfO+W7xvabe2PUYZ9HQpQ7kjeynh+lzLNbqmPUYZ9NR/iYcH1uevdagnXJ/8pVxZ1PVQBj1d8iUmfi7XZW3ns+pKO7TTc3t0PZRBT5d8ibVNDTvXsxnKr0waTT9l0NMlX2Ji/GvMNTZDeYrP/0hbr9ecp+mpDHp66EscWh/dlgfS1LCv14fypPrz3ar5u5rXvV6rlzLo6Rq4t3WNafZjuSyz1p6zB31J2pr9Xq/VSxn0dAlDuSr7WtfYltfN+fj79dye8UHvf/4dn9nr+b2UQU9rlszpo/LDbFczt8YHTbTXe+ilDHpaU8+35adq/lj2tfY75vZND7p1raF8lDVep6cy6GnNmrVW4xjK8+Y+/6Bbvd5DL2XQ0xqujb8FTGzKfVl/UK5Ve180rWmdWz/oobz5b74p92Z63mM/ZdDTGq4dWndrkyflRrPZzeoHPf6bf+tfeZ3WNXorg57WcO3M29X6zebeuf+UaHfSmO0/6Dl3va71UgY9reGaa1qzOVvtxKb8Jn1L7o9QBmmMMkhjlEEaowzSGGWQxiiDNEYZpDHKII1RBmmMMkhjlEEaowzSGGWQxiiDNEYZpDHKII0xSZIkSZI18CcpdbClDrbUwZY62NIweBB1sKUOttTBljrY0jB4EHWwpQ621MGWOtjSMHgQdbClDrbUwZY62NIweBB1sKUOttTBljrY0jB4EHWwpQ621MGWOtjSMHgQdbClDrbUwZY62NIweBB1sKUOttTBljrY0jB4EHWwpQ621MGWOtjSMKJeSjZe13HMS8m23+NLyUZ44JIbnuCei773aPZfpLjuJYzbI17CeNyLI+tzX3HZsn/uuntOkiRJ/vd8BnnbnC2TD9qmAAAAAElFTkSuQmCC"/>
  </div>
</a>



<a href='c.htm'><div class='book-cover' style='background-color: #f9f6f1;color: #111111;border: 1px solid #ccc;display: flex;justify-content: center;align-items: center;text-align: center;'>More C Books</div></a>
</div>
</div><script>
function copyCode(button) {const code = button.nextElementSibling.innerText;navigator.clipboard.writeText(code).then(() => {button.textContent = 'Copied!';setTimeout(() => { button.textContent = 'Copy'; }, 1500);});}
</script></div>
<style>
.site-footer {margin-top: 60px;padding: 20px 0;border-top: 1px solid #eee;text-align: center;font-size: 14px;}
.site-footer a {text-decoration: none;}
.light-mode .site-footer {color: #777;border-color: #eee;}
.dark-mode .site-footer {color: #888;border-color: #333;}
.light-mode .site-footer a {color: #555;}
.dark-mode .site-footer a {color: #aaa;}
.site-footer a:hover {text-decoration: underline;}    
</style>
<footer class="site-footer">
<nav><a href="https://readbytes.github.io">Home</a> |Email:<script type="text/javascript">
var part1 = 'yinpeng';var part6 = '263';var part2 = Math.pow(2,6);var part3 = String.fromCharCode(part2);var part4 = 'hotmail dot com';var part5 = part1 + String.fromCharCode(part2) + part4;document.write(part1 + part6 + part3 + part4);
</script>
| <a id="mode-toggle" href="#">Toggle Dark Mode</a>
</nav><p>© 2025 — All rights reserved.</p></footer>
<script>
const toggleButton = document.getElementById('mode-toggle');
const body = document.body;
const savedMode = localStorage.getItem('mode') || 'light';
body.classList.add(savedMode + '-mode');
toggleButton.addEventListener('click', () => {
      const isDark = body.classList.contains('dark-mode');
      body.classList.toggle('dark-mode', !isDark);
      body.classList.toggle('light-mode', isDark);
      localStorage.setItem('mode', isDark ? 'light' : 'dark');
});
function copyCode(button) {const code = button.nextElementSibling.innerText;navigator.clipboard.writeText(code).then(() => {button.textContent = 'Copied!';setTimeout(() => { button.textContent = 'Copy'; }, 1500);});}
</script>
</body>
</html>