<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>C Pointers Pointers and Data Structures</title>
<link rel='shortcut icon' href='https://java2s.com/style/favicon.ico'>
<link href="https://fonts.googleapis.com/css2?family=Merriweather&display=swap" rel="stylesheet" />
<link href="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet" />


  <script>
  const mode = localStorage.getItem('mode') || 'light';
  document.documentElement.classList.add(`${mode}-mode`);
  </script>   
<style> 
html {
  scroll-behavior: smooth;
}

body {
  font-family: 'Merriweather', serif;
  margin: 0;
  padding: 2rem 1rem;
  font-size: 15px;
  line-height: 1.5;
  transition: background-color 0.3s, color 0.3s;
}

.container {
  max-width: 700px;
  margin: 0 auto;
  padding: 1rem 2rem;
  box-shadow: 0 0 15px rgba(0,0,0,0.1);
}

h1, h2, h3 {
  font-weight: 600;
  margin-top: 2.5rem;
  margin-bottom: 1rem;
  line-height: 1.2;
}

h1 { font-size: 1.8rem; }
h2 { font-size: 1.4rem; }
h3 { font-size: 1.2rem; }

table {
  width: 100%;
  border-collapse: collapse;
  font-family: sans-serif;
  font-size: 1em;
  margin: 1em 0;
}

th, td {
  padding: 0.6em 1em;
  text-align: left;
  border: 1px solid;
}

tr:nth-child(even) {
  background-color: inherit;
}

tr:hover {
  background-color: inherit;
}

a {
  text-decoration: none;
  transition: color 0.2s;
}

a:hover {
  text-decoration: underline;
}

code {
  color: #d35400;
}

.book-title-chapter {
  font-family: 'Merriweather', serif;
  font-size: 2rem;
  font-weight: bold;
  text-align: center;
  margin-bottom: 2rem;
  border-bottom: 2px solid;
  padding-bottom: 0.5rem;
}

.book-subtitle-chapter {
  text-align: center;
  font-size: 1rem;
  margin-top: -1rem;
  margin-bottom: 2rem;
}

.related-books {
  margin-top: 40px;
}

.related-book-list {
  display: flex;
  flex-wrap: wrap;
  gap: 20px;
}

    .book-cover {
      width: 130px;
      height: 180px;
      font-family: Arial, sans-serif;
      position: relative;
      overflow: hidden;      
      line-height: normal;
      box-shadow: 2px 2px 4px rgba(0,0,0,0.1);
    }
    .book-cover-bottom-stripe {
      position: absolute;
      bottom: 0;
      left: 0;
      height: 5px;
      width: 100%;
    }
    .book-cover-title {
      position: absolute;
      width: 100%;
      text-align: center;
      font-weight: bold;
    }
     
    .book-cover-icon {
      position: absolute;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      align-items: center;
      justify-content: center; 
    }

    .book-cover-author {
      position: absolute;
      bottom: 10px;
      width: 100%;
      text-align: center;
      font-size: 8px;
      color: #333;
    }

.page-footer {
  margin-top: 4rem;
  padding: 1rem 0;
  text-align: center;
  font-size: 0.85rem;
  border-top: 1px solid;
}

.chapter-navi-section {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding-bottom: 10px;
}

.nav-link {
  color: inherit;
  text-decoration: none;
  opacity: 0.5;
  transition: opacity 0.3s ease, text-decoration 0.3s ease;
}

.nav-link:hover {
  opacity: 0.9;
  text-decoration: underline;
}

.prev { text-align: left; }
.toc-link { text-align: center; }
.next { text-align: right; }

.download-section {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 2rem;
  padding: 2rem 1rem;
  max-width: 600px;
  margin: 3rem auto;
  border-radius: 12px;
  box-shadow: 0 4px 10px rgba(0,0,0,0.05);
}

.download-info h2 {
  margin: 0 0 0.5rem;
  font-size: 1.2rem;
}

.format-label {
  margin: 0 0 0.5rem;
  font-size: 0.95rem;
}

.download-buttons {
  display: flex;
  gap: 1rem;
}

.download-button {
  background-color: #4A90E2;
  color: white;
  padding: 0.5em 1.2em;
  border-radius: 25px;
  font-size: 0.95rem;
  text-decoration: none;
  transition: background-color 0.3s ease;
}

.download-button:hover {
  background-color: #357ABD;
}

.code-block {
  position: relative;
  margin-bottom: 1em;
}

.copy-button {
  background: transparent;
  color: white;
  position: absolute;
  top: 8px;
  right: 8px;
  border: none;
  padding: 4px 8px;
  font-size: 12px;
  border-radius: 4px;
  cursor: pointer;
  z-index: 1;
}

.copy-button:hover {
  background-color: #0056b3;
}

.snippet-container {
  overflow: hidden;
}

.snippet-header {
  padding: 0.75rem 1rem;
  cursor: pointer;
  font-size: 1rem;
    background-color: #eeeeee;
    color:  #111111; 
    border-radius: 8px;
    cursor: pointer;
    box-shadow: 0 4px 6px rgba(0,0,0,0.1);  
}

.snippet-body {
  display: none;
  font-family: monospace;
}

.snippet-container.open .snippet-body {
  display: block;
}

.CodeMirror {
  border: 2px solid #ccc;
  border-radius: 4px;
  resize: vertical;
}

/* === Light Mode === */
html.light-mode {
  background-color: #f8f7f5;
  color: #333;
}

html.light-mode .container {
  background: white;
}

html.light-mode .book-title-chapter {
  color: #2c3e50;
  border-color: #ccc;
}
html.light-mode .book-subtitle-chapter{
  color: #888;
}

html.light-mode .page-footer,
html.light-mode .series-name,
html.light-mode .book-subtitle,
html.light-mode .format-label {
  color: #888;
}

html.light-mode .related-books h2 {
  color: #333;
  border-bottom: 2px solid #eee;
}

html.light-mode .book-title {
  color: #fff;
}

html.light-mode .book-cover {
  border: 1px solid #ccc;
}

html.light-mode th {
  background-color: #f2f2f2;
}

html.light-mode tr:nth-child(even) {
  background-color: #fafafa;
}

html.light-mode tr:hover {
  background-color: #e6f7ff;
}

html.light-mode a,
html.light-mode .page-footer a {
  color: #000;
}

/* === Dark Mode === */
html.dark-mode {
  background-color: #181818;
  color: #e0e0e0;
}

html.dark-mode .container {
  background: #222;
}

html.dark-mode .book-title-chapter {
  color: #ddd;
  border-color: #444;
}

html.dark-mode .snippet-header {
    background-color: #333;
    color:  #ddd; 
}


html.dark-mode .book-subtitle-chapter,
html.dark-mode .page-footer,
html.dark-mode .series-name,
html.dark-mode .book-subtitle,
html.dark-mode .book-footer,
html.dark-mode .format-label {
  color: #aaa;
}

html.dark-mode .related-books h2 {
  color: #ddd;
  border-bottom: 2px solid #333;
}

html.dark-mode .book-title {
  color: #fff;
}

html.dark-mode .book-cover {
  border: 1px solid #555;
}

html.dark-mode th {
  background-color: #333;
  color: #fff;
}

html.dark-mode td {
  border-color: #444;
}

html.dark-mode tr:nth-child(even) {
  background-color: #2a2a2a;
}

html.dark-mode tr:hover {
  background-color: #2c3e50;
}

html.dark-mode a,
html.dark-mode .page-footer a {
  color: #eee;
}

    .dialog-backdrop {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: rgba(0,0,0,0.5);
      display: none;
      justify-content: center;
      align-items: center;
      z-index: 10;
    }

    .dialog {
      background: white;
      padding: 20px;
      width: 90vw;
      height: 80vh;
      border-radius: 8px;
      box-shadow: 0 0 20px rgba(0,0,0,0.3);
      display: flex;
      flex-direction: column;
    }
    .dialog-content {
      display: flex;
      flex: 1;
      gap: 20px;
      margin-top: 10px;
    }
    .dialog h2 {
      margin-top: 0;
    }

    .textarea_dialog {
      width: 50%;
      height: 100%;
      resize: none;
      font-family: monospace;
      font-size: 14px;
      padding: 10px;
      box-sizing: border-box;
      border: 1px solid #ccc;
    }

    .iframe_dialog {
      width: 50%;
      height: 100%;
      border: 1px solid #ccc;
    }
    .controls_dialog {
      display: flex;
      justify-content: space-between;
      margin-top: 10px;
    }    
    button { padding: 0.5em 1em; background: green; color: white; border: none; cursor: pointer; }
    button:hover { background: #1e7e34; }
    .result_iframe { width:99%; height:200px; margin-top: 1em;  resize: both;border:1px solid #ccc;}        
</style>
</head>
<body> 
  <div class="container">
    <div class = "chapter-navi-section">
<a href="c-pointers-advanced-pointer-concepts.htm" class="nav-button prev">←</a>
<a href='c-pointers.htm#pointers-and-data-structures' class="nav-button toc-link">Index</a>
<a href="c-pointers-function-pointers-in-depth.htm" class="nav-button next">→</a>
</div>

    <h1 class="book-title-chapter" id = 'top'>Pointers and Data Structures</h1>
    <h3 class="book-subtitle-chapter">C Pointers</h3>   
    <!-- <h1 class ="chapter-title"></h1> -->
    <h2 id='implementing-linked-lists-using-pointers'>11.1 Implementing Linked Lists Using Pointers</h2><p>Linked lists are fundamental data structures composed of nodes linked together using pointers. They provide dynamic memory usage and flexible insertion or deletion compared to arrays.</p><p>In this section, we will explore <strong>singly linked lists</strong> and <strong>doubly linked lists</strong>, focusing on how pointers connect nodes and how to manipulate these connections dynamically.</p><h3 id="singly-linked-list">Singly Linked List</h3><p>A <strong>singly linked list</strong> consists of nodes where each node points to the next node in the sequence. The last node points to <code>NULL</code>, indicating the end of the list.</p><h3 id="defining-a-node">Defining a Node</h3><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

typedef struct Node {
    int data;
    struct Node *next;  // Pointer to the next node
} Node;</code></pre>
</div><h3 id="creating-a-new-node">Creating a New Node</h3><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-c">Node* create_node(int value) {
    Node *new_node = (Node *)malloc(sizeof(Node));
    if (new_node == NULL) {
        perror("Failed to allocate memory");
        exit(EXIT_FAILURE);
    }
    new_node-&gt;data = value;
    new_node-&gt;next = NULL;
    return new_node;
}</code></pre>
</div><h3 id="inserting-at-the-beginning">Inserting at the Beginning</h3><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-c">void insert_at_head(Node **head_ref, int value) {
    Node *new_node = create_node(value);
    new_node-&gt;next = *head_ref;
    *head_ref = new_node;
}</code></pre>
</div><p>Here, <code>head_ref</code> is a pointer to the head pointer. Modifying <code>*head_ref</code> updates the caller's head pointer.</p><h3 id="traversing-the-list">Traversing the List</h3><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-c">void print_list(Node *head) {
    Node *current = head;
    while (current != NULL) {
        printf("%d -&gt; ", current-&gt;data);
        current = current-&gt;next;
    }
    printf("NULL\n");
}</code></pre>
</div><h3 id="deleting-a-node-by-value">Deleting a Node by Value</h3><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-c">void delete_node(Node **head_ref, int value) {
    Node *current = *head_ref;
    Node *prev = NULL;

    while (current != NULL &amp;&amp; current-&gt;data != value) {
        prev = current;
        current = current-&gt;next;
    }

    if (current == NULL) {
        printf("Value %d not found in list.\n", value);
        return;
    }

    if (prev == NULL) {
        // Deleting the head node
        *head_ref = current-&gt;next;
    } else {
        prev-&gt;next = current-&gt;next;
    }
    free(current);
}</code></pre>
</div><h3 id="complete-example-singly-linked-list-usage">Complete Example: Singly Linked List Usage</h3><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-c">int main() {
    Node *head = NULL;

    insert_at_head(&amp;head, 10);
    insert_at_head(&amp;head, 20);
    insert_at_head(&amp;head, 30);

    printf("List after inserts: ");
    print_list(head);

    delete_node(&amp;head, 20);

    printf("List after deleting 20: ");
    print_list(head);

    // Free remaining nodes
    while (head != NULL) {
        Node *temp = head;
        head = head-&gt;next;
        free(temp);
    }

    return 0;
}</code></pre>
</div><div class="snippet-container" id="hkRkD">
 <div class="snippet-header" onclick="toggleSnippet('hkRkD')">
  Click to view full runnable Code
 </div>
 <div class="snippet-body">
  <div class="code-block"><button class="copy-button" onclick="copyCode(this)">📋</button>
   <pre><code class="language-c">
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

// Define a node structure
typedef struct Node {
    int data;
    struct Node *next;
} Node;

// Create a new node with the given value
Node* create_node(int value) {
    Node *new_node = (Node *)malloc(sizeof(Node));
    if (new_node == NULL) {
        perror("Failed to allocate memory");
        exit(EXIT_FAILURE);
    }
    new_node-&gt;data = value;
    new_node-&gt;next = NULL;
    return new_node;
}

// Insert a new node at the beginning (head)
void insert_at_head(Node **head_ref, int value) {
    Node *new_node = create_node(value);
    new_node-&gt;next = *head_ref;
    *head_ref = new_node;
}

// Traverse and print the list
void print_list(Node *head) {
    Node *current = head;
    while (current != NULL) {
        printf("%d -&gt; ", current-&gt;data);
        current = current-&gt;next;
    }
    printf("NULL\n");
}

// Delete a node by value
void delete_node(Node **head_ref, int value) {
    Node *current = *head_ref;
    Node *prev = NULL;

    while (current != NULL &amp;&amp; current-&gt;data != value) {
        prev = current;
        current = current-&gt;next;
    }

    if (current == NULL) {
        printf("Value %d not found in list.\n", value);
        return;
    }

    if (prev == NULL) {
        *head_ref = current-&gt;next;  // deleting head node
    } else {
        prev-&gt;next = current-&gt;next;
    }

    free(current);
}

// Main function to test the list
int main() {
    Node *head = NULL;

    insert_at_head(&amp;head, 10);
    insert_at_head(&amp;head, 20);
    insert_at_head(&amp;head, 30);

    printf("List after inserts: ");
    print_list(head);  // Expected: 30 -&gt; 20 -&gt; 10 -&gt; NULL

    delete_node(&amp;head, 20);

    printf("List after deleting 20: ");
    print_list(head);  // Expected: 30 -&gt; 10 -&gt; NULL

    // Clean up memory
    while (head != NULL) {
        Node *temp = head;
        head = head-&gt;next;
        free(temp);
    }

    return 0;
} 
</code></pre>
  </div>
 </div>
</div><h3 id="doubly-linked-list">Doubly Linked List</h3><p>A <strong>doubly linked list</strong> allows traversal in both directions by including a pointer to the previous node.</p><h3 id="defining-a-node">Defining a Node</h3><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-c">typedef struct DNode {
    int data;
    struct DNode *prev;
    struct DNode *next;
} DNode;</code></pre>
</div><h3 id="creating-a-new-node">Creating a New Node</h3><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-c">DNode* create_dnode(int value) {
    DNode *new_node = (DNode *)malloc(sizeof(DNode));
    if (new_node == NULL) {
        perror("Failed to allocate memory");
        exit(EXIT_FAILURE);
    }
    new_node-&gt;data = value;
    new_node-&gt;prev = NULL;
    new_node-&gt;next = NULL;
    return new_node;
}</code></pre>
</div><h3 id="inserting-at-the-head">Inserting at the Head</h3><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-c">void insert_at_head_d(DNode **head_ref, int value) {
    DNode *new_node = create_dnode(value);
    new_node-&gt;next = *head_ref;

    if (*head_ref != NULL) {
        (*head_ref)-&gt;prev = new_node;
    }
    *head_ref = new_node;
}</code></pre>
</div><h3 id="traversing-forward-and-backward">Traversing Forward and Backward</h3><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-c">void print_list_forward(DNode *head) {
    DNode *current = head;
    printf("Forward: ");
    while (current != NULL) {
        printf("%d &lt;-&gt; ", current-&gt;data);
        if (current-&gt;next == NULL) break;
        current = current-&gt;next;
    }
    printf("NULL\n");
}

void print_list_backward(DNode *tail) {
    DNode *current = tail;
    printf("Backward: ");
    while (current != NULL) {
        printf("%d &lt;-&gt; ", current-&gt;data);
        current = current-&gt;prev;
    }
    printf("NULL\n");
}</code></pre>
</div><h3 id="getting-the-tail-node">Getting the Tail Node</h3><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-c">DNode* get_tail(DNode *head) {
    DNode *current = head;
    while (current != NULL &amp;&amp; current-&gt;next != NULL) {
        current = current-&gt;next;
    }
    return current;
}</code></pre>
</div><h3 id="complete-example-doubly-linked-list-usage">Complete Example: Doubly Linked List Usage</h3><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-c">int main() {
    DNode *head = NULL;

    insert_at_head_d(&amp;head, 100);
    insert_at_head_d(&amp;head, 200);
    insert_at_head_d(&amp;head, 300);

    print_list_forward(head);

    DNode *tail = get_tail(head);
    print_list_backward(tail);

    // Free nodes
    DNode *current = head;
    while (current != NULL) {
        DNode *temp = current;
        current = current-&gt;next;
        free(temp);
    }

    return 0;
}</code></pre>
</div><div class="snippet-container" id="nDyBz">
 <div class="snippet-header" onclick="toggleSnippet('nDyBz')">
  Click to view full runnable Code
 </div>
 <div class="snippet-body">
  <div class="code-block"><button class="copy-button" onclick="copyCode(this)">📋</button>
   <pre><code class="language-c">
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

// Define the doubly linked list node
typedef struct DNode {
    int data;
    struct DNode *prev;
    struct DNode *next;
} DNode;

// Create a new node with given value
DNode* create_dnode(int value) {
    DNode *new_node = (DNode *)malloc(sizeof(DNode));
    if (new_node == NULL) {
        perror("Failed to allocate memory");
        exit(EXIT_FAILURE);
    }
    new_node-&gt;data = value;
    new_node-&gt;prev = NULL;
    new_node-&gt;next = NULL;
    return new_node;
}

// Insert a node at the beginning (head)
void insert_at_head_d(DNode **head_ref, int value) {
    DNode *new_node = create_dnode(value);
    new_node-&gt;next = *head_ref;

    if (*head_ref != NULL) {
        (*head_ref)-&gt;prev = new_node;
    }
    *head_ref = new_node;
}

// Print the list from head to tail
void print_list_forward(DNode *head) {
    DNode *current = head;
    printf("Forward: ");
    while (current != NULL) {
        printf("%d &lt;-&gt; ", current-&gt;data);
        if (current-&gt;next == NULL) break;  // stop at tail
        current = current-&gt;next;
    }
    printf("NULL\n");
}

// Print the list from tail to head
void print_list_backward(DNode *tail) {
    DNode *current = tail;
    printf("Backward: ");
    while (current != NULL) {
        printf("%d &lt;-&gt; ", current-&gt;data);
        current = current-&gt;prev;
    }
    printf("NULL\n");
}

// Get the last node (tail) from head
DNode* get_tail(DNode *head) {
    DNode *current = head;
    while (current != NULL &amp;&amp; current-&gt;next != NULL) {
        current = current-&gt;next;
    }
    return current;
}

// Main function demonstrating usage
int main() {
    DNode *head = NULL;

    insert_at_head_d(&amp;head, 100);
    insert_at_head_d(&amp;head, 200);
    insert_at_head_d(&amp;head, 300);

    print_list_forward(head);   // Expected: 300 &lt;-&gt; 200 &lt;-&gt; 100 &lt;-&gt; NULL

    DNode *tail = get_tail(head);
    print_list_backward(tail);  // Expected: 100 &lt;-&gt; 200 &lt;-&gt; 300 &lt;-&gt; NULL

    // Free all nodes
    DNode *current = head;
    while (current != NULL) {
        DNode *temp = current;
        current = current-&gt;next;
        free(temp);
    }

    return 0;
} 
</code></pre>
  </div>
 </div>
</div><h3 id="summary">Summary</h3><ul>
 <li><strong>Singly linked lists</strong> use a pointer to the next node, supporting simple forward traversal.</li>
 <li><strong>Doubly linked lists</strong> add a pointer to the previous node, allowing bidirectional traversal.</li>
 <li>Dynamic memory allocation (<code>malloc</code> and <code>free</code>) manages node creation and deletion.</li>
 <li>Proper pointer manipulation is essential to maintain list integrity during insertion, deletion, and traversal.</li>
</ul><p>Mastering linked lists with pointers builds a foundation for more complex data structures like trees and graphs, which we'll explore in later chapters.</p><div class = "chapter-navi-section">
<a href="#top" class="nav-button prev">↑</a>
<a href='c-pointers.htm#pointers-and-data-structures' class="nav-button toc-link">Index</a>
<a href="#bottom" class="nav-button next">↓</a>
</div>
<h2 id='trees-and-binary-search-trees-with-pointer-nodes'>11.2 Trees and Binary Search Trees with Pointer Nodes</h2><h1>Trees and Binary Search Trees with Pointer Nodes</h1><p>Trees are hierarchical data structures composed of nodes connected via pointers. Each node can have zero or more child nodes, making trees ideal for representing hierarchical relationships like file systems, organizational charts, and sorted data structures.</p><p>A <strong>binary tree</strong> is a special tree where each node has at most two children, commonly called <strong>left</strong> and <strong>right</strong>. A <strong>binary search tree (BST)</strong> is a binary tree with the added property that for each node:</p><ul>
 <li>All values in the left subtree are <strong>less than</strong> the node's value.</li>
 <li>All values in the right subtree are <strong>greater than</strong> the node's value.</li>
</ul><p>This property enables efficient searching, insertion, and deletion operations.</p><h3 id="defining-a-tree-node">Defining a Tree Node</h3><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

typedef struct TreeNode {
    int data;
    struct TreeNode *left;
    struct TreeNode *right;
} TreeNode;</code></pre>
</div><p>Each <code>TreeNode</code> contains an integer <code>data</code> and pointers to its left and right children.</p><h3 id="creating-a-new-node">Creating a New Node</h3><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-c">TreeNode* create_node(int value) {
    TreeNode *new_node = (TreeNode *)malloc(sizeof(TreeNode));
    if (new_node == NULL) {
        perror("Failed to allocate memory");
        exit(EXIT_FAILURE);
    }
    new_node-&gt;data = value;
    new_node-&gt;left = NULL;
    new_node-&gt;right = NULL;
    return new_node;
}</code></pre>
</div><h3 id="recursive-insertion-in-a-binary-search-tree">Recursive Insertion in a Binary Search Tree</h3><p>Insertion respects the BST property by recursively finding the correct spot for the new value.</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-c">TreeNode* insert(TreeNode *root, int value) {
    if (root == NULL) {
        return create_node(value);
    }
    
    if (value &lt; root-&gt;data) {
        root-&gt;left = insert(root-&gt;left, value);
    } else if (value &gt; root-&gt;data) {
        root-&gt;right = insert(root-&gt;right, value);
    }
    // If value == root-&gt;data, do not insert duplicates (optional)
    
    return root;
}</code></pre>
</div><h3 id="tree-traversal-methods">Tree Traversal Methods</h3><p>Traversal involves visiting nodes in a particular order. These are often implemented recursively.</p><h3 id="in-order-traversal-left-root-right">In-Order Traversal (Left, Root, Right)</h3><p>Prints values in ascending order for BSTs.</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-c">void inorder(TreeNode *root) {
    if (root == NULL) return;
    inorder(root-&gt;left);
    printf("%d ", root-&gt;data);
    inorder(root-&gt;right);
}</code></pre>
</div><h3 id="pre-order-traversal-root-left-right">Pre-Order Traversal (Root, Left, Right)</h3><p>Useful for copying the tree or prefix expressions.</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-c">void preorder(TreeNode *root) {
    if (root == NULL) return;
    printf("%d ", root-&gt;data);
    preorder(root-&gt;left);
    preorder(root-&gt;right);
}</code></pre>
</div><h3 id="post-order-traversal-left-right-root">Post-Order Traversal (Left, Right, Root)</h3><p>Useful for deleting trees or postfix expressions.</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-c">void postorder(TreeNode *root) {
    if (root == NULL) return;
    postorder(root-&gt;left);
    postorder(root-&gt;right);
    printf("%d ", root-&gt;data);
}</code></pre>
</div><h3 id="searching-in-a-binary-search-tree">Searching in a Binary Search Tree</h3><p>Recursive search leverages the BST property to efficiently locate a value.</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-c">TreeNode* search(TreeNode *root, int value) {
    if (root == NULL || root-&gt;data == value) {
        return root;
    }

    if (value &lt; root-&gt;data) {
        return search(root-&gt;left, value);
    } else {
        return search(root-&gt;right, value);
    }
}</code></pre>
</div><h3 id="complete-example-building-and-traversing-a-bst">Complete Example: Building and Traversing a BST</h3><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-c">int main() {
    TreeNode *root = NULL;

    int values[] = {50, 30, 70, 20, 40, 60, 80};
    int n = sizeof(values) / sizeof(values[0]);

    // Insert values
    for (int i = 0; i &lt; n; i++) {
        root = insert(root, values[i]);
    }

    printf("In-order traversal: ");
    inorder(root);
    printf("\n");

    printf("Pre-order traversal: ");
    preorder(root);
    printf("\n");

    printf("Post-order traversal: ");
    postorder(root);
    printf("\n");

    // Search for a value
    int target = 40;
    TreeNode *found = search(root, target);
    if (found != NULL) {
        printf("Value %d found in the tree.\n", target);
    } else {
        printf("Value %d not found in the tree.\n", target);
    }

    // Free memory would be implemented here (see next chapters)

    return 0;
}</code></pre>
</div><div class="snippet-container" id="8Bh70">
 <div class="snippet-header" onclick="toggleSnippet('8Bh70')">
  Click to view full runnable Code
 </div>
 <div class="snippet-body">
  <div class="code-block"><button class="copy-button" onclick="copyCode(this)">📋</button>
   <pre><code class="language-c">
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

// Define the TreeNode structure
typedef struct TreeNode {
    int data;
    struct TreeNode *left;
    struct TreeNode *right;
} TreeNode;

// Create a new tree node
TreeNode* create_node(int value) {
    TreeNode *new_node = (TreeNode *)malloc(sizeof(TreeNode));
    if (new_node == NULL) {
        perror("Failed to allocate memory");
        exit(EXIT_FAILURE);
    }
    new_node-&gt;data = value;
    new_node-&gt;left = NULL;
    new_node-&gt;right = NULL;
    return new_node;
}

// Insert value into the BST
TreeNode* insert(TreeNode *root, int value) {
    if (root == NULL) {
        return create_node(value);
    }
    if (value &lt; root-&gt;data) {
        root-&gt;left = insert(root-&gt;left, value);
    } else if (value &gt; root-&gt;data) {
        root-&gt;right = insert(root-&gt;right, value);
    }
    return root;
}

// In-order traversal (Left, Root, Right)
void inorder(TreeNode *root) {
    if (root == NULL) return;
    inorder(root-&gt;left);
    printf("%d ", root-&gt;data);
    inorder(root-&gt;right);
}

// Pre-order traversal (Root, Left, Right)
void preorder(TreeNode *root) {
    if (root == NULL) return;
    printf("%d ", root-&gt;data);
    preorder(root-&gt;left);
    preorder(root-&gt;right);
}

// Post-order traversal (Left, Right, Root)
void postorder(TreeNode *root) {
    if (root == NULL) return;
    postorder(root-&gt;left);
    postorder(root-&gt;right);
    printf("%d ", root-&gt;data);
}

// Search for a value in the BST
TreeNode* search(TreeNode *root, int value) {
    if (root == NULL || root-&gt;data == value) {
        return root;
    }
    if (value &lt; root-&gt;data) {
        return search(root-&gt;left, value);
    } else {
        return search(root-&gt;right, value);
    }
}

// Free the entire tree
void free_tree(TreeNode *root) {
    if (root == NULL) return;
    free_tree(root-&gt;left);
    free_tree(root-&gt;right);
    free(root);
}

// Main function
int main() {
    TreeNode *root = NULL;

    int values[] = {50, 30, 70, 20, 40, 60, 80};
    int n = sizeof(values) / sizeof(values[0]);

    // Insert values into BST
    for (int i = 0; i &lt; n; i++) {
        root = insert(root, values[i]);
    }

    // Perform tree traversals
    printf("In-order traversal: ");
    inorder(root);
    printf("\n");

    printf("Pre-order traversal: ");
    preorder(root);
    printf("\n");

    printf("Post-order traversal: ");
    postorder(root);
    printf("\n");

    // Search for a specific value
    int target = 40;
    TreeNode *found = search(root, target);
    if (found != NULL) {
        printf("Value %d found in the tree.\n", target);
    } else {
        printf("Value %d not found in the tree.\n", target);
    }

    // Free all nodes
    free_tree(root);
    return 0;
} 
</code></pre>
  </div>
 </div>
</div><h3 id="summary">Summary</h3><ul>
 <li>Binary search trees organize data hierarchically with efficient search, insertion, and traversal.</li>
 <li>Pointers connect nodes recursively, enabling flexible and dynamic tree structures.</li>
 <li>Recursive algorithms naturally fit tree operations, simplifying traversal and manipulation.</li>
 <li>Mastering pointer-based trees prepares you for more complex structures like balanced trees and graphs.</li>
</ul><p>This pointer-centric view of trees is foundational for effective C programming in data structures.</p><div class = "chapter-navi-section">
<a href="#top" class="nav-button prev">↑</a>
<a href='c-pointers.htm#pointers-and-data-structures' class="nav-button toc-link">Index</a>
<a href="#bottom" class="nav-button next">↓</a>
</div>
<h2 id='graphs-and-adjacency-lists-with-pointer-arrays'>11.3 Graphs and Adjacency Lists with Pointer Arrays</h2><p>Graphs are a fundamental data structure used to represent relationships between entities. A graph consists of <strong>vertices</strong> (or nodes) and <strong>edges</strong> connecting pairs of vertices. In C, one common way to represent graphs efficiently—especially sparse graphs—is through <strong>adjacency lists</strong>.</p><h3 id="what-is-an-adjacency-list">What is an Adjacency List?</h3><p>An adjacency list represents a graph as an array of lists. Each element in the array corresponds to a vertex and contains a pointer to a linked list of adjacent vertices (neighbors). This is more memory-efficient than adjacency matrices for sparse graphs because it only stores existing edges.</p><h3 id="using-arrays-of-pointers-to-linked-lists">Using Arrays of Pointers to Linked Lists</h3><p>In C, adjacency lists are implemented as:</p><ul>
 <li>An array where each element is a pointer to a linked list head.</li>
 <li>Each linked list node represents a neighboring vertex connected by an edge.</li>
</ul><p>This structure allows dynamic and flexible graph representation.</p><h3 id="graph-node-definition-for-adjacency-list">Graph Node Definition for Adjacency List</h3><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-c">typedef struct AdjListNode {
    int vertex;                   // Neighbor vertex index
    struct AdjListNode* next;    // Pointer to next node in list
} AdjListNode;</code></pre>
</div><h3 id="graph-structure-definition">Graph Structure Definition</h3><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-c">typedef struct Graph {
    int numVertices;             // Number of vertices in the graph
    AdjListNode** adjLists;      // Array of pointers to adjacency lists
} Graph;</code></pre>
</div><h3 id="creating-a-new-node">Creating a New Node</h3><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

AdjListNode* createNode(int vertex) {
    AdjListNode* newNode = (AdjListNode*)malloc(sizeof(AdjListNode));
    if (newNode == NULL) {
        perror("Failed to allocate memory");
        exit(EXIT_FAILURE);
    }
    newNode-&gt;vertex = vertex;
    newNode-&gt;next = NULL;
    return newNode;
}</code></pre>
</div><h3 id="initializing-the-graph">Initializing the Graph</h3><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-c">Graph* createGraph(int vertices) {
    Graph* graph = (Graph*)malloc(sizeof(Graph));
    if (graph == NULL) {
        perror("Failed to allocate memory");
        exit(EXIT_FAILURE);
    }

    graph-&gt;numVertices = vertices;
    graph-&gt;adjLists = (AdjListNode**)malloc(vertices * sizeof(AdjListNode*));
    if (graph-&gt;adjLists == NULL) {
        perror("Failed to allocate memory");
        free(graph);
        exit(EXIT_FAILURE);
    }

    // Initialize each adjacency list as empty (NULL)
    for (int i = 0; i &lt; vertices; i++) {
        graph-&gt;adjLists[i] = NULL;
    }
    return graph;
}</code></pre>
</div><h3 id="adding-an-edge">Adding an Edge</h3><p>For an undirected graph, add an edge by inserting the destination vertex to the source’s adjacency list <strong>and</strong> vice versa.</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-c">void addEdge(Graph* graph, int src, int dest) {
    // Add edge from src to dest
    AdjListNode* newNode = createNode(dest);
    newNode-&gt;next = graph-&gt;adjLists[src];
    graph-&gt;adjLists[src] = newNode;

    // Since undirected, add edge from dest to src
    newNode = createNode(src);
    newNode-&gt;next = graph-&gt;adjLists[dest];
    graph-&gt;adjLists[dest] = newNode;
}</code></pre>
</div><h3 id="traversing-the-graph-printing-adjacency-lists">Traversing the Graph: Printing Adjacency Lists</h3><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-c">void printGraph(Graph* graph) {
    for (int i = 0; i &lt; graph-&gt;numVertices; i++) {
        AdjListNode* temp = graph-&gt;adjLists[i];
        printf("Vertex %d: ", i);
        while (temp) {
            printf("%d -&gt; ", temp-&gt;vertex);
            temp = temp-&gt;next;
        }
        printf("NULL\n");
    }
}</code></pre>
</div><h3 id="basic-graph-traversal-depth-first-search-dfs">Basic Graph Traversal: Depth-First Search (DFS)</h3><p>DFS uses recursion and pointers to traverse all connected vertices:</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-c">void DFSUtil(Graph* graph, int vertex, int* visited) {
    visited[vertex] = 1;
    printf("%d ", vertex);

    AdjListNode* temp = graph-&gt;adjLists[vertex];
    while (temp) {
        int adjVertex = temp-&gt;vertex;
        if (!visited[adjVertex]) {
            DFSUtil(graph, adjVertex, visited);
        }
        temp = temp-&gt;next;
    }
}

void DFS(Graph* graph, int startVertex) {
    int* visited = (int*)calloc(graph-&gt;numVertices, sizeof(int));
    if (visited == NULL) {
        perror("Failed to allocate memory");
        exit(EXIT_FAILURE);
    }

    printf("DFS traversal starting at vertex %d: ", startVertex);
    DFSUtil(graph, startVertex, visited);
    printf("\n");

    free(visited);
}</code></pre>
</div><h3 id="complete-example-constructing-and-traversing-a-graph">Complete Example: Constructing and Traversing a Graph</h3><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-c">int main() {
    int vertices = 5;
    Graph* graph = createGraph(vertices);

    addEdge(graph, 0, 1);
    addEdge(graph, 0, 4);
    addEdge(graph, 1, 2);
    addEdge(graph, 1, 3);
    addEdge(graph, 1, 4);
    addEdge(graph, 2, 3);
    addEdge(graph, 3, 4);

    printGraph(graph);

    DFS(graph, 0);

    // Memory cleanup (free adjacency lists and graph) omitted for brevity

    return 0;
}</code></pre>
</div><div class="snippet-container" id="kzq6S">
 <div class="snippet-header" onclick="toggleSnippet('kzq6S')">
  Click to view full runnable Code
 </div>
 <div class="snippet-body">
  <div class="code-block"><button class="copy-button" onclick="copyCode(this)">📋</button>
   <pre><code class="language-c">
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

// Adjacency list node
typedef struct AdjListNode {
    int vertex;
    struct AdjListNode* next;
} AdjListNode;

// Graph structure
typedef struct Graph {
    int numVertices;
    AdjListNode** adjLists;
} Graph;

// Create a new adjacency list node
AdjListNode* createNode(int vertex) {
    AdjListNode* newNode = (AdjListNode*)malloc(sizeof(AdjListNode));
    if (newNode == NULL) {
        perror("Failed to allocate memory");
        exit(EXIT_FAILURE);
    }
    newNode-&gt;vertex = vertex;
    newNode-&gt;next = NULL;
    return newNode;
}

// Create a graph with given vertices
Graph* createGraph(int vertices) {
    Graph* graph = (Graph*)malloc(sizeof(Graph));
    if (graph == NULL) {
        perror("Failed to allocate memory");
        exit(EXIT_FAILURE);
    }

    graph-&gt;numVertices = vertices;
    graph-&gt;adjLists = (AdjListNode**)malloc(vertices * sizeof(AdjListNode*));
    if (graph-&gt;adjLists == NULL) {
        perror("Failed to allocate memory");
        free(graph);
        exit(EXIT_FAILURE);
    }

    for (int i = 0; i &lt; vertices; i++) {
        graph-&gt;adjLists[i] = NULL;
    }

    return graph;
}

// Add an undirected edge
void addEdge(Graph* graph, int src, int dest) {
    AdjListNode* newNode = createNode(dest);
    newNode-&gt;next = graph-&gt;adjLists[src];
    graph-&gt;adjLists[src] = newNode;

    newNode = createNode(src);
    newNode-&gt;next = graph-&gt;adjLists[dest];
    graph-&gt;adjLists[dest] = newNode;
}

// Print adjacency list of the graph
void printGraph(Graph* graph) {
    for (int i = 0; i &lt; graph-&gt;numVertices; i++) {
        AdjListNode* temp = graph-&gt;adjLists[i];
        printf("Vertex %d: ", i);
        while (temp) {
            printf("%d -&gt; ", temp-&gt;vertex);
            temp = temp-&gt;next;
        }
        printf("NULL\n");
    }
}

// DFS utility function
void DFSUtil(Graph* graph, int vertex, int* visited) {
    visited[vertex] = 1;
    printf("%d ", vertex);

    AdjListNode* temp = graph-&gt;adjLists[vertex];
    while (temp) {
        int adjVertex = temp-&gt;vertex;
        if (!visited[adjVertex]) {
            DFSUtil(graph, adjVertex, visited);
        }
        temp = temp-&gt;next;
    }
}

// Perform DFS traversal from a starting vertex
void DFS(Graph* graph, int startVertex) {
    int* visited = (int*)calloc(graph-&gt;numVertices, sizeof(int));
    if (visited == NULL) {
        perror("Failed to allocate memory");
        exit(EXIT_FAILURE);
    }

    printf("DFS traversal starting at vertex %d: ", startVertex);
    DFSUtil(graph, startVertex, visited);
    printf("\n");

    free(visited);
}

// Free graph memory
void freeGraph(Graph* graph) {
    for (int i = 0; i &lt; graph-&gt;numVertices; i++) {
        AdjListNode* temp = graph-&gt;adjLists[i];
        while (temp) {
            AdjListNode* toFree = temp;
            temp = temp-&gt;next;
            free(toFree);
        }
    }
    free(graph-&gt;adjLists);
    free(graph);
}

// Main function
int main() {
    int vertices = 5;
    Graph* graph = createGraph(vertices);

    addEdge(graph, 0, 1);
    addEdge(graph, 0, 4);
    addEdge(graph, 1, 2);
    addEdge(graph, 1, 3);
    addEdge(graph, 1, 4);
    addEdge(graph, 2, 3);
    addEdge(graph, 3, 4);

    printf("Graph adjacency list:\n");
    printGraph(graph);

    DFS(graph, 0);

    freeGraph(graph);
    return 0;
} 
</code></pre>
  </div>
 </div>
</div><h3 id="summary">Summary</h3><ul>
 <li><strong>Adjacency lists</strong> use arrays of pointers to linked lists to represent graphs efficiently.</li>
 <li>This dynamic structure minimizes memory use compared to adjacency matrices for sparse graphs.</li>
 <li>Linked lists connected by pointers allow easy insertion and deletion of edges.</li>
 <li>Recursive traversal algorithms like DFS elegantly navigate pointer-based graph structures.</li>
 <li>Proper memory management is crucial to avoid leaks when using dynamic pointers.</li>
</ul><p>Mastering pointer arrays and linked lists for graphs empowers you to implement complex, efficient graph algorithms in C.</p><div class = "chapter-navi-section">
<a href="#top" class="nav-button prev">↑</a>
<a href='c-pointers.htm#pointers-and-data-structures' class="nav-button toc-link">Index</a>
<a href="#bottom" class="nav-button next">↓</a>
</div>
<h2 id='examples-building-and-traversing-linked-data-structures'>11.4 Examples: Building and Traversing Linked Data Structures</h2><p>In this section, we’ll explore runnable examples illustrating the construction and traversal of three important linked data structures: <strong>linked lists</strong>, <strong>binary trees</strong>, and <strong>graphs</strong>. Each example emphasizes safe pointer usage, dynamic memory management, and recursive traversal where applicable. These fundamental building blocks showcase how pointers empower complex, flexible data organization in C.</p><h3 id="example-1-singly-linked-list-creation-and-traversal">Example 1: Singly Linked List Creation and Traversal</h3><div class="code-block"><button class="copy-button" onclick="copyCode(this)">📋</button>
 <pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

// Node definition
typedef struct Node {
    int data;
    struct Node* next;
} Node;

// Create a new node
Node* createNode(int data) {
    Node* newNode = (Node*)malloc(sizeof(Node));
    if (!newNode) {
        perror("Allocation failed");
        exit(EXIT_FAILURE);
    }
    newNode-&gt;data = data;
    newNode-&gt;next = NULL;
    return newNode;
}

// Append node to end of list
void append(Node** head, int data) {
    Node* newNode = createNode(data);
    if (*head == NULL) {
        *head = newNode;
        return;
    }
    Node* temp = *head;
    while (temp-&gt;next != NULL) {
        temp = temp-&gt;next;
    }
    temp-&gt;next = newNode;
}

// Print list elements
void printList(Node* head) {
    Node* temp = head;
    printf("Linked List: ");
    while (temp != NULL) {
        printf("%d -&gt; ", temp-&gt;data);
        temp = temp-&gt;next;
    }
    printf("NULL\n");
}

// Free the entire list
void freeList(Node* head) {
    Node* temp;
    while (head != NULL) {
        temp = head;
        head = head-&gt;next;
        free(temp);
    }
}

int main() {
    Node* head = NULL;

    // Build list: 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; NULL
    for (int i = 1; i &lt;= 4; i++) {
        append(&amp;head, i);
    }

    printList(head);
    freeList(head);

    return 0;
}</code></pre>
</div><h3 id="example-2-binary-tree-insertion-and-recursive-traversal">Example 2: Binary Tree Insertion and Recursive Traversal</h3><div class="code-block"><button class="copy-button" onclick="copyCode(this)">📋</button>
 <pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

// Binary Tree node definition
typedef struct TreeNode {
    int data;
    struct TreeNode* left;
    struct TreeNode* right;
} TreeNode;

// Create a new tree node
TreeNode* createTreeNode(int data) {
    TreeNode* newNode = (TreeNode*)malloc(sizeof(TreeNode));
    if (!newNode) {
        perror("Allocation failed");
        exit(EXIT_FAILURE);
    }
    newNode-&gt;data = data;
    newNode-&gt;left = newNode-&gt;right = NULL;
    return newNode;
}

// Insert data into the binary search tree (BST)
TreeNode* insertBST(TreeNode* root, int data) {
    if (root == NULL) return createTreeNode(data);

    if (data &lt; root-&gt;data)
        root-&gt;left = insertBST(root-&gt;left, data);
    else
        root-&gt;right = insertBST(root-&gt;right, data);

    return root;
}

// In-order traversal (left, root, right)
void inorderTraversal(TreeNode* root) {
    if (root == NULL) return;
    inorderTraversal(root-&gt;left);
    printf("%d ", root-&gt;data);
    inorderTraversal(root-&gt;right);
}

// Pre-order traversal (root, left, right)
void preorderTraversal(TreeNode* root) {
    if (root == NULL) return;
    printf("%d ", root-&gt;data);
    preorderTraversal(root-&gt;left);
    preorderTraversal(root-&gt;right);
}

// Post-order traversal (left, right, root)
void postorderTraversal(TreeNode* root) {
    if (root == NULL) return;
    postorderTraversal(root-&gt;left);
    postorderTraversal(root-&gt;right);
    printf("%d ", root-&gt;data);
}

// Free tree memory recursively
void freeTree(TreeNode* root) {
    if (root == NULL) return;
    freeTree(root-&gt;left);
    freeTree(root-&gt;right);
    free(root);
}

int main() {
    TreeNode* root = NULL;

    int values[] = {50, 30, 70, 20, 40, 60, 80};
    for (int i = 0; i &lt; 7; i++) {
        root = insertBST(root, values[i]);
    }

    printf("In-order Traversal: ");
    inorderTraversal(root);
    printf("\n");

    printf("Pre-order Traversal: ");
    preorderTraversal(root);
    printf("\n");

    printf("Post-order Traversal: ");
    postorderTraversal(root);
    printf("\n");

    freeTree(root);
    return 0;
}</code></pre>
</div><h3 id="example-3-graph-adjacency-list-construction-and-depth-first-search-dfs">Example 3: Graph Adjacency List Construction and Depth-First Search (DFS)</h3><div class="code-block"><button class="copy-button" onclick="copyCode(this)">📋</button>
 <pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

// Linked list node for adjacency list
typedef struct AdjListNode {
    int vertex;
    struct AdjListNode* next;
} AdjListNode;

// Graph structure
typedef struct Graph {
    int numVertices;
    AdjListNode** adjLists;
} Graph;

// Create a new adjacency list node
AdjListNode* createNode(int vertex) {
    AdjListNode* newNode = (AdjListNode*)malloc(sizeof(AdjListNode));
    if (!newNode) {
        perror("Allocation failed");
        exit(EXIT_FAILURE);
    }
    newNode-&gt;vertex = vertex;
    newNode-&gt;next = NULL;
    return newNode;
}

// Initialize graph
Graph* createGraph(int vertices) {
    Graph* graph = (Graph*)malloc(sizeof(Graph));
    if (!graph) {
        perror("Allocation failed");
        exit(EXIT_FAILURE);
    }
    graph-&gt;numVertices = vertices;
    graph-&gt;adjLists = (AdjListNode**)malloc(vertices * sizeof(AdjListNode*));
    if (!graph-&gt;adjLists) {
        perror("Allocation failed");
        free(graph);
        exit(EXIT_FAILURE);
    }
    for (int i = 0; i &lt; vertices; i++) {
        graph-&gt;adjLists[i] = NULL;
    }
    return graph;
}

// Add edge (undirected)
void addEdge(Graph* graph, int src, int dest) {
    AdjListNode* newNode = createNode(dest);
    newNode-&gt;next = graph-&gt;adjLists[src];
    graph-&gt;adjLists[src] = newNode;

    newNode = createNode(src);
    newNode-&gt;next = graph-&gt;adjLists[dest];
    graph-&gt;adjLists[dest] = newNode;
}

// DFS utility function
void DFSUtil(Graph* graph, int vertex, int* visited) {
    visited[vertex] = 1;
    printf("%d ", vertex);

    AdjListNode* temp = graph-&gt;adjLists[vertex];
    while (temp != NULL) {
        int adjVertex = temp-&gt;vertex;
        if (!visited[adjVertex]) {
            DFSUtil(graph, adjVertex, visited);
        }
        temp = temp-&gt;next;
    }
}

// DFS traversal
void DFS(Graph* graph, int startVertex) {
    int* visited = (int*)calloc(graph-&gt;numVertices, sizeof(int));
    if (!visited) {
        perror("Allocation failed");
        exit(EXIT_FAILURE);
    }
    printf("DFS starting from vertex %d: ", startVertex);
    DFSUtil(graph, startVertex, visited);
    printf("\n");
    free(visited);
}

// Free graph memory
void freeGraph(Graph* graph) {
    for (int i = 0; i &lt; graph-&gt;numVertices; i++) {
        AdjListNode* current = graph-&gt;adjLists[i];
        while (current != NULL) {
            AdjListNode* temp = current;
            current = current-&gt;next;
            free(temp);
        }
    }
    free(graph-&gt;adjLists);
    free(graph);
}

int main() {
    int vertices = 5;
    Graph* graph = createGraph(vertices);

    addEdge(graph, 0, 1);
    addEdge(graph, 0, 4);
    addEdge(graph, 1, 2);
    addEdge(graph, 1, 3);
    addEdge(graph, 1, 4);
    addEdge(graph, 2, 3);
    addEdge(graph, 3, 4);

    DFS(graph, 0);

    freeGraph(graph);
    return 0;
}</code></pre>
</div><h3 id="summary">Summary</h3><ul>
 <li><strong>Linked Lists</strong> demonstrate linear pointer chains with dynamic memory allocation.</li>
 <li><strong>Binary Trees</strong> illustrate hierarchical pointer-based structures with recursive traversal.</li>
 <li><strong>Graphs</strong> use arrays of pointers to linked lists for dynamic, flexible adjacency representation.</li>
 <li>Safe pointer handling and proper memory cleanup prevent leaks and undefined behavior.</li>
 <li>Recursive algorithms naturally fit pointer-based structures for elegant solutions.</li>
</ul><p>These examples solidify understanding of pointers in managing complex data and provide a strong foundation for advanced programming in C.</p><div class = "chapter-navi-section">
<a href="c-pointers-advanced-pointer-concepts.htm" class="nav-button prev">←</a>
<a href='c-pointers.htm#pointers-and-data-structures' class="nav-button toc-link">Index</a>
<a href="c-pointers-function-pointers-in-depth.htm" class="nav-button next">→</a>
</div>
<section class="download-section">
  <div class="book-cover" style="background-color: #f9f6f1;border: 1px solid #ccc;"> 
    <div class="book-cover-title" style="font-size: 22px;color: #333;top: 20px;">C Pointers</div>
    <div class="book-cover-author">readbytes</div>
    <div class="book-cover-bottom-stripe" style="background-color: #333;"></div>
    <img class="book-cover-icon" style="width: 90px;height: 90px;top: 70px;" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFoAAABaCAYAAAA4qEECAAAD5ElEQVR4Xu2dwYoUVxhGr7hQn0F8AyH4Cq5cCwFxk2cQ3GXR1TK+QN5AssnWrRsfwWR0LbhJxKXoIhBQK2Olb5/v1tdV0/fHOPwHDtj/PbdudYHOuKpSkiRJkovFUP744qevvuSyZSin1d5TLlvGs85/7re553OzO3DfJXDPRd97bobylxy49HC2tZvylvkem/Je9uz8wHyPTfmzsWeng23toXs+Ch5GHWypgy11sKUOtjQMHkQdbKmDLXWwpQ62NAweRB1sqYMtdbClDrY0DB5EHWypgy11sKUOtjQMHkQdbKmDLXWwpQ62NAweRB1sqYMtdbClDrY0DB5EHWypgy11sKUOtjQMHkQdbKmDLXWwpQ62NAweRB1sqYMtdbClDrY0SZIkSZI18CdpGqMM0hhlkMYogzRGGaQxyiCNUQZpjDJIY5RBGqMM0hhlkMYogzRGGaQxyiCNUQZpjDJIY5RBT5fAPfO+W7xvabe2PUYZ9HQpQ7kjeynh+lzLNbqmPUYZ9NR/iYcH1uevdagnXJ/8pVxZ1PVQBj1d8iUmfi7XZW3ns+pKO7TTc3t0PZRBT5d8ibVNDTvXsxnKr0waTT9l0NMlX2Ji/GvMNTZDeYrP/0hbr9ecp+mpDHp66EscWh/dlgfS1LCv14fypPrz3ar5u5rXvV6rlzLo6Rq4t3WNafZjuSyz1p6zB31J2pr9Xq/VSxn0dAlDuSr7WtfYltfN+fj79dye8UHvf/4dn9nr+b2UQU9rlszpo/LDbFczt8YHTbTXe+ilDHpaU8+35adq/lj2tfY75vZND7p1raF8lDVep6cy6GnNmrVW4xjK8+Y+/6Bbvd5DL2XQ0xqujb8FTGzKfVl/UK5Ve180rWmdWz/oobz5b74p92Z63mM/ZdDTGq4dWndrkyflRrPZzeoHPf6bf+tfeZ3WNXorg57WcO3M29X6zebeuf+UaHfSmO0/6Dl3va71UgY9reGaa1qzOVvtxKb8Jn1L7o9QBmmMMkhjlEEaowzSGGWQxiiDNEYZpDHKII1RBmmMMkhjlEEaowzSGGWQxiiDNEYZpDHKII0xSZIkSZI18CcpdbClDrbUwZY62NIweBB1sKUOttTBljrY0jB4EHWwpQ621MGWOtjSMHgQdbClDrbUwZY62NIweBB1sKUOttTBljrY0jB4EHWwpQ621MGWOtjSMHgQdbClDrbUwZY62NIweBB1sKUOttTBljrY0jB4EHWwpQ621MGWOtjSMKJeSjZe13HMS8m23+NLyUZ44JIbnuCei773aPZfpLjuJYzbI17CeNyLI+tzX3HZsn/uuntOkiRJ/vd8BnnbnC2TD9qmAAAAAElFTkSuQmCC"/>
  </div>
  <div class="download-info">
    <h2 id='bottom'>Download This Ebook</h2>
    <p class="format-label">Available formats:</p>
    <div class="download-buttons">
      <a href="c-pointers.pdf" class="download-button">📄 PDF</a>
      <a href="c-pointers.epub" class="download-button">📘 EPUB</a>
    </div>
  </div>
</section><div class='related-books'>
<h2>C Introduction Books</h2>
<div class='related-book-list'>
<a href="c-for-beginners.htm">
<div class="book-cover" style="background-color: #f9f6f1;border: 1px solid #ccc;"> 
    <div class="book-cover-title" style="font-size: 18px;color: #333;top: 20px;">C for Beginners</div>
    <div class="book-cover-author">readbytes</div>
    <div class="book-cover-bottom-stripe" style="background-color: #333;"></div>
    <img class="book-cover-icon" style="width: 90px;height: 90px;top: 70px;" src="data:image/png;base64,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"/>
  </div>
</a>


<a href="c-pointers.htm">
<div class="book-cover" style="background-color: #f9f6f1;border: 1px solid #ccc;"> 
    <div class="book-cover-title" style="font-size: 22px;color: #333;top: 20px;">C Pointers</div>
    <div class="book-cover-author">readbytes</div>
    <div class="book-cover-bottom-stripe" style="background-color: #333;"></div>
    <img class="book-cover-icon" style="width: 90px;height: 90px;top: 70px;" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFoAAABaCAYAAAA4qEECAAAD5ElEQVR4Xu2dwYoUVxhGr7hQn0F8AyH4Cq5cCwFxk2cQ3GXR1TK+QN5AssnWrRsfwWR0LbhJxKXoIhBQK2Olb5/v1tdV0/fHOPwHDtj/PbdudYHOuKpSkiRJkovFUP744qevvuSyZSin1d5TLlvGs85/7re553OzO3DfJXDPRd97bobylxy49HC2tZvylvkem/Je9uz8wHyPTfmzsWeng23toXs+Ch5GHWypgy11sKUOtjQMHkQdbKmDLXWwpQ62NAweRB1sqYMtdbClDrY0DB5EHWypgy11sKUOtjQMHkQdbKmDLXWwpQ62NAweRB1sqYMtdbClDrY0DB5EHWypgy11sKUOtjQMHkQdbKmDLXWwpQ62NAweRB1sqYMtdbClDrY0SZIkSZI18CdpGqMM0hhlkMYogzRGGaQxyiCNUQZpjDJIY5RBGqMM0hhlkMYogzRGGaQxyiCNUQZpjDJIY5RBT5fAPfO+W7xvabe2PUYZ9HQpQ7kjeynh+lzLNbqmPUYZ9NR/iYcH1uevdagnXJ/8pVxZ1PVQBj1d8iUmfi7XZW3ns+pKO7TTc3t0PZRBT5d8ibVNDTvXsxnKr0waTT9l0NMlX2Ji/GvMNTZDeYrP/0hbr9ecp+mpDHp66EscWh/dlgfS1LCv14fypPrz3ar5u5rXvV6rlzLo6Rq4t3WNafZjuSyz1p6zB31J2pr9Xq/VSxn0dAlDuSr7WtfYltfN+fj79dye8UHvf/4dn9nr+b2UQU9rlszpo/LDbFczt8YHTbTXe+ilDHpaU8+35adq/lj2tfY75vZND7p1raF8lDVep6cy6GnNmrVW4xjK8+Y+/6Bbvd5DL2XQ0xqujb8FTGzKfVl/UK5Ve180rWmdWz/oobz5b74p92Z63mM/ZdDTGq4dWndrkyflRrPZzeoHPf6bf+tfeZ3WNXorg57WcO3M29X6zebeuf+UaHfSmO0/6Dl3va71UgY9reGaa1qzOVvtxKb8Jn1L7o9QBmmMMkhjlEEaowzSGGWQxiiDNEYZpDHKII1RBmmMMkhjlEEaowzSGGWQxiiDNEYZpDHKII0xSZIkSZI18CcpdbClDrbUwZY62NIweBB1sKUOttTBljrY0jB4EHWwpQ621MGWOtjSMHgQdbClDrbUwZY62NIweBB1sKUOttTBljrY0jB4EHWwpQ621MGWOtjSMHgQdbClDrbUwZY62NIweBB1sKUOttTBljrY0jB4EHWwpQ621MGWOtjSMKJeSjZe13HMS8m23+NLyUZ44JIbnuCei773aPZfpLjuJYzbI17CeNyLI+tzX3HZsn/uuntOkiRJ/vd8BnnbnC2TD9qmAAAAAElFTkSuQmCC"/>
  </div>
</a>



<a href='c.htm'><div class='book-cover' style='background-color: #f9f6f1;color: #111111;border: 1px solid #ccc;display: flex;justify-content: center;align-items: center;text-align: center;'>More C Books</div></a>
</div>
</div>
  </div>
  <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/prism.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script>
  function toggleSnippet(id) {
      const box = document.getElementById(id);
      box.classList.toggle("open");
  }  
  </script>
  <script>
    function copyCode(button) {
      const code = button.nextElementSibling.innerText;
      navigator.clipboard.writeText(code).then(() => {
        button.textContent = 'Copied!';
        setTimeout(() => { button.textContent = 'Copy'; }, 1500);
      });
    }
  </script>  
<div id="floatingLog" aria-live="polite" role="alert"></div>
<footer class="page-footer">
    <nav>
      <a href="https://readbytes.github.io">Home</a> | 
      Email:<script language="JavaScript" type="text/javascript">
var part1 = 'yinpeng';var part6 = '263';var part2 = Math.pow(2,6);var part3 = String.fromCharCode(part2);var part4 = 'hotmail dot com';var part5 = part1 + String.fromCharCode(part2) + part4;document.write(part1 + part6 + part3 + part4);
</script>
    </nav>
  <p>© 2025 — All rights reserved.</p>    
  </footer>

</body>
</html>