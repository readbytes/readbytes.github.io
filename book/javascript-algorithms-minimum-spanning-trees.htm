<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>JavaScript Algorithms Minimum Spanning Trees</title>
<link rel='shortcut icon' href='https://java2s.com/style/favicon.ico'>
<link href="https://fonts.googleapis.com/css2?family=Merriweather&display=swap" rel="stylesheet" />
<link href="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet" />


  <script>
  const mode = localStorage.getItem('mode') || 'light';
  document.documentElement.classList.add(`${mode}-mode`);
  </script>   
<style> 
html {
  scroll-behavior: smooth;
}

body {
  font-family: 'Merriweather', serif;
  margin: 0;
  padding: 2rem 1rem;
  font-size: 15px;
  line-height: 1.5;
  transition: background-color 0.3s, color 0.3s;
}

.container {
  max-width: 700px;
  margin: 0 auto;
  padding: 1rem 2rem;
  box-shadow: 0 0 15px rgba(0,0,0,0.1);
}

h1, h2, h3 {
  font-weight: 600;
  margin-top: 2.5rem;
  margin-bottom: 1rem;
  line-height: 1.2;
}

h1 { font-size: 1.8rem; }
h2 { font-size: 1.4rem; }
h3 { font-size: 1.2rem; }

table {
  width: 100%;
  border-collapse: collapse;
  font-family: sans-serif;
  font-size: 1em;
  margin: 1em 0;
}

th, td {
  padding: 0.6em 1em;
  text-align: left;
  border: 1px solid;
}

tr:nth-child(even) {
  background-color: inherit;
}

tr:hover {
  background-color: inherit;
}

a {
  text-decoration: none;
  transition: color 0.2s;
}

a:hover {
  text-decoration: underline;
}

code {
  color: #d35400;
}

.book-title-chapter {
  font-family: 'Merriweather', serif;
  font-size: 2rem;
  font-weight: bold;
  text-align: center;
  margin-bottom: 2rem;
  border-bottom: 2px solid;
  padding-bottom: 0.5rem;
}

.book-subtitle-chapter {
  text-align: center;
  font-size: 1rem;
  margin-top: -1rem;
  margin-bottom: 2rem;
}

.related-books {
  margin-top: 40px;
}

.related-book-list {
  display: flex;
  flex-wrap: wrap;
  gap: 20px;
}

    .book-cover {
      width: 130px;
      height: 180px;
      font-family: Arial, sans-serif;
      position: relative;
      overflow: hidden;      
      line-height: normal;
      box-shadow: 2px 2px 4px rgba(0,0,0,0.1);
    }
    .book-cover-bottom-stripe {
      position: absolute;
      bottom: 0;
      left: 0;
      height: 5px;
      width: 100%;
    }
    .book-cover-title {
      position: absolute;
      width: 100%;
      text-align: center;
      font-weight: bold;
    }
     
    .book-cover-icon {
      position: absolute;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      align-items: center;
      justify-content: center; 
    }

    .book-cover-author {
      position: absolute;
      bottom: 10px;
      width: 100%;
      text-align: center;
      font-size: 8px;
      color: #333;
    }

.page-footer {
  margin-top: 4rem;
  padding: 1rem 0;
  text-align: center;
  font-size: 0.85rem;
  border-top: 1px solid;
}

.chapter-navi-section {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding-bottom: 10px;
}

.nav-link {
  color: inherit;
  text-decoration: none;
  opacity: 0.5;
  transition: opacity 0.3s ease, text-decoration 0.3s ease;
}

.nav-link:hover {
  opacity: 0.9;
  text-decoration: underline;
}

.prev { text-align: left; }
.toc-link { text-align: center; }
.next { text-align: right; }

.download-section {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 2rem;
  padding: 2rem 1rem;
  max-width: 600px;
  margin: 3rem auto;
  border-radius: 12px;
  box-shadow: 0 4px 10px rgba(0,0,0,0.05);
}

.download-info h2 {
  margin: 0 0 0.5rem;
  font-size: 1.2rem;
}

.format-label {
  margin: 0 0 0.5rem;
  font-size: 0.95rem;
}

.download-buttons {
  display: flex;
  gap: 1rem;
}

.download-button {
  background-color: #4A90E2;
  color: white;
  padding: 0.5em 1.2em;
  border-radius: 25px;
  font-size: 0.95rem;
  text-decoration: none;
  transition: background-color 0.3s ease;
}

.download-button:hover {
  background-color: #357ABD;
}

.code-block {
  position: relative;
  margin-bottom: 1em;
}

.copy-button {
  background: transparent;
  color: white;
  position: absolute;
  top: 8px;
  right: 8px;
  border: none;
  padding: 4px 8px;
  font-size: 12px;
  border-radius: 4px;
  cursor: pointer;
  z-index: 1;
}

.copy-button:hover {
  background-color: #0056b3;
}

.snippet-container {
  overflow: hidden;
}

.snippet-header {
  padding: 0.75rem 1rem;
  cursor: pointer;
  font-size: 1rem;
    background-color: #eeeeee;
    color:  #111111; 
    border-radius: 8px;
    cursor: pointer;
    box-shadow: 0 4px 6px rgba(0,0,0,0.1);  
}

.snippet-body {
  display: none;
  font-family: monospace;
}

.snippet-container.open .snippet-body {
  display: block;
}

.CodeMirror {
  border: 2px solid #ccc;
  border-radius: 4px;
  resize: vertical;
}

/* === Light Mode === */
html.light-mode {
  background-color: #f8f7f5;
  color: #333;
}

html.light-mode .container {
  background: white;
}

html.light-mode .book-title-chapter {
  color: #2c3e50;
  border-color: #ccc;
}
html.light-mode .book-subtitle-chapter{
  color: #888;
}

html.light-mode .page-footer,
html.light-mode .series-name,
html.light-mode .book-subtitle,
html.light-mode .format-label {
  color: #888;
}

html.light-mode .related-books h2 {
  color: #333;
  border-bottom: 2px solid #eee;
}

html.light-mode .book-title {
  color: #fff;
}

html.light-mode .book-cover {
  border: 1px solid #ccc;
}

html.light-mode th {
  background-color: #f2f2f2;
}

html.light-mode tr:nth-child(even) {
  background-color: #fafafa;
}

html.light-mode tr:hover {
  background-color: #e6f7ff;
}

html.light-mode a,
html.light-mode .page-footer a {
  color: #000;
}

/* === Dark Mode === */
html.dark-mode {
  background-color: #181818;
  color: #e0e0e0;
}

html.dark-mode .container {
  background: #222;
}

html.dark-mode .book-title-chapter {
  color: #ddd;
  border-color: #444;
}

html.dark-mode .snippet-header {
    background-color: #333;
    color:  #ddd; 
}


html.dark-mode .book-subtitle-chapter,
html.dark-mode .page-footer,
html.dark-mode .series-name,
html.dark-mode .book-subtitle,
html.dark-mode .book-footer,
html.dark-mode .format-label {
  color: #aaa;
}

html.dark-mode .related-books h2 {
  color: #ddd;
  border-bottom: 2px solid #333;
}

html.dark-mode .book-title {
  color: #fff;
}

html.dark-mode .book-cover {
  border: 1px solid #555;
}

html.dark-mode th {
  background-color: #333;
  color: #fff;
}

html.dark-mode td {
  border-color: #444;
}

html.dark-mode tr:nth-child(even) {
  background-color: #2a2a2a;
}

html.dark-mode tr:hover {
  background-color: #2c3e50;
}

html.dark-mode a,
html.dark-mode .page-footer a {
  color: #eee;
}

    .dialog-backdrop {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: rgba(0,0,0,0.5);
      display: none;
      justify-content: center;
      align-items: center;
      z-index: 10;
    }

    .dialog {
      background: white;
      padding: 20px;
      width: 90vw;
      height: 80vh;
      border-radius: 8px;
      box-shadow: 0 0 20px rgba(0,0,0,0.3);
      display: flex;
      flex-direction: column;
    }
    .dialog-content {
      display: flex;
      flex: 1;
      gap: 20px;
      margin-top: 10px;
    }
    .dialog h2 {
      margin-top: 0;
    }

    .textarea_dialog {
      width: 50%;
      height: 100%;
      resize: none;
      font-family: monospace;
      font-size: 14px;
      padding: 10px;
      box-sizing: border-box;
      border: 1px solid #ccc;
    }

    .iframe_dialog {
      width: 50%;
      height: 100%;
      border: 1px solid #ccc;
    }
    .controls_dialog {
      display: flex;
      justify-content: space-between;
      margin-top: 10px;
    }    
    button { padding: 0.5em 1em; background: green; color: white; border: none; cursor: pointer; }
    button:hover { background: #1e7e34; }
    .result_iframe { width:99%; height:200px; margin-top: 1em;  resize: both;border:1px solid #ccc;}        
</style>
</head>
<body> 
  <div class="container">
    <div class = "chapter-navi-section">
<a href="javascript-algorithms-graph-shortest-paths.htm" class="nav-button prev">←</a>
<a href='javascript-algorithms.htm#minimum-spanning-trees' class="nav-button toc-link">Index</a>
<a href="javascript-algorithms-principles-of-dynamic-programming.htm" class="nav-button next">→</a>
</div>

    <h1 class="book-title-chapter" id = 'top'>Minimum Spanning Trees</h1>
    <h3 class="book-subtitle-chapter">JavaScript Algorithms</h3>   
    <!-- <h1 class ="chapter-title"></h1> -->
    <h2 id='prim-s-algorithm'>16.1 Prim’s Algorithm</h2><p>In graph theory, a <strong>Minimum Spanning Tree (MST)</strong> is a subset of edges in a <strong>connected, weighted, undirected graph</strong> that connects all the vertices together without cycles and with the minimum possible total edge weight. <strong>Prim’s algorithm</strong> is a greedy technique to construct an MST by <strong>expanding from a starting node</strong>, always choosing the smallest edge that adds a new vertex to the tree.</p><h3 id="how-prims-algorithm-works">How Prims Algorithm Works</h3><p>Prim’s algorithm grows a tree by continuously selecting the <strong>lowest-weight edge</strong> that connects a visited node to an unvisited one.</p><h4 id="step-by-step-process">Step-by-step Process:</h4><ol>
 <li><p>Start from any arbitrary node.</p></li>
 <li><p>Mark it as visited.</p></li>
 <li><p>Push all its edges into a <strong>priority queue</strong> sorted by weight.</p></li>
 <li><p>At each step:</p>
  <ul>
   <li>Extract the smallest edge from the queue.</li>
   <li>If it connects to an unvisited node, add that node and the edge to the MST.</li>
   <li>Push all adjacent edges of the new node into the queue.</li>
  </ul></li>
 <li><p>Repeat until all vertices are included.</p></li>
</ol><div class="snippet-container" id="<!DOCTYPE html>
<html lang=&quot;en&quot;>
<head>
<meta charset=&quot;UTF-8&quot; />
<title>Minimum Spanning Tree (Kruskal's Algorithm)</title>
<style>
  body { font-family: sans-serif; text-align: center; padding: 20px; }
  canvas { border: 1px solid #ccc; background: #f9f9f9; display: block; margin: 0 auto; }
  button { font-size: 16px; padding: 8px 12px; margin: 10px; }
  #info { font-family: monospace; margin-top: 10px; }
</style>
</head>
<body>

<h2>Minimum Spanning Tree (Kruskal's Algorithm) Visualization</h2>
<button onclick=&quot;startKruskal()&quot;>Start Kruskal's MST</button>
<canvas id=&quot;canvas&quot; width=&quot;600&quot; height=&quot;600&quot;></canvas>
<div id=&quot;info&quot;></div>

<script>
  const canvas = document.getElementById(&quot;canvas&quot;);
  const ctx = canvas.getContext(&quot;2d&quot;);
  const infoDiv = document.getElementById(&quot;info&quot;);

  const nodes = [
    { label: 'A', x: 100, y: 100 },
    { label: 'B', x: 300, y: 80 },
    { label: 'C', x: 500, y: 120 },
    { label: 'D', x: 150, y: 300 },
    { label: 'E', x: 350, y: 320 },
    { label: 'F', x: 550, y: 320 },
    { label: 'G', x: 400, y: 450 },
  ];

  // Undirected edges: [from, to, weight]
  const edges = [
    ['A', 'B', 7],
    ['A', 'D', 5],
    ['B', 'C', 8],
    ['B', 'D', 9],
    ['B', 'E', 7],
    ['C', 'E', 5],
    ['D', 'E', 15],
    ['D', 'G', 6],
    ['E', 'F', 8],
    ['E', 'G', 9],
    ['F', 'G', 11],
  ];

  // Disjoint Set (Union-Find) data structure
  class DisjointSet {
    constructor(elements) {
      this.parent = {};
      this.rank = {};
      for (const el of elements) {
        this.parent[el] = el;
        this.rank[el] = 0;
      }
    }

    find(u) {
      if (this.parent[u] !== u) {
        this.parent[u] = this.find(this.parent[u]);
      }
      return this.parent[u];
    }

    union(u, v) {
      const rootU = this.find(u);
      const rootV = this.find(v);
      if (rootU === rootV) return false;
      if (this.rank[rootU] < this.rank[rootV]) {
        this.parent[rootU] = rootV;
      } else if (this.rank[rootV] < this.rank[rootU]) {
        this.parent[rootV] = rootU;
      } else {
        this.parent[rootV] = rootU;
        this.rank[rootU]++;
      }
      return true;
    }
  }

  let mstEdges = [];
  let stepIndex = 0;
  let sortedEdges = [];
  let ds;

  function startKruskal() {
    mstEdges = [];
    stepIndex = 0;
    sortedEdges = edges.slice().sort((a, b) => a[2] - b[2]);
    ds = new DisjointSet(nodes.map(n => n.label));
    infoDiv.textContent = 'Starting Kruskal\'s Algorithm...';
    animateStep();
  }

  function animateStep() {
    if (stepIndex >= sortedEdges.length) {
      infoDiv.textContent = 'Kruskal\'s Algorithm completed. MST edges selected: ' + mstEdges.map(e => `${e[0]}-${e[1]}`).join(', ');
      drawGraph();
      return;
    }
    const [u, v, w] = sortedEdges[stepIndex];
    if (ds.union(u, v)) {
      mstEdges.push([u, v, w]);
      infoDiv.textContent = `Adding edge ${u} - ${v} (weight: ${w}) to MST`;
    } else {
      infoDiv.textContent = `Skipping edge ${u} - ${v} (weight: ${w}) - would form a cycle`;
    }
    drawGraph();
    stepIndex++;
    setTimeout(animateStep, 1200);
  }

  function drawGraph() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // Draw all edges (light gray)
    ctx.strokeStyle = '#ccc';
    ctx.lineWidth = 2;
    for (const [from, to, w] of edges) {
      const fromNode = nodes.find(n => n.label === from);
      const toNode = nodes.find(n => n.label === to);
      ctx.beginPath();
      ctx.moveTo(fromNode.x, fromNode.y);
      ctx.lineTo(toNode.x, toNode.y);
      ctx.stroke();

      // Draw weight
      const midX = (fromNode.x + toNode.x) / 2;
      const midY = (fromNode.y + toNode.y) / 2;
      ctx.fillStyle = '#555';
      ctx.font = '14px Arial';
      ctx.fillText(w, midX + 5, midY - 5);
    }

    // Draw MST edges (green)
    ctx.strokeStyle = '#27ae60';
    ctx.lineWidth = 5;
    for (const [from, to] of mstEdges) {
      const fromNode = nodes.find(n => n.label === from);
      const toNode = nodes.find(n => n.label === to);
      ctx.beginPath();
      ctx.moveTo(fromNode.x, fromNode.y);
      ctx.lineTo(toNode.x, toNode.y);
      ctx.stroke();
    }

    // Draw nodes
    for (const node of nodes) {
      ctx.beginPath();
      ctx.arc(node.x, node.y, 25, 0, 2 * Math.PI);
      ctx.fillStyle = '#3498db';
      ctx.fill();
      ctx.strokeStyle = '#2980b9';
      ctx.lineWidth = 2;
      ctx.stroke();

      ctx.fillStyle = '#fff';
      ctx.font = '18px Arial';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(node.label, node.x, node.y);
    }
  }

  drawGraph();
</script>

</body>
</html>ID"><textarea id="V9Z5v" style="display: none;">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
&lt;meta charset="UTF-8" /&gt;
&lt;title&gt;Minimum Spanning Tree (Kruskal's Algorithm)&lt;/title&gt;
&lt;style&gt;
  body { font-family: sans-serif; text-align: center; padding: 20px; }
  canvas { border: 1px solid #ccc; background: #f9f9f9; display: block; margin: 0 auto; }
  button { font-size: 16px; padding: 8px 12px; margin: 10px; }
  #info { font-family: monospace; margin-top: 10px; }
&lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;h2&gt;Minimum Spanning Tree (Kruskal's Algorithm) Visualization&lt;/h2&gt;
&lt;button onclick="startKruskal()"&gt;Start Kruskal's MST&lt;/button&gt;
&lt;canvas id="canvas" width="600" height="600"&gt;&lt;/canvas&gt;
&lt;div id="info"&gt;&lt;/div&gt;

&lt;script&gt;
  const canvas = document.getElementById("canvas");
  const ctx = canvas.getContext("2d");
  const infoDiv = document.getElementById("info");

  const nodes = [
    { label: 'A', x: 100, y: 100 },
    { label: 'B', x: 300, y: 80 },
    { label: 'C', x: 500, y: 120 },
    { label: 'D', x: 150, y: 300 },
    { label: 'E', x: 350, y: 320 },
    { label: 'F', x: 550, y: 320 },
    { label: 'G', x: 400, y: 450 },
  ];

  // Undirected edges: [from, to, weight]
  const edges = [
    ['A', 'B', 7],
    ['A', 'D', 5],
    ['B', 'C', 8],
    ['B', 'D', 9],
    ['B', 'E', 7],
    ['C', 'E', 5],
    ['D', 'E', 15],
    ['D', 'G', 6],
    ['E', 'F', 8],
    ['E', 'G', 9],
    ['F', 'G', 11],
  ];

  // Disjoint Set (Union-Find) data structure
  class DisjointSet {
    constructor(elements) {
      this.parent = {};
      this.rank = {};
      for (const el of elements) {
        this.parent[el] = el;
        this.rank[el] = 0;
      }
    }

    find(u) {
      if (this.parent[u] !== u) {
        this.parent[u] = this.find(this.parent[u]);
      }
      return this.parent[u];
    }

    union(u, v) {
      const rootU = this.find(u);
      const rootV = this.find(v);
      if (rootU === rootV) return false;
      if (this.rank[rootU] &lt; this.rank[rootV]) {
        this.parent[rootU] = rootV;
      } else if (this.rank[rootV] &lt; this.rank[rootU]) {
        this.parent[rootV] = rootU;
      } else {
        this.parent[rootV] = rootU;
        this.rank[rootU]++;
      }
      return true;
    }
  }

  let mstEdges = [];
  let stepIndex = 0;
  let sortedEdges = [];
  let ds;

  function startKruskal() {
    mstEdges = [];
    stepIndex = 0;
    sortedEdges = edges.slice().sort((a, b) =&gt; a[2] - b[2]);
    ds = new DisjointSet(nodes.map(n =&gt; n.label));
    infoDiv.textContent = 'Starting Kruskal\'s Algorithm...';
    animateStep();
  }

  function animateStep() {
    if (stepIndex &gt;= sortedEdges.length) {
      infoDiv.textContent = 'Kruskal\'s Algorithm completed. MST edges selected: ' + mstEdges.map(e =&gt; `${e[0]}-${e[1]}`).join(', ');
      drawGraph();
      return;
    }
    const [u, v, w] = sortedEdges[stepIndex];
    if (ds.union(u, v)) {
      mstEdges.push([u, v, w]);
      infoDiv.textContent = `Adding edge ${u} - ${v} (weight: ${w}) to MST`;
    } else {
      infoDiv.textContent = `Skipping edge ${u} - ${v} (weight: ${w}) - would form a cycle`;
    }
    drawGraph();
    stepIndex++;
    setTimeout(animateStep, 1200);
  }

  function drawGraph() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // Draw all edges (light gray)
    ctx.strokeStyle = '#ccc';
    ctx.lineWidth = 2;
    for (const [from, to, w] of edges) {
      const fromNode = nodes.find(n =&gt; n.label === from);
      const toNode = nodes.find(n =&gt; n.label === to);
      ctx.beginPath();
      ctx.moveTo(fromNode.x, fromNode.y);
      ctx.lineTo(toNode.x, toNode.y);
      ctx.stroke();

      // Draw weight
      const midX = (fromNode.x + toNode.x) / 2;
      const midY = (fromNode.y + toNode.y) / 2;
      ctx.fillStyle = '#555';
      ctx.font = '14px Arial';
      ctx.fillText(w, midX + 5, midY - 5);
    }

    // Draw MST edges (green)
    ctx.strokeStyle = '#27ae60';
    ctx.lineWidth = 5;
    for (const [from, to] of mstEdges) {
      const fromNode = nodes.find(n =&gt; n.label === from);
      const toNode = nodes.find(n =&gt; n.label === to);
      ctx.beginPath();
      ctx.moveTo(fromNode.x, fromNode.y);
      ctx.lineTo(toNode.x, toNode.y);
      ctx.stroke();
    }

    // Draw nodes
    for (const node of nodes) {
      ctx.beginPath();
      ctx.arc(node.x, node.y, 25, 0, 2 * Math.PI);
      ctx.fillStyle = '#3498db';
      ctx.fill();
      ctx.strokeStyle = '#2980b9';
      ctx.lineWidth = 2;
      ctx.stroke();

      ctx.fillStyle = '#fff';
      ctx.font = '18px Arial';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(node.label, node.x, node.y);
    }
  }

  drawGraph();
&lt;/script&gt;

&lt;/body&gt;
&lt;/html&gt;</textarea> <iframe id="2aqIk" class="result_iframe" style="border:none;"></iframe>
 <script>{
const textarea = document.getElementById("V9Z5v");
const iframe = document.getElementById("2aqIk");
const html = textarea.value;
const iframeHTML = `${html}`;
const doc = iframe.contentDocument || iframe.contentWindow.document;
doc.open();
doc.write(iframeHTML);
doc.close();
setTimeout(() => {
   iframe.style.height = '0px';
   let contentHeight = Math.max(doc.body.scrollHeight,doc.documentElement.scrollHeight);
   if(contentHeight < 10 || contentHeight > 800){
	   contentHeight = 800;
   } 
   iframe.style.height = contentHeight + 'px';
}, 50);
}
		</script>
</div><h3 id="graph-representation">Graph Representation</h3><p>We’ll use an <strong>adjacency list</strong> to represent the graph, and a <strong>min-heap priority queue</strong> to always fetch the smallest available edge.</p><h3 id="javascript-implementation">JavaScript Implementation</h3><h4 id="priority-queue-min-heap">Priority Queue (Min-Heap)</h4><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-js">class MinHeap {
  constructor() {
    this.heap = [];
  }

  insert(item) {
    this.heap.push(item);
    this._bubbleUp();
  }

  extractMin() {
    if (this.heap.length &lt;= 1) return this.heap.pop();
    const min = this.heap[0];
    this.heap[0] = this.heap.pop();
    this._sinkDown();
    return min;
  }

  _bubbleUp() {
    let idx = this.heap.length - 1;
    const element = this.heap[idx];
    while (idx &gt; 0) {
      const parentIdx = Math.floor((idx - 1) / 2);
      if (this.heap[parentIdx].weight &lt;= element.weight) break;
      [this.heap[idx], this.heap[parentIdx]] = [this.heap[parentIdx], this.heap[idx]];
      idx = parentIdx;
    }
  }

  _sinkDown() {
    let idx = 0;
    const length = this.heap.length;
    const element = this.heap[0];

    while (true) {
      let left = 2 * idx + 1;
      let right = 2 * idx + 2;
      let smallest = idx;

      if (left &lt; length &amp;&amp; this.heap[left].weight &lt; this.heap[smallest].weight) smallest = left;
      if (right &lt; length &amp;&amp; this.heap[right].weight &lt; this.heap[smallest].weight) smallest = right;

      if (smallest === idx) break;

      [this.heap[idx], this.heap[smallest]] = [this.heap[smallest], this.heap[idx]];
      idx = smallest;
    }
  }

  isEmpty() {
    return this.heap.length === 0;
  }
}</code></pre>
</div><h4 id="prims-algorithm-on-a-graph">Prims Algorithm on a Graph</h4><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-js">class Graph {
  constructor() {
    this.adjList = new Map();
  }

  addEdge(u, v, weight) {
    if (!this.adjList.has(u)) this.adjList.set(u, []);
    if (!this.adjList.has(v)) this.adjList.set(v, []);
    this.adjList.get(u).push({ node: v, weight });
    this.adjList.get(v).push({ node: u, weight }); // Undirected graph
  }

  primMST(start) {
    const visited = new Set();
    const mst = [];
    const heap = new MinHeap();

    visited.add(start);
    for (let edge of this.adjList.get(start)) {
      heap.insert({ from: start, to: edge.node, weight: edge.weight });
    }

    while (!heap.isEmpty()) {
      const { from, to, weight } = heap.extractMin();
      if (visited.has(to)) continue;

      visited.add(to);
      mst.push({ from, to, weight });

      for (let neighbor of this.adjList.get(to)) {
        if (!visited.has(neighbor.node)) {
          heap.insert({ from: to, to: neighbor.node, weight: neighbor.weight });
        }
      }
    }

    return mst;
  }
}</code></pre>
</div><h4 id="example-usage">Example Usage</h4><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-js">const g = new Graph();
g.addEdge('A', 'B', 3);
g.addEdge('A', 'D', 1);
g.addEdge('B', 'D', 3);
g.addEdge('B', 'C', 1);
g.addEdge('C', 'D', 1);
g.addEdge('C', 'E', 5);
g.addEdge('D', 'E', 6);

const mst = g.primMST('A');
console.log(mst);</code></pre>
</div><h3 id="visual-step-example">Visual Step Example</h3><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-bash">Vertices: A, B, C, D, E
Start at A → choose edge with weight 1 (A-D)
From D → choose edge D-C (1)
From C → choose edge C-B (1)
From B → skip D (already visited), then done</code></pre>
</div><p>Final MST edges: A-D, D-C, C-B — total weight = 3</p><h3 id="time-complexity">Time Complexity</h3><ul>
 <li><strong>With min-heap + adjacency list</strong>: O(E log V)</li>
 <li><strong>Without heap</strong>: O(V²)</li>
</ul><p>Where:</p><ul>
 <li><code>V</code> = number of vertices</li>
 <li><code>E</code> = number of edges</li>
</ul><h3 id="real-world-applications">Real-World Applications</h3><ul>
 <li><strong>Network Design</strong>: Build efficient communication, electrical, or road networks with minimal cost.</li>
 <li><strong>Image Processing</strong>: Region grouping and segmentation.</li>
 <li><strong>Clustering Algorithms</strong>: Like single-linkage clustering in data science.</li>
 <li><strong>Approximation Algorithms</strong>: Used as part of heuristics in NP-hard problems.</li>
</ul><h3 id="summary">Summary</h3><p>Prim’s algorithm efficiently builds a <strong>Minimum Spanning Tree</strong> by incrementally expanding the frontier with the smallest possible edge. Its greedy nature ensures optimality in undirected graphs. With a solid JavaScript implementation using priority queues, it's practical for frontend visualizations, backend route planning, or any application needing cost-efficient connectivity.</p><div class = "chapter-navi-section">
<a href="#top" class="nav-button prev">↑</a>
<a href='javascript-algorithms.htm#minimum-spanning-trees' class="nav-button toc-link">Index</a>
<a href="#bottom" class="nav-button next">↓</a>
</div>
<h2 id='kruskal-s-algorithm'>16.2 Kruskal’s Algorithm</h2><p><strong>Kruskal’s algorithm</strong> is a classic greedy algorithm used to find a <strong>Minimum Spanning Tree (MST)</strong> of a connected, undirected, weighted graph. It takes a different approach from Prim’s algorithm. Instead of growing a tree from a starting vertex, Kruskal's algorithm <strong>sorts all edges by weight</strong> and adds them one by one to the MST, <strong>only if they don't form a cycle</strong>.</p><p>To efficiently detect cycles, Kruskal’s algorithm relies on a <strong>Union-Find</strong> (also known as Disjoint Set Union) data structure.</p><h3 id="how-kruskals-algorithm-works">How Kruskals Algorithm Works</h3><ol>
 <li><p>Sort all edges in <strong>ascending order</strong> based on their weights.</p></li>
 <li><p>Initialize a Union-Find data structure where each node is in its own set.</p></li>
 <li><p>For each edge:</p>
  <ul>
   <li>If the two vertices of the edge belong to <strong>different sets</strong>, include the edge in the MST and <strong>union</strong> their sets.</li>
   <li>If the two vertices are in the <strong>same set</strong>, skip the edge (it would form a cycle).</li>
  </ul></li>
 <li><p>Repeat until the MST has <code>V - 1</code> edges, where <code>V</code> is the number of vertices.</p></li>
</ol><div class="snippet-container" id="<!DOCTYPE html>
<html lang=&quot;en&quot;>
<head>
<meta charset=&quot;UTF-8&quot; />
<title>Kruskal’s Algorithm Visualization</title>
<style>
  body { font-family: sans-serif; text-align: center; padding: 20px; }
  canvas { border: 1px solid #ccc; background: #f9f9f9; display: block; margin: 0 auto; }
  button { font-size: 16px; padding: 8px 12px; margin: 10px; }
  #info { font-family: monospace; margin-top: 10px; }
</style>
</head>
<body>

<h2>Kruskal’s Algorithm Visualization</h2>
<button onclick=&quot;startKruskal()&quot;>Start Kruskal</button>
<canvas id=&quot;canvas&quot; width=&quot;600&quot; height=&quot;600&quot;></canvas>
<div id=&quot;info&quot;></div>

<script>
  const canvas = document.getElementById(&quot;canvas&quot;);
  const ctx = canvas.getContext(&quot;2d&quot;);
  const infoDiv = document.getElementById(&quot;info&quot;);

  // Graph nodes
  const nodes = [
    { label: 'A', x: 100, y: 100 },
    { label: 'B', x: 300, y: 80 },
    { label: 'C', x: 500, y: 120 },
    { label: 'D', x: 150, y: 300 },
    { label: 'E', x: 350, y: 320 },
    { label: 'F', x: 550, y: 320 },
    { label: 'G', x: 400, y: 450 },
  ];

  // Undirected weighted edges: [from, to, weight]
  const edges = [
    ['A', 'B', 7],
    ['A', 'D', 5],
    ['B', 'C', 8],
    ['B', 'D', 9],
    ['B', 'E', 7],
    ['C', 'E', 5],
    ['D', 'E', 15],
    ['D', 'G', 6],
    ['E', 'F', 8],
    ['E', 'G', 9],
    ['F', 'G', 11],
  ];

  // Union-Find (Disjoint Set) for cycle detection
  class DisjointSet {
    constructor(elements) {
      this.parent = {};
      this.rank = {};
      for (const el of elements) {
        this.parent[el] = el;
        this.rank[el] = 0;
      }
    }
    find(u) {
      if (this.parent[u] !== u) {
        this.parent[u] = this.find(this.parent[u]);
      }
      return this.parent[u];
    }
    union(u, v) {
      const rootU = this.find(u);
      const rootV = this.find(v);
      if (rootU === rootV) return false;
      if (this.rank[rootU] < this.rank[rootV]) {
        this.parent[rootU] = rootV;
      } else if (this.rank[rootV] < this.rank[rootU]) {
        this.parent[rootV] = rootU;
      } else {
        this.parent[rootV] = rootU;
        this.rank[rootU]++;
      }
      return true;
    }
  }

  let mstEdges = [];
  let stepIndex = 0;
  let sortedEdges = [];
  let ds;

  function startKruskal() {
    mstEdges = [];
    stepIndex = 0;
    sortedEdges = edges.slice().sort((a, b) => a[2] - b[2]);
    ds = new DisjointSet(nodes.map(n => n.label));
    infoDiv.textContent = 'Starting Kruskal’s Algorithm...';
    animateStep();
  }

  function animateStep() {
    if (stepIndex >= sortedEdges.length) {
      infoDiv.textContent = 'Kruskal’s Algorithm completed. MST edges: ' + mstEdges.map(e => `${e[0]}-${e[1]}`).join(', ');
      drawGraph();
      return;
    }
    const [u, v, w] = sortedEdges[stepIndex];
    if (ds.union(u, v)) {
      mstEdges.push([u, v, w]);
      infoDiv.textContent = `Adding edge ${u} - ${v} (weight: ${w}) to MST`;
    } else {
      infoDiv.textContent = `Skipping edge ${u} - ${v} (weight: ${w}) - would form cycle`;
    }
    drawGraph();
    stepIndex++;
    setTimeout(animateStep, 1200);
  }

  function drawGraph() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // Draw all edges (light gray)
    ctx.strokeStyle = '#ccc';
    ctx.lineWidth = 2;
    for (const [from, to, w] of edges) {
      const fromNode = nodes.find(n => n.label === from);
      const toNode = nodes.find(n => n.label === to);
      ctx.beginPath();
      ctx.moveTo(fromNode.x, fromNode.y);
      ctx.lineTo(toNode.x, toNode.y);
      ctx.stroke();

      // Edge weight
      const midX = (fromNode.x + toNode.x) / 2;
      const midY = (fromNode.y + toNode.y) / 2;
      ctx.fillStyle = '#555';
      ctx.font = '14px Arial';
      ctx.fillText(w, midX + 5, midY - 5);
    }

    // Draw MST edges (green &amp; thick)
    ctx.strokeStyle = '#27ae60';
    ctx.lineWidth = 5;
    for (const [from, to] of mstEdges) {
      const fromNode = nodes.find(n => n.label === from);
      const toNode = nodes.find(n => n.label === to);
      ctx.beginPath();
      ctx.moveTo(fromNode.x, fromNode.y);
      ctx.lineTo(toNode.x, toNode.y);
      ctx.stroke();
    }

    // Draw nodes
    for (const node of nodes) {
      ctx.beginPath();
      ctx.arc(node.x, node.y, 25, 0, 2 * Math.PI);
      ctx.fillStyle = '#3498db';
      ctx.fill();
      ctx.strokeStyle = '#2980b9';
      ctx.lineWidth = 2;
      ctx.stroke();

      ctx.fillStyle = '#fff';
      ctx.font = '18px Arial';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(node.label, node.x, node.y);
    }
  }

  drawGraph();
</script>

</body>
</html>ID"><textarea id="CuLzm" style="display: none;">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
&lt;meta charset="UTF-8" /&gt;
&lt;title&gt;Kruskal’s Algorithm Visualization&lt;/title&gt;
&lt;style&gt;
  body { font-family: sans-serif; text-align: center; padding: 20px; }
  canvas { border: 1px solid #ccc; background: #f9f9f9; display: block; margin: 0 auto; }
  button { font-size: 16px; padding: 8px 12px; margin: 10px; }
  #info { font-family: monospace; margin-top: 10px; }
&lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;h2&gt;Kruskal’s Algorithm Visualization&lt;/h2&gt;
&lt;button onclick="startKruskal()"&gt;Start Kruskal&lt;/button&gt;
&lt;canvas id="canvas" width="600" height="600"&gt;&lt;/canvas&gt;
&lt;div id="info"&gt;&lt;/div&gt;

&lt;script&gt;
  const canvas = document.getElementById("canvas");
  const ctx = canvas.getContext("2d");
  const infoDiv = document.getElementById("info");

  // Graph nodes
  const nodes = [
    { label: 'A', x: 100, y: 100 },
    { label: 'B', x: 300, y: 80 },
    { label: 'C', x: 500, y: 120 },
    { label: 'D', x: 150, y: 300 },
    { label: 'E', x: 350, y: 320 },
    { label: 'F', x: 550, y: 320 },
    { label: 'G', x: 400, y: 450 },
  ];

  // Undirected weighted edges: [from, to, weight]
  const edges = [
    ['A', 'B', 7],
    ['A', 'D', 5],
    ['B', 'C', 8],
    ['B', 'D', 9],
    ['B', 'E', 7],
    ['C', 'E', 5],
    ['D', 'E', 15],
    ['D', 'G', 6],
    ['E', 'F', 8],
    ['E', 'G', 9],
    ['F', 'G', 11],
  ];

  // Union-Find (Disjoint Set) for cycle detection
  class DisjointSet {
    constructor(elements) {
      this.parent = {};
      this.rank = {};
      for (const el of elements) {
        this.parent[el] = el;
        this.rank[el] = 0;
      }
    }
    find(u) {
      if (this.parent[u] !== u) {
        this.parent[u] = this.find(this.parent[u]);
      }
      return this.parent[u];
    }
    union(u, v) {
      const rootU = this.find(u);
      const rootV = this.find(v);
      if (rootU === rootV) return false;
      if (this.rank[rootU] &lt; this.rank[rootV]) {
        this.parent[rootU] = rootV;
      } else if (this.rank[rootV] &lt; this.rank[rootU]) {
        this.parent[rootV] = rootU;
      } else {
        this.parent[rootV] = rootU;
        this.rank[rootU]++;
      }
      return true;
    }
  }

  let mstEdges = [];
  let stepIndex = 0;
  let sortedEdges = [];
  let ds;

  function startKruskal() {
    mstEdges = [];
    stepIndex = 0;
    sortedEdges = edges.slice().sort((a, b) =&gt; a[2] - b[2]);
    ds = new DisjointSet(nodes.map(n =&gt; n.label));
    infoDiv.textContent = 'Starting Kruskal’s Algorithm...';
    animateStep();
  }

  function animateStep() {
    if (stepIndex &gt;= sortedEdges.length) {
      infoDiv.textContent = 'Kruskal’s Algorithm completed. MST edges: ' + mstEdges.map(e =&gt; `${e[0]}-${e[1]}`).join(', ');
      drawGraph();
      return;
    }
    const [u, v, w] = sortedEdges[stepIndex];
    if (ds.union(u, v)) {
      mstEdges.push([u, v, w]);
      infoDiv.textContent = `Adding edge ${u} - ${v} (weight: ${w}) to MST`;
    } else {
      infoDiv.textContent = `Skipping edge ${u} - ${v} (weight: ${w}) - would form cycle`;
    }
    drawGraph();
    stepIndex++;
    setTimeout(animateStep, 1200);
  }

  function drawGraph() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // Draw all edges (light gray)
    ctx.strokeStyle = '#ccc';
    ctx.lineWidth = 2;
    for (const [from, to, w] of edges) {
      const fromNode = nodes.find(n =&gt; n.label === from);
      const toNode = nodes.find(n =&gt; n.label === to);
      ctx.beginPath();
      ctx.moveTo(fromNode.x, fromNode.y);
      ctx.lineTo(toNode.x, toNode.y);
      ctx.stroke();

      // Edge weight
      const midX = (fromNode.x + toNode.x) / 2;
      const midY = (fromNode.y + toNode.y) / 2;
      ctx.fillStyle = '#555';
      ctx.font = '14px Arial';
      ctx.fillText(w, midX + 5, midY - 5);
    }

    // Draw MST edges (green &amp; thick)
    ctx.strokeStyle = '#27ae60';
    ctx.lineWidth = 5;
    for (const [from, to] of mstEdges) {
      const fromNode = nodes.find(n =&gt; n.label === from);
      const toNode = nodes.find(n =&gt; n.label === to);
      ctx.beginPath();
      ctx.moveTo(fromNode.x, fromNode.y);
      ctx.lineTo(toNode.x, toNode.y);
      ctx.stroke();
    }

    // Draw nodes
    for (const node of nodes) {
      ctx.beginPath();
      ctx.arc(node.x, node.y, 25, 0, 2 * Math.PI);
      ctx.fillStyle = '#3498db';
      ctx.fill();
      ctx.strokeStyle = '#2980b9';
      ctx.lineWidth = 2;
      ctx.stroke();

      ctx.fillStyle = '#fff';
      ctx.font = '18px Arial';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(node.label, node.x, node.y);
    }
  }

  drawGraph();
&lt;/script&gt;

&lt;/body&gt;
&lt;/html&gt;</textarea> <iframe id="vpVvQ" class="result_iframe" style="border:none;"></iframe>
 <script>{
const textarea = document.getElementById("CuLzm");
const iframe = document.getElementById("vpVvQ");
const html = textarea.value;
const iframeHTML = `${html}`;
const doc = iframe.contentDocument || iframe.contentWindow.document;
doc.open();
doc.write(iframeHTML);
doc.close();
setTimeout(() => {
   iframe.style.height = '0px';
   let contentHeight = Math.max(doc.body.scrollHeight,doc.documentElement.scrollHeight);
   if(contentHeight < 10 || contentHeight > 800){
	   contentHeight = 800;
   } 
   iframe.style.height = contentHeight + 'px';
}, 50);
}
		</script>
</div><h3 id="union-find-data-structure-in-javascript">Union-Find Data Structure in JavaScript</h3><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-js">class UnionFind {
  constructor(elements) {
    this.parent = {};
    this.rank = {};

    for (let el of elements) {
      this.parent[el] = el;
      this.rank[el] = 0;
    }
  }

  find(x) {
    if (this.parent[x] !== x) {
      this.parent[x] = this.find(this.parent[x]); // Path compression
    }
    return this.parent[x];
  }

  union(x, y) {
    const rootX = this.find(x);
    const rootY = this.find(y);

    if (rootX === rootY) return false; // Cycle detected

    // Union by rank
    if (this.rank[rootX] &lt; this.rank[rootY]) {
      this.parent[rootX] = rootY;
    } else if (this.rank[rootX] &gt; this.rank[rootY]) {
      this.parent[rootY] = rootX;
    } else {
      this.parent[rootY] = rootX;
      this.rank[rootX]++;
    }

    return true;
  }
}</code></pre>
</div><h3 id="kruskals-algorithm-in-javascript">Kruskals Algorithm in JavaScript</h3><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-js">function kruskalMST(vertices, edges) {
  const uf = new UnionFind(vertices);
  const mst = [];

  // Sort edges by weight
  edges.sort((a, b) =&gt; a.weight - b.weight);

  for (let { from, to, weight } of edges) {
    if (uf.union(from, to)) {
      mst.push({ from, to, weight });
    }
    if (mst.length === vertices.length - 1) break;
  }

  return mst;
}</code></pre>
</div><h3 id="example-usage">Example Usage</h3><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-js">const vertices = ['A', 'B', 'C', 'D', 'E'];
const edges = [
  { from: 'A', to: 'B', weight: 3 },
  { from: 'A', to: 'D', weight: 1 },
  { from: 'B', to: 'D', weight: 3 },
  { from: 'B', to: 'C', weight: 1 },
  { from: 'C', to: 'D', weight: 1 },
  { from: 'C', to: 'E', weight: 5 },
  { from: 'D', to: 'E', weight: 6 }
];

const mst = kruskalMST(vertices, edges);
console.log(mst);</code></pre>
</div><p>This will output the edges of the minimum spanning tree, such as:</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-bash">[
  { from: 'A', to: 'D', weight: 1 },
  { from: 'B', to: 'C', weight: 1 },
  { from: 'C', to: 'D', weight: 1 },
  { from: 'C', to: 'E', weight: 5 }
]</code></pre>
</div><h3 id="cycle-detection">Cycle Detection</h3><p>Kruskal’s algorithm avoids cycles by using Union-Find:</p><ul>
 <li>Before adding an edge, it checks if both nodes belong to the same set.</li>
 <li>If they do, adding the edge would create a cycle, so it is skipped.</li>
 <li>If they don’t, their sets are merged, and the edge is added.</li>
</ul><h3 id="time-complexity">Time Complexity</h3><ul>
 <li><strong>Sorting edges</strong>: O(E log E)</li>
 <li><strong>Union-Find operations</strong>: near O(1) per operation (amortized with path compression)</li>
 <li><strong>Total time</strong>: <strong>O(E log E)</strong></li>
</ul><p>Where:</p><ul>
 <li><code>E</code> = number of edges</li>
 <li><code>V</code> = number of vertices</li>
</ul><h3 id="kruskal-vs-prim">Kruskal vs. Prim</h3><table>
 <thead>
  <tr>
   <th>Feature</th>
   <th>Kruskal’s Algorithm</th>
   <th>Prim’s Algorithm</th>
  </tr>
 </thead>
 <tbody>
  <tr>
   <td>Graph type</td>
   <td>Works well with <strong>sparse</strong> graphs</td>
   <td>Best with <strong>dense</strong> graphs</td>
  </tr>
  <tr>
   <td>Data structure</td>
   <td>Union-Find (Disjoint Set)</td>
   <td>Priority Queue (Min-Heap)</td>
  </tr>
  <tr>
   <td>Edge selection</td>
   <td>Global edge sort</td>
   <td>Local (adjacent) edge search</td>
  </tr>
  <tr>
   <td>Cycle detection</td>
   <td>Union-Find</td>
   <td>Avoids via visited set</td>
  </tr>
 </tbody>
</table><h3 id="real-world-use-cases">Real-World Use Cases</h3><ul>
 <li><strong>Network design</strong>: Building low-cost road, electrical, or communication networks.</li>
 <li><strong>Clustering algorithms</strong>: In unsupervised learning, MST can help group data.</li>
 <li><strong>Approximate solutions</strong>: In routing problems like the traveling salesman, MSTs help build heuristics.</li>
 <li><strong>Image segmentation</strong>: Graph-based methods in computer vision use MSTs to group pixels.</li>
</ul><h3 id="summary">Summary</h3><p>Kruskal’s algorithm offers a simple, greedy solution for finding MSTs, particularly effective on <strong>sparse graphs</strong>. Its reliance on <strong>edge sorting</strong> and <strong>Union-Find</strong> ensures both correctness and performance. With a clean JavaScript implementation, it’s a must-know tool for solving graph optimization problems in frontend tools, simulations, and network design.</p><div class = "chapter-navi-section">
<a href="#top" class="nav-button prev">↑</a>
<a href='javascript-algorithms.htm#minimum-spanning-trees' class="nav-button toc-link">Index</a>
<a href="#bottom" class="nav-button next">↓</a>
</div>
<h2 id='real-world-applications'>16.3 Real-World Applications</h2><p>Minimum Spanning Tree (MST) algorithms like <strong>Prim’s</strong> and <strong>Kruskal’s</strong> are more than academic exercises — they power real-world systems that need efficient connectivity, cost minimization, and clustering. From designing physical infrastructure to solving abstract data problems, MSTs help make intelligent decisions in systems where connections have weights or costs.</p><h3 id="network-cabling-and-infrastructure-design">Network Cabling and Infrastructure Design</h3><p>One of the most direct applications of MSTs is in the design of <strong>communication networks</strong> — whether it's laying out fiber-optic cables, electric power lines, or roadways.</p><h4 id="example">Example:</h4><p>A telecom company wants to connect five cities with fiber. Each potential connection (edge) has a cost based on distance and terrain. Using <strong>Kruskal’s algorithm</strong>, the company can build a network that connects all cities <strong>with the least total cost</strong> and <strong>no redundant loops</strong>, which would waste resources.</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-js">// Imagine edges: [ {from: 'A', to: 'B', weight: 10}, ... ]
// Use kruskalMST(vertices, edges) to get the cheapest cable layout</code></pre>
</div><p>In JavaScript simulations or back-end planning tools, such MST algorithms can evaluate multiple network layout scenarios and pick the optimal one.</p><h3 id="clustering-in-machine-learning">Clustering in Machine Learning</h3><p>In <strong>unsupervised learning</strong>, MSTs are used for clustering data points. The idea is to construct an MST from the dataset (viewed as a complete graph with edge weights based on similarity or distance), then <strong>remove the longest edges</strong> to break it into clusters.</p><p>This method avoids assumptions about cluster shapes and can work well with non-convex data.</p><h4 id="example">Example:</h4><p>In a visual clustering demo built with JavaScript and D3.js, you can:</p><ol>
 <li>Compute distances between data points.</li>
 <li>Build an MST using Prim’s algorithm.</li>
 <li>Delete <code>k-1</code> heaviest edges to form <code>k</code> clusters. This is known as <strong>single-linkage clustering</strong>.</li>
</ol><h3 id="image-segmentation">Image Segmentation</h3><p>In <strong>computer vision</strong>, MSTs are used to segment images by grouping similar pixels.</p><p>Each pixel is treated as a node, and the edge weight between two pixels represents color or texture difference. An MST groups nearby similar pixels and helps identify object boundaries.</p><h4 id="example">Example:</h4><p>In a JavaScript-based image processing app (e.g., with Canvas API), one could:</p><ul>
 <li>Convert image into a graph of pixels.</li>
 <li>Use MST to partition regions with low color variance. This technique underlies algorithms like <strong>Felzenszwalb-Huttenlocher segmentation</strong>.</li>
</ul><h3 id="traffic-and-utility-networks">Traffic and Utility Networks</h3><p>City planners and utility companies use MSTs to design:</p><ul>
 <li><strong>Traffic sensor networks</strong></li>
 <li><strong>Water supply pipelines</strong></li>
 <li><strong>Power grids</strong></li>
</ul><p>These networks must connect all points efficiently while minimizing construction costs. MSTs help eliminate redundant or circular paths that do not add value.</p><p>A JavaScript simulation might visualize nodes (homes, sensors) and edges (pipes, wires), then apply Prim’s algorithm to simulate real-world infrastructure decisions.</p><h3 id="algorithm-choice-in-practice">Algorithm Choice in Practice</h3><ul>
 <li><strong>Kruskal’s Algorithm</strong> is preferred when the graph has <strong>many sparse edges</strong> or comes as a pre-sorted edge list (common in file-based input).</li>
 <li><strong>Prim’s Algorithm</strong> works well with <strong>dense graphs</strong> and when you already have an adjacency list (as you might in JavaScript apps using object maps).</li>
</ul><p>In web environments, libraries like D3.js can help <strong>visualize MST construction step-by-step</strong>, enhancing educational or planning tools.</p><h3 id="summary">Summary</h3><p>Minimum Spanning Trees are essential in a wide array of domains: from minimizing infrastructure costs to discovering meaningful data groupings and improving digital image analysis. By applying Kruskal’s or Prim’s algorithm — both of which can be implemented effectively in JavaScript — developers and analysts can solve real-world problems efficiently. MSTs demonstrate how core algorithmic principles directly power modern systems in networking, AI, and visualization.</p><div class = "chapter-navi-section">
<a href="javascript-algorithms-graph-shortest-paths.htm" class="nav-button prev">←</a>
<a href='javascript-algorithms.htm#minimum-spanning-trees' class="nav-button toc-link">Index</a>
<a href="javascript-algorithms-principles-of-dynamic-programming.htm" class="nav-button next">→</a>
</div>
<section class="download-section">
  <div class="book-cover" style="background-color: #f9f6f1;border: 1px solid #ccc;"> 
    <div class="book-cover-title" style="font-size: 18px;color: #333;top: 20px;">JavaScript Algorithms</div>
    <div class="book-cover-author">readbytes</div>
    <div class="book-cover-bottom-stripe" style="background-color: #333;"></div>
    <img class="book-cover-icon" style="width: 80px;height: 80px;top: 70px;" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFoAAABaCAYAAAA4qEECAAAErElEQVR4Xu2dPWgUQRiGo6BB8I+AlV3w9gzptLBWsLQ89O7ARrDXSivTCTaCnWhn7pQTxOoInpjCeEQQLC2CjVqoVSwMFpp1Jtzo7Luzs/Nd7uZ29r4HPpDsu7vPvIl7+SGTmRmGYRiGYZjCEzVacdnn9NX7+3DdXkGhMg+u3Su6SNztzsZvevH/efED8zrJbM+6EGJ2K5Hv9w9gRpHnXMyik2VsYVaHWJx7tt/bTOQ3urOYUch3QJ5z0YtOCeuQiqNlvybyto/ktbVDcG2jc5GLNgoriMW5Z/svPyfy693DmFHE71ePwrUznQta9ISeyViyKBIziri/Mpe8tt25kEXjMR1ScbQsPC5W5jCjMJT8DTM6MuO6vrHjIkIszj2LL3y2ktOPiy+Y0VE5l/V5IU+EVBwtm/wUzva4SL/wOZUsJ2993rCJEIujZJMl2174Up/C5T8u9LGtzyu6SNkH1+6VhUargkJlHVy7f5aW9qJUqeZy5zguufToBeAxZoRw0Z7goj3BRXuCi/YEF+0BvWQue0xgwfrMiy+aMM8QEUW+w2IHb8fC/+C5jCOGMhOPiqi+vG47zjiABVbr7XOYUWC2Um+fxwwDiKJeYXGYMYHniNnGDDPAUJZTyYph30nTg+G7f5VLj89gzBW8lu2xMzWIIt5iMZgZBrzmqK4bJFhENOLnatRsfcR7YKb0YAELF5+cwsyowHudrLcvYKZ0iIV+wIVjZhzgPaMR/+8pFIbFeilZUWm2Vyd5/5GxWOvsx4VkTbXROovn+wJdMqfevoHnFoKUaMbgeZMAnbIGzysEKGmZiX4DKKo/um5wMg6eWwhsgtVm62cRFoEOJg/xtltZxwqBTV4inuEHcZHztc4RzI0LvLeY15iRBF+0wrDgsX6qZXpUYEanNEVLROY3ZfHDgvdwuU+pipYs1h7OpUqI4z2YGxa8dqXefooZE6UrWoGFiMn8nRIXoubyTbymeLPzO7C0RUuiRvuXoRwyeI1hrlPqoiUnap1jWNLilU7mr0sgeK746rOFGRdKX7QCC4tyHiXi+DU8BzMUpqZoiSzXpTzMZOUoTFXROxh+xKV/gYPHqvVlp88q8pi+ogdgoabBc3bD1BYtEdfcxnLHeK/pLVoiHxvJktsPMDMKpr5oX3DRnuCiPcFFe4KL9gQX7Qku2hNctCe4aE94K1puD6mXNsmpOv74KUTnxEdmEQb9TOA5kx70M6KfcO/u8/j2nWffxb+XskZm9MHjw2YjgrTKygnFeUaF5cSEjZ4c9kJyz/Z7mxTpEJ0T0nhMhyRBy+5sTuXioAjR2UmaKEHJ/tsBLM9BJ0TnXGmiBCWb2GbN5oCE6GyVJkq4Z3FXxo3ubJaDiRCdM6VJErSscTtik0MWITobpYkS7lncKVfblREdbITonJImSVCyKAz7i1KkQ3ROSJMkaNnc7Ygp0iE6Z0pjTockjC8iBmEJRTpEZ6M0ZnRIwrhTrmU7Yop0iM4paTyusyvhnO2IKdIhOqdeWLLYlbDtL0oM/jaKi4MiRGcnaZIwPt8c/zZKnoNOiM4J6SIM+pnAcyY96GekYJtvf0I/EyE6MwzDMAzDjI+/5MPGam/zucIAAAAASUVORK5CYII="/>
  </div>
  <div class="download-info">
    <h2 id='bottom'>Download This Ebook</h2>
    <p class="format-label">Available formats:</p>
    <div class="download-buttons">
      <a href="javascript-algorithms.pdf" class="download-button">📄 PDF</a>
      <a href="javascript-algorithms.epub" class="download-button">📘 EPUB</a>
    </div>
  </div>
</section><div class='related-books'>
<h2>Javascript In-Depth Books</h2>
<div class='related-book-list'>
<a href="javascript-clean-code.htm">
<div class="book-cover" style="background-color: #f9f6f1;border: 1px solid #ccc;"> 
    <div class="book-cover-title" style="font-size: 18px;color: #333;top: 20px;">JavaScript Clean Code</div>
    <div class="book-cover-author">readbytes</div>
    <div class="book-cover-bottom-stripe" style="background-color: #333;"></div>
    <img class="book-cover-icon" style="width: 90px;height: 90px;top: 65px;" src='data:image/png;base64,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'/>
  </div>
</a>


<a href="javascript-coding-best-practices.htm">
<div class="book-cover" style="background-color: #f9f6f1;border: 1px solid #ccc;"> 
    <div class="book-cover-title" style="font-size: 16px;color: #333;top: 20px;">JavaScript Coding Best Practices</div>
    <div class="book-cover-author">readbytes</div>
    <div class="book-cover-bottom-stripe" style="background-color: #333;"></div>
    <img class="book-cover-icon" style="width: 80px;height: 80px;top: 80px;" src='data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFoAAABaCAYAAAA4qEECAAADdklEQVR4Xu2dPW/UMBjHH0QRlRA7MDDBgBAbH4ABNsRCQXwHFpAQQwVKws1IwMaXYO/M1I0VWEC8bIgy81LO53sS54l9OSe2G7f/n/S/c2zXefpT4g6nXIkAAADkQUFvqKR9JECUyw4lbXYmIqGyaYpWHXtNBwhCST8XbpcH2jyIQ+1XvRS0VQ+8opPzvrfLvDfayLpRDpmKbpMh+lw90N1jkCFhlNvFsXqxieb2Np2tx0A/EJ0IiE6Et2iOKVqOmQEa6aNXNLdxRfsB0YmA6ER4i+bYRMs5MoqK7nf6x6ai76KS6cG1Mr2iuW0TDdxAdCIgOhHeojku0XJejMQ41x063rvmGOQaa4jeXry7Rd+a/9yLqGFk/5g09T/vjKmUdK2eMwRv0dx2iQZ2IDoR3qI5q0Tv07HO/IPIlJA1BRGt/rDI+QeRKSFr6hXN7VWiQReIToS36JLOrxT9mk7QjK63YiLHQiQHBojWcYmW88wTyL5QyQFZa69obrtEAzsQnQiIToS3aI5LtJw3NGPX8//Zm/U5Y2DWpegVzW2XaGAHohMB0YnwFs2xiZZzYkSf50un35YpIWvqFc1tm+jHdDpqfM71iE615h80QUUDNxCdCG/RHJdoOW9IFPpzuu7YmHRrfFn3xUbWsIbob4t3t+hd0g/DDEtF75brbHTGxqap8ceyb6Pui423aG67RAM7EJ0Ib9ElfXSKruirV44SA0Tr2ETLOX05SsjfuVc0t22igRuITgREJ8JbNMcULcfMAI300Sua27ii/YDoREB0IrxFI+PSKxqEBaITAdGJaIlG4mfxUtA9qugGEiHKrSEaW0csstyjO7djBmQnWn9GqZ98bR5S2pXTJkeGopXYX/VxRXtZXNUt0TO6KMcnh9wu5PFUKehCI7qkv3J8krDcXCQrKvpjis6jaEVBVxfJhdpv+yo5I+eBgSiXrbuvOfgtpCPj0zgl/pJu9QA9CEvzpQTLL+uu6F9jHgSBfSq3LWa0Zbn0kTEp6G5b8lRQxYXYwviWBQ5Cygm51qGipJ2gcvTtuyO7Ae9roQi93qFBSXlKV2T3YJ7RZYi2EUNKjDWz5gldiiJFrTmbrw2WxNpPY62bLVrIZ9k9mpI+QbRJTBkx186OmDJirp0FJT2o99BUqeihLOPwo//hWVdGzBT0QZYBAAAA/AcQ1vXmtMbyGwAAAABJRU5ErkJggg=='/>
  </div>
</a>


<a href="javascript-asynchronous-programming.htm">
<div class="book-cover" style="background-color: #f9f6f1;border: 1px solid #ccc;"> 
    <div class="book-cover-title" style="font-size: 18px;color: #333;top: 20px;">JavaScript Asynchronous Programming</div>
    <div class="book-cover-author">readbytes</div>
    <div class="book-cover-bottom-stripe" style="background-color: #333;"></div>
    <img class="book-cover-icon" style="width: 80px;height: 80px;top: 80px;" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFoAAABaCAYAAAA4qEECAAADU0lEQVR4Xu2cvW7UQBRGkwKJV0CipqJbG9pIFLGXRyD2IgpeghegQ9DRUNHQUdLQUVFAC0h0tFEKkMJPCEykRHKObzZrr6/t8X5H+qrMN3PvUbQpEmVra8NI8vLfWWazh1f4ddEBVcmVPOA5sQZB6DND8mkWj3hetCQI/VAXXE3xhB3RkrrcWl6wI1qQZuUrQ+75ZOVr9kQL0mxxpya3nnfsiRbs7Ny/ashFiq/siZbU5Z7PLC9/sCNaQrlGfrIjWmLIxXd28Z0d0QKKvSCSvQ5pXr41pF6QxT77vRF+Or+vDzTdhJW36cAdDrEpoQdX+PgmhS482ebjmxTKcIMPb1roww0+vGmhDzf4MMPzY4fzL8tsd+8a+27w8Wp4Nga4w7Kw6wofr+Qzz8aAsYcZ9tzhAIMN0gFh7l/cwwp7vcAhBh1mDcLMf7iDFfZ6g4MMPlALwrzHnN/IMXu9YgwUlehktY+LI/Z6xxgqGtFhzgPObeQve4NgDBaF6Nl88YUzGxn246KKMVwUojlvPYtx/dqqPuD4RSeX/aXSvDxgZ3BqQ0YhunjOec+SzstvPD8KOGgMok/gvKf5xHOjwRg2CtEnVOdNs+Ipvz4qKDgm0VFBwRLtBAVLtBMULNFOULBEO0HBEu0EBUu0ExQs0U5QsEQ7QcES7QQFS7QTFCzRTlCwRDtBwRLtBAVLtBMULNFOULBEO0HBEu0EBUu0ExQs0U5QsEQ7QcES7QQFS7QTFCzRTlBw16LDXb897o0OCu5SSLjniPd2dXd0UEKXMnhn1/dHBQV0KYJ3Mjw/abh8lxJ4pxV2JgsX71oA77XCziTh0h7L824r7EwOLuy1OO+3ws6k4LKeSydZech3GHYmAxf1XniWl2/4FsPOJOCSfSyb5sVLvsewEz1csK9l+ZYVdqKGyzFpXj5O7hY3u0q6u5fxjWXhvNHCxcYYzhwlXGqM4cxRwqXGmPDxdci5o4SLjTGcOVq42JgSvqOH+8+4HtzO713nkmMI5xQrQpGXhX3RAMq8KOyJBtyalzco1Ap7ohkr/RtllkRDKNQKO6IhFGqFHdEQCrXCjmgIhVphRzSEQq2wIxpCoVbYES2gVIbnRUsoVpKdCEL3KViSnUjm5cepSf4Pt8Ix0I7hKy8AAAAASUVORK5CYII="/>
  </div>
</a>


<a href="javascript-pragmatic-developer.htm">
<div class="book-cover" style="background-color: #f9f6f1;border: 1px solid #ccc;"> 
    <div class="book-cover-title" style="font-size: 18px;color: #333;top: 20px;">JavaScript Pragmatic Developer</div>
    <div class="book-cover-author">readbytes</div>
    <div class="book-cover-bottom-stripe" style="background-color: #333;"></div>
    <img class="book-cover-icon" style="width: 80px;height: 70px;top: 85px;" src="data:image/png;base64,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"/>
  </div>
</a>


<a href="javascript-algorithms.htm">
<div class="book-cover" style="background-color: #f9f6f1;border: 1px solid #ccc;"> 
    <div class="book-cover-title" style="font-size: 18px;color: #333;top: 20px;">JavaScript Algorithms</div>
    <div class="book-cover-author">readbytes</div>
    <div class="book-cover-bottom-stripe" style="background-color: #333;"></div>
    <img class="book-cover-icon" style="width: 80px;height: 80px;top: 70px;" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFoAAABaCAYAAAA4qEECAAAErElEQVR4Xu2dPWgUQRiGo6BB8I+AlV3w9gzptLBWsLQ89O7ARrDXSivTCTaCnWhn7pQTxOoInpjCeEQQLC2CjVqoVSwMFpp1Jtzo7Luzs/Nd7uZ29r4HPpDsu7vPvIl7+SGTmRmGYRiGYZjCEzVacdnn9NX7+3DdXkGhMg+u3Su6SNztzsZvevH/efED8zrJbM+6EGJ2K5Hv9w9gRpHnXMyik2VsYVaHWJx7tt/bTOQ3urOYUch3QJ5z0YtOCeuQiqNlvybyto/ktbVDcG2jc5GLNgoriMW5Z/svPyfy693DmFHE71ePwrUznQta9ISeyViyKBIziri/Mpe8tt25kEXjMR1ScbQsPC5W5jCjMJT8DTM6MuO6vrHjIkIszj2LL3y2ktOPiy+Y0VE5l/V5IU+EVBwtm/wUzva4SL/wOZUsJ2993rCJEIujZJMl2174Up/C5T8u9LGtzyu6SNkH1+6VhUargkJlHVy7f5aW9qJUqeZy5zguufToBeAxZoRw0Z7goj3BRXuCi/YEF+0BvWQue0xgwfrMiy+aMM8QEUW+w2IHb8fC/+C5jCOGMhOPiqi+vG47zjiABVbr7XOYUWC2Um+fxwwDiKJeYXGYMYHniNnGDDPAUJZTyYph30nTg+G7f5VLj89gzBW8lu2xMzWIIt5iMZgZBrzmqK4bJFhENOLnatRsfcR7YKb0YAELF5+cwsyowHudrLcvYKZ0iIV+wIVjZhzgPaMR/+8pFIbFeilZUWm2Vyd5/5GxWOvsx4VkTbXROovn+wJdMqfevoHnFoKUaMbgeZMAnbIGzysEKGmZiX4DKKo/um5wMg6eWwhsgtVm62cRFoEOJg/xtltZxwqBTV4inuEHcZHztc4RzI0LvLeY15iRBF+0wrDgsX6qZXpUYEanNEVLROY3ZfHDgvdwuU+pipYs1h7OpUqI4z2YGxa8dqXefooZE6UrWoGFiMn8nRIXoubyTbymeLPzO7C0RUuiRvuXoRwyeI1hrlPqoiUnap1jWNLilU7mr0sgeK746rOFGRdKX7QCC4tyHiXi+DU8BzMUpqZoiSzXpTzMZOUoTFXROxh+xKV/gYPHqvVlp88q8pi+ogdgoabBc3bD1BYtEdfcxnLHeK/pLVoiHxvJktsPMDMKpr5oX3DRnuCiPcFFe4KL9gQX7Qku2hNctCe4aE94K1puD6mXNsmpOv74KUTnxEdmEQb9TOA5kx70M6KfcO/u8/j2nWffxb+XskZm9MHjw2YjgrTKygnFeUaF5cSEjZ4c9kJyz/Z7mxTpEJ0T0nhMhyRBy+5sTuXioAjR2UmaKEHJ/tsBLM9BJ0TnXGmiBCWb2GbN5oCE6GyVJkq4Z3FXxo3ubJaDiRCdM6VJErSscTtik0MWITobpYkS7lncKVfblREdbITonJImSVCyKAz7i1KkQ3ROSJMkaNnc7Ygp0iE6Z0pjTockjC8iBmEJRTpEZ6M0ZnRIwrhTrmU7Yop0iM4paTyusyvhnO2IKdIhOqdeWLLYlbDtL0oM/jaKi4MiRGcnaZIwPt8c/zZKnoNOiM4J6SIM+pnAcyY96GekYJtvf0I/EyE6MwzDMAzDjI+/5MPGam/zucIAAAAASUVORK5CYII="/>
  </div>
</a>



<a href='javascript.htm'><div class='book-cover' style='background-color: #f9f6f1;color: #111111;border: 1px solid #ccc;display: flex;justify-content: center;align-items: center;text-align: center;'>More Javascript Books</div></a>
</div>
</div>
  </div>
  <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/prism.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
  
  <script>
    function copyCode(button) {
      const code = button.nextElementSibling.innerText;
      navigator.clipboard.writeText(code).then(() => {
        button.textContent = 'Copied!';
        setTimeout(() => { button.textContent = 'Copy'; }, 1500);
      });
    }
  </script>  
<div id="floatingLog" aria-live="polite" role="alert"></div>
<footer class="page-footer">
    <nav>
      <a href="https://readbytes.github.io">Home</a> | 
      Email:<script language="JavaScript" type="text/javascript">
var part1 = 'yinpeng';var part6 = '263';var part2 = Math.pow(2,6);var part3 = String.fromCharCode(part2);var part4 = 'hotmail dot com';var part5 = part1 + String.fromCharCode(part2) + part4;document.write(part1 + part6 + part3 + part4);
</script>
    </nav>
  <p>© 2025 — All rights reserved.</p>    
  </footer>

</body>
</html>