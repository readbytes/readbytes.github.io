<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Java IO and NIO Asynchronous IO</title>
<link rel='shortcut icon' href='https://java2s.com/style/favicon.ico'>
<link href="https://fonts.googleapis.com/css2?family=Merriweather&display=swap" rel="stylesheet" />
<link href="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet" />


  <script>
  const mode = localStorage.getItem('mode') || 'light';
  document.documentElement.classList.add(`${mode}-mode`);
  </script>   
<style> 
html {
  scroll-behavior: smooth;
}

body {
  font-family: 'Merriweather', serif;
  margin: 0;
  padding: 2rem 1rem;
  font-size: 15px;
  line-height: 1.5;
  transition: background-color 0.3s, color 0.3s;
}

.container {
  max-width: 700px;
  margin: 0 auto;
  padding: 1rem 2rem;
  box-shadow: 0 0 15px rgba(0,0,0,0.1);
}

h1, h2, h3 {
  font-weight: 600;
  margin-top: 2.5rem;
  margin-bottom: 1rem;
  line-height: 1.2;
}

h1 { font-size: 1.8rem; }
h2 { font-size: 1.4rem; }
h3 { font-size: 1.2rem; }

table {
  width: 100%;
  border-collapse: collapse;
  font-family: sans-serif;
  font-size: 1em;
  margin: 1em 0;
}

th, td {
  padding: 0.6em 1em;
  text-align: left;
  border: 1px solid;
}

tr:nth-child(even) {
  background-color: inherit;
}

tr:hover {
  background-color: inherit;
}

a {
  text-decoration: none;
  transition: color 0.2s;
}

a:hover {
  text-decoration: underline;
}

code {
  color: #d35400;
}

.book-title-chapter {
  font-family: 'Merriweather', serif;
  font-size: 2rem;
  font-weight: bold;
  text-align: center;
  margin-bottom: 2rem;
  border-bottom: 2px solid;
  padding-bottom: 0.5rem;
}

.book-subtitle-chapter {
  text-align: center;
  font-size: 1rem;
  margin-top: -1rem;
  margin-bottom: 2rem;
}

.related-books {
  margin-top: 40px;
}

.related-book-list {
  display: flex;
  flex-wrap: wrap;
  gap: 20px;
}

    .book-cover {
      width: 130px;
      height: 180px;
      font-family: Arial, sans-serif;
      position: relative;
      overflow: hidden;      
      line-height: normal;
      box-shadow: 2px 2px 4px rgba(0,0,0,0.1);
    }
    .book-cover-bottom-stripe {
      position: absolute;
      bottom: 0;
      left: 0;
      height: 5px;
      width: 100%;
    }
    .book-cover-title {
      position: absolute;
      width: 100%;
      text-align: center;
      font-weight: bold;
    }
     
    .book-cover-icon {
      position: absolute;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      align-items: center;
      justify-content: center; 
    }

    .book-cover-author {
      position: absolute;
      bottom: 10px;
      width: 100%;
      text-align: center;
      font-size: 8px;
      color: #333;
    }

.page-footer {
  margin-top: 4rem;
  padding: 1rem 0;
  text-align: center;
  font-size: 0.85rem;
  border-top: 1px solid;
}

.chapter-navi-section {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding-bottom: 10px;
}

.nav-link {
  color: inherit;
  text-decoration: none;
  opacity: 0.5;
  transition: opacity 0.3s ease, text-decoration 0.3s ease;
}

.nav-link:hover {
  opacity: 0.9;
  text-decoration: underline;
}

.prev { text-align: left; }
.toc-link { text-align: center; }
.next { text-align: right; }

.download-section {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 2rem;
  padding: 2rem 1rem;
  max-width: 600px;
  margin: 3rem auto;
  border-radius: 12px;
  box-shadow: 0 4px 10px rgba(0,0,0,0.05);
}

.download-info h2 {
  margin: 0 0 0.5rem;
  font-size: 1.2rem;
}

.format-label {
  margin: 0 0 0.5rem;
  font-size: 0.95rem;
}

.download-buttons {
  display: flex;
  gap: 1rem;
}

.download-button {
  background-color: #4A90E2;
  color: white;
  padding: 0.5em 1.2em;
  border-radius: 25px;
  font-size: 0.95rem;
  text-decoration: none;
  transition: background-color 0.3s ease;
}

.download-button:hover {
  background-color: #357ABD;
}

.code-block {
  position: relative;
  margin-bottom: 1em;
}

.copy-button {
  background: transparent;
  color: white;
  position: absolute;
  top: 8px;
  right: 8px;
  border: none;
  padding: 4px 8px;
  font-size: 12px;
  border-radius: 4px;
  cursor: pointer;
  z-index: 1;
}

.copy-button:hover {
  background-color: #0056b3;
}

.snippet-container {
  overflow: hidden;
}

.snippet-header {
  padding: 0.75rem 1rem;
  cursor: pointer;
  font-size: 1rem;
    background-color: #eeeeee;
    color:  #111111; 
    border-radius: 8px;
    cursor: pointer;
    box-shadow: 0 4px 6px rgba(0,0,0,0.1);  
}

.snippet-body {
  display: none;
  font-family: monospace;
}

.snippet-container.open .snippet-body {
  display: block;
}

.CodeMirror {
  border: 2px solid #ccc;
  border-radius: 4px;
  resize: vertical;
}

/* === Light Mode === */
html.light-mode {
  background-color: #f8f7f5;
  color: #333;
}

html.light-mode .container {
  background: white;
}

html.light-mode .book-title-chapter {
  color: #2c3e50;
  border-color: #ccc;
}
html.light-mode .book-subtitle-chapter{
  color: #888;
}

html.light-mode .page-footer,
html.light-mode .series-name,
html.light-mode .book-subtitle,
html.light-mode .format-label {
  color: #888;
}

html.light-mode .related-books h2 {
  color: #333;
  border-bottom: 2px solid #eee;
}

html.light-mode .book-title {
  color: #fff;
}

html.light-mode .book-cover {
  border: 1px solid #ccc;
}

html.light-mode th {
  background-color: #f2f2f2;
}

html.light-mode tr:nth-child(even) {
  background-color: #fafafa;
}

html.light-mode tr:hover {
  background-color: #e6f7ff;
}

html.light-mode a,
html.light-mode .page-footer a {
  color: #000;
}

/* === Dark Mode === */
html.dark-mode {
  background-color: #181818;
  color: #e0e0e0;
}

html.dark-mode .container {
  background: #222;
}

html.dark-mode .book-title-chapter {
  color: #ddd;
  border-color: #444;
}

html.dark-mode .snippet-header {
    background-color: #333;
    color:  #ddd; 
}


html.dark-mode .book-subtitle-chapter,
html.dark-mode .page-footer,
html.dark-mode .series-name,
html.dark-mode .book-subtitle,
html.dark-mode .book-footer,
html.dark-mode .format-label {
  color: #aaa;
}

html.dark-mode .related-books h2 {
  color: #ddd;
  border-bottom: 2px solid #333;
}

html.dark-mode .book-title {
  color: #fff;
}

html.dark-mode .book-cover {
  border: 1px solid #555;
}

html.dark-mode th {
  background-color: #333;
  color: #fff;
}

html.dark-mode td {
  border-color: #444;
}

html.dark-mode tr:nth-child(even) {
  background-color: #2a2a2a;
}

html.dark-mode tr:hover {
  background-color: #2c3e50;
}

html.dark-mode a,
html.dark-mode .page-footer a {
  color: #eee;
}

    .dialog-backdrop {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: rgba(0,0,0,0.5);
      display: none;
      justify-content: center;
      align-items: center;
      z-index: 10;
    }

    .dialog {
      background: white;
      padding: 20px;
      width: 90vw;
      height: 80vh;
      border-radius: 8px;
      box-shadow: 0 0 20px rgba(0,0,0,0.3);
      display: flex;
      flex-direction: column;
    }
    .dialog-content {
      display: flex;
      flex: 1;
      gap: 20px;
      margin-top: 10px;
    }
    .dialog h2 {
      margin-top: 0;
    }

    .textarea_dialog {
      width: 50%;
      height: 100%;
      resize: none;
      font-family: monospace;
      font-size: 14px;
      padding: 10px;
      box-sizing: border-box;
      border: 1px solid #ccc;
    }

    .iframe_dialog {
      width: 50%;
      height: 100%;
      border: 1px solid #ccc;
    }
    .controls_dialog {
      display: flex;
      justify-content: space-between;
      margin-top: 10px;
    }    
    button { padding: 0.5em 1em; background: green; color: white; border: none; cursor: pointer; }
    button:hover { background: #1e7e34; }
    .result_iframe { width:99%; height:200px; margin-top: 1em;  resize: both;border:1px solid #ccc;}        
</style>
</head>
<body> 
  <div class="container">
    <div class = "chapter-navi-section">
<a href="java-io-and-nio-selectors-and-non-blocking-io.htm" class="nav-button prev">←</a>
<a href='java-io-and-nio.htm#asynchronous-io' class="nav-button toc-link">Index</a>
<a href="java-io-and-nio-working-with-character-sets-and-encodings.htm" class="nav-button next">→</a>
</div>

    <h1 class="book-title-chapter" id = 'top'>Asynchronous IO</h1>
    <h3 class="book-subtitle-chapter">Java IO and NIO</h3>   
    <!-- <h1 class ="chapter-title"></h1> -->
    <h2 id='introduction-to-asynchronous-io-in-java'>8.1 Introduction to Asynchronous IO in Java</h2><p>Asynchronous IO (AIO) is a powerful programming model designed to improve <strong>scalability</strong>, <strong>performance</strong>, and <strong>responsiveness</strong> in applications that perform intensive input/output operations. Java introduced support for AIO in Java 7 as part of the <code>java.nio.channels</code> package, offering developers an alternative to blocking and non-blocking IO models.</p><p>In this section, we’ll explore what asynchronous IO is, how it differs from traditional synchronous models, why it's useful in modern software systems, and how Java's AIO API fits into the larger IO ecosystem.</p><h3 id="understanding-asynchronous-vs-synchronous-io">Understanding Asynchronous vs Synchronous IO</h3><p>At a high level, the key distinction between <strong>synchronous</strong> and <strong>asynchronous</strong> IO lies in how <strong>control is managed during an IO operation</strong>.</p><h4 id="synchronous-io">Synchronous IO</h4><p>In synchronous IO (used by both traditional IO and some forms of NIO), when a program initiates a read or write operation, it <strong>waits</strong> for the operation to complete before continuing. This behavior is simple and predictable but can lead to performance issues in high-concurrency scenarios.</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-Java">// Traditional synchronous IO example
int bytesRead = inputStream.read(buffer);</code></pre>
</div><p>In this case, the thread is <strong>blocked</strong> until data is available.</p><h4 id="asynchronous-io">Asynchronous IO</h4><p>In asynchronous IO, the program initiates an IO operation and immediately regains control. The actual work is performed <strong>in the background</strong>, and a <strong>callback</strong> or <strong>future</strong> is used to notify the program when the operation is complete.</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-Java">// Pseudo-AIO concept
channel.read(buffer, attachment, completionHandler);</code></pre>
</div><p>The calling thread does <strong>not block</strong>, enabling it to manage many other tasks while IO is performed by the OS or a background thread.</p><h3 id="motivation-for-using-asynchronous-io">Motivation for Using Asynchronous IO</h3><p>The primary motivation for AIO is to <strong>increase concurrency without increasing the number of threads</strong>. This is especially critical in scenarios like:</p><ul>
 <li><strong>High-performance servers</strong> handling thousands of simultaneous connections</li>
 <li><strong>GUI applications</strong> that must remain responsive while performing background IO</li>
 <li><strong>Cloud services</strong> that need to scale under unpredictable load</li>
 <li><strong>Network-intensive systems</strong> that perform multiple IO operations concurrently</li>
</ul><p>With AIO:</p><ul>
 <li>You avoid <strong>thread-per-connection</strong> overhead</li>
 <li>Reduce <strong>CPU time</strong> spent in context switching</li>
 <li>Gain better <strong>hardware utilization</strong>, especially on multi-core systems</li>
</ul><h3 id="how-aio-improves-scalability-and-responsiveness">How AIO Improves Scalability and Responsiveness</h3><p>Let’s look at a typical server use case:</p><h4 id="synchronous-server">Synchronous Server:</h4><ul>
 <li>Each client connection is handled by a dedicated thread.</li>
 <li>1000 clients = 1000 threads.</li>
 <li>Results in increased memory consumption and context switching overhead.</li>
</ul><h4 id="asynchronous-server">Asynchronous Server:</h4><ul>
 <li>A small number of threads initiate and manage thousands of IO operations.</li>
 <li>IO is delegated to the OS or a thread pool and only resumes when necessary.</li>
 <li>The server is highly <strong>scalable</strong>, lightweight, and responsive.</li>
</ul><h4 id="gui-applications">GUI Applications:</h4><p>In GUI environments like JavaFX or Swing, blocking the main UI thread can cause freezing or lag. AIO allows data to be read or written <strong>in the background</strong>, keeping the UI fluid and interactive.</p><h3 id="overview-of-javas-aio-api">Overview of Javas AIO API</h3><p>Java introduced AIO support in Java 7 through the <code>java.nio.channels</code> package. The primary interfaces and classes include:</p><h4 id="asynchronouschannel"><code>AsynchronousChannel</code></h4><p>The base interface for channels supporting asynchronous operations. Two main implementations exist:</p><ul>
 <li><code>AsynchronousSocketChannel</code> (for TCP network IO)</li>
 <li><code>AsynchronousFileChannel</code> (for file IO)</li>
</ul><h4 id="completionhandlerv-a"><code>CompletionHandlerV, A</code></h4><p>A callback interface for handling the result of an asynchronous operation.</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-Java">channel.read(buffer, attachment, new CompletionHandler&lt;Integer, Object&gt;() {
    @Override
    public void completed(Integer result, Object attachment) {
        // Handle success
    }

    @Override
    public void failed(Throwable exc, Object attachment) {
        // Handle error
    }
});</code></pre>
</div><h4 id="futurev"><code>FutureV</code></h4><p>Alternatively, AIO methods can return a <code>Future&lt;V&gt;</code> that represents the result of the operation. This allows for polling or blocking to retrieve results.</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-Java">Future&lt;Integer&gt; future = channel.read(buffer);
while (!future.isDone()) {
    // do something else
}
int bytesRead = future.get(); // blocks if not done</code></pre>
</div><h4 id="thread-pool-backing">Thread Pool Backing</h4><p>Asynchronous channels often rely on an <strong>underlying thread pool</strong>, which can be:</p><ul>
 <li>The system default</li>
 <li>Custom-provided via <code>AsynchronousChannelGroup</code></li>
</ul><p>This allows flexibility in managing IO operation execution.</p><h3 id="where-aio-fits-in-the-java-io-ecosystem">Where AIO Fits in the Java IO Ecosystem</h3><p>Java now offers multiple IO paradigms:</p><table>
 <thead>
  <tr>
   <th>Model</th>
   <th>API</th>
   <th>Use Case</th>
  </tr>
 </thead>
 <tbody>
  <tr>
   <td>Blocking IO</td>
   <td><code>InputStream</code>, <code>Reader</code></td>
   <td>Simple applications, low concurrency</td>
  </tr>
  <tr>
   <td>Non-blocking IO</td>
   <td><code>SocketChannel</code>, <code>Selector</code></td>
   <td>Scalable servers, requires manual control</td>
  </tr>
  <tr>
   <td>Asynchronous IO</td>
   <td><code>Asynchronous*Channel</code></td>
   <td>Highly scalable, callback/future-based</td>
  </tr>
 </tbody>
</table><p>AIO is ideal when:</p><ul>
 <li>You need to perform multiple simultaneous IO operations without blocking.</li>
 <li>You want to offload IO latency without writing a full selector/event loop manually.</li>
 <li>You prefer a <strong>callback-driven or future-based programming style</strong>.</li>
</ul><h3 id="real-world-use-cases-for-aio">Real-world Use Cases for AIO</h3><ul>
 <li><strong>Web Servers</strong> (e.g., asynchronous HTTP or WebSocket handlers)</li>
 <li><strong>Chat Applications</strong> with many idle connections</li>
 <li><strong>File Watchers or Backup Systems</strong> reading/writing large files in the background</li>
 <li><strong>Microservices</strong> that fetch data from multiple services concurrently</li>
</ul><h3 id="summary">Summary</h3><p>Asynchronous IO in Java provides a modern, scalable solution for applications that demand high performance and low latency under concurrent loads. By decoupling IO operations from thread blocking, AIO enables developers to handle massive workloads using a small, efficient thread pool. Java’s AIO API, introduced in Java 7, is a natural complement to traditional and non-blocking IO and plays a crucial role in building responsive and scalable Java applications today.</p><p>In the next section, we’ll explore how to use <code>AsynchronousFileChannel</code> for asynchronous file reading and writing in real-world scenarios.</p><div class = "chapter-navi-section">
<a href="#top" class="nav-button prev">↑</a>
<a href='java-io-and-nio.htm#asynchronous-io' class="nav-button toc-link">Index</a>
<a href="#bottom" class="nav-button next">↓</a>
</div>
<h2 id='asynchronousfilechannel'>8.2 AsynchronousFileChannel</h2><p>Java NIO.2, introduced in Java 7, brought powerful file I/O enhancements, among them the <code>AsynchronousFileChannel</code> class. This class enables <strong>non-blocking, asynchronous file operations</strong>, allowing developers to read from and write to files without stalling the executing thread. It is part of the <code>java.nio.channels</code> package and leverages the underlying operating system's asynchronous I/O capabilities where available.</p><h3 id="overview">Overview</h3><p>Traditional file I/O in Java—whether through <code>java.io</code> or even the <code>FileChannel</code> class in the original NIO—tends to be <strong>blocking</strong>. This means that if a thread starts a read or write operation, it must wait for that operation to complete before doing anything else. In contrast, <code>AsynchronousFileChannel</code> allows I/O operations to be executed in the background, enabling the thread to continue with other tasks or respond to I/O completion events via callbacks.</p><p>This capability is particularly valuable in high-performance, scalable applications such as web servers, file processors, and database engines.</p><h3 id="creating-an-asynchronousfilechannel">Creating an AsynchronousFileChannel</h3><p>To use <code>AsynchronousFileChannel</code>, you typically open a file with the appropriate read/write permissions and optionally provide an <code>ExecutorService</code> for managing asynchronous tasks.</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-Java">Path path = Paths.get("example.txt");

// Open for asynchronous writing
AsynchronousFileChannel channel = AsynchronousFileChannel.open(
    path,
    StandardOpenOption.WRITE,
    StandardOpenOption.CREATE
);</code></pre>
</div><p>You can also provide a custom thread pool:</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-Java">ExecutorService executor = Executors.newFixedThreadPool(2);

AsynchronousFileChannel channel = AsynchronousFileChannel.open(
    path,
    EnumSet.of(StandardOpenOption.READ, StandardOpenOption.WRITE),
    executor
);</code></pre>
</div><h3 id="key-methods">Key Methods</h3><ul>
 <li><p><code>read(ByteBuffer dst, long position, A attachment, CompletionHandlerInteger, ? super A handler)</code> Reads bytes from the file into the given buffer starting at a given file position. The operation is non-blocking and handled by a <code>CompletionHandler</code>.</p></li>
 <li><p><code>write(ByteBuffer src, long position, A attachment, CompletionHandlerInteger, ? super A handler)</code> Writes bytes from the buffer into the file starting at the given position, using a completion handler for notification.</p></li>
 <li><p><code>FutureInteger read(ByteBuffer dst, long position)</code> Starts an asynchronous read operation and returns a <code>Future</code>, which can be queried or blocked on.</p></li>
 <li><p><code>FutureInteger write(ByteBuffer src, long position)</code> Initiates an asynchronous write and returns a <code>Future</code>.</p></li>
</ul><h3 id="asynchronous-read-example">Asynchronous Read Example</h3><p>Below is a complete example demonstrating how to asynchronously read data from a file using a <code>CompletionHandler</code>:</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">📋</button>
 <pre><code class="language-java">import java.nio.*;
import java.nio.channels.*;
import java.nio.file.*;
import java.util.concurrent.*;

public class AsyncFileRead {
    public static void main(String[] args) {
        try {
            Path path = Paths.get("input.txt");
            AsynchronousFileChannel channel = AsynchronousFileChannel.open(path, StandardOpenOption.READ);

            ByteBuffer buffer = ByteBuffer.allocate(1024);
            long position = 0;

            channel.read(buffer, position, buffer, new CompletionHandler&lt;Integer, ByteBuffer&gt;() {
                @Override
                public void completed(Integer result, ByteBuffer attachment) {
                    System.out.println("Read completed: " + result + " bytes");
                    attachment.flip();
                    byte[] data = new byte[attachment.limit()];
                    attachment.get(data);
                    System.out.println("Data: " + new String(data));
                }

                @Override
                public void failed(Throwable exc, ByteBuffer attachment) {
                    System.err.println("Read failed");
                    exc.printStackTrace();
                }
            });

            // Let the async read complete
            Thread.sleep(1000);

        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}</code></pre>
</div><h3 id="asynchronous-write-example">Asynchronous Write Example</h3><p>Here's how you can asynchronously write data to a file:</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">📋</button>
 <pre><code class="language-java">import java.nio.*;
import java.nio.channels.*;
import java.nio.file.*;
import java.util.concurrent.*;

public class AsyncFileWrite {
    public static void main(String[] args) {
        try {
            Path path = Paths.get("output.txt");
            AsynchronousFileChannel channel = AsynchronousFileChannel.open(
                path, StandardOpenOption.WRITE, StandardOpenOption.CREATE
            );

            ByteBuffer buffer = ByteBuffer.wrap("Hello, asynchronous world!".getBytes());
            long position = 0;

            channel.write(buffer, position, buffer, new CompletionHandler&lt;Integer, ByteBuffer&gt;() {
                @Override
                public void completed(Integer result, ByteBuffer attachment) {
                    System.out.println("Write completed: " + result + " bytes");
                }

                @Override
                public void failed(Throwable exc, ByteBuffer attachment) {
                    System.err.println("Write failed");
                    exc.printStackTrace();
                }
            });

            // Wait for async write to complete
            Thread.sleep(1000);

        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}</code></pre>
</div><h3 id="comparison-to-traditional-filechannel">Comparison to Traditional FileChannel</h3><table>
 <thead>
  <tr>
   <th>Feature</th>
   <th><code>FileChannel</code></th>
   <th><code>AsynchronousFileChannel</code></th>
  </tr>
 </thead>
 <tbody>
  <tr>
   <td>Blocking behavior</td>
   <td>Blocking</td>
   <td>Non-blocking</td>
  </tr>
  <tr>
   <td>Thread responsiveness</td>
   <td>Limited</td>
   <td>High</td>
  </tr>
  <tr>
   <td>Scalability</td>
   <td>Lower (one thread per I/O)</td>
   <td>Higher (event-driven, fewer threads)</td>
  </tr>
  <tr>
   <td>Use case suitability</td>
   <td>Simple, synchronous I/O</td>
   <td>High-performance, async applications</td>
  </tr>
  <tr>
   <td>Completion notification</td>
   <td>None (call returns on completion)</td>
   <td>Via <code>Future</code> or <code>CompletionHandler</code></td>
  </tr>
 </tbody>
</table><h3 id="use-cases">Use Cases</h3><ul>
 <li>File servers handling many concurrent requests</li>
 <li>Applications with a non-blocking I/O architecture (e.g., Netty)</li>
 <li>Log processors writing data asynchronously</li>
 <li>Background tasks that should not block the main thread</li>
</ul><h3 id="conclusion">Conclusion</h3><p>The <code>AsynchronousFileChannel</code> class provides a powerful mechanism for performing file I/O operations without blocking the thread. It is especially beneficial in high-concurrency environments where efficient use of threads is critical. By utilizing Java's asynchronous I/O APIs, developers can build more responsive and scalable applications. Whether through <code>Future</code> objects or <code>CompletionHandler</code> callbacks, <code>AsynchronousFileChannel</code> provides flexible options for integrating asynchronous file access into Java programs.</p><div class = "chapter-navi-section">
<a href="#top" class="nav-button prev">↑</a>
<a href='java-io-and-nio.htm#asynchronous-io' class="nav-button toc-link">Index</a>
<a href="#bottom" class="nav-button next">↓</a>
</div>
<h2 id='completionhandler-and-future'>8.3 CompletionHandler and Future</h2><p>Java’s asynchronous IO (NIO.2), introduced in Java 7, enables non-blocking I/O operations that allow a program to continue executing other tasks while waiting for potentially slow IO processes—like reading from or writing to files or network sockets—to complete. Two core mechanisms are provided to handle the completion of these asynchronous operations: the <strong>callback-based</strong> approach using the <code>CompletionHandler</code> interface and the <strong>future-based</strong> approach using the <code>Future</code> class. Understanding these two paradigms is essential for effectively working with Java’s asynchronous IO API.</p><h3 id="roles-in-handling-asynchronous-operation-completion">Roles in Handling Asynchronous Operation Completion</h3><p>When an asynchronous operation is initiated—such as reading from a file—Java returns control immediately to the caller, allowing the current thread to do other work instead of blocking. However, the program must still handle the result or status of the IO operation once it completes.</p><p>Java provides two main ways to handle this:</p><ol>
 <li><p><strong>Callback-based Handling with <code>CompletionHandler</code></strong> The <code>CompletionHandler</code> interface allows you to pass a callback object to the asynchronous IO method. This callback is notified when the operation completes (either successfully or with failure). This pattern fits well with event-driven programming and is very efficient for high-concurrency environments.</p></li>
 <li><p><strong>Future-based Handling with <code>Future</code></strong> The asynchronous IO methods can also return a <code>Future</code> object. This object represents the result of the asynchronous computation and can be queried or blocked on to retrieve the result once ready. This model is closer to the traditional synchronous model but allows you to defer waiting on the result until it is needed.</p></li>
</ol><h3 id="the-completionhandler-interface">The <code>CompletionHandler</code> Interface</h3><p>The <code>CompletionHandler</code> interface resides in the <code>java.nio.channels</code> package and is defined as:</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-Java">public interface CompletionHandler&lt;V, A&gt; {
    void completed(V result, A attachment);
    void failed(Throwable exc, A attachment);
}</code></pre>
</div><ul>
 <li><code>V</code> represents the result type of the I/O operation, typically an <code>Integer</code> indicating the number of bytes read or written.</li>
 <li><code>A</code> is an attachment object provided by the caller, useful for passing context or state into the callback.</li>
</ul><h3 id="how-it-works">How it Works</h3><p>When you start an asynchronous operation (e.g., <code>AsynchronousFileChannel.read()</code>), you pass a <code>CompletionHandler</code> implementation that defines what should happen on:</p><ul>
 <li><strong><code>completed</code></strong>: Called when the operation completes successfully.</li>
 <li><strong><code>failed</code></strong>: Called when the operation fails with an exception.</li>
</ul><p>This callback approach is highly efficient because it does not require any thread blocking or polling—your program simply reacts to events as they happen.</p><h3 id="the-future-class">The <code>Future</code> Class</h3><p>The <code>Future</code> interface (in <code>java.util.concurrent</code>) represents the result of an asynchronous computation. It provides methods such as:</p><ul>
 <li><code>get()</code>: Waits (blocks) if necessary for the computation to complete, then returns the result.</li>
 <li><code>isDone()</code>: Checks if the computation has completed.</li>
 <li><code>cancel()</code>: Attempts to cancel the operation.</li>
</ul><h3 id="how-it-works">How it Works</h3><p>When you invoke an asynchronous IO operation that returns a <code>Future</code>, you receive a placeholder object immediately. You can then:</p><ul>
 <li>Check periodically if the operation is done (polling).</li>
 <li>Block and wait for the operation result when needed.</li>
 <li>Cancel the operation if desired.</li>
</ul><p>While easier to reason about, this model may introduce blocking and is generally less performant for large numbers of concurrent operations compared to callbacks.</p><h3 id="differences-between-completionhandler-and-future">Differences Between <code>CompletionHandler</code> and <code>Future</code></h3><table>
 <thead>
  <tr>
   <th>Aspect</th>
   <th><code>CompletionHandler</code></th>
   <th><code>Future</code></th>
  </tr>
 </thead>
 <tbody>
  <tr>
   <td><strong>Notification style</strong></td>
   <td>Event-driven callback</td>
   <td>Polling or blocking to get the result</td>
  </tr>
  <tr>
   <td><strong>Thread blocking</strong></td>
   <td>No blocking; the callback runs on completion</td>
   <td>May block if <code>get()</code> is called before completion</td>
  </tr>
  <tr>
   <td><strong>Complexity</strong></td>
   <td>Requires implementing callback methods</td>
   <td>Simpler to use, similar to synchronous calls</td>
  </tr>
  <tr>
   <td><strong>Suitability</strong></td>
   <td>High concurrency, reactive/event-driven apps</td>
   <td>Simpler tasks or when blocking is acceptable</td>
  </tr>
  <tr>
   <td><strong>Error handling</strong></td>
   <td>In <code>failed()</code> callback</td>
   <td>Via exceptions thrown from <code>get()</code></td>
  </tr>
  <tr>
   <td><strong>Cancellation support</strong></td>
   <td>Managed via <code>cancel()</code> on the channel/future</td>
   <td>Direct cancellation on the <code>Future</code></td>
  </tr>
 </tbody>
</table><h3 id="when-to-use-each">When to Use Each</h3><ul>
 <li>Use <strong><code>CompletionHandler</code></strong> if you want your application to remain fully non-blocking and responsive, especially in servers or GUI apps where waiting on IO is undesirable.</li>
 <li>Use <strong><code>Future</code></strong> when you prefer simpler control flow or when blocking for completion at some point in your logic is acceptable or easier.</li>
</ul><h3 id="example-1-using-completionhandler-for-asynchronous-file-reading">Example 1: Using <code>CompletionHandler</code> for Asynchronous File Reading</h3><div class="code-block"><button class="copy-button" onclick="copyCode(this)">📋</button>
 <pre><code class="language-java">import java.nio.*;
import java.nio.channels.*;
import java.nio.file.*;

public class AsyncReadWithCompletionHandler {
    public static void main(String[] args) throws Exception {
        Path file = Paths.get("example.txt");
        AsynchronousFileChannel channel = AsynchronousFileChannel.open(file, StandardOpenOption.READ);

        ByteBuffer buffer = ByteBuffer.allocate(1024);
        channel.read(buffer, 0, buffer, new CompletionHandler&lt;Integer, ByteBuffer&gt;() {
            @Override
            public void completed(Integer result, ByteBuffer attachment) {
                System.out.println("Read " + result + " bytes.");
                attachment.flip();
                byte[] data = new byte[attachment.limit()];
                attachment.get(data);
                System.out.println("Data: " + new String(data));
            }

            @Override
            public void failed(Throwable exc, ByteBuffer attachment) {
                System.err.println("Read failed:");
                exc.printStackTrace();
            }
        });

        // Keep main thread alive to allow async operation to complete
        Thread.sleep(1000);
        channel.close();
    }
}</code></pre>
</div><h3 id="example-2-using-future-for-asynchronous-file-writing">Example 2: Using <code>Future</code> for Asynchronous File Writing</h3><div class="code-block"><button class="copy-button" onclick="copyCode(this)">📋</button>
 <pre><code class="language-java">import java.nio.*;
import java.nio.channels.*;
import java.nio.file.*;
import java.util.concurrent.Future;

public class AsyncWriteWithFuture {
    public static void main(String[] args) throws Exception {
        Path file = Paths.get("output.txt");
        AsynchronousFileChannel channel = AsynchronousFileChannel.open(
            file,
            StandardOpenOption.WRITE, StandardOpenOption.CREATE
        );

        ByteBuffer buffer = ByteBuffer.wrap("Hello, Future!".getBytes());
        Future&lt;Integer&gt; writeResult = channel.write(buffer, 0);

        // Do some other work here if needed

        // Wait for completion and get the result
        int bytesWritten = writeResult.get();  // This call blocks until done
        System.out.println("Written bytes: " + bytesWritten);

        channel.close();
    }
}</code></pre>
</div><h3 id="summary">Summary</h3><ul>
 <li><strong><code>CompletionHandler</code></strong> enables <strong>callback-driven</strong>, fully non-blocking handling of asynchronous operations. It is well-suited for reactive programming models and high scalability.</li>
 <li><strong><code>Future</code></strong> offers a simpler, <strong>polling/blocking</strong> model where you can check or wait for completion explicitly, at the expense of possible blocking.</li>
 <li>Understanding the differences allows you to select the right approach based on your application’s concurrency and responsiveness needs.</li>
</ul><p>By mastering both mechanisms, Java developers can efficiently handle asynchronous IO, improving performance and scalability in modern applications.</p><div class = "chapter-navi-section">
<a href="#top" class="nav-button prev">↑</a>
<a href='java-io-and-nio.htm#asynchronous-io' class="nav-button toc-link">Index</a>
<a href="#bottom" class="nav-button next">↓</a>
</div>
<h2 id='using-aio-for-network-communication'>8.4 Using AIO for Network Communication</h2><p>Java NIO.2 (introduced in Java 7) significantly enhanced Java’s IO capabilities by introducing asynchronous IO (AIO) APIs, which allow non-blocking, event-driven network communication. Unlike traditional blocking IO where threads wait idly for operations to complete, asynchronous IO enables efficient, scalable networking by delegating operations to the operating system or a thread pool and notifying the application upon completion. This approach reduces thread contention, improves resource utilization, and is ideal for high-performance network applications such as servers and clients handling many simultaneous connections.</p><h3 id="asynchronous-socket-channels-in-java">Asynchronous Socket Channels in Java</h3><p>The core class for asynchronous network communication in Java NIO.2 is <code>AsynchronousSocketChannel</code> for TCP/IP sockets. It represents a socket channel capable of non-blocking connect, read, and write operations.</p><p>There is also <code>AsynchronousServerSocketChannel</code> which is used for accepting incoming connections asynchronously.</p><p>Both classes reside in <code>java.nio.channels</code> and provide methods for starting asynchronous operations and handling their completion either via <code>CompletionHandler</code> callbacks or <code>Future</code> objects.</p><h3 id="how-asynchronoussocketchannel-works">How AsynchronousSocketChannel Works</h3><p><code>AsynchronousSocketChannel</code> supports three main asynchronous operations:</p><ol>
 <li><strong>Connect</strong>: Initiate a non-blocking connection to a remote server.</li>
 <li><strong>Read</strong>: Read data from the channel into a buffer without blocking.</li>
 <li><strong>Write</strong>: Write data from a buffer to the channel asynchronously.</li>
</ol><p>Each operation returns immediately, and you can be notified when it completes via:</p><ul>
 <li>A <code>CompletionHandler</code> — an event-driven callback interface.</li>
 <li>A <code>Future</code> — to block or poll for completion at your discretion.</li>
</ul><p>Using <code>CompletionHandler</code> is the preferred idiomatic way for truly asynchronous, non-blocking networking.</p><h3 id="performing-non-blocking-connect-read-and-write">Performing Non-blocking Connect, Read, and Write</h3><p><strong>Connecting</strong></p><p>To establish a connection asynchronously:</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-Java">AsynchronousSocketChannel socketChannel = AsynchronousSocketChannel.open();
socketChannel.connect(new InetSocketAddress("host", port), attachment, new CompletionHandler&lt;Void, AttachmentType&gt;() {
    @Override
    public void completed(Void result, AttachmentType attachment) {
        // Connection successful, proceed with reading or writing
    }

    @Override
    public void failed(Throwable exc, AttachmentType attachment) {
        // Handle connection failure
    }
});</code></pre>
</div><h3 id="reading">Reading</h3><p>After the connection is established, you can initiate asynchronous reads:</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-Java">ByteBuffer buffer = ByteBuffer.allocate(1024);
socketChannel.read(buffer, buffer, new CompletionHandler&lt;Integer, ByteBuffer&gt;() {
    @Override
    public void completed(Integer bytesRead, ByteBuffer buf) {
        if (bytesRead == -1) {
            // Channel closed by peer
            return;
        }
        buf.flip();
        // Process data in buffer here
        // Optionally start another read for continuous data
        buf.clear();
        socketChannel.read(buf, buf, this);
    }

    @Override
    public void failed(Throwable exc, ByteBuffer buf) {
        // Handle read failure
    }
});</code></pre>
</div><h3 id="writing">Writing</h3><p>Similarly, writing is done asynchronously:</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-Java">ByteBuffer buffer = ByteBuffer.wrap("Hello server!".getBytes());
socketChannel.write(buffer, buffer, new CompletionHandler&lt;Integer, ByteBuffer&gt;() {
    @Override
    public void completed(Integer bytesWritten, ByteBuffer buf) {
        if (buf.hasRemaining()) {
            // Not all data was written, write the rest
            socketChannel.write(buf, buf, this);
        } else {
            // Write complete, proceed as needed
        }
    }

    @Override
    public void failed(Throwable exc, ByteBuffer buf) {
        // Handle write failure
    }
});</code></pre>
</div><h3 id="event-driven-networking-with-completionhandler">Event-driven Networking with <code>CompletionHandler</code></h3><p>The power of asynchronous IO is realized fully when integrated with <code>CompletionHandler</code>s. Each network operation passes a <code>CompletionHandler</code> implementation to handle success or failure events, enabling event-driven programming:</p><ul>
 <li>When an operation completes, the JVM invokes the handler’s <code>completed()</code> method with the result.</li>
 <li>If an error occurs, <code>failed()</code> is invoked with an exception.</li>
 <li>You can chain subsequent operations inside these callbacks for continuous, non-blocking IO workflows.</li>
</ul><h3 id="sample-asynchronous-tcp-echo-server">Sample Asynchronous TCP Echo Server</h3><p>Below is an example of a simple asynchronous TCP echo server that accepts client connections and echoes back any received data.</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">📋</button>
 <pre><code class="language-java">import java.io.IOException;
import java.net.InetSocketAddress;
import java.nio.ByteBuffer;
import java.nio.channels.AsynchronousServerSocketChannel;
import java.nio.channels.AsynchronousSocketChannel;
import java.nio.channels.CompletionHandler;

public class AsyncEchoServer {
    public static void main(String[] args) throws IOException {
        int port = 5000;
        AsynchronousServerSocketChannel serverChannel = 
            AsynchronousServerSocketChannel.open()
                .bind(new InetSocketAddress(port));

        System.out.println("Echo server listening on port " + port);

        serverChannel.accept(null, new CompletionHandler&lt;AsynchronousSocketChannel, Void&gt;() {
            @Override
            public void completed(AsynchronousSocketChannel clientChannel, Void att) {
                // Accept the next connection
                serverChannel.accept(null, this);

                // Handle client communication
                handleClient(clientChannel);
            }

            @Override
            public void failed(Throwable exc, Void att) {
                System.err.println("Failed to accept a connection");
                exc.printStackTrace();
            }
        });

        // Keep the server running
        try {
            Thread.currentThread().join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }

    private static void handleClient(AsynchronousSocketChannel clientChannel) {
        ByteBuffer buffer = ByteBuffer.allocate(1024);

        clientChannel.read(buffer, buffer, new CompletionHandler&lt;Integer, ByteBuffer&gt;() {
            @Override
            public void completed(Integer bytesRead, ByteBuffer buf) {
                if (bytesRead == -1) {
                    // Client closed connection
                    try {
                        clientChannel.close();
                    } catch (IOException e) {
                        e.printStackTrace();
                    }
                    return;
                }

                buf.flip();
                // Echo back the data
                clientChannel.write(buf, buf, new CompletionHandler&lt;Integer, ByteBuffer&gt;() {
                    @Override
                    public void completed(Integer bytesWritten, ByteBuffer buf) {
                        if (buf.hasRemaining()) {
                            clientChannel.write(buf, buf, this);
                        } else {
                            buf.clear();
                            // Read more data from client
                            clientChannel.read(buf, buf, this);
                        }
                    }

                    @Override
                    public void failed(Throwable exc, ByteBuffer buf) {
                        System.err.println("Write failed");
                        exc.printStackTrace();
                        try {
                            clientChannel.close();
                        } catch (IOException e) {
                            e.printStackTrace();
                        }
                    }
                });
            }

            @Override
            public void failed(Throwable exc, ByteBuffer buf) {
                System.err.println("Read failed");
                exc.printStackTrace();
                try {
                    clientChannel.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        });
    }
}</code></pre>
</div><p><strong>How it works:</strong></p><ul>
 <li>The server opens an <code>AsynchronousServerSocketChannel</code> and binds it to a port.</li>
 <li>It calls <code>accept()</code> with a <code>CompletionHandler</code> to asynchronously wait for client connections.</li>
 <li>When a client connects, the handler is invoked. The server immediately calls <code>accept()</code> again to handle new incoming connections concurrently.</li>
 <li>The connected client is handled by the <code>handleClient()</code> method, which performs asynchronous reads.</li>
 <li>Upon receiving data, the server writes the same data back (echo), and once writing completes, it continues to read more data.</li>
 <li>All operations are non-blocking, and callbacks handle all I/O events.</li>
</ul><h3 id="sample-asynchronous-client-using-completionhandler">Sample Asynchronous Client Using CompletionHandler</h3><div class="code-block"><button class="copy-button" onclick="copyCode(this)">📋</button>
 <pre><code class="language-java">import java.net.InetSocketAddress;
import java.nio.ByteBuffer;
import java.nio.channels.AsynchronousSocketChannel;
import java.nio.channels.CompletionHandler;
import java.nio.charset.StandardCharsets;

public class AsyncEchoClient {
    public static void main(String[] args) throws Exception {
        AsynchronousSocketChannel clientChannel = AsynchronousSocketChannel.open();

        clientChannel.connect(new InetSocketAddress("localhost", 5000), null, new CompletionHandler&lt;Void,Void&gt;() {
            @Override
            public void completed(Void result, Void attachment) {
                System.out.println("Connected to server");

                String message = "Hello, Asynchronous Server!";
                ByteBuffer buffer = ByteBuffer.wrap(message.getBytes(StandardCharsets.UTF_8));

                clientChannel.write(buffer, buffer, new CompletionHandler&lt;Integer, ByteBuffer&gt;() {
                    @Override
                    public void completed(Integer bytesWritten, ByteBuffer buf) {
                        if (buf.hasRemaining()) {
                            clientChannel.write(buf, buf, this);
                        } else {
                            buf.clear();
                            // Read response from server
                            clientChannel.read(buf, buf, new CompletionHandler&lt;Integer, ByteBuffer&gt;() {
                                @Override
                                public void completed(Integer bytesRead, ByteBuffer buf) {
                                    buf.flip();
                                    byte[] data = new byte[buf.limit()];
                                    buf.get(data);
                                    System.out.println("Received from server: " + new String(data));
                                    try {
                                        clientChannel.close();
                                    } catch (Exception e) {
                                        e.printStackTrace();
                                    }
                                }

                                @Override
                                public void failed(Throwable exc, ByteBuffer attachment) {
                                    System.err.println("Read failed");
                                    exc.printStackTrace();
                                }
                            });
                        }
                    }

                    @Override
                    public void failed(Throwable exc, ByteBuffer buf) {
                        System.err.println("Write failed");
                        exc.printStackTrace();
                    }
                });
            }

            @Override
            public void failed(Throwable exc, Void attachment) {
                System.err.println("Connection failed");
                exc.printStackTrace();
            }
        });

        Thread.sleep(2000); // Keep main thread alive to complete async operations
    }
}</code></pre>
</div><h3 id="summary">Summary</h3><p>Java’s asynchronous IO network communication model via <code>AsynchronousSocketChannel</code> and <code>AsynchronousServerSocketChannel</code>:</p><ul>
 <li>Enables <strong>non-blocking connect, read, and write</strong> operations.</li>
 <li>Uses <strong><code>CompletionHandler</code> callbacks</strong> to receive notifications on operation completion or failure, enabling event-driven programming.</li>
 <li>Scales efficiently by avoiding thread blocking and allowing concurrent handling of many connections.</li>
 <li>Can be combined with <code>Future</code> objects when blocking on completion is acceptable.</li>
</ul><p>This approach is ideal for modern network servers and clients that require scalability, responsiveness, and efficient resource use. The event-driven style with <code>CompletionHandler</code>s encourages a clean separation of IO logic from processing logic, making it a powerful tool in the Java networking toolkit.</p><div class = "chapter-navi-section">
<a href="java-io-and-nio-selectors-and-non-blocking-io.htm" class="nav-button prev">←</a>
<a href='java-io-and-nio.htm#asynchronous-io' class="nav-button toc-link">Index</a>
<a href="java-io-and-nio-working-with-character-sets-and-encodings.htm" class="nav-button next">→</a>
</div>
<section class="download-section">
  <div class="book-cover" style="background-color: #f9f6f1;border: 1px solid #ccc;"> 
    <div class="book-cover-title" style="font-size: 18px;color: #333;top: 20px;">Java IO and NIO</div>
    <div class="book-cover-author">readbytes</div>
    <div class="book-cover-bottom-stripe" style="background-color: #333;"></div>
    <img class="book-cover-icon" style="width: 80px;height: 90px;top: 60px;" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFoAAABaCAYAAAA4qEECAAADAElEQVR4Xu2Zu6oTURSGjze0UfANtLAUzgOI4DOItc+VKk1uJ12aadNa21vbCpYK4wQmcPiYzL5k7eXM2f8HP0JYa/3ZX2PEmxshxAPi7u6uLRH2VA3lWId9VdK27WOKsQ47q6RpmucUYx12VolEOyHRToyJ5mwI7ufeeZBItBMS7YREOyHRTki0ExLthEQ7IdFOSLQTEu2ERDsxJtoq7KwSiXZCop04Ho9PKcY67KwWirEO+6qGcqzCHhGBJDoh0U5ItAP7/f6bRDtAyV3+ckYYQNHr9fo1Z8SVtG37iKI5Mzv4IKuwJwXeuvbef4ePsQ77YuGdLp85MysGHmQa9sXAG7l3JgUfZB32heh+0t3yRvfZD87NDj7KOuwLwf2cG5OEj7IO+8bg7imr1eoV55Lh0VC4bwE7cru4n3Jns9l85d7YPmdCSV8oADtyu7gfe4fzMbucCyV9oQDsyO3i/tid7i+395xjuHMfzoaSvlAAduR2cf/+ne7PT/x8JL94mwzsjCZ5wTN8XAjuTynT/nKJcH9KmfaXS4T7U8q0v1wi3J9Skr8cH3cJ7l3I98Ph8HLg86SuM9zPvRMDO0JJXwjQ/Wx6yx3kI3cGZqK6CPdz78TAjlDSF0ZYLpcvOH9O0zQX/xnL2ZiuIbifeycGdoSSvjACZ2N2TnA+do9wP/dODOwIhfvZ8HCfn5wbYmDPNOybLXxYn9+cu8TArmnYN1v4sNTHcdc67JslfFTOw7hvHfbNEj6q+3n3gTMheMM67JsdfNA1j+Idq7BnlvBR2+32DWfElazX63cUzRlhACVLdCEk2QmJdmC3232RaAcoucsfzogAAxJNwp6qoRzrsK9aKMY6i8XiGTurhGKsc/ofGHZWCcVYR6J7KMY6Et1DMedwLgT3JRpQjEQXgmIkuhAUI9GFoBiJLgTFSHQhKEaiC0ExEl0IipHoQlCMRBeCYiS6EBQj0YWgGOtIdA/FWEeieyjGOhLdQzHW2e/3T9hZJRRjHfZVDeVYhT1CiDnzD27IzgFe/xOvAAAAAElFTkSuQmCC"/>
  </div>
  <div class="download-info">
    <h2 id='bottom'>Download This Ebook</h2>
    <p class="format-label">Available formats:</p>
    <div class="download-buttons">
      <a href="java-io-and-nio.pdf" class="download-button">📄 PDF</a>
      <a href="java-io-and-nio.epub" class="download-button">📘 EPUB</a>
    </div>
  </div>
</section><div class='related-books'>
<h2>Java In-Depth Books</h2>
<div class='related-book-list'>
<a href="java-io-and-nio.htm">
<div class="book-cover" style="background-color: #f9f6f1;border: 1px solid #ccc;"> 
    <div class="book-cover-title" style="font-size: 18px;color: #333;top: 20px;">Java IO and NIO</div>
    <div class="book-cover-author">readbytes</div>
    <div class="book-cover-bottom-stripe" style="background-color: #333;"></div>
    <img class="book-cover-icon" style="width: 80px;height: 90px;top: 60px;" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFoAAABaCAYAAAA4qEECAAADAElEQVR4Xu2Zu6oTURSGjze0UfANtLAUzgOI4DOItc+VKk1uJ12aadNa21vbCpYK4wQmcPiYzL5k7eXM2f8HP0JYa/3ZX2PEmxshxAPi7u6uLRH2VA3lWId9VdK27WOKsQ47q6RpmucUYx12VolEOyHRToyJ5mwI7ufeeZBItBMS7YREOyHRTki0ExLthEQ7IdFOSLQTEu2ERDsxJtoq7KwSiXZCop04Ho9PKcY67KwWirEO+6qGcqzCHhGBJDoh0U5ItAP7/f6bRDtAyV3+ckYYQNHr9fo1Z8SVtG37iKI5Mzv4IKuwJwXeuvbef4ePsQ77YuGdLp85MysGHmQa9sXAG7l3JgUfZB32heh+0t3yRvfZD87NDj7KOuwLwf2cG5OEj7IO+8bg7imr1eoV55Lh0VC4bwE7cru4n3Jns9l85d7YPmdCSV8oADtyu7gfe4fzMbucCyV9oQDsyO3i/tid7i+395xjuHMfzoaSvlAAduR2cf/+ne7PT/x8JL94mwzsjCZ5wTN8XAjuTynT/nKJcH9KmfaXS4T7U8q0v1wi3J9Skr8cH3cJ7l3I98Ph8HLg86SuM9zPvRMDO0JJXwjQ/Wx6yx3kI3cGZqK6CPdz78TAjlDSF0ZYLpcvOH9O0zQX/xnL2ZiuIbifeycGdoSSvjACZ2N2TnA+do9wP/dODOwIhfvZ8HCfn5wbYmDPNOybLXxYn9+cu8TArmnYN1v4sNTHcdc67JslfFTOw7hvHfbNEj6q+3n3gTMheMM67JsdfNA1j+Idq7BnlvBR2+32DWfElazX63cUzRlhACVLdCEk2QmJdmC3232RaAcoucsfzogAAxJNwp6qoRzrsK9aKMY6i8XiGTurhGKsc/ofGHZWCcVYR6J7KMY6Et1DMedwLgT3JRpQjEQXgmIkuhAUI9GFoBiJLgTFSHQhKEaiC0ExEl0IipHoQlCMRBeCYiS6EBQj0YWgGOtIdA/FWEeieyjGOhLdQzHW2e/3T9hZJRRjHfZVDeVYhT1CiDnzD27IzgFe/xOvAAAAAElFTkSuQmCC"/>
  </div>
</a>


<a href="java-collections.htm">
<div class="book-cover" style="background-color: #f9f6f1;border: 1px solid #ccc;"> 
    <div class="book-cover-title" style="font-size: 18px;color: #333;top: 20px;">Java Collections</div>
    <div class="book-cover-author">readbytes</div>
    <div class="book-cover-bottom-stripe" style="background-color: #333;"></div>
    <img class="book-cover-icon" style="width: 80px;height: 90px;top: 60px;" src='data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFoAAABaCAYAAAA4qEECAAADAElEQVR4Xu2dQYrUUBRFIw50JI7FrYgrcAPOXYPORHci7sah4EAQFyA6dNKosZK2Ee8/dOclP7/+i/fAmaR+Xr17KehJV2oYjDHGGGM6YRxzmgZdPKvdMt4vl03vLU15ZsYnsORB7Apd7mh2gS51VM/K+LVc6LA+0/QNKZax9RnvlG+C/tI7+6PYuYLV0MHoc72rX8ZvsP9Gq6BDyWzo/jXcjA4sfKN39E+RoYaf9F2CFAPFjGiG3b0Y5r9111LcJGZEM7QW0UNqRjTDWXwQXCojmoEk9MxmHwWGZ0QzkMT4ujy31b/D4UU8uITp/J4uRDOQxPiyPFfDy+HwQnFoCdPZFi5AM5BE/0VP51r5brgRzUASexU9/piG60VxEdO5lt6AZiCJ3Yoep+Fw8Z8DS5gHNfLncCOagSSWFE2M38tzanFBXcS9k/OwBi5AM5DE2qIn9JxaXFAXM33S5oE7+nFYhGYgiRxFX7FH4V+GEJqBJHIV3QGagSRcdBDNQBIuOohmIAkXHUQzkISLDqIZSMJFB9EMJOGig2gGknDRQTQDSbjoIJqBJHIUfffkPLCC74dNaAaSyFH0PKyiL4bVaAaS6L/oedAOrkQzkISLDqIZSMJFB9EMJNF/0bdPzsMquxLNQBL9Fz3x4eQ8sJIb0AwkkaPoK56efLvSV0MVNANJ5Cq6AzQDSbjoIJqBJFx0EM1AEi46iGYgCRcdRDOQhIsOohlIwkUH0Qwk4aKDaAaScNFBNANJuOggmoEkXHQQzUASLjqIZiAJFx1EM5CEiw6iGUjCRQfRDCSxtuh2X63oDM1AEkuKXmtxQc2IZiCJ3Yqu9vW3ztAMJLFX0ZfD4YXiUDI0A0m46CCagSTyfOm+EzQDSeiZzT4ODM+IZjiLD4NLZUQztBbRQ2pGNMPu1nh4lR/H9sfP+i5BioFgNnT/Gm5GB6Ib/im8Nf0+MtMPgb3Wquhwqw1Vwg/qbkix0EHtAl3qaHaDfx6kIf7Bm8YUyyY1Dbp4Fo0xxhhj/kd+A/PkOH57kF8HAAAAAElFTkSuQmCC'/>
  </div>
</a>


<a href="java-regex.htm">
<div class="book-cover" style="background-color: #f9f6f1;border: 1px solid #ccc;"> 
    <div class="book-cover-title" style="font-size: 18px;color: #333;top: 20px;">Java Regex</div>
    <div class="book-cover-author">readbytes</div>
    <div class="book-cover-bottom-stripe" style="background-color: #333;"></div>
    <img class="book-cover-icon" style="width: 80px;height: 90px;top: 60px;" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFoAAABaCAYAAAA4qEECAAAFo0lEQVR4Xu2d3WscVRiH+y/YXuuFkov6H9je2huvlAQvFalCEW8qiFRFQcGrmoJ4U5TSLWglFqRIlJqCH6XWalM/0lrT1O1ukt3sV5qPTZrP3XHfLTM983vPztc5s+zZPQ88N5l3Z9inwzA70Dl79iQks29oM7N3yBkoW98ZO6RC62ANdvDBtYF9lJEcxHNi+CWnOvmXs5rN9aX03eg74vcWxV6xObX3iUdxp2P7DzqDztiTB1lsaoX9InF631BJ3NH408N4vIFn/NCwL/aZVjPsGAj+a1mCwV7YUwqeyZZoxDqz8ZpsiYfY7mzQNdtGVkdsiH3b2Mj6CIztbrB3F+qMHxqRh84Iv/gsehDO6oe/IN0/ju0/gPOWhNAPO3ZW27M5HXyhTwtP4Sx68S4f9NRPuJbgnEURsa0Xmp5QWfQyMfLwqZ8XunrtT5yzKEKPWFnoem4O5xKxsVbS5vbmMu7eKOr5OUnovHro1ep0KppKPT+vP/TGWpkF0qWp2NBdwobuEjY0MnXbcb4cd5xCGbco0XOhb8wuOhdnGp4//7fl254ah9/urAZ6KrQYGL01V0sndLPJw8pUxJjQ5OXsBh5KjVZjFjRIBXoqdKWcZXHRK/kGHi45GDJMBXoqNFku3WVx0V9nNcTGiK7nLgRvT0jPhSZLacfGeK7Xb4bPJaQnQz+InWNx0USXEQzn+vsUTvKZfgxNFhfyLC4a68x+7QMejrwieVqJM+QX3+BUZHo6NDlfnGNx0auzdPsQAQxHXprEKT7jqkDPhyZni/MsLhopNoY7kcEJPuN6bBQnY2FEaDJXLLC4aGhsjIfgdtdX3sHJ2BgTmswVwmMHXrMxoBgb/+76snpkwqjQZKnusLhox7uRryd4yDA1YVxoYmG1yeKi0jP7nzs8ZJAaMTI0UVhJEPvN4zxmJzVjbGhidik8tu8ygjE7mQJGha7XZvBQTnYxPHb7zF6o8qAyU8KY0Gv37uJhPGZq4bEXpnI8KpoiRoTe3lzBQzCmq51j59aabSu/3OBxSU23cEH0fOgHT+ej8W+Fx3Yju9YuXO16ZCKV0DvVSWfrzlnm+tyP/pCVW2xGNAlibIzsunT+p65GJroamhRD4zbVyC7TFR4XXf7qIn4sVVIJ3bj9meNce0OqGLM5+Rbb7jMhePmQWXzqWWf15Of40dRIJfTmwmV2hiY1LhhUJkV2Xfn4FO4iFXo+NBkVDCpTjOzFPvEp7ko7RoQmw8CgMjGw6PJourGNCU12AoPKXHpvlMVFl4+fxF1rw6jQJIJBZbpgWJnLH34i7F0fxoamnzEYVKZI6ZkXWViZS+9+5PucDowNjUFlIlt/3GRRO7n4+vv4cSWMDI1BZcpYP/89Cxpk7cgx3EVijAuNQWV2AkOSbZpN9nfX6uHkP5xE+i50EBgRwe1e7BeO4mhs+ip0GBjw/nc/4AibCZqNQ9+EjgLGI50G/yzOeLMK9EXoqBQPPMfixYm9cek3HIuM8aHjgvFcmzs7OMpm2v8oCTE6dBJ2q/dYPC/29rZvFrcPZGgVdss1FtCLvX6/PVN5/lW2beBC62C3VGURw2z/D66EGBdaJ7vFMosZpAoDHZqIGluVgQ/dJuAnuI7IhA0NVEaOtOMuHrVP74zEhu4SNnSXkIdWfHnVbr3AAunSVOjkZaF1vI4NA+nQZKSvY7MvGNSP9AWDpEUvYlv7EtgU8UK7Sz/Z0Ongnc34/mi7apA+xNWHxND21fOa8S4buHiZu4GWJbKo8W2nxRTE0PasVkdsiZ3b2NjqhEYmaNkhGzs5Yrszjzz+GPb1QQtq2djxEZu17pvL2FWK70M2dijYC3sGgmc2LUtk8SPeXcQ6kxFcdo+kG/FBR+tSqCK4U1F6QlW7/rezms33pfTdxKdwMrGXMhm7XLWo/uWqZdgF2OPxPxXwJpKIkhiiAAAAAElFTkSuQmCC"/>
  </div>
</a>


<a href="java-functional-programming.htm">
<div class="book-cover" style="background-color: #f9f6f1;border: 1px solid #ccc;"> 
    <div class="book-cover-title" style="font-size: 18px;color: #333;top: 20px;">Java Functional Programming</div>
    <div class="book-cover-author">readbytes</div>
    <div class="book-cover-bottom-stripe" style="background-color: #333;"></div>
    <img class="book-cover-icon" style="width: 80px;height: 80px;top: 80px;" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFoAAABaCAYAAAA4qEECAAADzUlEQVR4Xu2bO4sUURCFlxVBzfwLJkb+A1MxEgMRDBQDRTBRwchARk00MRFBAwNBzEQwMBfEBz7wbWIkiIGJoInio9wZdmZ7T1V3V91bPVhaH3xJ973n3jk2vdO968JCkiRJkiRRIYphWOgI/zB/uyHBDxHFUODmIxkK3HwkQ4Gbj2QY6BDffCTDgBuPZhhw49EMA248miGgW3zj0QwBbjqiIcBNRzQEuOlohoA+8Y1HMgy4cauJEizO5EZMS0RoUSjPYKIEi7OaKMHirCZKsDiTi5iWiNAmoTyDiRIszmqiBIsz+QXTklZYeQYTJXSUl2cxUYLFWU2UYHEmb2Na0gorz2CihJ7w8iwmSrA4q4kSLM7kYUxLWmHlGUyU0C9ensVECRZnNQS4abPPMNEOy7S4BdN00L5GxmU8q4cuNXL24tll2KYrLIXW8yyLJdAJnkP3cFQ/9FzIGeEgHOBgCZhh1Qod5xkzH+PoduiVMH/qqDkQT3q4trGAEpZh1AId4/OZb3EWh14K89DRdDCecNIKzjdp+IelHcL8Nj/g7BU6r2R0+3gCHvRyN26tHdoszDdoAef2KpQt3pN7ZAc81YLzrFrAuSrfNOY/Es4rZAdcfbCywS7YPIvfMa0buiBkaFz6ATn+POy4xmvjhfGgsxpwjsUSigsr8el0UTzh7c9Vn5FBe4Q5BkuZXKFCnqsPmwviyQHsAsdarWF8tWGem/dxMRwwkG3gOJMvMM1O7S8aRJtX8hQ2aCDbwHEWvXAte3pPlmCDBxKhK3yMRU9cbiOKp0k+aQg3+K7pTdUPyHeYVgELL9At7/zqLA9KH0YmNh5qqqHPwgJWLzby8JxBb1y+Wxve+vXCwguc5Lzmxy164lLy1IL32SJ0Qwi3+k04ZtSLqttFm3dxlUJY8Lzdijsqo+QtnFqPK5u2CcFz1APT++RSPe7ZLHSO1qL6zYiXmu/WXdAaIXRO1lD8mnSpsOKHmpu4CyMscB5W/m8rlqex8TBS+lBTDQYObS2Y16vwxFfydbAaDBzaWmgXz2y14/46fg3Kxre5E2cXwoKH8geuXIb4hzNo11u4ZVRX9kmcVQELH0hP6BTPnym9T26h8559Gkc7wBYZQG/oLF+D/WZEgfht5AyOcoLeC4s5OwR0oLHGVTyrh643cvbjWWewGFc/4mr/MXRQKMjJBMCCvEwAWsdL8jARwJKqvYMrJDNYWRUmHWBZNSY9YGGlJj1gYUWew9REhBVnNFFCX3l5FhMDWJ7WpAAssc+kAiyzzcQJLHbibxyVJEmSJMk/xB+4wdarC+OVAQAAAABJRU5ErkJggg=="/>
  </div>
</a>


<a href="java-streams.htm">
<div class="book-cover" style="background-color: #f9f6f1;border: 1px solid #ccc;"> 
    <div class="book-cover-title" style="font-size: 18px;color: #333;top: 20px;">Java Streams</div>
    <div class="book-cover-author">readbytes</div>
    <div class="book-cover-bottom-stripe" style="background-color: #333;"></div>
    <img class="book-cover-icon" style="width: 80px;height: 80px;top: 60px;" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFoAAABaCAYAAAA4qEECAAACbklEQVR4Xu3cP4oUQRiG8S8xEzESDI1MPIRHEQQPYTK9iCyewMxrGIiCoaFnWFkMTIwUxD894KI8VbNdVdNfzdR87w+eRKa2ul+WVZM1G8+3ud+d+mhBvbZ0DO/uWEAcoVfhcIBehcQRvAvt1dz7gjjaVfxcrhcmxTiwvkudcGAN7YQDa2gnHFhDO+HAGtoJB24ZmmdzhcdBWobh2VzhcZCWYXg2V3gcpGUYns0VHgdpGYZnc4XHQVqG4dlc4XGQlmF4Nld4HKRlGJ7NFR4HaRmGZ3MN48Hcu7lLS19ihI7SPUsfdPSOCh/ulDoKfKhT7KC2P3P5QKfawfBBTr2D4ENEqDs+QJS64uWR6ubc0ssj1Q0vjlYXvLS1X3Mv5x7NPTyi+Jy5uuClNY2Az5zL3RtLLy1pJHz2XO544VLbHw+j4TvkcscLlxoR3yGXO154XaPie+Ry9djSC69rVHyPXK62/xTjhbu6+HtmRHyXXK6iDH1wGroTDd2Jhu5EQ3eioTvR0J1o6E40tAMOt1YCHGitBDjQWglwoLUS4EBrJcCB1kqAA62VwFOnREREROSIPbP7/CNZ28Y+2KT/hPjbjnyVOPl/ZA3tZLLzZGiN7YAD/+smPyqt0nH1Xe2Cw7LndpdHpBZH3ZXs4YndSAbdleyBYy4ljTjkUtKAI5a0sS/8MrKEI5YmFTZ2mQxYmlTgeDVt7DO/nOzC8WqTApPdSoarTQpM9ikZrjYpMNmPZLjapMDZ/JcZh6tNCkx2OxmuNinE4WraDPnbZw5ksp/JgKVJJQ5YmjTgiEvJHib7mgyaS1Yy2dtk3DP7zo9F9wfJyGVFhM8g5gAAAABJRU5ErkJggg=="/>
  </div>
</a>



<a href='java.htm'><div class='book-cover' style='background-color: #f9f6f1;color: #111111;border: 1px solid #ccc;display: flex;justify-content: center;align-items: center;text-align: center;'>More Java Books</div></a>
</div>
</div>
  </div>
  <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/prism.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
  
  <script>
    function copyCode(button) {
      const code = button.nextElementSibling.innerText;
      navigator.clipboard.writeText(code).then(() => {
        button.textContent = 'Copied!';
        setTimeout(() => { button.textContent = 'Copy'; }, 1500);
      });
    }
  </script>  
<div id="floatingLog" aria-live="polite" role="alert"></div>
<footer class="page-footer">
    <nav>
      <a href="https://readbytes.github.io">Home</a> | 
      Email:<script language="JavaScript" type="text/javascript">
var part1 = 'yinpeng';var part6 = '263';var part2 = Math.pow(2,6);var part3 = String.fromCharCode(part2);var part4 = 'hotmail dot com';var part5 = part1 + String.fromCharCode(part2) + part4;document.write(part1 + part6 + part3 + part4);
</script>
    </nav>
  <p>© 2025 — All rights reserved.</p>    
  </footer>

</body>
</html>