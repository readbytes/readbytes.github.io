<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>C++ STL Functors, Lambdas, and Predicates in STL</title>
<link rel='shortcut icon' href='https://readbytes.github.io/images/favicon.ico'>
<link href="https://fonts.googleapis.com/css2?family=Merriweather&display=swap" rel="stylesheet" />
<link href="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet" />
<script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/prism.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/codemirror.min.css" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/codemirror.min.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/theme/dracula.min.css"><style>
html {scroll-behavior: smooth;}  
body {font-family: 'Merriweather', serif;;margin: 0;padding: 2rem 1rem;font-size: 15px;line-height: 1.5;transition: background-color 0.3s, color 0.3s;}
.container {max-width: 750px;margin: 0 auto;padding: 1rem 2rem;}
.light-mode {background-color: #f8f7f5;color: #333;} 
.dark-mode {background-color: #121212;color: #e0e0e0;}
a { text-decoration: none;transition: color 0.2s;}
a:hover {text-decoration: underline;}
.light-mode a {color: #555;}
.dark-mode a {color: #aaa;}
</style><style>
.related-book-list {display: flex;flex-wrap: wrap;gap: 20px;}
.related-books {margin-top: 40px;}
.related-books h2 {font-size: 22px;margin-bottom: 20px;border-bottom: 2px solid #eee;padding-bottom: 8px;}
.light-mode .related-books h2 {color: #333;border-color: #eee;}
.dark-mode .related-books h2 {color: #ddd;border-color: #333;}
</style><style>
.book-cover {width: 130px;height: 180px;font-family: Arial, sans-serif;position: relative;overflow: hidden;box-shadow: 2px 2px 4px rgba(0,0,0,0.1);}
.book-cover-bottom-stripe {position: absolute;bottom: 0;left: 0;height: 5px;width: 100%;}
.book-cover-title {position: absolute;width: 100%;text-align: center;font-weight: bold;}
.book-cover-icon {position: absolute;left: 50%;transform: translateX(-50%);display: flex;align-items: center;justify-content: center;}
.book-cover-author {position: absolute;bottom: 10px;width: 100%;text-align: center;font-size: 8px;color: #333;}
</style><style>
.book-title-toc {font-size: 32px;font-weight: bold; }
.book-subtitle-toc {font-size: 18px;margin-top: 8px;font-style: italic;}
.book-header {text-align: center;margin-bottom: 40px;}

.toc-container {border-radius: 10px;padding: 30px;margin-bottom: 40px;box-shadow: 0 8px 20px rgba(0,0,0,0.05);}
h1 {font-size: 24px;text-align: center;margin-bottom: 30px;letter-spacing: 1px;padding-bottom: 10px;}
.toc-list,.toc-section-list {list-style: none;padding: 0;margin: 0;}
.toc-section-list {padding-left: 18px;margin-top: 6px;margin-bottom: 20px; }
.toc-chapter {padding: 20px 0;}
.chapter-title,.toc-section {display: flex;justify-content: space-between;padding-top: 4px;}
.chapter-title {font-size: 17px;font-weight: bold;}
.chapter-page,.section-page {font-style: italic;}
 
 
.light-mode .book-title-toc,.light-mode .chapter-title,.light-mode .book-name {color: #222;}
.light-mode .book-subtitle-toc,.light-mode .book-sub,.light-mode .chapter-page,.light-mode .section-page {color: #666;}
.light-mode .toc-container { background: #fff;border: 1px solid #ddd;}
.light-mode h1 {border-bottom: 2px solid #eee;color: #222;}
.light-mode .toc-section {  color: #444;}

.light-mode .book-cover { border: 1px solid #ccc;box-shadow: 0 6px 12px rgba(0, 0, 0, 0.15);}
.light-mode .book-title,.light-mode .series-name {color: #fff;}
.light-mode .book-subtitle,.light-mode .book-footer {color: #aaa;}

.dark-mode .book-title-toc,.dark-mode .chapter-title,.dark-mode .book-name {color: #f5f5f5;}
.dark-mode .book-subtitle-toc,.dark-mode .book-sub,.dark-mode .chapter-page,.dark-mode .section-page {color: #aaa;}
.dark-mode .toc-container {background: #1e1e1e;border: 1px solid #444;}

.dark-mode h1 {border-bottom: 2px solid #333;color: #eee;}
.dark-mode .toc-section {color: #bbb;}

.dark-mode .related-books h2 {color: #ddd;border-bottom: 2px solid #333;}
.dark-mode .book-title,.dark-mode .series-name {color: #fff;}
.dark-mode .book-subtitle,.dark-mode .book-footer {color: #bbb;}
.dark-mode .toc-section {color: #ddd;}

@media (max-width: 600px) {
  .chapter-title,
  .toc-section {
    flex-direction: column;
    align-items: flex-start;
  }

  .chapter-page,
  .section-page {
    margin-top: 4px;
  }
}

</style><style>
.light-mode .container {box-shadow: 0 0 15px rgba(0,0,0,0.1);}
.dark-mode .container {box-shadow: 0 0 15px rgba(255, 255, 255, 0.05);}

h1, h2, h3 {font-weight: 600;margin-top: 2.5rem;margin-bottom: 1rem;line-height: 1.2;}
h1 { font-size: 1.8rem; }
h2 { font-size: 1.4rem; }
h3 { font-size: 1.2rem; }

table {width: 100%;border-collapse: collapse;font-family: sans-serif;font-size: 1em;margin: 1em 0;}
th, td {padding: 0.6em 1em;text-align: left;border: 1px solid;}
tr:nth-child(even) {  background-color: inherit;}
tr:hover { background-color: inherit;}

code {color: #d35400;}

.chapter-navi-section {display: flex;justify-content: space-between;align-items: center;padding-bottom: 10px;padding-top: 10px;}
.nav-link {color: inherit;text-decoration: none;opacity: 0.5;transition: opacity 0.3s ease, text-decoration 0.3s ease;}
.nav-link:hover {opacity: 0.9;text-decoration: underline;}
.prev { text-align: left; }
.toc-link { text-align: center; }
.next { text-align: right; }

.download-section {display: flex;align-items: center;justify-content: center;gap: 2rem;padding: 2rem 1rem;max-width: 600px;margin: 3rem auto;border-radius: 12px;box-shadow: 0 4px 10px rgba(0,0,0,0.05);}
.download-info h2 {margin: 0 0 0.5rem;font-size: 1.2rem;}
.format-label {margin: 0 0 0.5rem;font-size: 0.95rem;}
.download-buttons {display: flex;gap: 1rem;}
.download-button {background-color: #4A90E2;color: white;padding: 0.5em 1.2em;border-radius: 25px;font-size: 0.95rem;text-decoration: none;transition: background-color 0.3s ease;}
.download-button:hover {background-color: #357ABD;}

.code-block {position: relative;margin-bottom: 1em;}
.copy-button {background: transparent;color: white;position: absolute;top: 8px;right: 8px;border: none;padding: 4px 8px;font-size: 12px;border-radius: 4px;cursor: pointer;z-index: 1;}
.copy-button:hover {background-color: #0056b3;}

.snippet-container {overflow: hidden;}
.snippet-header {padding: 0.75rem 1rem;cursor: pointer;font-size: 1rem;background-color: #eeeeee;color:  #111111; border-radius: 8px;cursor: pointer;box-shadow: 0 4px 6px rgba(0,0,0,0.1); }
.snippet-body {display: none;font-family: monospace;}
.snippet-container.open .snippet-body {display: block;}

.CodeMirror {border: 2px solid #ccc;border-radius: 4px;resize: vertical;}

.light-mode .format-label {color: #888;}
.light-mode th {background-color: #f2f2f2;}
.light-mode tr:nth-child(even) {background-color: #fafafa;}
.light-mode tr:hover {background-color: #e6f7ff;}

.dark-mode .snippet-header {background-color: #333;color:  #ddd; }
.dark-mode .format-label {color: #aaa;}
.dark-mode th {background-color: #333;color: #fff;}
.dark-mode td {border-color: #444;}
.dark-mode tr:nth-child(even) {background-color: #2a2a2a;}
.dark-mode tr:hover {background-color: #2c3e50;}


.button-group-run-edit {display: flex;width: 100%;gap: 1rem;}
.button-run-edit {flex: 1;padding: 1rem;font-size: 1rem;font-weight: 600;border: none;border-radius: 8px;cursor: pointer;transition: background 0.3s, color 0.3s;}

.light-mode .button-run-edit {background-color: #f0f0f0;color: #222;box-shadow: 0 0 10px rgba(0, 0, 0, 0.05);}
.light-mode .button-run-edit:hover {background-color: #e0e0e0;}

.dark-mode .button-run-edit {background-color: #2a2a2a;color: #f5f5f5;box-shadow: 0 0 10px rgba(255, 255, 255, 0.05);}
.dark-mode .button-run-edit:hover {background-color: #3a3a3a;}

button { padding: 0.5em 1em; background: green; color: white; border: none; cursor: pointer; }
button:hover { background: #1e7e34; }
.result_iframe { width:99%; margin-top: 1em;  resize: both;background-color: #515b63;border:1px solid #ccc;}   

.dialog-backdrop {position: fixed;top: 0;left: 0;width: 100vw;height: 100vh;background: rgba(0,0,0,0.5);display: none;justify-content: center;align-items: center;z-index: 10;}
.dialog {background: #90979e;padding: 20px;width: 90vw;height: 80vh;border-radius: 8px;box-shadow: 0 0 20px rgba(0,0,0,0.3);display: flex;flex-direction: column;}
.dialog-content {display: flex;gap: 20px;margin-top: 10px;height: calc(100% - 40px);}
.editor-container, .preview-container {flex: 1;height: 100%;max-height: 100%;overflow: hidden; }
.result_iframe_dialog {width: 100%;height: 100%;resize: both;border:1px solid #ccc;overflow: auto; }   
.CodeMirror {width: 100% !important;height: 100% !important;}
</style>
</head>
<body>
<script>const mode = localStorage.getItem('mode') || 'light';document.documentElement.classList.add(`${mode}-mode`);</script>  
<div class="container"><div class = "chapter-navi-section">
<a href="cplusplus-stl-stl-algorithms-fundamentals.htm" class="nav-button prev">‚Üê</a>
<a href='cplusplus-stl.htm#functors-lambdas-and-predicates-in-stl' class="nav-button toc-link">Index</a>
<a href="cplusplus-stl-advanced-algorithms-and-utilities.htm" class="nav-button next">‚Üí</a>
</div>
<div class='book-header'><h1 class='book-title-toc' id = 'top'>Functors, Lambdas, and Predicates in STL</h1><h3 class='book-subtitle-toc'>C++ STL</h3></div><h2 id='what-are-functors-and-why-use-them'>7.1 What Are Functors and Why Use Them?</h2><p>In C++, <strong>functors</strong>‚Äîalso known as <strong>function objects</strong>‚Äîare objects that can be called like functions. This is possible because they overload the function call operator <code>operator()</code>. Instead of writing a standalone function, you create a class or struct that defines how the object behaves when used with parentheses, just like a function call.</p><h4 id="basic-concept">Basic Concept</h4><p>Here‚Äôs a simple example of a functor:</p><div class="code-block">
 <button class="copy-button" onclick="copyCode(this)">‚ñØ</button>
 <pre><code class="language-cpp">struct Adder {
    int value;
    Adder(int v) : value(v) {}

    int operator()(int x) const {
        return x + value;
    }
};

int main() {
    Adder add5(5);
    int result = add5(10);  // Calls add5.operator()(10)
    // result == 15
}</code></pre>
</div><p>In this example, <code>Adder</code> holds a state (<code>value</code>) and uses it in the call operator to add to an input. You use the object like a function, but with the power of storing data inside it.</p><h4 id="advantages-of-functors">Advantages of Functors</h4><ol>
 <li><p><strong>Statefulness:</strong> Unlike plain functions, functors can store internal data/state. This allows customized behavior based on member variables, which is useful in many algorithms that require context.</p></li>
 <li><p><strong>Inline Performance:</strong> Since functors are typically small objects and their call operators are often defined inline, compilers can optimize calls efficiently, sometimes outperforming regular function pointers.</p></li>
 <li><p><strong>Flexibility:</strong> Functors can have multiple overloaded call operators or other member functions, giving you more control than a simple function.</p></li>
 <li><p><strong>Type Safety:</strong> Functors are typed objects, enabling the compiler to enforce stronger type checks.</p></li>
</ol><h4 id="functors-in-stl-algorithms">Functors in STL Algorithms</h4><p>The STL algorithms heavily rely on functors to provide <strong>custom behavior</strong>. For example, sorting algorithms like <code>std::sort</code> accept a functor (or any callable) as a comparison function to define how elements should be ordered.</p><div class="code-block">
 <button class="copy-button" onclick="copyCode(this)">‚ñØ</button>
 <pre><code class="language-cpp">struct Descending {
    bool operator()(int a, int b) const {
        return a &gt; b;  // Sort in descending order
    }
};

std::vector&lt;int&gt; v = {3, 1, 4, 2};
std::sort(v.begin(), v.end(), Descending());</code></pre>
</div><p>Here, <code>Descending</code> is a functor that tells <code>std::sort</code> to arrange elements in descending order.</p><p>Using functors instead of raw function pointers allows the STL algorithms to be <strong>generic and extensible</strong>‚Äîusers can provide their own callable objects to customize behavior while keeping the algorithms container-agnostic.</p><h3 id="summary">Summary</h3><p>Functors are objects that act like functions by overloading <code>operator()</code>. They combine the power of objects‚Äîsuch as storing state and supporting inline calls‚Äîwith the simplicity of functions. This makes them essential for customizing STL algorithms, enabling flexible, efficient, and reusable code designs. Understanding functors lays the foundation for mastering advanced STL features and writing clean, expressive C++ code.</p><div class = "chapter-navi-section">
<a href="#top" class="nav-button prev">‚Üë</a>
<a href='cplusplus-stl.htm#functors-lambdas-and-predicates-in-stl' class="nav-button toc-link">Index</a>
<a href="#bottom" class="nav-button next">‚Üì</a>
</div>
<h2 id='writing-custom-functors'>7.2 Writing Custom Functors</h2><p>Custom functors are user-defined classes or structs that overload the function call operator <code>operator()</code>, allowing them to be used like functions. Writing your own functors enables you to encapsulate complex behaviors, including state, which can be passed to STL algorithms for flexible, reusable operations.</p><h4 id="creating-a-custom-functor">Creating a Custom Functor</h4><p>Let's write a functor that compares strings by their length, useful for sorting strings by size instead of alphabetically.</p><div class="code-block">
 <button class="copy-button" onclick="copyCode(this)">üìã</button>
 <pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;string&gt;

struct CompareByLength {
    bool operator()(const std::string&amp; a, const std::string&amp; b) const {
        return a.size() &lt; b.size();
    }
};

int main() {
    std::vector&lt;std::string&gt; words = {"apple", "banana", "kiwi", "cherry"};
    
    std::sort(words.begin(), words.end(), CompareByLength());
    
    for (const auto&amp; word : words) {
        std::cout &lt;&lt; word &lt;&lt; " ";
    }
}</code></pre>
</div><p><strong>Output:</strong></p><div class="code-block">
 <button class="copy-button" onclick="copyCode(this)">‚ñØ</button>
 <pre><code class="language-bash">kiwi apple banana cherry</code></pre>
</div><p>This functor enables <code>std::sort</code> to order words by length, showcasing how functors customize algorithm behavior.</p><h4 id="functors-with-state">Functors with State</h4><p>Functors can also store state through constructor parameters, which can influence their behavior during calls. Here's an example of a functor that checks if numbers are greater than a stored threshold:</p><div class="code-block">
 <button class="copy-button" onclick="copyCode(this)">üìã</button>
 <pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;

struct IsGreaterThan {
    int threshold;
    
    IsGreaterThan(int t) : threshold(t) {}

    bool operator()(int value) const {
        return value &gt; threshold;
    }
};

int main() {
    std::vector&lt;int&gt; nums = {10, 25, 5, 30, 15};
    
    IsGreaterThan greaterThan20(20);
    
    int count = std::count_if(nums.begin(), nums.end(), greaterThan20);
    
    std::cout &lt;&lt; "Numbers greater than 20: " &lt;&lt; count &lt;&lt; std::endl;
}</code></pre>
</div><p><strong>Output:</strong></p><div class="code-block">
 <button class="copy-button" onclick="copyCode(this)">‚ñØ</button>
 <pre><code class="language-bash">Numbers greater than 20: 2</code></pre>
</div><p>Here, the functor stores the threshold value <code>20</code> and uses it in <code>operator()</code> to test each number. This makes the functor reusable with different thresholds by simply changing the constructor argument.</p><h3 id="benefits-of-custom-functors">Benefits of Custom Functors</h3><ul>
 <li><strong>Reusability:</strong> Encapsulating logic in functors allows easy reuse across algorithms without rewriting code.</li>
 <li><strong>Statefulness:</strong> Constructor parameters enable parameterizing behavior without global variables.</li>
 <li><strong>Clarity:</strong> Functors clearly package logic and state, improving code readability.</li>
 <li><strong>Performance:</strong> Defined inline, functors often allow compilers to optimize calls efficiently.</li>
</ul><h3 id="summary">Summary</h3><p>Writing custom functors involves defining classes with an overloaded <code>operator()</code>, optionally storing state through constructors. These objects provide a powerful way to inject custom behavior into STL algorithms like <code>std::sort</code> or <code>std::count_if</code>. Mastering functor creation enhances your ability to write modular, maintainable, and expressive C++ code.</p><div class = "chapter-navi-section">
<a href="#top" class="nav-button prev">‚Üë</a>
<a href='cplusplus-stl.htm#functors-lambdas-and-predicates-in-stl' class="nav-button toc-link">Index</a>
<a href="#bottom" class="nav-button next">‚Üì</a>
</div>
<h2 id='using-lambdas-with-stl-algorithms'>7.3 Using Lambdas with STL Algorithms</h2><p>Lambda expressions are a modern C++ feature that provides a concise way to write <strong>inline, anonymous functors</strong>‚Äîsmall blocks of code that can be passed directly to STL algorithms without needing a separate named functor class. Lambdas are perfect for short, custom operations that improve code clarity and reduce boilerplate.</p><h4 id="anatomy-of-a-lambda">Anatomy of a Lambda</h4><p>A lambda expression has this general form:</p><div class="code-block">
 <button class="copy-button" onclick="copyCode(this)">‚ñØ</button>
 <pre><code class="language-cpp">[capture](parameters) -&gt; return_type {
    // function body
}</code></pre>
</div><ul>
 <li><p><strong>Capture list <code>[]</code></strong>: Specifies which variables from the surrounding scope the lambda can use. For example:</p>
  <ul>
   <li><code>[=]</code> captures all variables by value.</li>
   <li><code>[&amp;]</code> captures all variables by reference.</li>
   <li><code>[x, &amp;y]</code> captures <code>x</code> by value and <code>y</code> by reference.</li>
  </ul></li>
 <li><p><strong>Parameters <code>(‚Ä¶)</code></strong>: Like function parameters.</p></li>
 <li><p><strong>Return type <code>-&gt; type</code></strong>: Usually inferred by the compiler, but can be explicitly specified.</p></li>
 <li><p><strong>Body <code>{‚Ä¶}</code></strong>: The code executed when the lambda is called.</p></li>
</ul><h4 id="example-sorting-with-a-lambda">Example: Sorting with a Lambda</h4><p>Suppose you want to sort a vector of integers in descending order without defining a separate functor:</p><div class="code-block">
 <button class="copy-button" onclick="copyCode(this)">üìã</button>
 <pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

int main() {
    std::vector&lt;int&gt; nums = {5, 2, 9, 1, 7};

    std::sort(nums.begin(), nums.end(), [](int a, int b) {
        return a &gt; b;  // Sort descending
    });

    for (int n : nums) std::cout &lt;&lt; n &lt;&lt; " ";
}</code></pre>
</div><p><strong>Output:</strong></p><div class="code-block">
 <button class="copy-button" onclick="copyCode(this)">‚ñØ</button>
 <pre><code class="language-bash">9 7 5 2 1</code></pre>
</div><p>Here, the lambda <code>[](int a, int b) { return a &gt; b; }</code> is passed directly as the comparison function.</p><h4 id="example-finding-an-element-with-std-find-if">Example: Finding an Element with <code>std::find_if</code></h4><p>Lambdas are handy for custom search conditions:</p><div class="code-block">
 <button class="copy-button" onclick="copyCode(this)">‚ñØ</button>
 <pre><code class="language-cpp">auto it = std::find_if(nums.begin(), nums.end(), [](int x) {
    return x % 2 == 0;  // Find first even number
});

if (it != nums.end()) {
    std::cout &lt;&lt; "First even number: " &lt;&lt; *it &lt;&lt; std::endl;
}</code></pre>
</div><h4 id="example-applying-actions-with-std-for-each">Example: Applying Actions with <code>std::for_each</code></h4><p>You can also perform operations on every element inline:</p><div class="code-block">
 <button class="copy-button" onclick="copyCode(this)">‚ñØ</button>
 <pre><code class="language-cpp">std::for_each(nums.begin(), nums.end(), [](int&amp; n) {
    n *= 2;  // Double each element
});</code></pre>
</div><h3 id="why-use-lambdas">Why Use Lambdas?</h3><ul>
 <li><strong>Conciseness:</strong> No need to write separate functor classes.</li>
 <li><strong>Readability:</strong> Code stays close to where it‚Äôs used, improving clarity.</li>
 <li><strong>Flexibility:</strong> Capture local variables effortlessly for context.</li>
 <li><strong>Performance:</strong> Compilers optimize lambdas effectively, comparable to functors.</li>
</ul><h3 id="summary">Summary</h3><p>Lambdas are lightweight, inline functors ideal for quick, custom behaviors in STL algorithms. Their capture lists allow access to surrounding variables, making them versatile. By mastering lambdas with <code>std::sort</code>, <code>std::find_if</code>, <code>std::for_each</code>, and more, you gain powerful tools for clean, expressive, and efficient C++ code.</p><div class = "chapter-navi-section">
<a href="#top" class="nav-button prev">‚Üë</a>
<a href='cplusplus-stl.htm#functors-lambdas-and-predicates-in-stl' class="nav-button toc-link">Index</a>
<a href="#bottom" class="nav-button next">‚Üì</a>
</div>
<h2 id='predicate-functions-unary-and-binary-predicates'>7.4 Predicate Functions: Unary and Binary Predicates</h2><p>In STL algorithms, <strong>predicates</strong> are special types of functors or functions that return a boolean (<code>true</code> or <code>false</code>) value. They serve as <strong>conditions or rules</strong> to control the behavior of algorithms like filtering, counting, and sorting.</p><h4 id="unary-predicates">Unary Predicates</h4><p>A <strong>unary predicate</strong> takes a single argument and returns a boolean. It‚Äôs commonly used in algorithms that process elements individually, such as filtering or counting.</p><p><strong>Example:</strong> Count how many numbers in a vector are greater than 10.</p><div class="code-block">
 <button class="copy-button" onclick="copyCode(this)">üìã</button>
 <pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

bool isGreaterThan10(int x) {
    return x &gt; 10;
}

int main() {
    std::vector&lt;int&gt; nums = {5, 12, 7, 20, 15};
    
    int count = std::count_if(nums.begin(), nums.end(), isGreaterThan10);
    
    std::cout &lt;&lt; "Numbers greater than 10: " &lt;&lt; count &lt;&lt; std::endl;
}</code></pre>
</div><p>Output:</p><div class="code-block">
 <button class="copy-button" onclick="copyCode(this)">‚ñØ</button>
 <pre><code class="language-bash">Numbers greater than 10: 3</code></pre>
</div><p>Here, <code>isGreaterThan10</code> is a unary predicate that controls which elements are counted.</p><h4 id="binary-predicates">Binary Predicates</h4><p>A <strong>binary predicate</strong> takes two arguments and returns a boolean. It is often used in sorting or comparing pairs of elements, where the predicate defines the order between two values.</p><p><strong>Example:</strong> Sort a vector in descending order using a binary predicate.</p><div class="code-block">
 <button class="copy-button" onclick="copyCode(this)">üìã</button>
 <pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

bool descending(int a, int b) {
    return a &gt; b;  // Return true if 'a' should come before 'b'
}

int main() {
    std::vector&lt;int&gt; nums = {5, 12, 7, 20, 15};
    
    std::sort(nums.begin(), nums.end(), descending);
    
    for (int n : nums) std::cout &lt;&lt; n &lt;&lt; " ";
}</code></pre>
</div><p>Output:</p><div class="code-block">
 <button class="copy-button" onclick="copyCode(this)">‚ñØ</button>
 <pre><code class="language-bash">20 15 12 7 5</code></pre>
</div><p>The <code>descending</code> predicate tells <code>std::sort</code> how to order the elements.</p><h4 id="how-predicates-control-algorithm-behavior">How Predicates Control Algorithm Behavior</h4><ul>
 <li><strong>Unary predicates</strong> decide whether an element satisfies a condition (e.g., for filtering or counting).</li>
 <li><strong>Binary predicates</strong> decide the relative ordering of two elements (e.g., for sorting).</li>
</ul><p>Both predicate types must return <code>bool</code>, guiding the STL algorithms to perform actions conditionally or reorder elements accordingly.</p><h3 id="summary">Summary</h3><p>Unary and binary predicates are boolean functions that drive the logic of many STL algorithms. Unary predicates filter or select elements based on a condition, while binary predicates define custom orderings. Understanding and writing these predicates is key to harnessing the full power of STL‚Äôs generic algorithms.</p><div class = "chapter-navi-section">
<a href="#top" class="nav-button prev">‚Üë</a>
<a href='cplusplus-stl.htm#functors-lambdas-and-predicates-in-stl' class="nav-button toc-link">Index</a>
<a href="#bottom" class="nav-button next">‚Üì</a>
</div>
<h2 id='practical-examples-filtering-custom-sorting'>7.5 Practical Examples: Filtering, Custom Sorting</h2><p>In this section, we‚Äôll explore practical ways to use <strong>functors</strong> and <strong>lambdas</strong> to filter elements and perform custom sorting in STL containers. Combining these with STL algorithms helps write expressive, concise, and reusable code.</p><h4 id="example-1-filtering-with-a-custom-functor">Example 1: Filtering with a Custom Functor</h4><p>Suppose we want to filter and count all numbers greater than a threshold using a functor:</p><div class="code-block">
 <button class="copy-button" onclick="copyCode(this)">üìã</button>
 <pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

struct IsGreaterThan {
    int threshold;
    IsGreaterThan(int t) : threshold(t) {}

    bool operator()(int value) const {
        return value &gt; threshold;
    }
};

int main() {
    std::vector&lt;int&gt; nums = {10, 25, 5, 30, 15};

    IsGreaterThan greaterThan20(20);

    int count = std::count_if(nums.begin(), nums.end(), greaterThan20);
    
    std::cout &lt;&lt; "Numbers greater than 20: " &lt;&lt; count &lt;&lt; std::endl;
}</code></pre>
</div><p><strong>Output:</strong></p><div class="code-block">
 <button class="copy-button" onclick="copyCode(this)">‚ñØ</button>
 <pre><code class="language-bash">Numbers greater than 20: 2</code></pre>
</div><p>Here, the functor <code>IsGreaterThan</code> holds the threshold state and is used with <code>std::count_if</code> to filter elements.</p><h4 id="example-2-filtering-with-a-lambda-expression">Example 2: Filtering with a Lambda Expression</h4><p>You can achieve the same filtering inline with a lambda for quick, one-off conditions:</p><div class="code-block">
 <button class="copy-button" onclick="copyCode(this)">‚ñØ</button>
 <pre><code class="language-cpp">int countLambda = std::count_if(nums.begin(), nums.end(), [](int x) {
    return x &gt; 20;
});
std::cout &lt;&lt; "Numbers greater than 20 (lambda): " &lt;&lt; countLambda &lt;&lt; std::endl;</code></pre>
</div><h4 id="example-3-custom-sorting-with-a-lambda">Example 3: Custom Sorting with a Lambda</h4><p>Custom sorting is straightforward with lambdas. Suppose you want to sort strings by their length:</p><div class="code-block">
 <button class="copy-button" onclick="copyCode(this)">üìã</button>
 <pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;string&gt;

int main() {
    std::vector&lt;std::string&gt; words = {"apple", "banana", "kiwi", "cherry"};

    std::sort(words.begin(), words.end(), [](const std::string&amp; a, const std::string&amp; b) {
        return a.size() &lt; b.size();  // Sort ascending by length
    });

    for (const auto&amp; word : words)
        std::cout &lt;&lt; word &lt;&lt; " ";
}</code></pre>
</div><p><strong>Output:</strong></p><div class="code-block">
 <button class="copy-button" onclick="copyCode(this)">‚ñØ</button>
 <pre><code class="language-bash">kiwi apple banana cherry</code></pre>
</div><h4 id="how-predicates-integrate-with-stl-algorithms">How Predicates Integrate with STL Algorithms</h4><ul>
 <li><strong>Filtering algorithms</strong> like <code>std::count_if</code>, <code>std::find_if</code>, and <code>std::remove_if</code> take <strong>unary predicates</strong> to select elements meeting specific conditions.</li>
 <li><strong>Sorting algorithms</strong> like <code>std::sort</code> accept <strong>binary predicates</strong> to define custom ordering rules.</li>
</ul><p>Whether using a stateful functor or a compact lambda, predicates make STL algorithms adaptable to your needs. Lambdas shine when you want concise, inline logic without boilerplate, while functors excel when reusability or stored state is required.</p><h3 id="summary">Summary</h3><p>By combining functors and lambdas with STL algorithms, you write clear, maintainable code that filters and sorts data precisely how you want. This flexibility is a core strength of the STL, enabling powerful data manipulation with minimal effort.</p><div class = "chapter-navi-section">
<a href="cplusplus-stl-stl-algorithms-fundamentals.htm" class="nav-button prev">‚Üê</a>
<a href='cplusplus-stl.htm#functors-lambdas-and-predicates-in-stl' class="nav-button toc-link">Index</a>
<a href="cplusplus-stl-advanced-algorithms-and-utilities.htm" class="nav-button next">‚Üí</a>
</div>
<section class="download-section">
  <div class="book-cover" style="background-color: #f9f6f1;border: 1px solid #ccc;"> 
    <div class="book-cover-title" style="font-size: 20px;color: #333;top: 20px;">C++ STL</div>
    <div class="book-cover-author">readbytes</div>
    <div class="book-cover-bottom-stripe" style="background-color: #333;"></div>
    <img class="book-cover-icon" style="width: 90px;height: 90px;top: 70px;" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFoAAABaCAYAAAA4qEECAAADK0lEQVR4Xu2cvWsTcRjHo+DkIKiTjiJugqTJ0cG/QcRZ/wJXQTd3ByeHDiLJnS84dHMVBHUSRQUH90pNfmfb6CKi8fqSaj93ae4lzzV3+X7gS9vkeZ7f7/lwEDq0jYYQQgghxFzQ9t0wbTzf3WO/SAllpg3niAlQYJa0uu4W54kxeA96ZykwU4JwnTPFGGLyMqd3nTNFAnFx2cOZIiee//UK5TLsEQWg3D1ZHpxgvShATLCeajsoWKKNaAfuDyVvZuGhu8paURBK1lNtBAVLtBEULNFGULBEG0HBlRfNRUrMqwW/f473GZFQvxXWVQbPD5e4zEGlcXt4eHQvvrdbU2W4zEGn5Yd3+NoovHul4DKzHN69UnCZWQ7vXim8IHzJhWY1vLtIQSRujSInhTNEBppL345R6LiwV+SAUpPCHpETimVYLwpAuRJtBOVKtBHNR4OTFCzRRlCwRBtBwRJtBAVLtBEULNFGeN3wPiVvp/+OtVmJ5qzvmdl1z1kzV8Ql53+q0/6az765gBLyConqN9i/X9hfeyiAYX0S7cCtsi9NOKf2UADDesL6LOGsWsPlx+V8d/Vo3t5x4bzyGA4P8TK1TuBeU0FpxC5T83D/0uBF6h7uXxq8SN3D/Utj80OHl6ltgvAX9y+V2IUm53eUQZQvUT4nvJ8x/e/R14+RiBeeHz4bZfPn6PW3bT908Z7s4d6Vgwsxix13mj15iGb94Ows4bxKwWUY1heF89OGcyoHFypjOZ4zKV7gVjijUjSfrJ/hUqOwdtrwvH2yzN7KkbDUTsKfrLWgufTmSPzsf2F9ZeFitVtwVqBgiTaCgiXaCAqWaCMoWKKNoGCJNoKCJdoICpZoIyhYoo2gYIk2goIl2ggKlmgjKFiijaBgiTaCgiXagLbfu0jBW+m6NdaKAsQEj9Jxl1krChATvBPWiQJ4fviJgiV6yiw+3ThOuRI9ZbzA3aRYSZ4iFx73T1FqUtg3l1DKbrr9960gvBt9f207/Rst332I1U0Iz5tbKGaa4VlzTSQk8X84Fw3PEY3p/70KTxA7UFTeeB13ibPFf1BY1nCeEEIIIYQowl8t5mhjJHw+fQAAAABJRU5ErkJggg=="/>
  </div>
  <div class="download-info">
    <h2 id='bottom'>Download This Ebook</h2>
    <p class="format-label">Available formats:</p>
    <div class="download-buttons">
      <a href="cplusplus-stl.pdf" class="download-button">üìÑ PDF</a>
      <a href="cplusplus-stl.epub" class="download-button">üìò EPUB</a>
    </div>
  </div>
</section><div class='related-books'>
<h2>C++ Introduction Books</h2>
<div class='related-book-list'>
<a href="cplusplus-for-beginners.htm">
<div class="book-cover" style="background-color: #f9f6f1;border: 1px solid #ccc;"> 
    <div class="book-cover-title" style="font-size: 18px;color: #333;top: 20px;">C++ for Beginners</div>
    <div class="book-cover-author">readbytes</div>
    <div class="book-cover-bottom-stripe" style="background-color: #333;"></div>
    <img class="book-cover-icon" style="width: 90px;height: 90px;top: 70px;" src="data:image/png;base64,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"/>
  </div>
</a>


<a href="cplusplus-syntax.htm">
<div class="book-cover" style="background-color: #f9f6f1;border: 1px solid #ccc;"> 
    <div class="book-cover-title" style="font-size: 20px;color: #333;top: 20px;">C++ Syntax</div>
    <div class="book-cover-author">readbytes</div>
    <div class="book-cover-bottom-stripe" style="background-color: #333;"></div>
    <img class="book-cover-icon" style="width: 90px;height: 90px;top: 70px;" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFoAAABaCAYAAAA4qEECAAAFZ0lEQVR4Xu2dy4scVRSH8ye0iYtkERcmzgjT2OYBuhNREMVXBh/TgsYQx5ULDYTgVl3EFyg6uFJBV76IEXdKXAVBJCgISSTRGRmZiZlADBo6M5kp+3ZbnXt/p7q6btWtc++pqQPfpu/p7vP7UnSqi+m6GzbkrMbYO50u0Tqjgx5Kqe4brSa8+XplFf0UroQ3GbDltqNRs70Y3Tw5G22//2SXU0Fyy5MXc6GyqYyYWwd9WdfGbW9uxRe9vvlBtOvZKLrpwTOiUDO7QjlALxu3zWxFf5mq++RF/YU27/40au39lwSQAspygXICwhfRY2rhv5Z6URxcEuoAQUkuQV/oM7HwSN45vUoGlwaKKQOrI1t9zuhPaD19mQwtEZRSFrq71M/sqh3JMSikTHSH6LdXeoN6Ag4rlV3Ta0RG2aTKjhfU/6Q4rGRQAgf62QhKHnzjk3wKlwRK4EI7qq99g4wf3NR8nwwqmfE9s0QAF8olOarjB1QDDisZDM+NIbqhXYXDQaWDwbnRPj46xtkGDiodDM6N7nYgWl2hwkEl09r7DwnOzZbbr131G4iemFokw0oGQ/ug2XVKRI9PzpJhJYOhfdB66m8qevsDp8iwksHQPqi8aAzsi1o0E7VoJioteuzh30lgX1RaNIb1SS2aiVo0E5UVPTH1Fwnrk8qKxqC+qUUzUYtmwovoL49dioYV9uZhx/4VEjRmWM2fp70uYRc9qrA/DxhSZ1RhvyuCEL1wfiU6PXulB/bnAUPqnJnv8+cSTtEv7HeFd9G4XpyzJGQaWLjuisqJxoCjeOVjc572y7THBayim4+cNUKdONkhPUXBgKO495AxUrTvVdrjAq+ij//k/i9UMeAo7jlojFSLzsLE4/ZfuyspuvXYb0Yo16IxXBZQ9DOv0x4XsIqeOjRvhPri20ukpwgYLgt3HTBGir75kfa4gFU01h373f5ZA4bLChauu4BNdPtF82hWhT1FuHVfh4TLCtbR47SnKKWKTqu5hWXSXwQMZsOBGZzOLOzPA7voNz66QPpcgMHy8Py7OG2/sC8P7KLjurK8RvqLgMFsmDmC05mF/XkoVbTOjinz1E4V9uSl6I+AsF6YoT1FYROtwLpzeo705AFD2YKF6y5gFf3oQfPM48h3w8+jD3+4ZIDrOnGYtz7vgyHTuBvOo7/+nva4gFW0zTdDLFyPGdN+BBQXhkyDfDN8jfa4gFW0zbWOH365bIDrMXqYE7/2wZBpoOhKXOuwEZ0VDGTLuhD98+kO6bEFA9lyXxWvRyuwcN0GdccFDGTLe1+Z87Rfoj0uEC0aw+QBC9dd4V10XMsraz2wPw0Mk4WVq33WcID/C/tdwS766uqwiP3C/jQwTBZGFfa7gl204rnDC5hvUNg7DAySlWH1yTHa6xIvol2AQUKnFs2ESNHjk3MkSOiIFI0hJFCLZqIWzYQ40c0nLpAQEhAnGgNIoRbNRC2aCVGid6b8CCh0RInG4SVRi2YiUXSIN68ae8juR0ChkSg6xNux4eDSSLwdW4g3GMTBpZF4g0EFBvUNDi4N3a0SHeRNYCfaS2RwaWii+1s/xQ+oRQzsCxxaIoOjGe8fHdKNunFoaWzSdh/SRQd363kcXBrax4a5eVm8EMJmCmn33pDA5t2f0aMZRStUM4bnBAeXhu4SPfdKb/C54Q0OLomRklWFsoUTDi8F3d11N759A/o1quF5UzIcXgq6sy7n0GtiwZN6L4RCygIDSAB9oc/UwiOba+NIDBEy+tmF1ZGMhZ/ZijK3Qh3f8wcJEyJOt0LVC19UR12harbPOdncFzfWDQGVTb8KlwT6KlyNertqHffbVSdVo96A3ar+A5kzbYSE7G+UAAAAAElFTkSuQmCC"/>
  </div>
</a>


<a href="cplusplus-stl.htm">
<div class="book-cover" style="background-color: #f9f6f1;border: 1px solid #ccc;"> 
    <div class="book-cover-title" style="font-size: 20px;color: #333;top: 20px;">C++ STL</div>
    <div class="book-cover-author">readbytes</div>
    <div class="book-cover-bottom-stripe" style="background-color: #333;"></div>
    <img class="book-cover-icon" style="width: 90px;height: 90px;top: 70px;" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFoAAABaCAYAAAA4qEECAAADK0lEQVR4Xu2cvWsTcRjHo+DkIKiTjiJugqTJ0cG/QcRZ/wJXQTd3ByeHDiLJnS84dHMVBHUSRQUH90pNfmfb6CKi8fqSaj93ae4lzzV3+X7gS9vkeZ7f7/lwEDq0jYYQQgghxFzQ9t0wbTzf3WO/SAllpg3niAlQYJa0uu4W54kxeA96ZykwU4JwnTPFGGLyMqd3nTNFAnFx2cOZIiee//UK5TLsEQWg3D1ZHpxgvShATLCeajsoWKKNaAfuDyVvZuGhu8paURBK1lNtBAVLtBEULNFGULBEG0HBlRfNRUrMqwW/f473GZFQvxXWVQbPD5e4zEGlcXt4eHQvvrdbU2W4zEGn5Yd3+NoovHul4DKzHN69UnCZWQ7vXim8IHzJhWY1vLtIQSRujSInhTNEBppL345R6LiwV+SAUpPCHpETimVYLwpAuRJtBOVKtBHNR4OTFCzRRlCwRBtBwRJtBAVLtBEULNFGeN3wPiVvp/+OtVmJ5qzvmdl1z1kzV8Ql53+q0/6az765gBLyConqN9i/X9hfeyiAYX0S7cCtsi9NOKf2UADDesL6LOGsWsPlx+V8d/Vo3t5x4bzyGA4P8TK1TuBeU0FpxC5T83D/0uBF6h7uXxq8SN3D/Utj80OHl6ltgvAX9y+V2IUm53eUQZQvUT4nvJ8x/e/R14+RiBeeHz4bZfPn6PW3bT908Z7s4d6Vgwsxix13mj15iGb94Ows4bxKwWUY1heF89OGcyoHFypjOZ4zKV7gVjijUjSfrJ/hUqOwdtrwvH2yzN7KkbDUTsKfrLWgufTmSPzsf2F9ZeFitVtwVqBgiTaCgiXaCAqWaCMoWKKNoGCJNoKCJdoICpZoIyhYoo2gYIk2goIl2ggKlmgjKFiijaBgiTaCgiXagLbfu0jBW+m6NdaKAsQEj9Jxl1krChATvBPWiQJ4fviJgiV6yiw+3ThOuRI9ZbzA3aRYSZ4iFx73T1FqUtg3l1DKbrr9960gvBt9f207/Rst332I1U0Iz5tbKGaa4VlzTSQk8X84Fw3PEY3p/70KTxA7UFTeeB13ibPFf1BY1nCeEEIIIYQowl8t5mhjJHw+fQAAAABJRU5ErkJggg=="/>
  </div>
</a>



<a href='cplusplus.htm'><div class='book-cover' style='background-color: #f9f6f1;color: #111111;border: 1px solid #ccc;display: flex;justify-content: center;align-items: center;text-align: center;'>More C++ Books</div></a>
</div>
</div><script>
function copyCode(button) {const code = button.nextElementSibling.innerText;navigator.clipboard.writeText(code).then(() => {button.textContent = 'Copied!';setTimeout(() => { button.textContent = 'Copy'; }, 1500);});}
</script></div>
<style>
.site-footer {margin-top: 60px;padding: 20px 0;border-top: 1px solid #eee;text-align: center;font-size: 14px;}
.site-footer a {text-decoration: none;}
.light-mode .site-footer {color: #777;border-color: #eee;}
.dark-mode .site-footer {color: #888;border-color: #333;}
.light-mode .site-footer a {color: #555;}
.dark-mode .site-footer a {color: #aaa;}
.site-footer a:hover {text-decoration: underline;}    
</style>
<footer class="site-footer">
<nav><a href="https://readbytes.github.io">Home</a> |Email:<script type="text/javascript">
var part1 = 'yinpeng';var part6 = '263';var part2 = Math.pow(2,6);var part3 = String.fromCharCode(part2);var part4 = 'hotmail dot com';var part5 = part1 + String.fromCharCode(part2) + part4;document.write(part1 + part6 + part3 + part4);
</script>
| <a id="mode-toggle" href="#">Toggle Dark Mode</a>
</nav><p>¬© 2025 ‚Äî All rights reserved.</p></footer>
<script>
const toggleButton = document.getElementById('mode-toggle');
const body = document.body;
const savedMode = localStorage.getItem('mode') || 'light';
body.classList.add(savedMode + '-mode');
toggleButton.addEventListener('click', () => {
      const isDark = body.classList.contains('dark-mode');
      body.classList.toggle('dark-mode', !isDark);
      body.classList.toggle('light-mode', isDark);
      localStorage.setItem('mode', isDark ? 'light' : 'dark');
});
function copyCode(button) {const code = button.nextElementSibling.innerText;navigator.clipboard.writeText(code).then(() => {button.textContent = 'Copied!';setTimeout(() => { button.textContent = 'Copy'; }, 1500);});}
</script>
</body>
</html>