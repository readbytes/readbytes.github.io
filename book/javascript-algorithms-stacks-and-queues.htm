<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>JavaScript Algorithms Stacks and Queues</title>
<link rel='shortcut icon' href='https://java2s.com/style/favicon.ico'>
<link href="https://fonts.googleapis.com/css2?family=Merriweather&display=swap" rel="stylesheet" />
<link href="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet" />


  <script>
  const mode = localStorage.getItem('mode') || 'light';
  document.documentElement.classList.add(`${mode}-mode`);
  </script>   
<style> 
html {
  scroll-behavior: smooth;
}

body {
  font-family: 'Merriweather', serif;
  margin: 0;
  padding: 2rem 1rem;
  font-size: 15px;
  line-height: 1.5;
  transition: background-color 0.3s, color 0.3s;
}

.container {
  max-width: 700px;
  margin: 0 auto;
  padding: 1rem 2rem;
  box-shadow: 0 0 15px rgba(0,0,0,0.1);
}

h1, h2, h3 {
  font-weight: 600;
  margin-top: 2.5rem;
  margin-bottom: 1rem;
  line-height: 1.2;
}

h1 { font-size: 1.8rem; }
h2 { font-size: 1.4rem; }
h3 { font-size: 1.2rem; }

table {
  width: 100%;
  border-collapse: collapse;
  font-family: sans-serif;
  font-size: 1em;
  margin: 1em 0;
}

th, td {
  padding: 0.6em 1em;
  text-align: left;
  border: 1px solid;
}

tr:nth-child(even) {
  background-color: inherit;
}

tr:hover {
  background-color: inherit;
}

a {
  text-decoration: none;
  transition: color 0.2s;
}

a:hover {
  text-decoration: underline;
}

code {
  color: #d35400;
}

.book-title-chapter {
  font-family: 'Merriweather', serif;
  font-size: 2rem;
  font-weight: bold;
  text-align: center;
  margin-bottom: 2rem;
  border-bottom: 2px solid;
  padding-bottom: 0.5rem;
}

.book-subtitle-chapter {
  text-align: center;
  font-size: 1rem;
  margin-top: -1rem;
  margin-bottom: 2rem;
}

.related-books {
  margin-top: 40px;
}

.related-book-list {
  display: flex;
  flex-wrap: wrap;
  gap: 20px;
}

    .book-cover {
      width: 130px;
      height: 180px;
      font-family: Arial, sans-serif;
      position: relative;
      overflow: hidden;      
      line-height: normal;
      box-shadow: 2px 2px 4px rgba(0,0,0,0.1);
    }
    .book-cover-bottom-stripe {
      position: absolute;
      bottom: 0;
      left: 0;
      height: 5px;
      width: 100%;
    }
    .book-cover-title {
      position: absolute;
      width: 100%;
      text-align: center;
      font-weight: bold;
    }
     
    .book-cover-icon {
      position: absolute;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      align-items: center;
      justify-content: center; 
    }

    .book-cover-author {
      position: absolute;
      bottom: 10px;
      width: 100%;
      text-align: center;
      font-size: 8px;
      color: #333;
    }

.page-footer {
  margin-top: 4rem;
  padding: 1rem 0;
  text-align: center;
  font-size: 0.85rem;
  border-top: 1px solid;
}

.chapter-navi-section {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding-bottom: 10px;
}

.nav-link {
  color: inherit;
  text-decoration: none;
  opacity: 0.5;
  transition: opacity 0.3s ease, text-decoration 0.3s ease;
}

.nav-link:hover {
  opacity: 0.9;
  text-decoration: underline;
}

.prev { text-align: left; }
.toc-link { text-align: center; }
.next { text-align: right; }

.download-section {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 2rem;
  padding: 2rem 1rem;
  max-width: 600px;
  margin: 3rem auto;
  border-radius: 12px;
  box-shadow: 0 4px 10px rgba(0,0,0,0.05);
}

.download-info h2 {
  margin: 0 0 0.5rem;
  font-size: 1.2rem;
}

.format-label {
  margin: 0 0 0.5rem;
  font-size: 0.95rem;
}

.download-buttons {
  display: flex;
  gap: 1rem;
}

.download-button {
  background-color: #4A90E2;
  color: white;
  padding: 0.5em 1.2em;
  border-radius: 25px;
  font-size: 0.95rem;
  text-decoration: none;
  transition: background-color 0.3s ease;
}

.download-button:hover {
  background-color: #357ABD;
}

.code-block {
  position: relative;
  margin-bottom: 1em;
}

.copy-button {
  background: transparent;
  color: white;
  position: absolute;
  top: 8px;
  right: 8px;
  border: none;
  padding: 4px 8px;
  font-size: 12px;
  border-radius: 4px;
  cursor: pointer;
  z-index: 1;
}

.copy-button:hover {
  background-color: #0056b3;
}

.snippet-container {
  overflow: hidden;
}

.snippet-header {
  padding: 0.75rem 1rem;
  cursor: pointer;
  font-size: 1rem;
    background-color: #eeeeee;
    color:  #111111; 
    border-radius: 8px;
    cursor: pointer;
    box-shadow: 0 4px 6px rgba(0,0,0,0.1);  
}

.snippet-body {
  display: none;
  font-family: monospace;
}

.snippet-container.open .snippet-body {
  display: block;
}

.CodeMirror {
  border: 2px solid #ccc;
  border-radius: 4px;
  resize: vertical;
}

/* === Light Mode === */
html.light-mode {
  background-color: #f8f7f5;
  color: #333;
}

html.light-mode .container {
  background: white;
}

html.light-mode .book-title-chapter {
  color: #2c3e50;
  border-color: #ccc;
}
html.light-mode .book-subtitle-chapter{
  color: #888;
}

html.light-mode .page-footer,
html.light-mode .series-name,
html.light-mode .book-subtitle,
html.light-mode .format-label {
  color: #888;
}

html.light-mode .related-books h2 {
  color: #333;
  border-bottom: 2px solid #eee;
}

html.light-mode .book-title {
  color: #fff;
}

html.light-mode .book-cover {
  border: 1px solid #ccc;
}

html.light-mode th {
  background-color: #f2f2f2;
}

html.light-mode tr:nth-child(even) {
  background-color: #fafafa;
}

html.light-mode tr:hover {
  background-color: #e6f7ff;
}

html.light-mode a,
html.light-mode .page-footer a {
  color: #000;
}

/* === Dark Mode === */
html.dark-mode {
  background-color: #181818;
  color: #e0e0e0;
}

html.dark-mode .container {
  background: #222;
}

html.dark-mode .book-title-chapter {
  color: #ddd;
  border-color: #444;
}

html.dark-mode .snippet-header {
    background-color: #333;
    color:  #ddd; 
}


html.dark-mode .book-subtitle-chapter,
html.dark-mode .page-footer,
html.dark-mode .series-name,
html.dark-mode .book-subtitle,
html.dark-mode .book-footer,
html.dark-mode .format-label {
  color: #aaa;
}

html.dark-mode .related-books h2 {
  color: #ddd;
  border-bottom: 2px solid #333;
}

html.dark-mode .book-title {
  color: #fff;
}

html.dark-mode .book-cover {
  border: 1px solid #555;
}

html.dark-mode th {
  background-color: #333;
  color: #fff;
}

html.dark-mode td {
  border-color: #444;
}

html.dark-mode tr:nth-child(even) {
  background-color: #2a2a2a;
}

html.dark-mode tr:hover {
  background-color: #2c3e50;
}

html.dark-mode a,
html.dark-mode .page-footer a {
  color: #eee;
}

    .dialog-backdrop {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: rgba(0,0,0,0.5);
      display: none;
      justify-content: center;
      align-items: center;
      z-index: 10;
    }

    .dialog {
      background: white;
      padding: 20px;
      width: 90vw;
      height: 80vh;
      border-radius: 8px;
      box-shadow: 0 0 20px rgba(0,0,0,0.3);
      display: flex;
      flex-direction: column;
    }
    .dialog-content {
      display: flex;
      flex: 1;
      gap: 20px;
      margin-top: 10px;
    }
    .dialog h2 {
      margin-top: 0;
    }

    .textarea_dialog {
      width: 50%;
      height: 100%;
      resize: none;
      font-family: monospace;
      font-size: 14px;
      padding: 10px;
      box-sizing: border-box;
      border: 1px solid #ccc;
    }

    .iframe_dialog {
      width: 50%;
      height: 100%;
      border: 1px solid #ccc;
    }
    .controls_dialog {
      display: flex;
      justify-content: space-between;
      margin-top: 10px;
    }    
    button { padding: 0.5em 1em; background: green; color: white; border: none; cursor: pointer; }
    button:hover { background: #1e7e34; }
    .result_iframe { width:99%; height:200px; margin-top: 1em;  resize: both;border:1px solid #ccc;}        
</style>
</head>
<body> 
  <div class="container">
    <div class = "chapter-navi-section">
<a href="javascript-algorithms-arrays-and-linked-lists.htm" class="nav-button prev">←</a>
<a href='javascript-algorithms.htm#stacks-and-queues' class="nav-button toc-link">Index</a>
<a href="javascript-algorithms-hash-tables.htm" class="nav-button next">→</a>
</div>

    <h1 class="book-title-chapter" id = 'top'>Stacks and Queues</h1>
    <h3 class="book-subtitle-chapter">JavaScript Algorithms</h3>   
    <!-- <h1 class ="chapter-title"></h1> -->
    <h2 id='implementing-from-scratch'>8.1 Implementing from Scratch</h2><p>Stacks and queues are two of the most fundamental data structures in computer science. Though simple in concept, they are incredibly powerful tools for managing data in a controlled, sequential manner. Whether you're parsing expressions, handling undo/redo logic, or implementing search algorithms, stacks and queues provide predictable, efficient behavior.</p><h3 id="stack-lifo-last-in-first-out">Stack: LIFO (Last In, First Out)</h3><p>A <strong>stack</strong> allows access only to the <em>top</em> element—like a pile of plates. You can <strong>push</strong> (add) items onto the top and <strong>pop</strong> (remove) the topmost item.</p><h4 id="stack-operations">Stack Operations</h4><ul>
 <li><code>push(value)</code>: Add an element to the top.</li>
 <li><code>pop()</code>: Remove and return the top element.</li>
 <li><code>peek()</code>: Return the top element without removing it.</li>
 <li><code>isEmpty()</code>: Check if the stack is empty.</li>
</ul><div class="snippet-container" id="<!DOCTYPE html>
<html lang=&quot;en&quot;>
<head>
  <meta charset=&quot;UTF-8&quot; />
  <title>Stack Visualization (Canvas)</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      text-align: center;
      padding: 20px;
    }
    canvas {
      border: 1px solid #aaa;
      background: #f9f9f9;
      margin-top: 20px;
    }
    input, button {
      font-size: 16px;
      padding: 6px 10px;
      margin: 5px;
    }
  </style>
</head>
<body>

<h2>Stack Visualization (Canvas)</h2>

<div>
  <input type=&quot;number&quot; id=&quot;valueInput&quot; placeholder=&quot;Value to push&quot; />
  <button onclick=&quot;push()&quot;>Push</button>
  <button onclick=&quot;pop()&quot;>Pop</button>
  <button onclick=&quot;highlightTop()&quot;>Highlight Top</button>
</div>

<canvas id=&quot;canvas&quot; width=&quot;300&quot; height=&quot;400&quot;></canvas>

<script>
const canvas = document.getElementById(&quot;canvas&quot;);
const ctx = canvas.getContext(&quot;2d&quot;);

const STACK_X = 100;
const STACK_BOTTOM = 350;
const BOX_WIDTH = 100;
const BOX_HEIGHT = 40;
const BOX_GAP = 10;

let stack = [];
let highlightTopIndex = -1;

function drawStack() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  for (let i = 0; i < stack.length; i++) {
    const y = STACK_BOTTOM - i * (BOX_HEIGHT + BOX_GAP);

    // Draw box
    ctx.fillStyle = (i === highlightTopIndex) ? &quot;#f5a623&quot; : &quot;#4a90e2&quot;;
    ctx.strokeStyle = &quot;#333&quot;;
    ctx.lineWidth = 2;
    ctx.fillRect(STACK_X, y, BOX_WIDTH, BOX_HEIGHT);
    ctx.strokeRect(STACK_X, y, BOX_WIDTH, BOX_HEIGHT);

    // Draw value
    ctx.fillStyle = &quot;white&quot;;
    ctx.font = &quot;18px Arial&quot;;
    ctx.textAlign = &quot;center&quot;;
    ctx.textBaseline = &quot;middle&quot;;
    ctx.fillText(stack[i], STACK_X + BOX_WIDTH / 2, y + BOX_HEIGHT / 2);
  }

  // Draw &quot;Top →&quot; label
  if (stack.length > 0) {
    const topY = STACK_BOTTOM - (stack.length - 1) * (BOX_HEIGHT + BOX_GAP);
    ctx.fillStyle = &quot;black&quot;;
    ctx.font = &quot;16px Arial&quot;;
    ctx.fillText(&quot;Top →&quot;, STACK_X - 30, topY + BOX_HEIGHT / 2);
  }
}

function push() {
  const val = parseInt(document.getElementById(&quot;valueInput&quot;).value);
  if (isNaN(val)) {
    alert(&quot;Enter a valid number to push.&quot;);
    return;
  }
  stack.push(val);
  highlightTopIndex = stack.length - 1;
  drawStack();
}

function pop() {
  if (stack.length === 0) {
    alert(&quot;Stack is empty.&quot;);
    return;
  }
  stack.pop();
  highlightTopIndex = -1;
  drawStack();
}

function highlightTop() {
  if (stack.length === 0) {
    alert(&quot;Stack is empty.&quot;);
    return;
  }
  highlightTopIndex = stack.length - 1;
  drawStack();
}

// Initial draw
drawStack();
</script>

</body>
</html>ID"><textarea id="mpiB4" style="display: none;">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
  &lt;meta charset="UTF-8" /&gt;
  &lt;title&gt;Stack Visualization (Canvas)&lt;/title&gt;
  &lt;style&gt;
    body {
      font-family: Arial, sans-serif;
      text-align: center;
      padding: 20px;
    }
    canvas {
      border: 1px solid #aaa;
      background: #f9f9f9;
      margin-top: 20px;
    }
    input, button {
      font-size: 16px;
      padding: 6px 10px;
      margin: 5px;
    }
  &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;h2&gt;Stack Visualization (Canvas)&lt;/h2&gt;

&lt;div&gt;
  &lt;input type="number" id="valueInput" placeholder="Value to push" /&gt;
  &lt;button onclick="push()"&gt;Push&lt;/button&gt;
  &lt;button onclick="pop()"&gt;Pop&lt;/button&gt;
  &lt;button onclick="highlightTop()"&gt;Highlight Top&lt;/button&gt;
&lt;/div&gt;

&lt;canvas id="canvas" width="300" height="400"&gt;&lt;/canvas&gt;

&lt;script&gt;
const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");

const STACK_X = 100;
const STACK_BOTTOM = 350;
const BOX_WIDTH = 100;
const BOX_HEIGHT = 40;
const BOX_GAP = 10;

let stack = [];
let highlightTopIndex = -1;

function drawStack() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  for (let i = 0; i &lt; stack.length; i++) {
    const y = STACK_BOTTOM - i * (BOX_HEIGHT + BOX_GAP);

    // Draw box
    ctx.fillStyle = (i === highlightTopIndex) ? "#f5a623" : "#4a90e2";
    ctx.strokeStyle = "#333";
    ctx.lineWidth = 2;
    ctx.fillRect(STACK_X, y, BOX_WIDTH, BOX_HEIGHT);
    ctx.strokeRect(STACK_X, y, BOX_WIDTH, BOX_HEIGHT);

    // Draw value
    ctx.fillStyle = "white";
    ctx.font = "18px Arial";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillText(stack[i], STACK_X + BOX_WIDTH / 2, y + BOX_HEIGHT / 2);
  }

  // Draw "Top →" label
  if (stack.length &gt; 0) {
    const topY = STACK_BOTTOM - (stack.length - 1) * (BOX_HEIGHT + BOX_GAP);
    ctx.fillStyle = "black";
    ctx.font = "16px Arial";
    ctx.fillText("Top →", STACK_X - 30, topY + BOX_HEIGHT / 2);
  }
}

function push() {
  const val = parseInt(document.getElementById("valueInput").value);
  if (isNaN(val)) {
    alert("Enter a valid number to push.");
    return;
  }
  stack.push(val);
  highlightTopIndex = stack.length - 1;
  drawStack();
}

function pop() {
  if (stack.length === 0) {
    alert("Stack is empty.");
    return;
  }
  stack.pop();
  highlightTopIndex = -1;
  drawStack();
}

function highlightTop() {
  if (stack.length === 0) {
    alert("Stack is empty.");
    return;
  }
  highlightTopIndex = stack.length - 1;
  drawStack();
}

// Initial draw
drawStack();
&lt;/script&gt;

&lt;/body&gt;
&lt;/html&gt;</textarea> <iframe id="klKap" class="result_iframe" style="border:none;"></iframe>
 <script>{
const textarea = document.getElementById("mpiB4");
const iframe = document.getElementById("klKap");
const html = textarea.value;
const iframeHTML = `${html}`;
const doc = iframe.contentDocument || iframe.contentWindow.document;
doc.open();
doc.write(iframeHTML);
doc.close();
setTimeout(() => {
iframe.style.height = '0px';
const contentHeight = Math.max(
  doc.body.scrollHeight,
  doc.documentElement.scrollHeight
);
iframe.style.height = contentHeight + 'px';
}, 50);
}
		</script>
</div><h4 id="stack-using-array">Stack Using Array</h4><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-js">class Stack {
  constructor() {
    this.items = [];
  }

  push(value) {
    this.items.push(value);
  }

  pop() {
    return this.items.pop();
  }

  peek() {
    return this.items[this.items.length - 1];
  }

  isEmpty() {
    return this.items.length === 0;
  }
}</code></pre>
</div><h4 id="example-expression-evaluation-postfix">Example: Expression Evaluation (Postfix)</h4><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-js">function evaluatePostfix(expr) {
  const stack = new Stack();
  const tokens = expr.split(' ');

  for (const token of tokens) {
    if (!isNaN(token)) {
      stack.push(Number(token));
    } else {
      const b = stack.pop();
      const a = stack.pop();
      switch (token) {
        case '+': stack.push(a + b); break;
        case '-': stack.push(a - b); break;
        case '*': stack.push(a * b); break;
        case '/': stack.push(a / b); break;
      }
    }
  }

  return stack.pop();
}

console.log(evaluatePostfix("3 4 + 2 *")); // 14</code></pre>
</div><p>Stacks simplify parsing and evaluation by tracking operands and applying operations in order.</p><h3 id="queue-fifo-first-in-first-out">Queue: FIFO (First In, First Out)</h3><p>A <strong>queue</strong> processes items in the order they arrive—like a line at a coffee shop. You <strong>enqueue</strong> elements at the back and <strong>dequeue</strong> them from the front.</p><h4 id="queue-operations">Queue Operations</h4><ul>
 <li><code>enqueue(value)</code>: Add an element to the back.</li>
 <li><code>dequeue()</code>: Remove and return the front element.</li>
 <li><code>peek()</code>: View the front element.</li>
 <li><code>isEmpty()</code>: Check if the queue is empty.</li>
</ul><div class="snippet-container" id="<!DOCTYPE html>
<html lang=&quot;en&quot;>
<head>
  <meta charset=&quot;UTF-8&quot; />
  <title>Queue Visualization (Canvas)</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      text-align: center;
      padding: 20px;
    }
    canvas {
      border: 1px solid #aaa;
      background: #f9f9f9;
      margin-top: 20px;
    }
    input, button {
      font-size: 16px;
      padding: 6px 10px;
      margin: 5px;
    }
  </style>
</head>
<body>

<h2>Queue Visualization (Canvas)</h2>

<div>
  <input type=&quot;number&quot; id=&quot;valueInput&quot; placeholder=&quot;Value to enqueue&quot; />
  <button onclick=&quot;enqueue()&quot;>Enqueue</button>
  <button onclick=&quot;dequeue()&quot;>Dequeue</button>
  <button onclick=&quot;highlightHead()&quot;>Highlight Head</button>
</div>

<canvas id=&quot;canvas&quot; width=&quot;900&quot; height=&quot;200&quot;></canvas>

<script>
const canvas = document.getElementById(&quot;canvas&quot;);
const ctx = canvas.getContext(&quot;2d&quot;);

const START_X = 50;
const START_Y = 80;
const BOX_WIDTH = 80;
const BOX_HEIGHT = 50;
const BOX_GAP = 20;

let queue = [];
let highlightHeadIndex = -1;

function drawQueue() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  for (let i = 0; i < queue.length; i++) {
    const x = START_X + i * (BOX_WIDTH + BOX_GAP);

    // Draw box
    ctx.fillStyle = (i === 0 &amp;&amp; highlightHeadIndex === 0) ? &quot;#f5a623&quot; : &quot;#4a90e2&quot;;
    ctx.strokeStyle = &quot;#333&quot;;
    ctx.lineWidth = 2;
    ctx.fillRect(x, START_Y, BOX_WIDTH, BOX_HEIGHT);
    ctx.strokeRect(x, START_Y, BOX_WIDTH, BOX_HEIGHT);

    // Draw value
    ctx.fillStyle = &quot;white&quot;;
    ctx.font = &quot;18px Arial&quot;;
    ctx.textAlign = &quot;center&quot;;
    ctx.textBaseline = &quot;middle&quot;;
    ctx.fillText(queue[i], x + BOX_WIDTH / 2, START_Y + BOX_HEIGHT / 2);
  }

  // Labels for head and tail
  if (queue.length > 0) {
    const headX = START_X;
    const tailX = START_X + (queue.length - 1) * (BOX_WIDTH + BOX_GAP);

    // Head label
    ctx.fillStyle = &quot;black&quot;;
    ctx.font = &quot;14px Arial&quot;;
    ctx.fillText(&quot;Head →&quot;, headX + BOX_WIDTH / 2, START_Y - 10);

    // Tail label
    ctx.fillText(&quot;Tail →&quot;, tailX + BOX_WIDTH / 2, START_Y + BOX_HEIGHT + 20);
  }
}

function enqueue() {
  const val = parseInt(document.getElementById(&quot;valueInput&quot;).value);
  if (isNaN(val)) {
    alert(&quot;Enter a valid number to enqueue.&quot;);
    return;
  }
  queue.push(val);
  highlightHeadIndex = -1;
  drawQueue();
}

function dequeue() {
  if (queue.length === 0) {
    alert(&quot;Queue is empty.&quot;);
    return;
  }
  queue.shift();
  highlightHeadIndex = -1;
  drawQueue();
}

function highlightHead() {
  if (queue.length === 0) {
    alert(&quot;Queue is empty.&quot;);
    return;
  }
  highlightHeadIndex = 0;
  drawQueue();
}

// Initial draw
drawQueue();
</script>

</body>
</html>ID"><textarea id="zpSFY" style="display: none;">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
  &lt;meta charset="UTF-8" /&gt;
  &lt;title&gt;Queue Visualization (Canvas)&lt;/title&gt;
  &lt;style&gt;
    body {
      font-family: Arial, sans-serif;
      text-align: center;
      padding: 20px;
    }
    canvas {
      border: 1px solid #aaa;
      background: #f9f9f9;
      margin-top: 20px;
    }
    input, button {
      font-size: 16px;
      padding: 6px 10px;
      margin: 5px;
    }
  &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;h2&gt;Queue Visualization (Canvas)&lt;/h2&gt;

&lt;div&gt;
  &lt;input type="number" id="valueInput" placeholder="Value to enqueue" /&gt;
  &lt;button onclick="enqueue()"&gt;Enqueue&lt;/button&gt;
  &lt;button onclick="dequeue()"&gt;Dequeue&lt;/button&gt;
  &lt;button onclick="highlightHead()"&gt;Highlight Head&lt;/button&gt;
&lt;/div&gt;

&lt;canvas id="canvas" width="900" height="200"&gt;&lt;/canvas&gt;

&lt;script&gt;
const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");

const START_X = 50;
const START_Y = 80;
const BOX_WIDTH = 80;
const BOX_HEIGHT = 50;
const BOX_GAP = 20;

let queue = [];
let highlightHeadIndex = -1;

function drawQueue() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  for (let i = 0; i &lt; queue.length; i++) {
    const x = START_X + i * (BOX_WIDTH + BOX_GAP);

    // Draw box
    ctx.fillStyle = (i === 0 &amp;&amp; highlightHeadIndex === 0) ? "#f5a623" : "#4a90e2";
    ctx.strokeStyle = "#333";
    ctx.lineWidth = 2;
    ctx.fillRect(x, START_Y, BOX_WIDTH, BOX_HEIGHT);
    ctx.strokeRect(x, START_Y, BOX_WIDTH, BOX_HEIGHT);

    // Draw value
    ctx.fillStyle = "white";
    ctx.font = "18px Arial";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillText(queue[i], x + BOX_WIDTH / 2, START_Y + BOX_HEIGHT / 2);
  }

  // Labels for head and tail
  if (queue.length &gt; 0) {
    const headX = START_X;
    const tailX = START_X + (queue.length - 1) * (BOX_WIDTH + BOX_GAP);

    // Head label
    ctx.fillStyle = "black";
    ctx.font = "14px Arial";
    ctx.fillText("Head →", headX + BOX_WIDTH / 2, START_Y - 10);

    // Tail label
    ctx.fillText("Tail →", tailX + BOX_WIDTH / 2, START_Y + BOX_HEIGHT + 20);
  }
}

function enqueue() {
  const val = parseInt(document.getElementById("valueInput").value);
  if (isNaN(val)) {
    alert("Enter a valid number to enqueue.");
    return;
  }
  queue.push(val);
  highlightHeadIndex = -1;
  drawQueue();
}

function dequeue() {
  if (queue.length === 0) {
    alert("Queue is empty.");
    return;
  }
  queue.shift();
  highlightHeadIndex = -1;
  drawQueue();
}

function highlightHead() {
  if (queue.length === 0) {
    alert("Queue is empty.");
    return;
  }
  highlightHeadIndex = 0;
  drawQueue();
}

// Initial draw
drawQueue();
&lt;/script&gt;

&lt;/body&gt;
&lt;/html&gt;</textarea> <iframe id="zMQ6P" class="result_iframe" style="border:none;"></iframe>
 <script>{
const textarea = document.getElementById("zpSFY");
const iframe = document.getElementById("zMQ6P");
const html = textarea.value;
const iframeHTML = `${html}`;
const doc = iframe.contentDocument || iframe.contentWindow.document;
doc.open();
doc.write(iframeHTML);
doc.close();
setTimeout(() => {
iframe.style.height = '0px';
const contentHeight = Math.max(
  doc.body.scrollHeight,
  doc.documentElement.scrollHeight
);
iframe.style.height = contentHeight + 'px';
}, 50);
}
		</script>
</div><h4 id="queue-using-array-simple">Queue Using Array (Simple)</h4><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-js">class Queue {
  constructor() {
    this.items = [];
  }

  enqueue(value) {
    this.items.push(value);
  }

  dequeue() {
    return this.items.shift(); // O(n) in JS
  }

  peek() {
    return this.items[0];
  }

  isEmpty() {
    return this.items.length === 0;
  }
}</code></pre>
</div><blockquote>
 <p>Note: <code>shift()</code> is O(n) in JavaScript arrays. For high-performance queues, a <strong>linked list</strong> or <strong>two-stack queue</strong> is preferred.</p>
</blockquote><h3 id="queue-using-linked-list">Queue Using Linked List</h3><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-js">class QueueNode {
  constructor(value) {
    this.value = value;
    this.next = null;
  }
}

class LinkedQueue {
  constructor() {
    this.head = this.tail = null;
  }

  enqueue(value) {
    const node = new QueueNode(value);
    if (!this.tail) {
      this.head = this.tail = node;
    } else {
      this.tail.next = node;
      this.tail = node;
    }
  }

  dequeue() {
    if (!this.head) return null;
    const value = this.head.value;
    this.head = this.head.next;
    if (!this.head) this.tail = null;
    return value;
  }

  peek() {
    return this.head?.value ?? null;
  }

  isEmpty() {
    return !this.head;
  }
}</code></pre>
</div><h3 id="example-bfs-breadth-first-search">Example: BFS (Breadth-First Search)</h3><p>A queue is essential for breadth-first traversal in graphs or trees.</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-js">function bfs(graph, start) {
  const visited = new Set();
  const queue = new LinkedQueue();

  queue.enqueue(start);
  visited.add(start);

  while (!queue.isEmpty()) {
    const node = queue.dequeue();
    console.log(node);

    for (const neighbor of graph[node]) {
      if (!visited.has(neighbor)) {
        visited.add(neighbor);
        queue.enqueue(neighbor);
      }
    }
  }
}

const graph = {
  A: ['B', 'C'],
  B: ['D'],
  C: ['E'],
  D: [],
  E: ['F'],
  F: []
};

bfs(graph, 'A');
// Output: A B C D E F</code></pre>
</div><h3 id="summary">Summary</h3><table>
 <thead>
  <tr>
   <th>Feature</th>
   <th>Stack</th>
   <th>Queue</th>
  </tr>
 </thead>
 <tbody>
  <tr>
   <td>Order</td>
   <td>LIFO</td>
   <td>FIFO</td>
  </tr>
  <tr>
   <td>Use Cases</td>
   <td>Undo, parsing</td>
   <td>BFS, task queues</td>
  </tr>
  <tr>
   <td>JS Backing</td>
   <td>Array, LinkedList</td>
   <td>Array, LinkedList</td>
  </tr>
  <tr>
   <td>Performance</td>
   <td>Push/Pop: O(1)</td>
   <td>Enqueue: O(1), Dequeue: O(1) (Linked)</td>
  </tr>
 </tbody>
</table><p>Stacks and queues simplify a wide range of problems by enforcing strict order on how elements are processed. While JavaScript doesn’t offer built-in stack or queue types, implementing them from scratch gives you deeper insight and more control—essential when solving algorithmic challenges or building data flow systems.</p><div class = "chapter-navi-section">
<a href="#top" class="nav-button prev">↑</a>
<a href='javascript-algorithms.htm#stacks-and-queues' class="nav-button toc-link">Index</a>
<a href="#bottom" class="nav-button next">↓</a>
</div>
<h2 id='use-cases-in-frontend-backend'>8.2 Use Cases in Frontend/Backend</h2><p>Stacks and queues are not just theoretical data structures—they are deeply embedded in how modern JavaScript applications function. From browser behavior to server-side task processing, stacks and queues help manage <strong>control flow</strong>, <strong>user interactions</strong>, and <strong>asynchronous execution</strong>. In this section, we'll explore key use cases in frontend and backend development, with examples that show how these structures simplify real-world problems.</p><h3 id="undo-redo-functionality-frontend-stack">Undo/Redo Functionality (Frontend Stack)</h3><p>A common UI feature, especially in text editors or drawing apps, is the ability to <em>undo</em> and <em>redo</em> user actions. This is a classic stack use case.</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-js">class HistoryManager {
  constructor() {
    this.undoStack = [];
    this.redoStack = [];
  }

  do(action) {
    this.undoStack.push(action);
    this.redoStack = []; // Clear redo on new action
  }

  undo() {
    if (this.undoStack.length === 0) return;
    const action = this.undoStack.pop();
    this.redoStack.push(action);
    // logic to reverse `action`
  }

  redo() {
    if (this.redoStack.length === 0) return;
    const action = this.redoStack.pop();
    this.undoStack.push(action);
    // logic to reapply `action`
  }
}</code></pre>
</div><p>Each operation is pushed onto a stack. Undo pops from the undo stack and pushes to the redo stack, and vice versa—LIFO behavior in action.</p><h3 id="call-stack-javascript-runtime">Call Stack (JavaScript Runtime)</h3><p>Behind the scenes, the <strong>JavaScript engine</strong> uses a call stack to manage function execution. Every time a function is called, it’s <em>pushed</em> onto the stack. When the function completes, it’s <em>popped</em> off.</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-js">function a() {
  b();
}
function b() {
  c();
}
function c() {
  console.log("End");
}

a();</code></pre>
</div><p>This results in:</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-bash">Call Stack:
- c()
- b()
- a()</code></pre>
</div><p>Understanding this model helps developers trace <strong>stack overflows</strong>, <strong>recursion limits</strong>, and <strong>debugging call traces</strong> in the browser.</p><h3 id="event-queue-and-task-scheduling-frontend-queue">Event Queue and Task Scheduling (Frontend Queue)</h3><p>The <strong>event loop</strong> in JavaScript uses a queue to handle asynchronous tasks. When you use <code>setTimeout</code>, <code>fetch</code>, or DOM events, the callbacks are queued for execution.</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-js">console.log("Start");

setTimeout(() =&gt; {
  console.log("Timeout");
}, 0);

console.log("End");</code></pre>
</div><p>Output:</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-bash">Start
End
Timeout</code></pre>
</div><p>The callback to <code>setTimeout</code> is added to the <strong>task queue</strong> and executed after the current call stack is clear. This asynchronous queueing system allows JavaScript to be non-blocking.</p><h3 id="task-processing-and-job-queues-backend-queue">Task Processing and Job Queues (Backend Queue)</h3><p>On the server side (e.g., with Node.js), queues are vital for processing background jobs, rate-limiting requests, or managing task retries.</p><h4 id="example-basic-task-queue-for-batch-processing">Example: Basic Task Queue for Batch Processing</h4><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-js">class TaskQueue {
  constructor() {
    this.queue = [];
    this.processing = false;
  }

  enqueue(task) {
    this.queue.push(task);
    this.process();
  }

  async process() {
    if (this.processing) return;
    this.processing = true;

    while (this.queue.length &gt; 0) {
      const task = this.queue.shift(); // FIFO
      await task();
    }

    this.processing = false;
  }
}

// Usage
const queue = new TaskQueue();

queue.enqueue(() =&gt; fetchDataFromAPI(1));
queue.enqueue(() =&gt; fetchDataFromAPI(2));</code></pre>
</div><p>This simple queue ensures tasks are processed in order and <strong>not concurrently</strong>, which is useful for rate-limited APIs or sequential operations.</p><h3 id="why-use-these-structures">Why Use These Structures?</h3><ul>
 <li><strong>Predictability</strong>: Stacks and queues enforce clear rules (LIFO, FIFO), making program flow easier to reason about.</li>
 <li><strong>Performance</strong>: These structures offer constant-time insertions/removals, which is essential for real-time apps.</li>
 <li><strong>Modularity</strong>: They help encapsulate logic like command history, job scheduling, or deferred execution cleanly.</li>
</ul><h3 id="summary">Summary</h3><table>
 <thead>
  <tr>
   <th>Structure</th>
   <th>Use Case</th>
   <th>Environment</th>
  </tr>
 </thead>
 <tbody>
  <tr>
   <td>Stack</td>
   <td>Undo/Redo, Call Stack</td>
   <td>Frontend</td>
  </tr>
  <tr>
   <td>Queue</td>
   <td>Event Loop, Async Jobs, Task Queue</td>
   <td>Frontend &amp; Backend</td>
  </tr>
 </tbody>
</table><p>Understanding stacks and queues helps you write better-performing, more predictable code—whether you're building a real-time UI or managing background jobs in a serverless function.</p><div class = "chapter-navi-section">
<a href="javascript-algorithms-arrays-and-linked-lists.htm" class="nav-button prev">←</a>
<a href='javascript-algorithms.htm#stacks-and-queues' class="nav-button toc-link">Index</a>
<a href="javascript-algorithms-hash-tables.htm" class="nav-button next">→</a>
</div>
<section class="download-section">
  <div class="book-cover" style="background-color: #f9f6f1;border: 1px solid #ccc;"> 
    <div class="book-cover-title" style="font-size: 18px;color: #333;top: 20px;">JavaScript Algorithms</div>
    <div class="book-cover-author">readbytes</div>
    <div class="book-cover-bottom-stripe" style="background-color: #333;"></div>
    <img class="book-cover-icon" style="width: 80px;height: 80px;top: 70px;" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFoAAABaCAYAAAA4qEECAAAErElEQVR4Xu2dPWgUQRiGo6BB8I+AlV3w9gzptLBWsLQ89O7ARrDXSivTCTaCnWhn7pQTxOoInpjCeEQQLC2CjVqoVSwMFpp1Jtzo7Luzs/Nd7uZ29r4HPpDsu7vPvIl7+SGTmRmGYRiGYZjCEzVacdnn9NX7+3DdXkGhMg+u3Su6SNztzsZvevH/efED8zrJbM+6EGJ2K5Hv9w9gRpHnXMyik2VsYVaHWJx7tt/bTOQ3urOYUch3QJ5z0YtOCeuQiqNlvybyto/ktbVDcG2jc5GLNgoriMW5Z/svPyfy693DmFHE71ePwrUznQta9ISeyViyKBIziri/Mpe8tt25kEXjMR1ScbQsPC5W5jCjMJT8DTM6MuO6vrHjIkIszj2LL3y2ktOPiy+Y0VE5l/V5IU+EVBwtm/wUzva4SL/wOZUsJ2993rCJEIujZJMl2174Up/C5T8u9LGtzyu6SNkH1+6VhUargkJlHVy7f5aW9qJUqeZy5zguufToBeAxZoRw0Z7goj3BRXuCi/YEF+0BvWQue0xgwfrMiy+aMM8QEUW+w2IHb8fC/+C5jCOGMhOPiqi+vG47zjiABVbr7XOYUWC2Um+fxwwDiKJeYXGYMYHniNnGDDPAUJZTyYph30nTg+G7f5VLj89gzBW8lu2xMzWIIt5iMZgZBrzmqK4bJFhENOLnatRsfcR7YKb0YAELF5+cwsyowHudrLcvYKZ0iIV+wIVjZhzgPaMR/+8pFIbFeilZUWm2Vyd5/5GxWOvsx4VkTbXROovn+wJdMqfevoHnFoKUaMbgeZMAnbIGzysEKGmZiX4DKKo/um5wMg6eWwhsgtVm62cRFoEOJg/xtltZxwqBTV4inuEHcZHztc4RzI0LvLeY15iRBF+0wrDgsX6qZXpUYEanNEVLROY3ZfHDgvdwuU+pipYs1h7OpUqI4z2YGxa8dqXefooZE6UrWoGFiMn8nRIXoubyTbymeLPzO7C0RUuiRvuXoRwyeI1hrlPqoiUnap1jWNLilU7mr0sgeK746rOFGRdKX7QCC4tyHiXi+DU8BzMUpqZoiSzXpTzMZOUoTFXROxh+xKV/gYPHqvVlp88q8pi+ogdgoabBc3bD1BYtEdfcxnLHeK/pLVoiHxvJktsPMDMKpr5oX3DRnuCiPcFFe4KL9gQX7Qku2hNctCe4aE94K1puD6mXNsmpOv74KUTnxEdmEQb9TOA5kx70M6KfcO/u8/j2nWffxb+XskZm9MHjw2YjgrTKygnFeUaF5cSEjZ4c9kJyz/Z7mxTpEJ0T0nhMhyRBy+5sTuXioAjR2UmaKEHJ/tsBLM9BJ0TnXGmiBCWb2GbN5oCE6GyVJkq4Z3FXxo3ubJaDiRCdM6VJErSscTtik0MWITobpYkS7lncKVfblREdbITonJImSVCyKAz7i1KkQ3ROSJMkaNnc7Ygp0iE6Z0pjTockjC8iBmEJRTpEZ6M0ZnRIwrhTrmU7Yop0iM4paTyusyvhnO2IKdIhOqdeWLLYlbDtL0oM/jaKi4MiRGcnaZIwPt8c/zZKnoNOiM4J6SIM+pnAcyY96GekYJtvf0I/EyE6MwzDMAzDjI+/5MPGam/zucIAAAAASUVORK5CYII="/>
  </div>
  <div class="download-info">
    <h2 id='bottom'>Download This Ebook</h2>
    <p class="format-label">Available formats:</p>
    <div class="download-buttons">
      <a href="javascript-algorithms.pdf" class="download-button">📄 PDF</a>
      <a href="javascript-algorithms.epub" class="download-button">📘 EPUB</a>
    </div>
  </div>
</section><div class='related-books'>
<h2>Java Introduction Books</h2>
<div class='related-book-list'>
<a href="javascript-algorithms.htm">
<div class="book-cover" style="background-color: #f9f6f1;border: 1px solid #ccc;"> 
    <div class="book-cover-title" style="font-size: 18px;color: #333;top: 20px;">JavaScript Algorithms</div>
    <div class="book-cover-author">readbytes</div>
    <div class="book-cover-bottom-stripe" style="background-color: #333;"></div>
    <img class="book-cover-icon" style="width: 80px;height: 80px;top: 70px;" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFoAAABaCAYAAAA4qEECAAAErElEQVR4Xu2dPWgUQRiGo6BB8I+AlV3w9gzptLBWsLQ89O7ARrDXSivTCTaCnWhn7pQTxOoInpjCeEQQLC2CjVqoVSwMFpp1Jtzo7Luzs/Nd7uZ29r4HPpDsu7vPvIl7+SGTmRmGYRiGYZjCEzVacdnn9NX7+3DdXkGhMg+u3Su6SNztzsZvevH/efED8zrJbM+6EGJ2K5Hv9w9gRpHnXMyik2VsYVaHWJx7tt/bTOQ3urOYUch3QJ5z0YtOCeuQiqNlvybyto/ktbVDcG2jc5GLNgoriMW5Z/svPyfy693DmFHE71ePwrUznQta9ISeyViyKBIziri/Mpe8tt25kEXjMR1ScbQsPC5W5jCjMJT8DTM6MuO6vrHjIkIszj2LL3y2ktOPiy+Y0VE5l/V5IU+EVBwtm/wUzva4SL/wOZUsJ2993rCJEIujZJMl2174Up/C5T8u9LGtzyu6SNkH1+6VhUargkJlHVy7f5aW9qJUqeZy5zguufToBeAxZoRw0Z7goj3BRXuCi/YEF+0BvWQue0xgwfrMiy+aMM8QEUW+w2IHb8fC/+C5jCOGMhOPiqi+vG47zjiABVbr7XOYUWC2Um+fxwwDiKJeYXGYMYHniNnGDDPAUJZTyYph30nTg+G7f5VLj89gzBW8lu2xMzWIIt5iMZgZBrzmqK4bJFhENOLnatRsfcR7YKb0YAELF5+cwsyowHudrLcvYKZ0iIV+wIVjZhzgPaMR/+8pFIbFeilZUWm2Vyd5/5GxWOvsx4VkTbXROovn+wJdMqfevoHnFoKUaMbgeZMAnbIGzysEKGmZiX4DKKo/um5wMg6eWwhsgtVm62cRFoEOJg/xtltZxwqBTV4inuEHcZHztc4RzI0LvLeY15iRBF+0wrDgsX6qZXpUYEanNEVLROY3ZfHDgvdwuU+pipYs1h7OpUqI4z2YGxa8dqXefooZE6UrWoGFiMn8nRIXoubyTbymeLPzO7C0RUuiRvuXoRwyeI1hrlPqoiUnap1jWNLilU7mr0sgeK746rOFGRdKX7QCC4tyHiXi+DU8BzMUpqZoiSzXpTzMZOUoTFXROxh+xKV/gYPHqvVlp88q8pi+ogdgoabBc3bD1BYtEdfcxnLHeK/pLVoiHxvJktsPMDMKpr5oX3DRnuCiPcFFe4KL9gQX7Qku2hNctCe4aE94K1puD6mXNsmpOv74KUTnxEdmEQb9TOA5kx70M6KfcO/u8/j2nWffxb+XskZm9MHjw2YjgrTKygnFeUaF5cSEjZ4c9kJyz/Z7mxTpEJ0T0nhMhyRBy+5sTuXioAjR2UmaKEHJ/tsBLM9BJ0TnXGmiBCWb2GbN5oCE6GyVJkq4Z3FXxo3ubJaDiRCdM6VJErSscTtik0MWITobpYkS7lncKVfblREdbITonJImSVCyKAz7i1KkQ3ROSJMkaNnc7Ygp0iE6Z0pjTockjC8iBmEJRTpEZ6M0ZnRIwrhTrmU7Yop0iM4paTyusyvhnO2IKdIhOqdeWLLYlbDtL0oM/jaKi4MiRGcnaZIwPt8c/zZKnoNOiM4J6SIM+pnAcyY96GekYJtvf0I/EyE6MwzDMAzDjI+/5MPGam/zucIAAAAASUVORK5CYII="/>
  </div>
</a>



<a href='java.htm'><div class='book-cover' style='background-color: #f9f6f1;color: #111111;border: 1px solid #ccc;display: flex;justify-content: center;align-items: center;text-align: center;'>More Java Books</div></a>
</div>
</div>
  </div>
  <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/prism.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
  
  <script>
    function copyCode(button) {
      const code = button.nextElementSibling.innerText;
      navigator.clipboard.writeText(code).then(() => {
        button.textContent = 'Copied!';
        setTimeout(() => { button.textContent = 'Copy'; }, 1500);
      });
    }
  </script>  
<div id="floatingLog" aria-live="polite" role="alert"></div>
<footer class="page-footer">
    <nav>
      <a href="https://readbytes.github.io">Home</a> | 
      Email:<script language="JavaScript" type="text/javascript">
var part1 = 'yinpeng';var part6 = '263';var part2 = Math.pow(2,6);var part3 = String.fromCharCode(part2);var part4 = 'hotmail dot com';var part5 = part1 + String.fromCharCode(part2) + part4;document.write(part1 + part6 + part3 + part4);
</script>
    </nav>
  <p>© 2025 — All rights reserved.</p>    
  </footer>

</body>
</html>