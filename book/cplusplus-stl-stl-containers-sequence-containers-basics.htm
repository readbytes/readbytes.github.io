<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>C++ STL STL Containers: Sequence Containers Basics</title>
<link rel='shortcut icon' href='https://java2s.com/style/favicon.ico'>
<link href="https://fonts.googleapis.com/css2?family=Merriweather&display=swap" rel="stylesheet" />
<link href="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet" />


  <script>
  const mode = localStorage.getItem('mode') || 'light';
  document.documentElement.classList.add(`${mode}-mode`);
  </script>   
<style> 
html {
  scroll-behavior: smooth;
}

body {
  font-family: 'Merriweather', serif;
  margin: 0;
  padding: 2rem 1rem;
  font-size: 15px;
  line-height: 1.5;
  transition: background-color 0.3s, color 0.3s;
}

.container {
  max-width: 700px;
  margin: 0 auto;
  padding: 1rem 2rem;
  box-shadow: 0 0 15px rgba(0,0,0,0.1);
}

h1, h2, h3 {
  font-weight: 600;
  margin-top: 2.5rem;
  margin-bottom: 1rem;
  line-height: 1.2;
}

h1 { font-size: 1.8rem; }
h2 { font-size: 1.4rem; }
h3 { font-size: 1.2rem; }

table {
  width: 100%;
  border-collapse: collapse;
  font-family: sans-serif;
  font-size: 1em;
  margin: 1em 0;
}

th, td {
  padding: 0.6em 1em;
  text-align: left;
  border: 1px solid;
}

tr:nth-child(even) {
  background-color: inherit;
}

tr:hover {
  background-color: inherit;
}

a {
  text-decoration: none;
  transition: color 0.2s;
}

a:hover {
  text-decoration: underline;
}

code {
  color: #d35400;
}

.book-title-chapter {
  font-family: 'Merriweather', serif;
  font-size: 2rem;
  font-weight: bold;
  text-align: center;
  margin-bottom: 2rem;
  border-bottom: 2px solid;
  padding-bottom: 0.5rem;
}

.book-subtitle-chapter {
  text-align: center;
  font-size: 1rem;
  margin-top: -1rem;
  margin-bottom: 2rem;
}

.related-books {
  margin-top: 40px;
}

.related-book-list {
  display: flex;
  flex-wrap: wrap;
  gap: 20px;
}

    .book-cover {
      width: 130px;
      height: 180px;
      font-family: Arial, sans-serif;
      position: relative;
      overflow: hidden;      
      line-height: normal;
      box-shadow: 2px 2px 4px rgba(0,0,0,0.1);
    }
    .book-cover-bottom-stripe {
      position: absolute;
      bottom: 0;
      left: 0;
      height: 5px;
      width: 100%;
    }
    .book-cover-title {
      position: absolute;
      width: 100%;
      text-align: center;
      font-weight: bold;
    }
     
    .book-cover-icon {
      position: absolute;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      align-items: center;
      justify-content: center; 
    }

    .book-cover-author {
      position: absolute;
      bottom: 10px;
      width: 100%;
      text-align: center;
      font-size: 8px;
      color: #333;
    }

.page-footer {
  margin-top: 4rem;
  padding: 1rem 0;
  text-align: center;
  font-size: 0.85rem;
  border-top: 1px solid;
}

.chapter-navi-section {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding-bottom: 10px;
}

.nav-link {
  color: inherit;
  text-decoration: none;
  opacity: 0.5;
  transition: opacity 0.3s ease, text-decoration 0.3s ease;
}

.nav-link:hover {
  opacity: 0.9;
  text-decoration: underline;
}

.prev { text-align: left; }
.toc-link { text-align: center; }
.next { text-align: right; }

.download-section {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 2rem;
  padding: 2rem 1rem;
  max-width: 600px;
  margin: 3rem auto;
  border-radius: 12px;
  box-shadow: 0 4px 10px rgba(0,0,0,0.05);
}

.download-info h2 {
  margin: 0 0 0.5rem;
  font-size: 1.2rem;
}

.format-label {
  margin: 0 0 0.5rem;
  font-size: 0.95rem;
}

.download-buttons {
  display: flex;
  gap: 1rem;
}

.download-button {
  background-color: #4A90E2;
  color: white;
  padding: 0.5em 1.2em;
  border-radius: 25px;
  font-size: 0.95rem;
  text-decoration: none;
  transition: background-color 0.3s ease;
}

.download-button:hover {
  background-color: #357ABD;
}

.code-block {
  position: relative;
  margin-bottom: 1em;
}

.copy-button {
  background: transparent;
  color: white;
  position: absolute;
  top: 8px;
  right: 8px;
  border: none;
  padding: 4px 8px;
  font-size: 12px;
  border-radius: 4px;
  cursor: pointer;
  z-index: 1;
}

.copy-button:hover {
  background-color: #0056b3;
}

.snippet-container {
  overflow: hidden;
}

.snippet-header {
  padding: 0.75rem 1rem;
  cursor: pointer;
  font-size: 1rem;
    background-color: #eeeeee;
    color:  #111111; 
    border-radius: 8px;
    cursor: pointer;
    box-shadow: 0 4px 6px rgba(0,0,0,0.1);  
}

.snippet-body {
  display: none;
  font-family: monospace;
}

.snippet-container.open .snippet-body {
  display: block;
}

.CodeMirror {
  border: 2px solid #ccc;
  border-radius: 4px;
  resize: vertical;
}

/* === Light Mode === */
html.light-mode {
  background-color: #f8f7f5;
  color: #333;
}

html.light-mode .container {
  background: white;
}

html.light-mode .book-title-chapter {
  color: #2c3e50;
  border-color: #ccc;
}
html.light-mode .book-subtitle-chapter{
  color: #888;
}

html.light-mode .page-footer,
html.light-mode .series-name,
html.light-mode .book-subtitle,
html.light-mode .format-label {
  color: #888;
}

html.light-mode .related-books h2 {
  color: #333;
  border-bottom: 2px solid #eee;
}

html.light-mode .book-title {
  color: #fff;
}

html.light-mode .book-cover {
  border: 1px solid #ccc;
}

html.light-mode th {
  background-color: #f2f2f2;
}

html.light-mode tr:nth-child(even) {
  background-color: #fafafa;
}

html.light-mode tr:hover {
  background-color: #e6f7ff;
}

html.light-mode a,
html.light-mode .page-footer a {
  color: #000;
}

/* === Dark Mode === */
html.dark-mode {
  background-color: #181818;
  color: #e0e0e0;
}

html.dark-mode .container {
  background: #222;
}

html.dark-mode .book-title-chapter {
  color: #ddd;
  border-color: #444;
}

html.dark-mode .snippet-header {
    background-color: #333;
    color:  #ddd; 
}


html.dark-mode .book-subtitle-chapter,
html.dark-mode .page-footer,
html.dark-mode .series-name,
html.dark-mode .book-subtitle,
html.dark-mode .book-footer,
html.dark-mode .format-label {
  color: #aaa;
}

html.dark-mode .related-books h2 {
  color: #ddd;
  border-bottom: 2px solid #333;
}

html.dark-mode .book-title {
  color: #fff;
}

html.dark-mode .book-cover {
  border: 1px solid #555;
}

html.dark-mode th {
  background-color: #333;
  color: #fff;
}

html.dark-mode td {
  border-color: #444;
}

html.dark-mode tr:nth-child(even) {
  background-color: #2a2a2a;
}

html.dark-mode tr:hover {
  background-color: #2c3e50;
}

html.dark-mode a,
html.dark-mode .page-footer a {
  color: #eee;
}

    .dialog-backdrop {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: rgba(0,0,0,0.5);
      display: none;
      justify-content: center;
      align-items: center;
      z-index: 10;
    }

    .dialog {
      background: white;
      padding: 20px;
      width: 90vw;
      height: 80vh;
      border-radius: 8px;
      box-shadow: 0 0 20px rgba(0,0,0,0.3);
      display: flex;
      flex-direction: column;
    }
    .dialog-content {
      display: flex;
      flex: 1;
      gap: 20px;
      margin-top: 10px;
    }
    .dialog h2 {
      margin-top: 0;
    }

    .textarea_dialog {
      width: 50%;
      height: 100%;
      resize: none;
      font-family: monospace;
      font-size: 14px;
      padding: 10px;
      box-sizing: border-box;
      border: 1px solid #ccc;
    }

    .iframe_dialog {
      width: 50%;
      height: 100%;
      border: 1px solid #ccc;
    }
    .controls_dialog {
      display: flex;
      justify-content: space-between;
      margin-top: 10px;
    }    
    button { padding: 0.5em 1em; background: green; color: white; border: none; cursor: pointer; }
    button:hover { background: #1e7e34; }
    .result_iframe { width:99%; height:200px; margin-top: 1em;  resize: both;border:1px solid #ccc;}        
</style>
</head>
<body> 
  <div class="container">
    <div class = "chapter-navi-section">
<a href="cplusplus-stl-introduction-to-the-stl.htm" class="nav-button prev">←</a>
<a href='cplusplus-stl.htm#stl-containers-sequence-containers-basics' class="nav-button toc-link">Index</a>
<a href="cplusplus-stl-stl-containers-associative-containers.htm" class="nav-button next">→</a>
</div>

    <h1 class="book-title-chapter" id = 'top'>STL Containers: Sequence Containers Basics</h1>
    <h3 class="book-subtitle-chapter">C++ STL</h3>   
    <!-- <h1 class ="chapter-title"></h1> -->
    <h2 id='overview-of-sequence-containers'>2.1 Overview of Sequence Containers</h2><p><strong>Sequence containers</strong> in the C++ Standard Template Library (STL) are designed to store elements in a <strong>linear</strong> arrangement—meaning the order in which elements are inserted is preserved. These containers support operations like iteration, insertion, and deletion and are ideal for handling lists, queues, buffers, or any other ordered collection of elements.</p><p>There are <strong>three primary sequence containers</strong> in STL:</p><ul>
 <li><code>std::vector</code></li>
 <li><code>std::deque</code></li>
 <li><code>std::list</code></li>
</ul><p>Each has unique strengths and trade-offs depending on the performance characteristics you need.</p><h4 id="container-introductions">Container Introductions</h4><ul>
 <li><p><strong><code>std::vector</code></strong>: A dynamic array that provides fast <strong>random access</strong> and efficient <strong>insertion/removal at the end</strong>. It stores elements in a contiguous memory block, making it cache-friendly and compatible with raw arrays.</p></li>
 <li><p><strong><code>std::deque</code></strong> (<em>double-ended queue</em>): Supports fast <strong>insertion and deletion at both ends</strong>. Unlike <code>vector</code>, it may not store elements contiguously but allows efficient expansion at both the front and back.</p></li>
 <li><p><strong><code>std::list</code></strong>: A <strong>doubly linked list</strong> with fast <strong>insertion and deletion at any position</strong>, especially in the middle. However, it does <strong>not support random access</strong>, and traversing elements is slower due to pointer-based structure.</p></li>
</ul><h4 id="comparison-table">Comparison Table</h4><table>
 <thead>
  <tr>
   <th>Feature</th>
   <th><code>std::vector</code></th>
   <th><code>std::deque</code></th>
   <th><code>std::list</code></th>
  </tr>
 </thead>
 <tbody>
  <tr>
   <td>Memory layout</td>
   <td>Contiguous</td>
   <td>Non-contiguous</td>
   <td>Node-based</td>
  </tr>
  <tr>
   <td>Random access</td>
   <td>✅ Fast (<code>O(1)</code>)</td>
   <td>✅ Fast (<code>O(1)</code>)</td>
   <td>❌ (<code>O(n)</code>)</td>
  </tr>
  <tr>
   <td>Insert/remove at end</td>
   <td>✅ Fast (<code>O(1)</code> amort.)</td>
   <td>✅ Fast (<code>O(1)</code>)</td>
   <td>✅ Fast (<code>O(1)</code>)</td>
  </tr>
  <tr>
   <td>Insert/remove at front</td>
   <td>❌ Slow (<code>O(n)</code>)</td>
   <td>✅ Fast (<code>O(1)</code>)</td>
   <td>✅ Fast (<code>O(1)</code>)</td>
  </tr>
  <tr>
   <td>Insert/remove in middle</td>
   <td>❌ Slow (<code>O(n)</code>)</td>
   <td>❌ Moderate (<code>O(n)</code>)</td>
   <td>✅ Fast (<code>O(1)</code>)</td>
  </tr>
  <tr>
   <td>Cache friendliness</td>
   <td>✅ High</td>
   <td>⚠️ Medium</td>
   <td>❌ Low</td>
  </tr>
  <tr>
   <td>Best use cases</td>
   <td>Arrays, buffers</td>
   <td>Queues, sliding windows</td>
   <td>Frequent mid-inserts</td>
  </tr>
 </tbody>
</table><h4 id="choosing-the-right-container">Choosing the Right Container</h4><ul>
 <li>Use <strong><code>vector</code></strong> when you need fast random access and frequent growth at the end.</li>
 <li>Use <strong><code>deque</code></strong> for <strong>double-ended queues</strong> or when you need fast front and back operations.</li>
 <li>Use <strong><code>list</code></strong> when your application involves <strong>frequent insertions or deletions in the middle</strong> of the collection.</li>
</ul><p>Sequence containers are the building blocks for many STL programs. Choosing the right one based on your performance needs can significantly improve efficiency and clarity in your code. As we explore each container in detail, you’ll see how their internal design affects real-world usage.</p><div class = "chapter-navi-section">
<a href="#top" class="nav-button prev">↑</a>
<a href='cplusplus-stl.htm#stl-containers-sequence-containers-basics' class="nav-button toc-link">Index</a>
<a href="#bottom" class="nav-button next">↓</a>
</div>
<h2 id='std-vector-dynamic-arrays-and-usage-examples'>2.2 <code>std::vector</code>: Dynamic Arrays and Usage Examples</h2><p>The <code>std::vector</code> container is one of the most widely used sequence containers in the C++ Standard Template Library. It acts like a <strong>dynamic array</strong>, automatically managing memory as elements are added or removed, while providing <strong>fast random access</strong> and <strong>contiguous memory storage</strong>.</p><h4 id="key-features-of-std-vector">Key Features of <code>std::vector</code></h4><ul>
 <li><p><strong>Dynamic resizing:</strong> Unlike a regular array with fixed size, a vector can grow or shrink at runtime. When you add elements beyond its current capacity, it automatically allocates more memory.</p></li>
 <li><p><strong>Contiguous memory:</strong> Elements in a vector are stored sequentially in memory, which makes vector very cache-friendly and allows efficient pointer arithmetic.</p></li>
 <li><p><strong>Random access:</strong> You can access any element in constant time using the subscript operator <code>[]</code> or the <code>.at()</code> method.</p></li>
 <li><p><strong>Efficient end insertions:</strong> Adding elements at the end (<code>push_back()</code>) is usually fast, with occasional reallocations that double capacity.</p></li>
 <li><p><strong>Size vs Capacity:</strong></p>
  <ul>
   <li><strong>Size</strong> is the number of elements currently stored.</li>
   <li><strong>Capacity</strong> is the amount of allocated memory available before resizing is needed.</li>
  </ul></li>
</ul><h4 id="basic-usage-example">Basic Usage Example</h4><div class="code-block"><button class="copy-button" onclick="copyCode(this)">📋</button>
 <pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;

int main() {
    // Create an empty vector of integers
    std::vector&lt;int&gt; numbers;

    // Insert elements at the end
    numbers.push_back(10);
    numbers.push_back(20);
    numbers.push_back(30);

    // Print size and capacity
    std::cout &lt;&lt; "Size: " &lt;&lt; numbers.size() &lt;&lt; ", Capacity: " &lt;&lt; numbers.capacity() &lt;&lt; "\n";

    // Access elements using random access
    std::cout &lt;&lt; "Element at index 1: " &lt;&lt; numbers[1] &lt;&lt; std::endl;

    // Resize vector to contain 5 elements
    numbers.resize(5);  // New elements initialized to 0 by default

    std::cout &lt;&lt; "After resizing to 5 elements:" &lt;&lt; std::endl;
    for (int n : numbers) {
        std::cout &lt;&lt; n &lt;&lt; " ";
    }
    std::cout &lt;&lt; std::endl;

    return 0;
}</code></pre>
</div><h4 id="explanation">Explanation:</h4><ul>
 <li><code>push_back()</code> adds elements to the end, increasing size.</li>
 <li><code>size()</code> returns current number of elements.</li>
 <li><code>capacity()</code> shows allocated storage — may be larger than size.</li>
 <li><code>resize()</code> changes the size. If increased, new elements are default-initialized.</li>
 <li>Accessing elements by index is fast and simple.</li>
</ul><h4 id="when-to-use-std-vector">When to Use <code>std::vector</code></h4><p>Vectors are ideal when:</p><ul>
 <li>You need <strong>fast random access</strong> to elements.</li>
 <li>Your collection size may change but most insertions are at the <strong>end</strong>.</li>
 <li>Memory locality and performance matter (e.g., numerical computations, buffers).</li>
 <li>You want a simple, flexible container with low overhead.</li>
</ul><p>By mastering <code>std::vector</code>, you gain a versatile tool that fits a wide range of programming needs. Next, we’ll explore <code>std::deque</code>, which offers some additional flexibility for front-end operations.</p><div class = "chapter-navi-section">
<a href="#top" class="nav-button prev">↑</a>
<a href='cplusplus-stl.htm#stl-containers-sequence-containers-basics' class="nav-button toc-link">Index</a>
<a href="#bottom" class="nav-button next">↓</a>
</div>
<h2 id='std-deque-double-ended-queues'>2.3 <code>std::deque</code>: Double-Ended Queues</h2><p>The <strong><code>std::deque</code></strong> (double-ended queue) is a versatile sequence container in the C++ Standard Library designed for efficient insertions and deletions at <strong>both the front and the back</strong> of the container. This contrasts with <code>std::vector</code>, which offers fast insertions only at the back.</p><h4 id="how-std-deque-differs-from-std-vector">How <code>std::deque</code> Differs from <code>std::vector</code></h4><p>While both <code>deque</code> and <code>vector</code> support random access and store elements in order, their <strong>internal structures</strong> differ:</p><ul>
 <li><code>std::vector</code> stores elements in a <strong>single contiguous block</strong> of memory, making it very cache-friendly but slow for insertions at the front (which require shifting elements).</li>
 <li><code>std::deque</code> uses a <strong>sequence of fixed-size memory blocks</strong> linked together, allowing it to efficiently add or remove elements at both ends without relocating all elements.</li>
</ul><p>This internal structure allows <code>deque</code> to grow dynamically on either side, providing more flexibility than <code>vector</code>.</p><h4 id="conceptual-diagram-of-std-deque">Conceptual Diagram of <code>std::deque</code></h4><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-bash">[Block 1] &lt;-&gt; [Block 2] &lt;-&gt; [Block 3] &lt;-&gt; ... &lt;-&gt; [Block N]
|          |    |          |    |          |           |
Elements    Elements       Elements        Elements</code></pre>
</div><p>Each block holds a chunk of elements. This arrangement supports quick front and back operations.</p><h4 id="basic-usage-example">Basic Usage Example</h4><div class="code-block"><button class="copy-button" onclick="copyCode(this)">📋</button>
 <pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;deque&gt;

int main() {
    std::deque&lt;int&gt; d;

    // Insert elements at the back
    d.push_back(10);
    d.push_back(20);

    // Insert elements at the front
    d.push_front(5);
    d.push_front(2);

    // Print all elements
    std::cout &lt;&lt; "Deque elements: ";
    for (int n : d) {
        std::cout &lt;&lt; n &lt;&lt; " ";
    }
    std::cout &lt;&lt; std::endl;

    // Remove elements from front and back
    d.pop_front();  // removes 2
    d.pop_back();   // removes 20

    std::cout &lt;&lt; "After pop operations: ";
    for (int n : d) {
        std::cout &lt;&lt; n &lt;&lt; " ";
    }
    std::cout &lt;&lt; std::endl;

    // Random access
    std::cout &lt;&lt; "Element at index 0: " &lt;&lt; d[0] &lt;&lt; std::endl;

    return 0;
}</code></pre>
</div><h4 id="performance-considerations">Performance Considerations</h4><table>
 <thead>
  <tr>
   <th>Operation</th>
   <th><code>std::vector</code></th>
   <th><code>std::deque</code></th>
  </tr>
 </thead>
 <tbody>
  <tr>
   <td>Insert/remove at back</td>
   <td>Fast (<code>O(1)</code> amortized)</td>
   <td>Fast (<code>O(1)</code>)</td>
  </tr>
  <tr>
   <td>Insert/remove at front</td>
   <td>Slow (<code>O(n)</code>)</td>
   <td>Fast (<code>O(1)</code>)</td>
  </tr>
  <tr>
   <td>Random access</td>
   <td>Fast (<code>O(1)</code>)</td>
   <td>Fast (<code>O(1)</code>)</td>
  </tr>
  <tr>
   <td>Memory layout</td>
   <td>Contiguous</td>
   <td>Non-contiguous</td>
  </tr>
  <tr>
   <td>Cache friendliness</td>
   <td>High</td>
   <td>Moderate</td>
  </tr>
 </tbody>
</table><p>Because <code>deque</code> is not contiguous in memory, iterating over it may be slightly slower than a vector, but its flexibility for front-end operations makes it an excellent choice for <strong>queues</strong>, <strong>double-ended buffers</strong>, or when you need efficient insertion/removal at both ends.</p><p>In summary, <code>std::deque</code> combines many benefits of <code>vector</code> and <code>list</code>, making it a flexible container when you need quick insertions/removals at either end without sacrificing random access.</p><div class = "chapter-navi-section">
<a href="#top" class="nav-button prev">↑</a>
<a href='cplusplus-stl.htm#stl-containers-sequence-containers-basics' class="nav-button toc-link">Index</a>
<a href="#bottom" class="nav-button next">↓</a>
</div>
<h2 id='std-list-doubly-linked-lists'>2.4 <code>std::list</code>: Doubly Linked Lists</h2><p>The <strong><code>std::list</code></strong> container implements a <strong>doubly linked list</strong>, a sequence of elements where each element points to both its previous and next neighbor. This structure makes it especially efficient for frequent insertions and deletions <strong>anywhere</strong> in the list—even in the middle—without needing to move other elements.</p><h4 id="characteristics-of-std-list">Characteristics of <code>std::list</code></h4><ul>
 <li>Unlike <code>vector</code> or <code>deque</code>, <code>std::list</code> <strong>does not provide random access</strong> (no direct indexing like <code>list[2]</code>).</li>
 <li>Accessing elements requires sequential traversal, which means accessing the <em>n</em>-th element takes time proportional to <em>n</em> (<code>O(n)</code>).</li>
 <li>However, inserting or removing elements is very fast (<code>O(1)</code>) once you have an iterator to the position.</li>
</ul><h4 id="when-to-use-std-list">When to Use <code>std::list</code></h4><p>Use <code>std::list</code> when:</p><ul>
 <li>Your program requires <strong>frequent insertions or deletions in the middle</strong> of the sequence.</li>
 <li>You need stable iterators and pointers—elements won’t be invalidated by insertions or removals elsewhere.</li>
 <li>Random access speed is less critical than flexibility in modifying the container.</li>
</ul><h4 id="basic-usage-example">Basic Usage Example</h4><div class="code-block"><button class="copy-button" onclick="copyCode(this)">📋</button>
 <pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;list&gt;

int main() {
    std::list&lt;int&gt; numbers = {10, 20, 30};

    // Insert at the front and back
    numbers.push_front(5);
    numbers.push_back(40);

    // Insert in the middle using an iterator
    auto it = numbers.begin();
    std::advance(it, 2);  // Move iterator to third element (value 20)
    numbers.insert(it, 15);  // Insert 15 before 20

    // Remove an element
    numbers.remove(30);  // Removes all occurrences of 30

    // Traverse and print
    std::cout &lt;&lt; "List elements: ";
    for (int n : numbers) {
        std::cout &lt;&lt; n &lt;&lt; " ";
    }
    std::cout &lt;&lt; std::endl;

    return 0;
}</code></pre>
</div><h4 id="why-std-list-lacks-random-access">Why <code>std::list</code> Lacks Random Access</h4><p>Because elements are stored as nodes linked via pointers, they are <strong>not contiguous in memory</strong>. This prevents direct access by index and requires stepping through each node sequentially. While this makes <code>list</code> slower for indexed access, it provides unmatched efficiency for modifying the list structure.</p><p>In summary, <code>std::list</code> is a powerful container when you need flexible insertion and removal at arbitrary positions in your sequence. For scenarios involving heavy middle insertions or deletions, it outperforms vectors and deques, but if you need fast indexed access, other containers like <code>vector</code> are preferable.</p><div class = "chapter-navi-section">
<a href="#top" class="nav-button prev">↑</a>
<a href='cplusplus-stl.htm#stl-containers-sequence-containers-basics' class="nav-button toc-link">Index</a>
<a href="#bottom" class="nav-button next">↓</a>
</div>
<h2 id='comparing-sequence-containers-performance-and-use-cases'>2.5 Comparing Sequence Containers: Performance and Use Cases</h2><p>Choosing the right sequence container—<code>std::vector</code>, <code>std::deque</code>, or <code>std::list</code>—depends on your program’s <strong>performance needs</strong> and <strong>usage patterns</strong>. Each container has different strengths and trade-offs related to insertion, deletion, memory layout, and access speed.</p><h4 id="performance-summary">Performance Summary</h4><table>
 <thead>
  <tr>
   <th>Operation</th>
   <th><code>std::vector</code></th>
   <th><code>std::deque</code></th>
   <th><code>std::list</code></th>
  </tr>
 </thead>
 <tbody>
  <tr>
   <td><strong>Random access</strong></td>
   <td>Fast (<code>O(1)</code>)</td>
   <td>Fast (<code>O(1)</code>)</td>
   <td>Slow (<code>O(n)</code>)</td>
  </tr>
  <tr>
   <td><strong>Insertion at back</strong></td>
   <td>Fast (<code>O(1)</code> amort.)</td>
   <td>Fast (<code>O(1)</code>)</td>
   <td>Fast (<code>O(1)</code>)</td>
  </tr>
  <tr>
   <td><strong>Insertion at front</strong></td>
   <td>Slow (<code>O(n)</code>)</td>
   <td>Fast (<code>O(1)</code>)</td>
   <td>Fast (<code>O(1)</code>)</td>
  </tr>
  <tr>
   <td><strong>Insertion in middle</strong></td>
   <td>Slow (<code>O(n)</code>)</td>
   <td>Moderate (<code>O(n)</code>)</td>
   <td>Fast (<code>O(1)</code>)</td>
  </tr>
  <tr>
   <td><strong>Deletion at back</strong></td>
   <td>Fast (<code>O(1)</code>)</td>
   <td>Fast (<code>O(1)</code>)</td>
   <td>Fast (<code>O(1)</code>)</td>
  </tr>
  <tr>
   <td><strong>Deletion at front</strong></td>
   <td>Slow (<code>O(n)</code>)</td>
   <td>Fast (<code>O(1)</code>)</td>
   <td>Fast (<code>O(1)</code>)</td>
  </tr>
  <tr>
   <td><strong>Deletion in middle</strong></td>
   <td>Slow (<code>O(n)</code>)</td>
   <td>Moderate (<code>O(n)</code>)</td>
   <td>Fast (<code>O(1)</code>)</td>
  </tr>
  <tr>
   <td><strong>Memory layout</strong></td>
   <td>Contiguous</td>
   <td>Non-contiguous</td>
   <td>Non-contiguous</td>
  </tr>
  <tr>
   <td><strong>Cache friendliness</strong></td>
   <td>High</td>
   <td>Moderate</td>
   <td>Low</td>
  </tr>
 </tbody>
</table><h4 id="when-to-use-each-container">When to Use Each Container</h4><p><strong><code>std::vector</code></strong></p><ul>
 <li>Ideal when you need <strong>fast random access</strong> and expect most insertions/removals at the <strong>end</strong>.</li>
 <li>Perfect for numerical computations, buffers, and static-size collections that occasionally grow.</li>
 <li>Example: Storing a list of scores or processing a large array of sensor data.</li>
</ul><p><strong><code>std::deque</code></strong></p><ul>
 <li>Best when you need fast insertions/removals at <strong>both ends</strong> but still want efficient random access.</li>
 <li>Useful for implementing queues, sliding windows, or double-ended buffers.</li>
 <li>Example: Maintaining a list of recent events with frequent additions/removals at front and back.</li>
</ul><p><strong><code>std::list</code></strong></p><ul>
 <li>Suited for scenarios with frequent <strong>insertions and deletions in the middle</strong> of the sequence.</li>
 <li>Avoids costly element shifting but sacrifices random access speed.</li>
 <li>Example: Managing playlists or editing text buffers where items are frequently inserted or removed anywhere.</li>
</ul><h4 id="practical-scenario-comparison">Practical Scenario Comparison</h4><p>Imagine you need to maintain a collection of tasks:</p><table>
 <thead>
  <tr>
   <th>Scenario</th>
   <th>Recommended Container</th>
   <th>Reason</th>
  </tr>
 </thead>
 <tbody>
  <tr>
   <td>Fast lookup by position, occasional growth</td>
   <td><code>std::vector</code></td>
   <td>Contiguous storage, quick indexing</td>
  </tr>
  <tr>
   <td>Tasks added/removed frequently at both ends</td>
   <td><code>std::deque</code></td>
   <td>Efficient front/back insertions</td>
  </tr>
  <tr>
   <td>Frequent insertions/deletions in middle</td>
   <td><code>std::list</code></td>
   <td>Fast splicing without copying elements</td>
  </tr>
 </tbody>
</table><h3 id="conclusion">Conclusion</h3><p>Understanding the strengths and weaknesses of these containers allows you to <strong>choose the best tool for your data structure needs</strong>. While <code>vector</code> often suffices due to its simplicity and speed, knowing when <code>deque</code> or <code>list</code> outperforms it is crucial for writing efficient, maintainable C++ code. This foundation will help you apply STL containers confidently in your projects.</p><div class = "chapter-navi-section">
<a href="cplusplus-stl-introduction-to-the-stl.htm" class="nav-button prev">←</a>
<a href='cplusplus-stl.htm#stl-containers-sequence-containers-basics' class="nav-button toc-link">Index</a>
<a href="cplusplus-stl-stl-containers-associative-containers.htm" class="nav-button next">→</a>
</div>
<section class="download-section">
  <div class="book-cover" style="background-color: #f9f6f1;border: 1px solid #ccc;"> 
    <div class="book-cover-title" style="font-size: 20px;color: #333;top: 20px;">C++ STL</div>
    <div class="book-cover-author">readbytes</div>
    <div class="book-cover-bottom-stripe" style="background-color: #333;"></div>
    <img class="book-cover-icon" style="width: 90px;height: 90px;top: 70px;" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFoAAABaCAYAAAA4qEECAAADK0lEQVR4Xu2cvWsTcRjHo+DkIKiTjiJugqTJ0cG/QcRZ/wJXQTd3ByeHDiLJnS84dHMVBHUSRQUH90pNfmfb6CKi8fqSaj93ae4lzzV3+X7gS9vkeZ7f7/lwEDq0jYYQQgghxFzQ9t0wbTzf3WO/SAllpg3niAlQYJa0uu4W54kxeA96ZykwU4JwnTPFGGLyMqd3nTNFAnFx2cOZIiee//UK5TLsEQWg3D1ZHpxgvShATLCeajsoWKKNaAfuDyVvZuGhu8paURBK1lNtBAVLtBEULNFGULBEG0HBlRfNRUrMqwW/f473GZFQvxXWVQbPD5e4zEGlcXt4eHQvvrdbU2W4zEGn5Yd3+NoovHul4DKzHN69UnCZWQ7vXim8IHzJhWY1vLtIQSRujSInhTNEBppL345R6LiwV+SAUpPCHpETimVYLwpAuRJtBOVKtBHNR4OTFCzRRlCwRBtBwRJtBAVLtBEULNFGeN3wPiVvp/+OtVmJ5qzvmdl1z1kzV8Ql53+q0/6az765gBLyConqN9i/X9hfeyiAYX0S7cCtsi9NOKf2UADDesL6LOGsWsPlx+V8d/Vo3t5x4bzyGA4P8TK1TuBeU0FpxC5T83D/0uBF6h7uXxq8SN3D/Utj80OHl6ltgvAX9y+V2IUm53eUQZQvUT4nvJ8x/e/R14+RiBeeHz4bZfPn6PW3bT908Z7s4d6Vgwsxix13mj15iGb94Ows4bxKwWUY1heF89OGcyoHFypjOZ4zKV7gVjijUjSfrJ/hUqOwdtrwvH2yzN7KkbDUTsKfrLWgufTmSPzsf2F9ZeFitVtwVqBgiTaCgiXaCAqWaCMoWKKNoGCJNoKCJdoICpZoIyhYoo2gYIk2goIl2ggKlmgjKFiijaBgiTaCgiXagLbfu0jBW+m6NdaKAsQEj9Jxl1krChATvBPWiQJ4fviJgiV6yiw+3ThOuRI9ZbzA3aRYSZ4iFx73T1FqUtg3l1DKbrr9960gvBt9f207/Rst332I1U0Iz5tbKGaa4VlzTSQk8X84Fw3PEY3p/70KTxA7UFTeeB13ibPFf1BY1nCeEEIIIYQowl8t5mhjJHw+fQAAAABJRU5ErkJggg=="/>
  </div>
  <div class="download-info">
    <h2 id='bottom'>Download This Ebook</h2>
    <p class="format-label">Available formats:</p>
    <div class="download-buttons">
      <a href="cplusplus-stl.pdf" class="download-button">📄 PDF</a>
      <a href="cplusplus-stl.epub" class="download-button">📘 EPUB</a>
    </div>
  </div>
</section><div class='related-books'>
<h2>C++ Introduction Books</h2>
<div class='related-book-list'>
<a href="cplusplus-for-beginners.htm">
<div class="book-cover" style="background-color: #f9f6f1;border: 1px solid #ccc;"> 
    <div class="book-cover-title" style="font-size: 18px;color: #333;top: 20px;">C++ for Beginners</div>
    <div class="book-cover-author">readbytes</div>
    <div class="book-cover-bottom-stripe" style="background-color: #333;"></div>
    <img class="book-cover-icon" style="width: 90px;height: 90px;top: 70px;" src="data:image/png;base64,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"/>
  </div>
</a>


<a href="cplusplus-syntax.htm">
<div class="book-cover" style="background-color: #f9f6f1;border: 1px solid #ccc;"> 
    <div class="book-cover-title" style="font-size: 20px;color: #333;top: 20px;">C++ Syntax</div>
    <div class="book-cover-author">readbytes</div>
    <div class="book-cover-bottom-stripe" style="background-color: #333;"></div>
    <img class="book-cover-icon" style="width: 90px;height: 90px;top: 70px;" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFoAAABaCAYAAAA4qEECAAAFZ0lEQVR4Xu2dy4scVRSH8ye0iYtkERcmzgjT2OYBuhNREMVXBh/TgsYQx5ULDYTgVl3EFyg6uFJBV76IEXdKXAVBJCgISSTRGRmZiZlADBo6M5kp+3ZbnXt/p7q6btWtc++pqQPfpu/p7vP7UnSqi+m6GzbkrMbYO50u0Tqjgx5Kqe4brSa8+XplFf0UroQ3GbDltqNRs70Y3Tw5G22//2SXU0Fyy5MXc6GyqYyYWwd9WdfGbW9uxRe9vvlBtOvZKLrpwTOiUDO7QjlALxu3zWxFf5mq++RF/YU27/40au39lwSQAspygXICwhfRY2rhv5Z6URxcEuoAQUkuQV/oM7HwSN45vUoGlwaKKQOrI1t9zuhPaD19mQwtEZRSFrq71M/sqh3JMSikTHSH6LdXeoN6Ag4rlV3Ta0RG2aTKjhfU/6Q4rGRQAgf62QhKHnzjk3wKlwRK4EI7qq99g4wf3NR8nwwqmfE9s0QAF8olOarjB1QDDisZDM+NIbqhXYXDQaWDwbnRPj46xtkGDiodDM6N7nYgWl2hwkEl09r7DwnOzZbbr131G4iemFokw0oGQ/ug2XVKRI9PzpJhJYOhfdB66m8qevsDp8iwksHQPqi8aAzsi1o0E7VoJioteuzh30lgX1RaNIb1SS2aiVo0E5UVPTH1Fwnrk8qKxqC+qUUzUYtmwovoL49dioYV9uZhx/4VEjRmWM2fp70uYRc9qrA/DxhSZ1RhvyuCEL1wfiU6PXulB/bnAUPqnJnv8+cSTtEv7HeFd9G4XpyzJGQaWLjuisqJxoCjeOVjc572y7THBayim4+cNUKdONkhPUXBgKO495AxUrTvVdrjAq+ij//k/i9UMeAo7jlojFSLzsLE4/ZfuyspuvXYb0Yo16IxXBZQ9DOv0x4XsIqeOjRvhPri20ukpwgYLgt3HTBGir75kfa4gFU01h373f5ZA4bLChauu4BNdPtF82hWhT1FuHVfh4TLCtbR47SnKKWKTqu5hWXSXwQMZsOBGZzOLOzPA7voNz66QPpcgMHy8Py7OG2/sC8P7KLjurK8RvqLgMFsmDmC05mF/XkoVbTOjinz1E4V9uSl6I+AsF6YoT1FYROtwLpzeo705AFD2YKF6y5gFf3oQfPM48h3w8+jD3+4ZIDrOnGYtz7vgyHTuBvOo7/+nva4gFW0zTdDLFyPGdN+BBQXhkyDfDN8jfa4gFW0zbWOH365bIDrMXqYE7/2wZBpoOhKXOuwEZ0VDGTLuhD98+kO6bEFA9lyXxWvRyuwcN0GdccFDGTLe1+Z87Rfoj0uEC0aw+QBC9dd4V10XMsraz2wPw0Mk4WVq33WcID/C/tdwS766uqwiP3C/jQwTBZGFfa7gl204rnDC5hvUNg7DAySlWH1yTHa6xIvol2AQUKnFs2ESNHjk3MkSOiIFI0hJFCLZqIWzYQ40c0nLpAQEhAnGgNIoRbNRC2aCVGid6b8CCh0RInG4SVRi2YiUXSIN68ae8juR0ChkSg6xNux4eDSSLwdW4g3GMTBpZF4g0EFBvUNDi4N3a0SHeRNYCfaS2RwaWii+1s/xQ+oRQzsCxxaIoOjGe8fHdKNunFoaWzSdh/SRQd363kcXBrax4a5eVm8EMJmCmn33pDA5t2f0aMZRStUM4bnBAeXhu4SPfdKb/C54Q0OLomRklWFsoUTDi8F3d11N759A/o1quF5UzIcXgq6sy7n0GtiwZN6L4RCygIDSAB9oc/UwiOba+NIDBEy+tmF1ZGMhZ/ZijK3Qh3f8wcJEyJOt0LVC19UR12harbPOdncFzfWDQGVTb8KlwT6KlyNertqHffbVSdVo96A3ar+A5kzbYSE7G+UAAAAAElFTkSuQmCC"/>
  </div>
</a>


<a href="cplusplus-stl.htm">
<div class="book-cover" style="background-color: #f9f6f1;border: 1px solid #ccc;"> 
    <div class="book-cover-title" style="font-size: 20px;color: #333;top: 20px;">C++ STL</div>
    <div class="book-cover-author">readbytes</div>
    <div class="book-cover-bottom-stripe" style="background-color: #333;"></div>
    <img class="book-cover-icon" style="width: 90px;height: 90px;top: 70px;" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFoAAABaCAYAAAA4qEECAAADK0lEQVR4Xu2cvWsTcRjHo+DkIKiTjiJugqTJ0cG/QcRZ/wJXQTd3ByeHDiLJnS84dHMVBHUSRQUH90pNfmfb6CKi8fqSaj93ae4lzzV3+X7gS9vkeZ7f7/lwEDq0jYYQQgghxFzQ9t0wbTzf3WO/SAllpg3niAlQYJa0uu4W54kxeA96ZykwU4JwnTPFGGLyMqd3nTNFAnFx2cOZIiee//UK5TLsEQWg3D1ZHpxgvShATLCeajsoWKKNaAfuDyVvZuGhu8paURBK1lNtBAVLtBEULNFGULBEG0HBlRfNRUrMqwW/f473GZFQvxXWVQbPD5e4zEGlcXt4eHQvvrdbU2W4zEGn5Yd3+NoovHul4DKzHN69UnCZWQ7vXim8IHzJhWY1vLtIQSRujSInhTNEBppL345R6LiwV+SAUpPCHpETimVYLwpAuRJtBOVKtBHNR4OTFCzRRlCwRBtBwRJtBAVLtBEULNFGeN3wPiVvp/+OtVmJ5qzvmdl1z1kzV8Ql53+q0/6az765gBLyConqN9i/X9hfeyiAYX0S7cCtsi9NOKf2UADDesL6LOGsWsPlx+V8d/Vo3t5x4bzyGA4P8TK1TuBeU0FpxC5T83D/0uBF6h7uXxq8SN3D/Utj80OHl6ltgvAX9y+V2IUm53eUQZQvUT4nvJ8x/e/R14+RiBeeHz4bZfPn6PW3bT908Z7s4d6Vgwsxix13mj15iGb94Ows4bxKwWUY1heF89OGcyoHFypjOZ4zKV7gVjijUjSfrJ/hUqOwdtrwvH2yzN7KkbDUTsKfrLWgufTmSPzsf2F9ZeFitVtwVqBgiTaCgiXaCAqWaCMoWKKNoGCJNoKCJdoICpZoIyhYoo2gYIk2goIl2ggKlmgjKFiijaBgiTaCgiXagLbfu0jBW+m6NdaKAsQEj9Jxl1krChATvBPWiQJ4fviJgiV6yiw+3ThOuRI9ZbzA3aRYSZ4iFx73T1FqUtg3l1DKbrr9960gvBt9f207/Rst332I1U0Iz5tbKGaa4VlzTSQk8X84Fw3PEY3p/70KTxA7UFTeeB13ibPFf1BY1nCeEEIIIYQowl8t5mhjJHw+fQAAAABJRU5ErkJggg=="/>
  </div>
</a>



<a href='cplusplus.htm'><div class='book-cover' style='background-color: #f9f6f1;color: #111111;border: 1px solid #ccc;display: flex;justify-content: center;align-items: center;text-align: center;'>More C++ Books</div></a>
</div>
</div>
  </div>
  <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/prism.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
  
  <script>
    function copyCode(button) {
      const code = button.nextElementSibling.innerText;
      navigator.clipboard.writeText(code).then(() => {
        button.textContent = 'Copied!';
        setTimeout(() => { button.textContent = 'Copy'; }, 1500);
      });
    }
  </script>  
<div id="floatingLog" aria-live="polite" role="alert"></div>
<footer class="page-footer">
    <nav>
      <a href="https://readbytes.github.io">Home</a> | 
      Email:<script language="JavaScript" type="text/javascript">
var part1 = 'yinpeng';var part6 = '263';var part2 = Math.pow(2,6);var part3 = String.fromCharCode(part2);var part4 = 'hotmail dot com';var part5 = part1 + String.fromCharCode(part2) + part4;document.write(part1 + part6 + part3 + part4);
</script>
    </nav>
  <p>© 2025 — All rights reserved.</p>    
  </footer>

</body>
</html>