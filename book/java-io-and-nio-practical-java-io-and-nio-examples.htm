<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Java IO and NIO Practical Java IO and NIO Examples</title>
<link rel='shortcut icon' href='https://java2s.com/style/favicon.ico'>
<link href="https://fonts.googleapis.com/css2?family=Merriweather&display=swap" rel="stylesheet" />
<link href="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet" />


  <script>
  const mode = localStorage.getItem('mode') || 'light';
  document.documentElement.classList.add(`${mode}-mode`);
  </script>   
<style> 
html {
  scroll-behavior: smooth;
}

body {
  font-family: 'Merriweather', serif;
  margin: 0;
  padding: 2rem 1rem;
  font-size: 15px;
  line-height: 1.5;
  transition: background-color 0.3s, color 0.3s;
}

.container {
  max-width: 700px;
  margin: 0 auto;
  padding: 1rem 2rem;
  box-shadow: 0 0 15px rgba(0,0,0,0.1);
}

h1, h2, h3 {
  font-weight: 600;
  margin-top: 2.5rem;
  margin-bottom: 1rem;
  line-height: 1.2;
}

h1 { font-size: 1.8rem; }
h2 { font-size: 1.4rem; }
h3 { font-size: 1.2rem; }

table {
  width: 100%;
  border-collapse: collapse;
  font-family: sans-serif;
  font-size: 1em;
  margin: 1em 0;
}

th, td {
  padding: 0.6em 1em;
  text-align: left;
  border: 1px solid;
}

tr:nth-child(even) {
  background-color: inherit;
}

tr:hover {
  background-color: inherit;
}

a {
  text-decoration: none;
  transition: color 0.2s;
}

a:hover {
  text-decoration: underline;
}

code {
  color: #d35400;
}

.book-title-chapter {
  font-family: 'Merriweather', serif;
  font-size: 2rem;
  font-weight: bold;
  text-align: center;
  margin-bottom: 2rem;
  border-bottom: 2px solid;
  padding-bottom: 0.5rem;
}

.book-subtitle-chapter {
  text-align: center;
  font-size: 1rem;
  margin-top: -1rem;
  margin-bottom: 2rem;
}

.related-books {
  margin-top: 40px;
}

.related-book-list {
  display: flex;
  flex-wrap: wrap;
  gap: 20px;
}

    .book-cover {
      width: 130px;
      height: 180px;
      font-family: Arial, sans-serif;
      position: relative;
      overflow: hidden;      
      line-height: normal;
      box-shadow: 2px 2px 4px rgba(0,0,0,0.1);
    }
    .book-cover-bottom-stripe {
      position: absolute;
      bottom: 0;
      left: 0;
      height: 5px;
      width: 100%;
    }
    .book-cover-title {
      position: absolute;
      width: 100%;
      text-align: center;
      font-weight: bold;
    }
     
    .book-cover-icon {
      position: absolute;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      align-items: center;
      justify-content: center; 
    }

    .book-cover-author {
      position: absolute;
      bottom: 10px;
      width: 100%;
      text-align: center;
      font-size: 8px;
      color: #333;
    }

.page-footer {
  margin-top: 4rem;
  padding: 1rem 0;
  text-align: center;
  font-size: 0.85rem;
  border-top: 1px solid;
}

.chapter-navi-section {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding-bottom: 10px;
}

.nav-link {
  color: inherit;
  text-decoration: none;
  opacity: 0.5;
  transition: opacity 0.3s ease, text-decoration 0.3s ease;
}

.nav-link:hover {
  opacity: 0.9;
  text-decoration: underline;
}

.prev { text-align: left; }
.toc-link { text-align: center; }
.next { text-align: right; }

.download-section {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 2rem;
  padding: 2rem 1rem;
  max-width: 600px;
  margin: 3rem auto;
  border-radius: 12px;
  box-shadow: 0 4px 10px rgba(0,0,0,0.05);
}

.download-info h2 {
  margin: 0 0 0.5rem;
  font-size: 1.2rem;
}

.format-label {
  margin: 0 0 0.5rem;
  font-size: 0.95rem;
}

.download-buttons {
  display: flex;
  gap: 1rem;
}

.download-button {
  background-color: #4A90E2;
  color: white;
  padding: 0.5em 1.2em;
  border-radius: 25px;
  font-size: 0.95rem;
  text-decoration: none;
  transition: background-color 0.3s ease;
}

.download-button:hover {
  background-color: #357ABD;
}

.code-block {
  position: relative;
  margin-bottom: 1em;
}

.copy-button {
  background: transparent;
  color: white;
  position: absolute;
  top: 8px;
  right: 8px;
  border: none;
  padding: 4px 8px;
  font-size: 12px;
  border-radius: 4px;
  cursor: pointer;
  z-index: 1;
}

.copy-button:hover {
  background-color: #0056b3;
}

.snippet-container {
  overflow: hidden;
}

.snippet-header {
  padding: 0.75rem 1rem;
  cursor: pointer;
  font-size: 1rem;
    background-color: #eeeeee;
    color:  #111111; 
    border-radius: 8px;
    cursor: pointer;
    box-shadow: 0 4px 6px rgba(0,0,0,0.1);  
}

.snippet-body {
  display: none;
  font-family: monospace;
}

.snippet-container.open .snippet-body {
  display: block;
}

.CodeMirror {
  border: 2px solid #ccc;
  border-radius: 4px;
  resize: vertical;
}

/* === Light Mode === */
html.light-mode {
  background-color: #f8f7f5;
  color: #333;
}

html.light-mode .container {
  background: white;
}

html.light-mode .book-title-chapter {
  color: #2c3e50;
  border-color: #ccc;
}
html.light-mode .book-subtitle-chapter{
  color: #888;
}

html.light-mode .page-footer,
html.light-mode .series-name,
html.light-mode .book-subtitle,
html.light-mode .format-label {
  color: #888;
}

html.light-mode .related-books h2 {
  color: #333;
  border-bottom: 2px solid #eee;
}

html.light-mode .book-title {
  color: #fff;
}

html.light-mode .book-cover {
  border: 1px solid #ccc;
}

html.light-mode th {
  background-color: #f2f2f2;
}

html.light-mode tr:nth-child(even) {
  background-color: #fafafa;
}

html.light-mode tr:hover {
  background-color: #e6f7ff;
}

html.light-mode a,
html.light-mode .page-footer a {
  color: #000;
}

/* === Dark Mode === */
html.dark-mode {
  background-color: #181818;
  color: #e0e0e0;
}

html.dark-mode .container {
  background: #222;
}

html.dark-mode .book-title-chapter {
  color: #ddd;
  border-color: #444;
}

html.dark-mode .snippet-header {
    background-color: #333;
    color:  #ddd; 
}


html.dark-mode .book-subtitle-chapter,
html.dark-mode .page-footer,
html.dark-mode .series-name,
html.dark-mode .book-subtitle,
html.dark-mode .book-footer,
html.dark-mode .format-label {
  color: #aaa;
}

html.dark-mode .related-books h2 {
  color: #ddd;
  border-bottom: 2px solid #333;
}

html.dark-mode .book-title {
  color: #fff;
}

html.dark-mode .book-cover {
  border: 1px solid #555;
}

html.dark-mode th {
  background-color: #333;
  color: #fff;
}

html.dark-mode td {
  border-color: #444;
}

html.dark-mode tr:nth-child(even) {
  background-color: #2a2a2a;
}

html.dark-mode tr:hover {
  background-color: #2c3e50;
}

html.dark-mode a,
html.dark-mode .page-footer a {
  color: #eee;
}

    .dialog-backdrop {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: rgba(0,0,0,0.5);
      display: none;
      justify-content: center;
      align-items: center;
      z-index: 10;
    }

    .dialog {
      background: white;
      padding: 20px;
      width: 90vw;
      height: 80vh;
      border-radius: 8px;
      box-shadow: 0 0 20px rgba(0,0,0,0.3);
      display: flex;
      flex-direction: column;
    }
    .dialog-content {
      display: flex;
      flex: 1;
      gap: 20px;
      margin-top: 10px;
    }
    .dialog h2 {
      margin-top: 0;
    }

    .textarea_dialog {
      width: 50%;
      height: 100%;
      resize: none;
      font-family: monospace;
      font-size: 14px;
      padding: 10px;
      box-sizing: border-box;
      border: 1px solid #ccc;
    }

    .iframe_dialog {
      width: 50%;
      height: 100%;
      border: 1px solid #ccc;
    }
    .controls_dialog {
      display: flex;
      justify-content: space-between;
      margin-top: 10px;
    }    
    button { padding: 0.5em 1em; background: green; color: white; border: none; cursor: pointer; }
    button:hover { background: #1e7e34; }
    .result_iframe { width:99%; height:200px; margin-top: 1em;  resize: both;border:1px solid #ccc;}        
</style>
</head>
<body> 
  <div class="container">
    <div class = "chapter-navi-section">
<a href="java-io-and-nio-working-with-character-sets-and-encodings.htm" class="nav-button prev">‚Üê</a>
<a href='java-io-and-nio.htm#practical-java-io-and-nio-examples' class="nav-button toc-link">Index</a>
<a href="java-io-and-nio-performance-and-tuning.htm" class="nav-button next">‚Üí</a>
</div>

    <h1 class="book-title-chapter" id = 'top'>Practical Java IO and NIO Examples</h1>
    <h3 class="book-subtitle-chapter">Java IO and NIO</h3>   
    <!-- <h1 class ="chapter-title"></h1> -->
    <h2 id='file-copying-and-moving'>10.1 File Copying and Moving</h2><p>File manipulation‚Äîcopying and moving files‚Äîis a common requirement in many Java applications, whether for backup, organization, or processing workflows. Java provides multiple APIs to accomplish these tasks: the traditional I/O streams (<code>FileInputStream</code>/<code>FileOutputStream</code>) and the modern NIO (<code>java.nio.file.Files</code>) utilities introduced since Java 7.</p><p>This tutorial covers both approaches with practical examples, explaining their differences, advantages, and use cases.</p><h3 id="traditional-io-approach-copying-files-using-streams">Traditional IO Approach: Copying Files Using Streams</h3><p>Before Java 7, the common way to copy a file was to open input and output streams and manually transfer bytes. This approach gives you low-level control but requires careful resource management and more code.</p><h3 id="copying-a-file-using-fileinputstream-and-fileoutputstream">Copying a File Using <code>FileInputStream</code> and <code>FileOutputStream</code></h3><div class="code-block"><button class="copy-button" onclick="copyCode(this)">üìã</button>
 <pre><code class="language-java">import java.io.*;

public class FileCopyTraditional {
    public static void copyFile(File source, File destination) throws IOException {
        try (FileInputStream fis = new FileInputStream(source);
             FileOutputStream fos = new FileOutputStream(destination)) {

            byte[] buffer = new byte[8192]; // 8KB buffer
            int bytesRead;

            while ((bytesRead = fis.read(buffer)) != -1) {
                fos.write(buffer, 0, bytesRead);
            }
        }
    }

    public static void main(String[] args) {
        File src = new File("source.txt");
        File dest = new File("destination.txt");

        try {
            copyFile(src, dest);
            System.out.println("File copied successfully using traditional IO.");
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}</code></pre>
</div><h3 id="explanation">Explanation</h3><ul>
 <li><code>FileInputStream</code> reads raw bytes from the source file.</li>
 <li><code>FileOutputStream</code> writes bytes to the destination file.</li>
 <li>The <code>buffer</code> temporarily stores chunks of bytes during transfer, improving efficiency.</li>
 <li>The <code>try-with-resources</code> statement ensures streams are closed automatically, avoiding resource leaks.</li>
 <li>This method works on any JVM version, but it requires manual buffer management and error handling.</li>
</ul><h3 id="moving-files-using-traditional-io">Moving Files Using Traditional IO</h3><p>Moving a file by streams requires copying the file contents and then deleting the original file:</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">üìã</button>
 <pre><code class="language-java">import java.io.*;

public class FileMoveTraditional {
    public static void moveFile(File source, File destination) throws IOException {
        copyFile(source, destination);  // Copy the file
        if (!source.delete()) {         // Delete the original file
            throw new IOException("Failed to delete original file: " + source.getAbsolutePath());
        }
    }

    // Reuse copyFile from previous example
    public static void copyFile(File source, File destination) throws IOException {
        try (FileInputStream fis = new FileInputStream(source);
             FileOutputStream fos = new FileOutputStream(destination)) {

            byte[] buffer = new byte[8192];
            int bytesRead;

            while ((bytesRead = fis.read(buffer)) != -1) {
                fos.write(buffer, 0, bytesRead);
            }
        }
    }

    public static void main(String[] args) {
        File src = new File("source.txt");
        File dest = new File("moved.txt");

        try {
            moveFile(src, dest);
            System.out.println("File moved successfully using traditional IO.");
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}</code></pre>
</div><h3 id="explanation">Explanation</h3><ul>
 <li>Move is done by copying and deleting the source file.</li>
 <li>This approach is less efficient and more error-prone because deletion might fail or leave duplicates.</li>
 <li>It does not handle atomic moves or filesystem-specific optimizations.</li>
</ul><h3 id="modern-nio-approach-using-java-nio-file-files">Modern NIO Approach: Using <code>java.nio.file.Files</code></h3><p>Java 7 introduced the NIO.2 package (<code>java.nio.file</code>), which simplifies file operations with the <code>Files</code> utility class. It provides methods such as <code>Files.copy()</code> and <code>Files.move()</code>, which are easier to use, safer, and more powerful.</p><h3 id="copying-files-using-files-copy">Copying Files Using <code>Files.copy()</code></h3><div class="code-block"><button class="copy-button" onclick="copyCode(this)">üìã</button>
 <pre><code class="language-java">import java.io.*;
import java.nio.file.*;

public class FileCopyNIO {
    public static void main(String[] args) {
        Path source = Paths.get("source.txt");
        Path destination = Paths.get("destination.txt");

        try {
            Files.copy(source, destination, StandardCopyOption.REPLACE_EXISTING);
            System.out.println("File copied successfully using NIO.");
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}</code></pre>
</div><h3 id="explanation">Explanation</h3><ul>
 <li><p><code>Files.copy()</code> copies the file content atomically when supported by the file system.</p></li>
 <li><p>The third argument is a varargs of <code>CopyOption</code>s:</p>
  <ul>
   <li><code>StandardCopyOption.REPLACE_EXISTING</code> overwrites the destination file if it exists.</li>
   <li>Other options include <code>COPY_ATTRIBUTES</code> (copy file metadata).</li>
  </ul></li>
 <li><p><code>Files.copy()</code> can also copy directories recursively with additional logic.</p></li>
 <li><p>It automatically handles resource management and buffering internally.</p></li>
</ul><h3 id="moving-files-using-files-move">Moving Files Using <code>Files.move()</code></h3><div class="code-block"><button class="copy-button" onclick="copyCode(this)">üìã</button>
 <pre><code class="language-java">import java.io.*;
import java.nio.file.*;

public class FileMoveNIO {
    public static void main(String[] args) {
        Path source = Paths.get("source.txt");
        Path destination = Paths.get("moved.txt");

        try {
            Files.move(source, destination, StandardCopyOption.REPLACE_EXISTING);
            System.out.println("File moved successfully using NIO.");
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}</code></pre>
</div><h3 id="explanation">Explanation</h3><ul>
 <li><code>Files.move()</code> moves or renames a file.</li>
 <li>It attempts to perform the move atomically if the file system supports it, which is faster and safer.</li>
 <li>You can specify options similar to <code>Files.copy()</code>, e.g., <code>REPLACE_EXISTING</code>.</li>
 <li>If moving across different file systems, it falls back to copy-and-delete, handling errors gracefully.</li>
</ul><h3 id="when-to-use-each-approach">When to Use Each Approach?</h3><table>
 <thead>
  <tr>
   <th>Feature</th>
   <th>Traditional IO (<code>FileInputStream</code> / <code>FileOutputStream</code>)</th>
   <th>NIO (<code>Files.copy()</code>, <code>Files.move()</code>)</th>
  </tr>
 </thead>
 <tbody>
  <tr>
   <td>Simplicity</td>
   <td>Verbose and manual</td>
   <td>Simple and concise</td>
  </tr>
  <tr>
   <td>Performance</td>
   <td>Buffer size configurable but requires manual code</td>
   <td>Optimized, atomic operations where supported</td>
  </tr>
  <tr>
   <td>Resource management</td>
   <td>Must manage streams explicitly</td>
   <td>Automatic and safer</td>
  </tr>
  <tr>
   <td>Atomic moves (rename)</td>
   <td>Not supported</td>
   <td>Supported if file system allows</td>
  </tr>
  <tr>
   <td>Metadata copying</td>
   <td>Not handled</td>
   <td>Supported (<code>COPY_ATTRIBUTES</code> option)</td>
  </tr>
  <tr>
   <td>Portability and modern API</td>
   <td>Legacy, less portable</td>
   <td>Modern, recommended since Java 7</td>
  </tr>
  <tr>
   <td>Error handling</td>
   <td>More complex to handle all corner cases</td>
   <td>Robust and consistent</td>
  </tr>
 </tbody>
</table><h3 id="summary-and-best-practices">Summary and Best Practices</h3><ul>
 <li>For <strong>new projects</strong>, always prefer NIO‚Äôs <code>Files.copy()</code> and <code>Files.move()</code>. These methods are simpler, safer, and usually more efficient.</li>
 <li>Use <strong>traditional IO</strong> only when you need explicit control over byte streams or need compatibility with very old Java versions.</li>
 <li>When using NIO, specify options like <code>StandardCopyOption.REPLACE_EXISTING</code> to control behavior explicitly.</li>
 <li>Handle exceptions gracefully, especially for moves, since atomicity depends on the underlying filesystem.</li>
 <li>Remember to consider permissions and filesystem differences when copying or moving files, especially across different volumes or network drives.</li>
</ul><h3 id="conclusion">Conclusion</h3><p>Copying and moving files in Java can be done either with low-level stream-based APIs or the modern NIO utilities. While traditional IO is still valid, NIO‚Äôs <code>Files</code> API is the recommended approach for most use cases, offering simplicity, reliability, and enhanced functionality.</p><p>By mastering both, you‚Äôll be equipped to handle file operations in any Java environment, ensuring your applications manipulate files efficiently and correctly.</p><div class = "chapter-navi-section">
<a href="#top" class="nav-button prev">‚Üë</a>
<a href='java-io-and-nio.htm#practical-java-io-and-nio-examples' class="nav-button toc-link">Index</a>
<a href="#bottom" class="nav-button next">‚Üì</a>
</div>
<h2 id='implementing-a-file-watcher'>10.2 Implementing a File Watcher</h2><p>Monitoring file system changes‚Äîsuch as file creation, modification, or deletion‚Äîis a common need in many applications, including logging systems, IDEs, synchronization tools, and auto-reloaders. Java‚Äôs NIO.2 API, introduced in Java 7, provides a powerful and efficient way to watch file system events through the <code>WatchService</code> API.</p><p>This guide walks you through implementing a file watcher step-by-step, explaining key concepts, and providing a complete, well-commented Java example.</p><h3 id="understanding-the-watchservice-api">Understanding the <code>WatchService</code> API</h3><p>The <code>WatchService</code> API allows you to monitor one or more directories for changes such as:</p><ul>
 <li><strong>ENTRY_CREATE:</strong> A new file or directory is created.</li>
 <li><strong>ENTRY_MODIFY:</strong> An existing file or directory is modified.</li>
 <li><strong>ENTRY_DELETE:</strong> A file or directory is deleted.</li>
</ul><p>The API works by:</p><ol>
 <li>Registering a directory (<code>Path</code>) with a <code>WatchService</code>.</li>
 <li>Listening asynchronously for events on the registered directory.</li>
 <li>Retrieving and processing the events as they occur.</li>
</ol><h3 id="step-1-obtain-a-watchservice">Step 1: Obtain a WatchService</h3><p>You create a <code>WatchService</code> from the file system's default provider:</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">‚ñØ</button>
 <pre><code class="language-Java">WatchService watchService = FileSystems.getDefault().newWatchService();</code></pre>
</div><p>This service will be used to register directories and poll for events.</p><h3 id="step-2-register-a-directory-with-the-watchservice">Step 2: Register a Directory with the WatchService</h3><p>You register a <code>Path</code> representing a directory with the <code>WatchService</code>, specifying which event kinds to watch:</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">‚ñØ</button>
 <pre><code class="language-Java">Path dir = Paths.get("path/to/directory");

dir.register(watchService, 
             StandardWatchEventKinds.ENTRY_CREATE,
             StandardWatchEventKinds.ENTRY_DELETE,
             StandardWatchEventKinds.ENTRY_MODIFY);</code></pre>
</div><p>You can register multiple directories if needed.</p><h3 id="step-3-poll-and-process-events">Step 3: Poll and Process Events</h3><p>Events are retrieved as <code>WatchKey</code> instances from the <code>WatchService</code>. You can use blocking or non-blocking polling:</p><ul>
 <li><code>watchService.take()</code> blocks until an event occurs.</li>
 <li><code>watchService.poll()</code> returns immediately, possibly returning <code>null</code> if no event is available.</li>
</ul><p>Each <code>WatchKey</code> contains one or more <code>WatchEvent</code>s, each describing an event kind and the affected file relative to the registered directory.</p><h3 id="complete-java-example-directory-file-watcher">Complete Java Example: Directory File Watcher</h3><div class="code-block"><button class="copy-button" onclick="copyCode(this)">üìã</button>
 <pre><code class="language-java">import java.io.IOException;
import java.nio.file.*;
import static java.nio.file.StandardWatchEventKinds.*;
import java.util.List;

public class DirectoryWatcher {

    public static void main(String[] args) {
        // Directory to monitor
        Path dir = Paths.get("watched-dir");

        // Create the watcher service
        try (WatchService watchService = FileSystems.getDefault().newWatchService()) {

            // Register the directory for CREATE, DELETE, and MODIFY events
            dir.register(watchService, ENTRY_CREATE, ENTRY_DELETE, ENTRY_MODIFY);

            System.out.println("Watching directory: " + dir.toAbsolutePath());

            // Infinite loop to wait and process events
            while (true) {
                WatchKey key;
                try {
                    // Wait for a key to be signaled (blocking call)
                    key = watchService.take();
                } catch (InterruptedException e) {
                    System.out.println("Interrupted. Exiting.");
                    return;
                }

                // Retrieve all pending events for the key
                List&lt;WatchEvent&lt;?&gt;&gt; events = key.pollEvents();

                for (WatchEvent&lt;?&gt; event : events) {
                    // Get event kind
                    WatchEvent.Kind&lt;?&gt; kind = event.kind();

                    // The context for directory entry event is the relative path to the file
                    WatchEvent&lt;Path&gt; ev = (WatchEvent&lt;Path&gt;) event;
                    Path filename = ev.context();

                    System.out.printf("Event kind: %s. File affected: %s%n", kind.name(), filename);

                    // You can add custom logic here, e.g. react to specific files
                }

                // Reset the key ‚Äî this step is critical to receive further watch events
                boolean valid = key.reset();
                if (!valid) {
                    System.out.println("WatchKey no longer valid, directory might be inaccessible.");
                    break;
                }
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}</code></pre>
</div><h3 id="explanation-of-the-code">Explanation of the Code</h3><ul>
 <li><p><strong>WatchService Creation:</strong> We create a new <code>WatchService</code> instance from the default filesystem.</p></li>
 <li><p><strong>Registering the Directory:</strong> The <code>dir.register()</code> method registers the directory and specifies the event kinds to monitor: create, delete, and modify.</p></li>
 <li><p><strong>Event Loop:</strong> The <code>while(true)</code> loop calls <code>watchService.take()</code>, which blocks until an event is available.</p></li>
 <li><p><strong>Processing Events:</strong> Each <code>WatchKey</code> may have multiple events; we iterate over them. Each event provides:</p>
  <ul>
   <li>The <strong>kind</strong> of event (<code>ENTRY_CREATE</code>, <code>ENTRY_MODIFY</code>, or <code>ENTRY_DELETE</code>).</li>
   <li>The <strong>context</strong> ‚Äî the relative path of the affected file/directory (relative to the registered path).</li>
  </ul></li>
 <li><p><strong>Resetting the Key:</strong> Calling <code>key.reset()</code> re-enables the key for further event notifications. If it returns <code>false</code>, the key is invalid, possibly because the directory was deleted or is inaccessible.</p></li>
 <li><p><strong>Exception Handling:</strong> IO exceptions and interruptions are handled gracefully.</p></li>
</ul><h3 id="important-notes-and-best-practices">Important Notes and Best Practices</h3><ul>
 <li><p><strong>Only directories can be registered.</strong> You cannot register individual files. To monitor multiple directories, register each one separately.</p></li>
 <li><p><strong>Events are relative paths.</strong> The event‚Äôs <code>context()</code> is relative to the directory registered, so combine it with the directory path if you need the full path.</p></li>
 <li><p><strong>WatchService behavior is platform-dependent.</strong> Some platforms may coalesce multiple events or behave slightly differently. For example, on Linux with <code>inotify</code>, modify events may trigger multiple times.</p></li>
 <li><p><strong>Long-running processes should handle interruptions gracefully.</strong> When shutting down the watcher thread, interrupting the thread waiting on <code>take()</code> is the recommended way to stop.</p></li>
 <li><p><strong>Performance considerations:</strong> For directories with heavy changes, events may be lost or coalesced. Monitor carefully for missed changes if that matters.</p></li>
 <li><p><strong>File renames:</strong> A rename may appear as a delete event followed by a create event.</p></li>
</ul><h3 id="extending-the-file-watcher">Extending the File Watcher</h3><p>You can extend the watcher to:</p><ul>
 <li><strong>Monitor multiple directories</strong> by registering each directory‚Äôs <code>Path</code> with the same <code>WatchService</code>.</li>
 <li><strong>React to specific files</strong> or patterns by adding conditional logic inside the event loop.</li>
 <li><strong>Run the watcher in a separate thread</strong> for non-blocking operation in GUI or server applications.</li>
 <li><strong>Use logging frameworks</strong> instead of <code>System.out.println</code> for production use.</li>
</ul><h3 id="summary">Summary</h3><ul>
 <li>Java NIO‚Äôs <code>WatchService</code> API provides an efficient way to monitor directories for file creation, modification, and deletion.</li>
 <li>You create a <code>WatchService</code>, register directories with it, and then loop, waiting for events.</li>
 <li>Handling the <code>WatchKey</code> and calling <code>reset()</code> is essential to continue receiving events.</li>
 <li>This approach is more efficient and cleaner compared to periodic polling for file changes.</li>
</ul><p>By following this guide and using the example code, you can implement your own directory monitoring solution in Java that responds in near real-time to file system changes.</p><div class = "chapter-navi-section">
<a href="#top" class="nav-button prev">‚Üë</a>
<a href='java-io-and-nio.htm#practical-java-io-and-nio-examples' class="nav-button toc-link">Index</a>
<a href="#bottom" class="nav-button next">‚Üì</a>
</div>
<h2 id='building-a-simple-http-server-with-nio'>10.3 Building a Simple HTTP Server with NIO</h2><p>Traditional Java networking with <code>ServerSocket</code> and <code>Socket</code> classes uses blocking IO, where a thread waits for each client. While simple, this doesn‚Äôt scale well with many concurrent clients because each connection consumes a thread.</p><p>Java NIO (New IO) introduced <strong>non-blocking IO</strong> and the <strong>selector pattern</strong> to handle many connections efficiently with a small number of threads. This tutorial walks you through creating a minimal HTTP server using NIO‚Äôs <code>ServerSocketChannel</code>, <code>SocketChannel</code>, and <code>Selector</code>.</p><h3 id="what-youll-learn">What Youll Learn</h3><ul>
 <li>How to open a <code>ServerSocketChannel</code> in non-blocking mode.</li>
 <li>How to create and use a <code>Selector</code> to multiplex multiple client connections.</li>
 <li>How to accept new client connections.</li>
 <li>How to read and parse simple HTTP requests.</li>
 <li>How to write basic HTTP responses.</li>
 <li>Understanding the non-blocking design pattern with selectors.</li>
</ul><h3 id="non-blocking-io-and-selector-overview">Non-blocking IO and Selector Overview</h3><p><strong>Non-blocking IO</strong></p><p>In non-blocking mode, read/write calls on channels <strong>do not block</strong> if the data is not immediately available. Instead, they return immediately with how much data was read or written. This means a single thread can:</p><ul>
 <li>Check which channels are ready for reading or writing.</li>
 <li>Read/write only the ready channels without blocking.</li>
 <li>Move on to check other channels.</li>
</ul><h3 id="selector">Selector</h3><p>A <strong>Selector</strong> allows a single thread to monitor multiple channels for IO events:</p><ul>
 <li>Channels register with the selector, specifying which operations they‚Äôre interested in (e.g., accept, read, write).</li>
 <li>The selector‚Äôs <code>select()</code> method blocks until one or more registered channels are ready for any of the requested operations.</li>
 <li>The thread processes ready channels and then calls <code>select()</code> again.</li>
</ul><h3 id="step-1-setting-up-the-serversocketchannel">Step 1: Setting up the ServerSocketChannel</h3><div class="code-block"><button class="copy-button" onclick="copyCode(this)">‚ñØ</button>
 <pre><code class="language-Java">ServerSocketChannel serverChannel = ServerSocketChannel.open();
serverChannel.bind(new InetSocketAddress(8080));
serverChannel.configureBlocking(false);  // Non-blocking mode</code></pre>
</div><ul>
 <li>Open the server socket channel.</li>
 <li>Bind it to port 8080.</li>
 <li>Set it to non-blocking mode to work with the selector.</li>
</ul><h3 id="step-2-creating-the-selector-and-registering-the-server-channel">Step 2: Creating the Selector and Registering the Server Channel</h3><div class="code-block"><button class="copy-button" onclick="copyCode(this)">‚ñØ</button>
 <pre><code class="language-Java">Selector selector = Selector.open();
serverChannel.register(selector, SelectionKey.OP_ACCEPT);</code></pre>
</div><ul>
 <li>Open a selector.</li>
 <li>Register the server socket channel with the selector for <strong>accept</strong> events (new incoming connections).</li>
</ul><h3 id="step-3-event-loop-with-selector">Step 3: Event Loop with Selector</h3><p>The server runs an event loop, calling <code>selector.select()</code> to wait for events, then handling each ready channel accordingly.</p><h3 id="step-4-accepting-connections-and-registering-client-channels">Step 4: Accepting Connections and Registering Client Channels</h3><p>When the server socket channel is ready to accept, you call <code>accept()</code>, configure the new socket channel as non-blocking, and register it with the selector for <strong>read</strong> events.</p><h3 id="step-5-reading-data-from-client-channels">Step 5: Reading Data from Client Channels</h3><p>When a socket channel is ready for reading, you read bytes into a buffer. For simplicity, we assume the request fits into one read. (In production, you'd accumulate and parse incrementally.)</p><h3 id="step-6-parsing-http-requests-and-writing-responses">Step 6: Parsing HTTP Requests and Writing Responses</h3><p>We parse the request line (e.g., <code>GET / HTTP/1.1</code>), ignore headers for simplicity, and respond with a simple HTTP 200 OK message with a plain text body.</p><h3 id="full-working-java-code">Full Working Java Code</h3><div class="code-block"><button class="copy-button" onclick="copyCode(this)">üìã</button>
 <pre><code class="language-java">import java.io.IOException;
import java.net.InetSocketAddress;
import java.nio.ByteBuffer;
import java.nio.channels.*;
import java.nio.charset.StandardCharsets;
import java.util.Iterator;
import java.util.Set;

public class SimpleNIOServer {

    private static final int PORT = 8080;
    private static final String RESPONSE_BODY = "Hello from NIO HTTP Server!";
    private static final String RESPONSE_TEMPLATE = 
        "HTTP/1.1 200 OK\r\n" +
        "Content-Length: %d\r\n" +
        "Content-Type: text/plain\r\n" +
        "Connection: close\r\n" +
        "\r\n%s";

    public static void main(String[] args) throws IOException {
        // Open server socket channel
        ServerSocketChannel serverChannel = ServerSocketChannel.open();
        serverChannel.bind(new InetSocketAddress(PORT));
        serverChannel.configureBlocking(false);

        // Open selector
        Selector selector = Selector.open();

        // Register server channel for accept events
        serverChannel.register(selector, SelectionKey.OP_ACCEPT);

        System.out.println("Server listening on port " + PORT);

        while (true) {
            // Wait for events
            selector.select();

            Set&lt;SelectionKey&gt; selectedKeys = selector.selectedKeys();
            Iterator&lt;SelectionKey&gt; iter = selectedKeys.iterator();

            while (iter.hasNext()) {
                SelectionKey key = iter.next();
                iter.remove();

                if (key.isAcceptable()) {
                    handleAccept(key, selector);
                }

                if (key.isReadable()) {
                    handleRead(key);
                }

                if (key.isWritable()) {
                    handleWrite(key);
                }
            }
        }
    }

    private static void handleAccept(SelectionKey key, Selector selector) throws IOException {
        ServerSocketChannel serverChannel = (ServerSocketChannel) key.channel();
        SocketChannel clientChannel = serverChannel.accept();  // Accept connection
        clientChannel.configureBlocking(false);

        System.out.println("Accepted connection from " + clientChannel.getRemoteAddress());

        // Register client channel for reading
        clientChannel.register(selector, SelectionKey.OP_READ, ByteBuffer.allocate(1024));
    }

    private static void handleRead(SelectionKey key) throws IOException {
        SocketChannel clientChannel = (SocketChannel) key.channel();
        ByteBuffer buffer = (ByteBuffer) key.attachment();

        int bytesRead = clientChannel.read(buffer);
        if (bytesRead == -1) {
            // Client closed connection
            System.out.println("Client closed connection: " + clientChannel.getRemoteAddress());
            clientChannel.close();
            key.cancel();
            return;
        }

        // Check if we have received a full HTTP request (simplistic check: look for double CRLF)
        String request = new String(buffer.array(), 0, buffer.position(), StandardCharsets.US_ASCII);
        if (request.contains("\r\n\r\n")) {
            System.out.println("Received request:\n" + request.split("\r\n")[0]);  // Print request line

            // Prepare response
            String response = String.format(RESPONSE_TEMPLATE, RESPONSE_BODY.length(), RESPONSE_BODY);

            // Attach response bytes to the key for writing
            key.attach(ByteBuffer.wrap(response.getBytes(StandardCharsets.US_ASCII)));

            // Change interest to write
            key.interestOps(SelectionKey.OP_WRITE);
        }
    }

    private static void handleWrite(SelectionKey key) throws IOException {
        SocketChannel clientChannel = (SocketChannel) key.channel();
        ByteBuffer buffer = (ByteBuffer) key.attachment();

        clientChannel.write(buffer);

        if (!buffer.hasRemaining()) {
            // Response fully sent; close connection
            System.out.println("Response sent. Closing connection: " + clientChannel.getRemoteAddress());
            clientChannel.close();
            key.cancel();
        }
    }
}</code></pre>
</div><h3 id="explanation-of-the-code">Explanation of the Code</h3><ul>
 <li><p><strong>ServerSocketChannel &amp; Selector:</strong> We create and bind a non-blocking server socket channel, then register it with a selector for accept events.</p></li>
 <li><p><strong>Event Loop:</strong> The server thread loops calling <code>selector.select()</code>, which blocks until events occur.</p></li>
 <li><p><strong>Accepting Connections:</strong> When <code>isAcceptable()</code> is true, a new client connection is accepted, configured as non-blocking, and registered for read events with a 1024-byte buffer attached.</p></li>
 <li><p><strong>Reading Requests:</strong> When a channel is readable, we read bytes into the buffer. We do a basic check for the end of the HTTP headers (double CRLF) in the buffer.</p></li>
 <li><p><strong>Parsing Request:</strong> For simplicity, we just print the first request line. Real servers would parse method, path, headers, and body.</p></li>
 <li><p><strong>Preparing the Response:</strong> We create a simple HTTP 200 OK response with plain text body. The response bytes are wrapped into a new <code>ByteBuffer</code> and attached to the key.</p></li>
 <li><p><strong>Writing Response:</strong> When the channel is writable, we write bytes from the buffer to the client socket channel.</p></li>
 <li><p><strong>Connection Close:</strong> After sending the response fully, the connection is closed and the key canceled.</p></li>
</ul><h3 id="key-points-about-non-blocking-design-pattern">Key Points About Non-blocking Design Pattern</h3><ul>
 <li><p><strong>Single-threaded, multiplexed IO:</strong> One thread manages multiple client connections, reacting only when channels are ready, avoiding busy waiting or many threads.</p></li>
 <li><p><strong>Stateful keys:</strong> Each <code>SelectionKey</code> holds state: a <code>ByteBuffer</code> for reading and later a buffer for writing response bytes.</p></li>
 <li><p><strong>InterestOps Switching:</strong> We switch interest ops between reading and writing as appropriate. When done writing, the channel is closed.</p></li>
 <li><p><strong>Efficiency:</strong> Non-blocking IO with selectors scales much better than one-thread-per-connection blocking IO, especially under many simultaneous connections.</p></li>
</ul><h3 id="how-to-run-and-test">How to Run and Test</h3><ul>
 <li>Compile and run the Java program.</li>
 <li>Open a browser or use <code>curl</code> to access <code>http://localhost:8080/</code>.</li>
 <li>You should see the response text <code>"Hello from NIO HTTP Server!"</code>.</li>
 <li>Multiple clients can connect concurrently with minimal threads.</li>
</ul><h3 id="limitations-and-next-steps">Limitations and Next Steps</h3><ul>
 <li><p><strong>Basic request parsing only:</strong> This server just reads until it sees <code>\r\n\r\n</code> and does not handle HTTP methods, headers, or request bodies.</p></li>
 <li><p><strong>No concurrency or thread pool:</strong> The single-threaded event loop handles all IO. For CPU-bound tasks, you may want a worker thread pool.</p></li>
 <li><p><strong>No HTTPS or advanced HTTP features:</strong> This is a minimal proof of concept.</p></li>
 <li><p><strong>Error handling:</strong> Production servers need more robust error handling and resource cleanup.</p></li>
</ul><h3 id="summary">Summary</h3><p>This tutorial demonstrated building a simple HTTP server using Java NIO‚Äôs non-blocking IO:</p><ul>
 <li>Open a <code>ServerSocketChannel</code> in non-blocking mode.</li>
 <li>Use a <code>Selector</code> to multiplex multiple connections efficiently.</li>
 <li>Accept new connections and register for reading.</li>
 <li>Read and parse basic HTTP requests.</li>
 <li>Write HTTP responses asynchronously.</li>
 <li>Close connections after response.</li>
</ul><p>With this foundation, you can explore building more advanced servers with richer HTTP support and better scalability.</p><div class = "chapter-navi-section">
<a href="#top" class="nav-button prev">‚Üë</a>
<a href='java-io-and-nio.htm#practical-java-io-and-nio-examples' class="nav-button toc-link">Index</a>
<a href="#bottom" class="nav-button next">‚Üì</a>
</div>
<h2 id='logging-and-debugging-io-operations'>10.4 Logging and Debugging IO Operations</h2><p>Input/output (IO) operations are fundamental to many Java applications‚Äîreading files, writing logs, communicating over networks, or processing streams. However, IO operations are often a common source of bugs and issues, such as silent failures, resource leaks, or encoding mismatches. Effective logging and debugging practices are essential to identify, diagnose, and fix these problems efficiently.</p><p>This section explores common IO issues, how to trace them, and how to implement logging strategies using Java‚Äôs built-in logging (<code>java.util.logging</code>) as well as the popular SLF4J facade, illustrated with IO-specific examples.</p><h3 id="silent-failures">Silent Failures</h3><p>A very frequent problem is when IO operations fail silently. For example, failing to close a stream due to swallowed exceptions or ignoring error return codes can cause resource leaks or data corruption.</p><h3 id="encoding-mismatches">Encoding Mismatches</h3><p>When reading or writing text files or network data, incorrect or inconsistent character encodings cause garbled text or data loss. For example, reading UTF-8 encoded data using ISO-8859-1 results in corrupted characters.</p><h3 id="buffering-and-partial-reads-writes">Buffering and Partial Reads/Writes</h3><p>Reading or writing in incorrect buffer sizes or misunderstanding the non-blocking nature of some channels can cause incomplete data processing or infinite loops.</p><h3 id="concurrency-and-resource-contention">Concurrency and Resource Contention</h3><p>Accessing the same file or stream from multiple threads without synchronization can lead to unpredictable behavior and hard-to-reproduce bugs.</p><h3 id="file-not-found-or-permission-issues">File Not Found or Permission Issues</h3><p>Common IOExceptions due to missing files or permission denied can halt program execution if not handled or logged properly.</p><h3 id="why-logging-is-important-in-io">Why Logging is Important in IO</h3><ul>
 <li><p><strong>Trace Errors and Exceptions:</strong> Logging stack traces and exception messages provides insight into the root cause of failures.</p></li>
 <li><p><strong>Monitor Resource Usage:</strong> Logs can indicate if streams or channels were properly closed.</p></li>
 <li><p><strong>Detect Encoding Issues Early:</strong> Logging the charset used during read/write helps ensure encoding consistency.</p></li>
 <li><p><strong>Track Data Flow:</strong> Debug logs can show what data was read/written, aiding in diagnosing corruption or unexpected input.</p></li>
</ul><h3 id="using-javas-built-in-logging-java-util-logging">Using Javas Built-in Logging (<code>java.util.logging</code>)</h3><p>Java provides a built-in logging API in the <code>java.util.logging</code> package. Here‚Äôs an example demonstrating logging around an IO operation with proper error handling:</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">üìã</button>
 <pre><code class="language-java">import java.io.*;
import java.nio.charset.Charset;
import java.util.logging.*;

public class LoggingIOExample {
    private static final Logger logger = Logger.getLogger(LoggingIOExample.class.getName());

    public static void readFile(String path, Charset charset) {
        logger.info("Starting to read file: " + path + " with charset: " + charset);

        try (BufferedReader reader = new BufferedReader(new InputStreamReader(new FileInputStream(path), charset))) {
            String line;
            while ((line = reader.readLine()) != null) {
                logger.fine("Read line: " + line);
            }
        } catch (FileNotFoundException e) {
            logger.log(Level.SEVERE, "File not found: " + path, e);
        } catch (IOException e) {
            logger.log(Level.SEVERE, "Error reading file: " + path, e);
        }

        logger.info("Finished reading file: " + path);
    }

    public static void main(String[] args) {
        // Set log level to show info and above; fine logs won't appear by default
        Logger rootLogger = Logger.getLogger("");
        rootLogger.setLevel(Level.INFO);

        readFile("example.txt", Charset.forName("UTF-8"));
    }
}</code></pre>
</div><h3 id="explanation">Explanation:</h3><ul>
 <li>Use <code>Logger.getLogger()</code> to create a logger for the class.</li>
 <li>Log entry and exit of important IO methods (<code>info</code> level).</li>
 <li>Log each line read with <code>fine</code> level (debug-level logs; can be enabled in detailed debug mode).</li>
 <li>Log exceptions with full stack traces using <code>logger.log(Level.SEVERE, message, exception)</code>.</li>
 <li>Properly close resources using try-with-resources.</li>
</ul><h3 id="configuring-logging-levels">Configuring Logging Levels</h3><p>By default, <code>java.util.logging</code> shows logs of level INFO and above. To see DEBUG-level logs (<code>FINE</code>), configure the logging level programmatically or via a properties file.</p><h3 id="using-slf4j-for-io-logging">Using SLF4J for IO Logging</h3><p>SLF4J (Simple Logging Facade for Java) is widely used in enterprise applications for flexible logging abstraction. SLF4J works with popular backends like Logback or Log4j.</p><h3 id="example-of-logging-io-operations-with-slf4j">Example of Logging IO Operations with SLF4J</h3><div class="code-block"><button class="copy-button" onclick="copyCode(this)">üìã</button>
 <pre><code class="language-java">import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.*;
import java.nio.charset.StandardCharsets;

public class Slf4jLoggingIOExample {

    private static final Logger logger = LoggerFactory.getLogger(Slf4jLoggingIOExample.class);

    public static void writeFile(String path, String content) {
        logger.info("Writing to file: {}", path);

        try (BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(path), StandardCharsets.UTF_8))) {
            writer.write(content);
            logger.debug("Written content length: {}", content.length());
        } catch (IOException e) {
            logger.error("Error writing to file: {}", path, e);
        }

        logger.info("Finished writing to file: {}", path);
    }

    public static void main(String[] args) {
        writeFile("output.txt", "Hello SLF4J IO logging!");
    }
}</code></pre>
</div><h3 id="key-points">Key Points:</h3><ul>
 <li>Parameterized logging (<code>{}</code> placeholders) avoids unnecessary string concatenation when logs are disabled.</li>
 <li>Separate log levels (<code>info</code>, <code>debug</code>, <code>error</code>) provide flexible control.</li>
 <li>Log exceptions with the exception object to get stack traces.</li>
 <li>SLF4J makes it easy to switch logging implementations without changing application code.</li>
</ul><p><strong>Debugging Tips for IO Issues</strong></p><h3 id="log-byte-buffers-and-content-dumps">Log Byte Buffers and Content Dumps</h3><p>When reading raw bytes (e.g., from network sockets or files), logging hex dumps or base64 representations of data helps spot corruption.</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">‚ñØ</button>
 <pre><code class="language-java">private static void logBufferContent(ByteBuffer buffer, Logger logger) {
    byte[] bytes = new byte[buffer.remaining()];
    buffer.get(bytes);
    String hexDump = javax.xml.bind.DatatypeConverter.printHexBinary(bytes);
    logger.debug("Buffer content (hex): {}", hexDump);
    buffer.position(buffer.position() - bytes.length); // reset position after reading
}</code></pre>
</div><h3 id="log-charset-details">Log Charset Details</h3><p>Always log which charset you are using to read or write text, as mismatches often cause hard-to-detect bugs.</p><h3 id="use-stack-traces-and-cause-chains">Use Stack Traces and Cause Chains</h3><p>IOExceptions often wrap root causes. Use <code>logger.log()</code> to print full stack traces and investigate nested exceptions.</p><h3 id="watch-for-resource-leaks">Watch for Resource Leaks</h3><p>Log when streams or channels are opened and closed to detect if resources are not properly freed.</p><h3 id="enable-more-verbose-logging-temporarily">Enable More Verbose Logging Temporarily</h3><p>In troubleshooting, increase log verbosity to <code>FINE</code> or <code>DEBUG</code> for IO classes or packages.</p><h3 id="summary">Summary</h3><ul>
 <li>IO operations are prone to subtle bugs like silent failures, encoding issues, and resource leaks.</li>
 <li>Effective logging is critical to surface and diagnose these problems.</li>
 <li>Use <code>java.util.logging</code> or SLF4J to log entry/exit points, data content, exceptions, and charset details.</li>
 <li>Employ parameterized logging and log at appropriate levels to avoid performance overhead.</li>
 <li>Always close resources safely and log their lifecycle events.</li>
 <li>Logging combined with careful exception handling and charset awareness will make your IO operations robust and easier to debug.</li>
</ul><p>By following these guidelines and using logging strategically, you can confidently trace and fix issues in Java IO code‚Äîturning black-box problems into understandable and manageable events.</p><div class = "chapter-navi-section">
<a href="#top" class="nav-button prev">‚Üë</a>
<a href='java-io-and-nio.htm#practical-java-io-and-nio-examples' class="nav-button toc-link">Index</a>
<a href="#bottom" class="nav-button next">‚Üì</a>
</div>
<h2 id='best-practices-for-efficient-io'>10.5 Best Practices for Efficient IO</h2><p>Input/output (IO) is a critical aspect of many Java applications, ranging from file processing to network communication. However, IO operations can become bottlenecks if not handled efficiently. Writing efficient IO code helps reduce latency, improve throughput, and conserve system resources.</p><p>This guide covers essential best practices to write performant and robust IO code in Java, with practical examples and tips.</p><h3 id="use-buffering-to-improve-performance">Use Buffering to Improve Performance</h3><p>Reading or writing data byte-by-byte or character-by-character is extremely inefficient because each call may result in an expensive system call.</p><h3 id="why-buffer">Why Buffer?</h3><ul>
 <li><strong>Reduce system calls:</strong> Buffering batches many small reads or writes into fewer larger ones.</li>
 <li><strong>Lower overhead:</strong> Less interaction with the underlying OS reduces context switches and CPU usage.</li>
</ul><h3 id="how-to-buffer-in-java">How to Buffer in Java?</h3><p>Java provides buffered wrappers:</p><ul>
 <li><code>BufferedInputStream</code> and <code>BufferedOutputStream</code> for byte streams.</li>
 <li><code>BufferedReader</code> and <code>BufferedWriter</code> for character streams.</li>
</ul><h3 id="example-buffered-file-copy">Example: Buffered File Copy</h3><div class="code-block"><button class="copy-button" onclick="copyCode(this)">üìã</button>
 <pre><code class="language-java">import java.io.*;

public class BufferedFileCopy {
    public static void copyFile(File source, File dest) throws IOException {
        try (BufferedInputStream bis = new BufferedInputStream(new FileInputStream(source));
             BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(dest))) {
            byte[] buffer = new byte[8192];  // 8KB buffer
            int bytesRead;
            while ((bytesRead = bis.read(buffer)) != -1) {
                bos.write(buffer, 0, bytesRead);
            }
        }
    }
}</code></pre>
</div><h3 id="performance-tip">Performance Tip:</h3><p>Use at least an 8KB buffer size (<code>8192</code> bytes) for disk IO; smaller buffers may increase overhead, while excessively large buffers waste memory and may cause GC pressure.</p><h3 id="always-use-try-with-resources-to-avoid-resource-leaks">Always Use Try-With-Resources to Avoid Resource Leaks</h3><p>Open IO resources (streams, readers, sockets) must be closed promptly to release system resources like file descriptors.</p><h3 id="why-avoid-leaks">Why Avoid Leaks?</h3><ul>
 <li>Unclosed resources can cause application slowdowns, file locking issues, or even crashes due to exhaustion of handles.</li>
</ul><h3 id="javas-solution-try-with-resources">Javas Solution: Try-With-Resources</h3><p>Since Java 7, the <strong>try-with-resources</strong> statement ensures automatic closing:</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">‚ñØ</button>
 <pre><code class="language-Java">try (BufferedReader reader = new BufferedReader(new FileReader("input.txt"))) {
    String line;
    while ((line = reader.readLine()) != null) {
        System.out.println(line);
    }
}  // reader is automatically closed here, even if exceptions occur</code></pre>
</div><p><strong>Avoid</strong> manual closing or ignoring exceptions in finally blocks. Try-with-resources is safer, cleaner, and less error-prone.</p><h3 id="choose-proper-buffer-sizes-based-on-context">Choose Proper Buffer Sizes Based on Context</h3><p>Buffer size affects latency and throughput:</p><ul>
 <li><strong>Too small:</strong> Frequent system calls degrade performance.</li>
 <li><strong>Too large:</strong> Wastes memory and may slow down GC, especially in memory-constrained environments.</li>
</ul><h3 id="general-recommendations">General Recommendations:</h3><ul>
 <li><strong>File IO:</strong> 8KB to 64KB buffers typically work well.</li>
 <li><strong>Network IO:</strong> Depending on the protocol, 4KB to 16KB buffers are common.</li>
 <li><strong>Memory-mapped files (NIO):</strong> Use buffers aligned to system page sizes (usually 4KB or 8KB).</li>
</ul><p>Experiment with buffer sizes using benchmarks specific to your workload.</p><h3 id="know-when-to-use-traditional-io-vs-nio">Know When to Use Traditional IO vs NIO</h3><h4 id="traditional-io-java-io">Traditional IO (<code>java.io</code>)</h4><ul>
 <li>Easier to use, great for simple tasks.</li>
 <li>Blocking by nature‚Äîeach call waits until data is ready.</li>
 <li>Uses stream-based APIs.</li>
 <li>Good for straightforward file reading/writing or small-scale applications.</li>
</ul><h4 id="nio-java-nio">NIO (<code>java.nio</code>)</h4><ul>
 <li>Non-blocking, scalable for high-concurrency scenarios.</li>
 <li>Uses channels, buffers, and selectors.</li>
 <li>Ideal for network servers or apps handling many simultaneous connections.</li>
 <li>Can perform memory-mapped file IO (<code>FileChannel.map()</code>) for large files with efficient OS paging.</li>
</ul><h4 id="choosing-between-them">Choosing Between Them</h4><table>
 <thead>
  <tr>
   <th>Scenario</th>
   <th>Recommended API</th>
  </tr>
 </thead>
 <tbody>
  <tr>
   <td>Simple file read/write</td>
   <td>Traditional IO</td>
  </tr>
  <tr>
   <td>High-performance, large files</td>
   <td>NIO FileChannel</td>
  </tr>
  <tr>
   <td>Network servers with many clients</td>
   <td>NIO with Selectors</td>
  </tr>
  <tr>
   <td>Low concurrency, simple apps</td>
   <td>Traditional IO</td>
  </tr>
 </tbody>
</table><h3 id="minimize-disk-or-network-io-when-possible">Minimize Disk or Network IO When Possible</h3><p>IO is often orders of magnitude slower than CPU and memory access. Minimizing the number of IO operations can drastically improve performance.</p><h3 id="strategies">Strategies:</h3><ul>
 <li><strong>Batch IO operations:</strong> Read/write larger blocks instead of many small chunks.</li>
 <li><strong>Cache data in memory:</strong> When data is reused frequently, avoid repeated disk/network access.</li>
 <li><strong>Avoid unnecessary flushes:</strong> Flushing buffers too frequently forces OS-level writes.</li>
 <li><strong>Use lazy loading:</strong> Only load data when necessary.</li>
 <li><strong>Compress data:</strong> To reduce the amount transferred over networks or stored on disk.</li>
</ul><h3 id="use-direct-byte-buffers-with-nio-for-network-io">Use Direct Byte Buffers with NIO for Network IO</h3><p>Java NIO provides <strong>direct byte buffers</strong> (<code>ByteBuffer.allocateDirect()</code>) that allocate memory outside the JVM heap and can improve IO performance by avoiding an extra copy between Java heap and OS buffers.</p><h3 id="example">Example:</h3><div class="code-block"><button class="copy-button" onclick="copyCode(this)">‚ñØ</button>
 <pre><code class="language-java">ByteBuffer buffer = ByteBuffer.allocateDirect(8192);</code></pre>
</div><p>Use direct buffers cautiously‚Äîthey are more expensive to create and clean up, but beneficial for long-lived buffers in high-performance networking.</p><h3 id="avoid-blocking-calls-in-critical-threads">Avoid Blocking Calls in Critical Threads</h3><p>If you use traditional IO in UI or event-driven applications, blocking calls can freeze the program.</p><ul>
 <li>Use asynchronous IO (<code>AsynchronousFileChannel</code>, <code>AsynchronousSocketChannel</code>).</li>
 <li>Offload blocking IO calls to separate worker threads.</li>
</ul><h3 id="examples-combining-best-practices">Examples Combining Best Practices</h3><h4 id="reading-a-text-file-efficiently">Reading a Text File Efficiently</h4><div class="code-block"><button class="copy-button" onclick="copyCode(this)">üìã</button>
 <pre><code class="language-java">import java.io.*;
import java.nio.charset.StandardCharsets;

public class EfficientFileReader {

    public static void readFile(String path) {
        try (BufferedReader reader = new BufferedReader(
                new InputStreamReader(new FileInputStream(path), StandardCharsets.UTF_8))) {
            String line;
            while ((line = reader.readLine()) != null) {
                // Process line
                System.out.println(line);
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}</code></pre>
</div><ul>
 <li>Uses buffering (<code>BufferedReader</code>).</li>
 <li>Specifies charset explicitly.</li>
 <li>Uses try-with-resources for safety.</li>
</ul><h4 id="writing-to-a-network-socket-with-nio">Writing to a Network Socket with NIO</h4><div class="code-block"><button class="copy-button" onclick="copyCode(this)">üìã</button>
 <pre><code class="language-java">import java.io.IOException;
import java.net.InetSocketAddress;
import java.nio.ByteBuffer;
import java.nio.channels.SocketChannel;

public class NIONetworkWriteExample {

    public static void sendMessage(String host, int port, String message) throws IOException {
        try (SocketChannel socketChannel = SocketChannel.open()) {
            socketChannel.connect(new InetSocketAddress(host, port));
            socketChannel.configureBlocking(true);

            ByteBuffer buffer = ByteBuffer.allocate(1024);
            buffer.put(message.getBytes());
            buffer.flip();

            while (buffer.hasRemaining()) {
                socketChannel.write(buffer);
            }
        }
    }
}</code></pre>
</div><ul>
 <li>Allocates a properly sized buffer.</li>
 <li>Uses try-with-resources.</li>
 <li>Writes entire message in a loop to ensure complete transmission.</li>
</ul><h3 id="summary-of-best-practices">Summary of Best Practices</h3><table>
 <thead>
  <tr>
   <th>Practice</th>
   <th>Why It Matters</th>
  </tr>
 </thead>
 <tbody>
  <tr>
   <td>Use buffering</td>
   <td>Reduces costly system calls, improves throughput</td>
  </tr>
  <tr>
   <td>Use try-with-resources</td>
   <td>Prevents resource leaks, simplifies cleanup</td>
  </tr>
  <tr>
   <td>Choose appropriate buffer sizes</td>
   <td>Balances memory use and IO efficiency</td>
  </tr>
  <tr>
   <td>Pick IO vs NIO based on need</td>
   <td>Simplifies code or enables scalability</td>
  </tr>
  <tr>
   <td>Minimize IO operations</td>
   <td>Reduces latency and resource consumption</td>
  </tr>
  <tr>
   <td>Use direct buffers for NIO</td>
   <td>Enhances performance in networking and large file IO</td>
  </tr>
  <tr>
   <td>Avoid blocking calls on main threads</td>
   <td>Keeps UI and event loops responsive</td>
  </tr>
 </tbody>
</table><p>By following these best practices, you can write IO code in Java that is not only functionally correct but also efficient and scalable‚Äîhelping your applications run smoothly in real-world environments.</p><div class = "chapter-navi-section">
<a href="java-io-and-nio-working-with-character-sets-and-encodings.htm" class="nav-button prev">‚Üê</a>
<a href='java-io-and-nio.htm#practical-java-io-and-nio-examples' class="nav-button toc-link">Index</a>
<a href="java-io-and-nio-performance-and-tuning.htm" class="nav-button next">‚Üí</a>
</div>
<section class="download-section">
  <div class="book-cover" style="background-color: #f9f6f1;border: 1px solid #ccc;"> 
    <div class="book-cover-title" style="font-size: 18px;color: #333;top: 20px;">Java IO and NIO</div>
    <div class="book-cover-author">readbytes</div>
    <div class="book-cover-bottom-stripe" style="background-color: #333;"></div>
    <img class="book-cover-icon" style="width: 80px;height: 90px;top: 60px;" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFoAAABaCAYAAAA4qEECAAADAElEQVR4Xu2Zu6oTURSGjze0UfANtLAUzgOI4DOItc+VKk1uJ12aadNa21vbCpYK4wQmcPiYzL5k7eXM2f8HP0JYa/3ZX2PEmxshxAPi7u6uLRH2VA3lWId9VdK27WOKsQ47q6RpmucUYx12VolEOyHRToyJ5mwI7ufeeZBItBMS7YREOyHRTki0ExLthEQ7IdFOSLQTEu2ERDsxJtoq7KwSiXZCop04Ho9PKcY67KwWirEO+6qGcqzCHhGBJDoh0U5ItAP7/f6bRDtAyV3+ckYYQNHr9fo1Z8SVtG37iKI5Mzv4IKuwJwXeuvbef4ePsQ77YuGdLp85MysGHmQa9sXAG7l3JgUfZB32heh+0t3yRvfZD87NDj7KOuwLwf2cG5OEj7IO+8bg7imr1eoV55Lh0VC4bwE7cru4n3Jns9l85d7YPmdCSV8oADtyu7gfe4fzMbucCyV9oQDsyO3i/tid7i+395xjuHMfzoaSvlAAduR2cf/+ne7PT/x8JL94mwzsjCZ5wTN8XAjuTynT/nKJcH9KmfaXS4T7U8q0v1wi3J9Skr8cH3cJ7l3I98Ph8HLg86SuM9zPvRMDO0JJXwjQ/Wx6yx3kI3cGZqK6CPdz78TAjlDSF0ZYLpcvOH9O0zQX/xnL2ZiuIbifeycGdoSSvjACZ2N2TnA+do9wP/dODOwIhfvZ8HCfn5wbYmDPNOybLXxYn9+cu8TArmnYN1v4sNTHcdc67JslfFTOw7hvHfbNEj6q+3n3gTMheMM67JsdfNA1j+Idq7BnlvBR2+32DWfElazX63cUzRlhACVLdCEk2QmJdmC3232RaAcoucsfzogAAxJNwp6qoRzrsK9aKMY6i8XiGTurhGKsc/ofGHZWCcVYR6J7KMY6Et1DMedwLgT3JRpQjEQXgmIkuhAUI9GFoBiJLgTFSHQhKEaiC0ExEl0IipHoQlCMRBeCYiS6EBQj0YWgGOtIdA/FWEeieyjGOhLdQzHW2e/3T9hZJRRjHfZVDeVYhT1CiDnzD27IzgFe/xOvAAAAAElFTkSuQmCC"/>
  </div>
  <div class="download-info">
    <h2 id='bottom'>Download This Ebook</h2>
    <p class="format-label">Available formats:</p>
    <div class="download-buttons">
      <a href="java-io-and-nio.pdf" class="download-button">üìÑ PDF</a>
      <a href="java-io-and-nio.epub" class="download-button">üìò EPUB</a>
    </div>
  </div>
</section><div class='related-books'>
<h2>Java In-Depth Books</h2>
<div class='related-book-list'>
<a href="java-io-and-nio.htm">
<div class="book-cover" style="background-color: #f9f6f1;border: 1px solid #ccc;"> 
    <div class="book-cover-title" style="font-size: 18px;color: #333;top: 20px;">Java IO and NIO</div>
    <div class="book-cover-author">readbytes</div>
    <div class="book-cover-bottom-stripe" style="background-color: #333;"></div>
    <img class="book-cover-icon" style="width: 80px;height: 90px;top: 60px;" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFoAAABaCAYAAAA4qEECAAADAElEQVR4Xu2Zu6oTURSGjze0UfANtLAUzgOI4DOItc+VKk1uJ12aadNa21vbCpYK4wQmcPiYzL5k7eXM2f8HP0JYa/3ZX2PEmxshxAPi7u6uLRH2VA3lWId9VdK27WOKsQ47q6RpmucUYx12VolEOyHRToyJ5mwI7ufeeZBItBMS7YREOyHRTki0ExLthEQ7IdFOSLQTEu2ERDsxJtoq7KwSiXZCop04Ho9PKcY67KwWirEO+6qGcqzCHhGBJDoh0U5ItAP7/f6bRDtAyV3+ckYYQNHr9fo1Z8SVtG37iKI5Mzv4IKuwJwXeuvbef4ePsQ77YuGdLp85MysGHmQa9sXAG7l3JgUfZB32heh+0t3yRvfZD87NDj7KOuwLwf2cG5OEj7IO+8bg7imr1eoV55Lh0VC4bwE7cru4n3Jns9l85d7YPmdCSV8oADtyu7gfe4fzMbucCyV9oQDsyO3i/tid7i+395xjuHMfzoaSvlAAduR2cf/+ne7PT/x8JL94mwzsjCZ5wTN8XAjuTynT/nKJcH9KmfaXS4T7U8q0v1wi3J9Skr8cH3cJ7l3I98Ph8HLg86SuM9zPvRMDO0JJXwjQ/Wx6yx3kI3cGZqK6CPdz78TAjlDSF0ZYLpcvOH9O0zQX/xnL2ZiuIbifeycGdoSSvjACZ2N2TnA+do9wP/dODOwIhfvZ8HCfn5wbYmDPNOybLXxYn9+cu8TArmnYN1v4sNTHcdc67JslfFTOw7hvHfbNEj6q+3n3gTMheMM67JsdfNA1j+Idq7BnlvBR2+32DWfElazX63cUzRlhACVLdCEk2QmJdmC3232RaAcoucsfzogAAxJNwp6qoRzrsK9aKMY6i8XiGTurhGKsc/ofGHZWCcVYR6J7KMY6Et1DMedwLgT3JRpQjEQXgmIkuhAUI9GFoBiJLgTFSHQhKEaiC0ExEl0IipHoQlCMRBeCYiS6EBQj0YWgGOtIdA/FWEeieyjGOhLdQzHW2e/3T9hZJRRjHfZVDeVYhT1CiDnzD27IzgFe/xOvAAAAAElFTkSuQmCC"/>
  </div>
</a>


<a href="java-collections.htm">
<div class="book-cover" style="background-color: #f9f6f1;border: 1px solid #ccc;"> 
    <div class="book-cover-title" style="font-size: 18px;color: #333;top: 20px;">Java Collections</div>
    <div class="book-cover-author">readbytes</div>
    <div class="book-cover-bottom-stripe" style="background-color: #333;"></div>
    <img class="book-cover-icon" style="width: 80px;height: 90px;top: 60px;" src='data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFoAAABaCAYAAAA4qEECAAADAElEQVR4Xu2dQYrUUBRFIw50JI7FrYgrcAPOXYPORHci7sah4EAQFyA6dNKosZK2Ee8/dOclP7/+i/fAmaR+Xr17KehJV2oYjDHGGGM6YRxzmgZdPKvdMt4vl03vLU15ZsYnsORB7Apd7mh2gS51VM/K+LVc6LA+0/QNKZax9RnvlG+C/tI7+6PYuYLV0MHoc72rX8ZvsP9Gq6BDyWzo/jXcjA4sfKN39E+RoYaf9F2CFAPFjGiG3b0Y5r9111LcJGZEM7QW0UNqRjTDWXwQXCojmoEk9MxmHwWGZ0QzkMT4ujy31b/D4UU8uITp/J4uRDOQxPiyPFfDy+HwQnFoCdPZFi5AM5BE/0VP51r5brgRzUASexU9/piG60VxEdO5lt6AZiCJ3Yoep+Fw8Z8DS5gHNfLncCOagSSWFE2M38tzanFBXcS9k/OwBi5AM5DE2qIn9JxaXFAXM33S5oE7+nFYhGYgiRxFX7FH4V+GEJqBJHIV3QGagSRcdBDNQBIuOohmIAkXHUQzkISLDqIZSMJFB9EMJOGig2gGknDRQTQDSbjoIJqBJHIUfffkPLCC74dNaAaSyFH0PKyiL4bVaAaS6L/oedAOrkQzkISLDqIZSMJFB9EMJNF/0bdPzsMquxLNQBL9Fz3x4eQ8sJIb0AwkkaPoK56efLvSV0MVNANJ5Cq6AzQDSbjoIJqBJFx0EM1AEi46iGYgCRcdRDOQhIsOohlIwkUH0Qwk4aKDaAaScNFBNANJuOggmoEkXHQQzUASLjqIZiAJFx1EM5CEiw6iGUjCRQfRDCSxtuh2X63oDM1AEkuKXmtxQc2IZiCJ3Yqu9vW3ztAMJLFX0ZfD4YXiUDI0A0m46CCagSTyfOm+EzQDSeiZzT4ODM+IZjiLD4NLZUQztBbRQ2pGNMPu1nh4lR/H9sfP+i5BioFgNnT/Gm5GB6Ib/im8Nf0+MtMPgb3Wquhwqw1Vwg/qbkix0EHtAl3qaHaDfx6kIf7Bm8YUyyY1Dbp4Fo0xxhhj/kd+A/PkOH57kF8HAAAAAElFTkSuQmCC'/>
  </div>
</a>


<a href="java-regex.htm">
<div class="book-cover" style="background-color: #f9f6f1;border: 1px solid #ccc;"> 
    <div class="book-cover-title" style="font-size: 18px;color: #333;top: 20px;">Java Regex</div>
    <div class="book-cover-author">readbytes</div>
    <div class="book-cover-bottom-stripe" style="background-color: #333;"></div>
    <img class="book-cover-icon" style="width: 80px;height: 90px;top: 60px;" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFoAAABaCAYAAAA4qEECAAAFo0lEQVR4Xu2d3WscVRiH+y/YXuuFkov6H9je2huvlAQvFalCEW8qiFRFQcGrmoJ4U5TSLWglFqRIlJqCH6XWalM/0lrT1O1ukt3sV5qPTZrP3XHfLTM983vPztc5s+zZPQ88N5l3Z9inwzA70Dl79iQks29oM7N3yBkoW98ZO6RC62ANdvDBtYF9lJEcxHNi+CWnOvmXs5rN9aX03eg74vcWxV6xObX3iUdxp2P7DzqDztiTB1lsaoX9InF631BJ3NH408N4vIFn/NCwL/aZVjPsGAj+a1mCwV7YUwqeyZZoxDqz8ZpsiYfY7mzQNdtGVkdsiH3b2Mj6CIztbrB3F+qMHxqRh84Iv/gsehDO6oe/IN0/ju0/gPOWhNAPO3ZW27M5HXyhTwtP4Sx68S4f9NRPuJbgnEURsa0Xmp5QWfQyMfLwqZ8XunrtT5yzKEKPWFnoem4O5xKxsVbS5vbmMu7eKOr5OUnovHro1ep0KppKPT+vP/TGWpkF0qWp2NBdwobuEjY0MnXbcb4cd5xCGbco0XOhb8wuOhdnGp4//7fl254ah9/urAZ6KrQYGL01V0sndLPJw8pUxJjQ5OXsBh5KjVZjFjRIBXoqdKWcZXHRK/kGHi45GDJMBXoqNFku3WVx0V9nNcTGiK7nLgRvT0jPhSZLacfGeK7Xb4bPJaQnQz+InWNx0USXEQzn+vsUTvKZfgxNFhfyLC4a68x+7QMejrwieVqJM+QX3+BUZHo6NDlfnGNx0auzdPsQAQxHXprEKT7jqkDPhyZni/MsLhopNoY7kcEJPuN6bBQnY2FEaDJXLLC4aGhsjIfgdtdX3sHJ2BgTmswVwmMHXrMxoBgb/+76snpkwqjQZKnusLhox7uRryd4yDA1YVxoYmG1yeKi0jP7nzs8ZJAaMTI0UVhJEPvN4zxmJzVjbGhidik8tu8ygjE7mQJGha7XZvBQTnYxPHb7zF6o8qAyU8KY0Gv37uJhPGZq4bEXpnI8KpoiRoTe3lzBQzCmq51j59aabSu/3OBxSU23cEH0fOgHT+ej8W+Fx3Yju9YuXO16ZCKV0DvVSWfrzlnm+tyP/pCVW2xGNAlibIzsunT+p65GJroamhRD4zbVyC7TFR4XXf7qIn4sVVIJ3bj9meNce0OqGLM5+Rbb7jMhePmQWXzqWWf15Of40dRIJfTmwmV2hiY1LhhUJkV2Xfn4FO4iFXo+NBkVDCpTjOzFPvEp7ko7RoQmw8CgMjGw6PJourGNCU12AoPKXHpvlMVFl4+fxF1rw6jQJIJBZbpgWJnLH34i7F0fxoamnzEYVKZI6ZkXWViZS+9+5PucDowNjUFlIlt/3GRRO7n4+vv4cSWMDI1BZcpYP/89Cxpk7cgx3EVijAuNQWV2AkOSbZpN9nfX6uHkP5xE+i50EBgRwe1e7BeO4mhs+ip0GBjw/nc/4AibCZqNQ9+EjgLGI50G/yzOeLMK9EXoqBQPPMfixYm9cek3HIuM8aHjgvFcmzs7OMpm2v8oCTE6dBJ2q/dYPC/29rZvFrcPZGgVdss1FtCLvX6/PVN5/lW2beBC62C3VGURw2z/D66EGBdaJ7vFMosZpAoDHZqIGluVgQ/dJuAnuI7IhA0NVEaOtOMuHrVP74zEhu4SNnSXkIdWfHnVbr3AAunSVOjkZaF1vI4NA+nQZKSvY7MvGNSP9AWDpEUvYlv7EtgU8UK7Sz/Z0Ongnc34/mi7apA+xNWHxND21fOa8S4buHiZu4GWJbKo8W2nxRTE0PasVkdsiZ3b2NjqhEYmaNkhGzs5Yrszjzz+GPb1QQtq2djxEZu17pvL2FWK70M2dijYC3sGgmc2LUtk8SPeXcQ6kxFcdo+kG/FBR+tSqCK4U1F6QlW7/rezms33pfTdxKdwMrGXMhm7XLWo/uWqZdgF2OPxPxXwJpKIkhiiAAAAAElFTkSuQmCC"/>
  </div>
</a>


<a href="java-functional-programming.htm">
<div class="book-cover" style="background-color: #f9f6f1;border: 1px solid #ccc;"> 
    <div class="book-cover-title" style="font-size: 18px;color: #333;top: 20px;">Java Functional Programming</div>
    <div class="book-cover-author">readbytes</div>
    <div class="book-cover-bottom-stripe" style="background-color: #333;"></div>
    <img class="book-cover-icon" style="width: 80px;height: 80px;top: 80px;" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFoAAABaCAYAAAA4qEECAAADzUlEQVR4Xu2bO4sUURCFlxVBzfwLJkb+A1MxEgMRDBQDRTBRwchARk00MRFBAwNBzEQwMBfEBz7wbWIkiIGJoInio9wZdmZ7T1V3V91bPVhaH3xJ973n3jk2vdO968JCkiRJkiRRIYphWOgI/zB/uyHBDxHFUODmIxkK3HwkQ4Gbj2QY6BDffCTDgBuPZhhw49EMA248miGgW3zj0QwBbjqiIcBNRzQEuOlohoA+8Y1HMgy4cauJEizO5EZMS0RoUSjPYKIEi7OaKMHirCZKsDiTi5iWiNAmoTyDiRIszmqiBIsz+QXTklZYeQYTJXSUl2cxUYLFWU2UYHEmb2Na0gorz2CihJ7w8iwmSrA4q4kSLM7kYUxLWmHlGUyU0C9ensVECRZnNQS4abPPMNEOy7S4BdN00L5GxmU8q4cuNXL24tll2KYrLIXW8yyLJdAJnkP3cFQ/9FzIGeEgHOBgCZhh1Qod5xkzH+PoduiVMH/qqDkQT3q4trGAEpZh1AId4/OZb3EWh14K89DRdDCecNIKzjdp+IelHcL8Nj/g7BU6r2R0+3gCHvRyN26tHdoszDdoAef2KpQt3pN7ZAc81YLzrFrAuSrfNOY/Es4rZAdcfbCywS7YPIvfMa0buiBkaFz6ATn+POy4xmvjhfGgsxpwjsUSigsr8el0UTzh7c9Vn5FBe4Q5BkuZXKFCnqsPmwviyQHsAsdarWF8tWGem/dxMRwwkG3gOJMvMM1O7S8aRJtX8hQ2aCDbwHEWvXAte3pPlmCDBxKhK3yMRU9cbiOKp0k+aQg3+K7pTdUPyHeYVgELL9At7/zqLA9KH0YmNh5qqqHPwgJWLzby8JxBb1y+Wxve+vXCwguc5Lzmxy164lLy1IL32SJ0Qwi3+k04ZtSLqttFm3dxlUJY8Lzdijsqo+QtnFqPK5u2CcFz1APT++RSPe7ZLHSO1qL6zYiXmu/WXdAaIXRO1lD8mnSpsOKHmpu4CyMscB5W/m8rlqex8TBS+lBTDQYObS2Y16vwxFfydbAaDBzaWmgXz2y14/46fg3Kxre5E2cXwoKH8geuXIb4hzNo11u4ZVRX9kmcVQELH0hP6BTPnym9T26h8559Gkc7wBYZQG/oLF+D/WZEgfht5AyOcoLeC4s5OwR0oLHGVTyrh643cvbjWWewGFc/4mr/MXRQKMjJBMCCvEwAWsdL8jARwJKqvYMrJDNYWRUmHWBZNSY9YGGlJj1gYUWew9REhBVnNFFCX3l5FhMDWJ7WpAAssc+kAiyzzcQJLHbibxyVJEmSJMk/xB+4wdarC+OVAQAAAABJRU5ErkJggg=="/>
  </div>
</a>


<a href="java-streams.htm">
<div class="book-cover" style="background-color: #f9f6f1;border: 1px solid #ccc;"> 
    <div class="book-cover-title" style="font-size: 18px;color: #333;top: 20px;">Java Streams</div>
    <div class="book-cover-author">readbytes</div>
    <div class="book-cover-bottom-stripe" style="background-color: #333;"></div>
    <img class="book-cover-icon" style="width: 80px;height: 80px;top: 60px;" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFoAAABaCAYAAAA4qEECAAACbklEQVR4Xu3cP4oUQRiG8S8xEzESDI1MPIRHEQQPYTK9iCyewMxrGIiCoaFnWFkMTIwUxD894KI8VbNdVdNfzdR87w+eRKa2ul+WVZM1G8+3ud+d+mhBvbZ0DO/uWEAcoVfhcIBehcQRvAvt1dz7gjjaVfxcrhcmxTiwvkudcGAN7YQDa2gnHFhDO+HAGtoJB24ZmmdzhcdBWobh2VzhcZCWYXg2V3gcpGUYns0VHgdpGYZnc4XHQVqG4dlc4XGQlmF4Nld4HKRlGJ7NFR4HaRmGZ3MN48Hcu7lLS19ihI7SPUsfdPSOCh/ulDoKfKhT7KC2P3P5QKfawfBBTr2D4ENEqDs+QJS64uWR6ubc0ssj1Q0vjlYXvLS1X3Mv5x7NPTyi+Jy5uuClNY2Az5zL3RtLLy1pJHz2XO544VLbHw+j4TvkcscLlxoR3yGXO154XaPie+Ry9djSC69rVHyPXK62/xTjhbu6+HtmRHyXXK6iDH1wGroTDd2Jhu5EQ3eioTvR0J1o6E40tAMOt1YCHGitBDjQWglwoLUS4EBrJcCB1kqAA62VwFOnREREROSIPbP7/CNZ28Y+2KT/hPjbjnyVOPl/ZA3tZLLzZGiN7YAD/+smPyqt0nH1Xe2Cw7LndpdHpBZH3ZXs4YndSAbdleyBYy4ljTjkUtKAI5a0sS/8MrKEI5YmFTZ2mQxYmlTgeDVt7DO/nOzC8WqTApPdSoarTQpM9ikZrjYpMNmPZLjapMDZ/JcZh6tNCkx2OxmuNinE4WraDPnbZw5ksp/JgKVJJQ5YmjTgiEvJHib7mgyaS1Yy2dtk3DP7zo9F9wfJyGVFhM8g5gAAAABJRU5ErkJggg=="/>
  </div>
</a>



<a href='java.htm'><div class='book-cover' style='background-color: #f9f6f1;color: #111111;border: 1px solid #ccc;display: flex;justify-content: center;align-items: center;text-align: center;'>More Java Books</div></a>
</div>
</div>
  </div>
  <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/prism.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
  
  <script>
    function copyCode(button) {
      const code = button.nextElementSibling.innerText;
      navigator.clipboard.writeText(code).then(() => {
        button.textContent = 'Copied!';
        setTimeout(() => { button.textContent = 'Copy'; }, 1500);
      });
    }
  </script>  
<div id="floatingLog" aria-live="polite" role="alert"></div>
<footer class="page-footer">
    <nav>
      <a href="https://readbytes.github.io">Home</a> | 
      Email:<script language="JavaScript" type="text/javascript">
var part1 = 'yinpeng';var part6 = '263';var part2 = Math.pow(2,6);var part3 = String.fromCharCode(part2);var part4 = 'hotmail dot com';var part5 = part1 + String.fromCharCode(part2) + part4;document.write(part1 + part6 + part3 + part4);
</script>
    </nav>
  <p>¬© 2025 ‚Äî All rights reserved.</p>    
  </footer>

</body>
</html>