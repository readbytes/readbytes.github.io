<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>C++ for Beginners Pointers and References</title>
<link rel='shortcut icon' href='https://java2s.com/style/favicon.ico'>
<link href="https://fonts.googleapis.com/css2?family=Merriweather&display=swap" rel="stylesheet" />
<link href="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet" />


  <script>
  const mode = localStorage.getItem('mode') || 'light';
  document.documentElement.classList.add(`${mode}-mode`);
  </script>   
<style> 
html {
  scroll-behavior: smooth;
}

body {
  font-family: 'Merriweather', serif;
  margin: 0;
  padding: 2rem 1rem;
  font-size: 15px;
  line-height: 1.5;
  transition: background-color 0.3s, color 0.3s;
}

.container {
  max-width: 700px;
  margin: 0 auto;
  padding: 1rem 2rem;
  box-shadow: 0 0 15px rgba(0,0,0,0.1);
}

h1, h2, h3 {
  font-weight: 600;
  margin-top: 2.5rem;
  margin-bottom: 1rem;
  line-height: 1.2;
}

h1 { font-size: 1.8rem; }
h2 { font-size: 1.4rem; }
h3 { font-size: 1.2rem; }

table {
  width: 100%;
  border-collapse: collapse;
  font-family: sans-serif;
  font-size: 1em;
  margin: 1em 0;
}

th, td {
  padding: 0.6em 1em;
  text-align: left;
  border: 1px solid;
}

tr:nth-child(even) {
  background-color: inherit;
}

tr:hover {
  background-color: inherit;
}

a {
  text-decoration: none;
  transition: color 0.2s;
}

a:hover {
  text-decoration: underline;
}

code {
  color: #d35400;
}

.book-title-chapter {
  font-family: 'Merriweather', serif;
  font-size: 2rem;
  font-weight: bold;
  text-align: center;
  margin-bottom: 2rem;
  border-bottom: 2px solid;
  padding-bottom: 0.5rem;
}

.book-subtitle-chapter {
  text-align: center;
  font-size: 1rem;
  margin-top: -1rem;
  margin-bottom: 2rem;
}

.related-books {
  margin-top: 40px;
}

.related-book-list {
  display: flex;
  flex-wrap: wrap;
  gap: 20px;
}

    .book-cover {
      width: 130px;
      height: 180px;
      font-family: Arial, sans-serif;
      position: relative;
      overflow: hidden;      
      line-height: normal;
      box-shadow: 2px 2px 4px rgba(0,0,0,0.1);
    }
    .book-cover-bottom-stripe {
      position: absolute;
      bottom: 0;
      left: 0;
      height: 5px;
      width: 100%;
    }
    .book-cover-title {
      position: absolute;
      width: 100%;
      text-align: center;
      font-weight: bold;
    }
     
    .book-cover-icon {
      position: absolute;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      align-items: center;
      justify-content: center; 
    }

    .book-cover-author {
      position: absolute;
      bottom: 10px;
      width: 100%;
      text-align: center;
      font-size: 8px;
      color: #333;
    }

.page-footer {
  margin-top: 4rem;
  padding: 1rem 0;
  text-align: center;
  font-size: 0.85rem;
  border-top: 1px solid;
}

.chapter-navi-section {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding-bottom: 10px;
}

.nav-link {
  color: inherit;
  text-decoration: none;
  opacity: 0.5;
  transition: opacity 0.3s ease, text-decoration 0.3s ease;
}

.nav-link:hover {
  opacity: 0.9;
  text-decoration: underline;
}

.prev { text-align: left; }
.toc-link { text-align: center; }
.next { text-align: right; }

.download-section {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 2rem;
  padding: 2rem 1rem;
  max-width: 600px;
  margin: 3rem auto;
  border-radius: 12px;
  box-shadow: 0 4px 10px rgba(0,0,0,0.05);
}

.download-info h2 {
  margin: 0 0 0.5rem;
  font-size: 1.2rem;
}

.format-label {
  margin: 0 0 0.5rem;
  font-size: 0.95rem;
}

.download-buttons {
  display: flex;
  gap: 1rem;
}

.download-button {
  background-color: #4A90E2;
  color: white;
  padding: 0.5em 1.2em;
  border-radius: 25px;
  font-size: 0.95rem;
  text-decoration: none;
  transition: background-color 0.3s ease;
}

.download-button:hover {
  background-color: #357ABD;
}

.code-block {
  position: relative;
  margin-bottom: 1em;
}

.copy-button {
  background: transparent;
  color: white;
  position: absolute;
  top: 8px;
  right: 8px;
  border: none;
  padding: 4px 8px;
  font-size: 12px;
  border-radius: 4px;
  cursor: pointer;
  z-index: 1;
}

.copy-button:hover {
  background-color: #0056b3;
}

.snippet-container {
  overflow: hidden;
}

.snippet-header {
  padding: 0.75rem 1rem;
  cursor: pointer;
  font-size: 1rem;
    background-color: #eeeeee;
    color:  #111111; 
    border-radius: 8px;
    cursor: pointer;
    box-shadow: 0 4px 6px rgba(0,0,0,0.1);  
}

.snippet-body {
  display: none;
  font-family: monospace;
}

.snippet-container.open .snippet-body {
  display: block;
}

.CodeMirror {
  border: 2px solid #ccc;
  border-radius: 4px;
  resize: vertical;
}

/* === Light Mode === */
html.light-mode {
  background-color: #f8f7f5;
  color: #333;
}

html.light-mode .container {
  background: white;
}

html.light-mode .book-title-chapter {
  color: #2c3e50;
  border-color: #ccc;
}
html.light-mode .book-subtitle-chapter{
  color: #888;
}

html.light-mode .page-footer,
html.light-mode .series-name,
html.light-mode .book-subtitle,
html.light-mode .format-label {
  color: #888;
}

html.light-mode .related-books h2 {
  color: #333;
  border-bottom: 2px solid #eee;
}

html.light-mode .book-title {
  color: #fff;
}

html.light-mode .book-cover {
  border: 1px solid #ccc;
}

html.light-mode th {
  background-color: #f2f2f2;
}

html.light-mode tr:nth-child(even) {
  background-color: #fafafa;
}

html.light-mode tr:hover {
  background-color: #e6f7ff;
}

html.light-mode a,
html.light-mode .page-footer a {
  color: #000;
}

/* === Dark Mode === */
html.dark-mode {
  background-color: #181818;
  color: #e0e0e0;
}

html.dark-mode .container {
  background: #222;
}

html.dark-mode .book-title-chapter {
  color: #ddd;
  border-color: #444;
}

html.dark-mode .snippet-header {
    background-color: #333;
    color:  #ddd; 
}


html.dark-mode .book-subtitle-chapter,
html.dark-mode .page-footer,
html.dark-mode .series-name,
html.dark-mode .book-subtitle,
html.dark-mode .book-footer,
html.dark-mode .format-label {
  color: #aaa;
}

html.dark-mode .related-books h2 {
  color: #ddd;
  border-bottom: 2px solid #333;
}

html.dark-mode .book-title {
  color: #fff;
}

html.dark-mode .book-cover {
  border: 1px solid #555;
}

html.dark-mode th {
  background-color: #333;
  color: #fff;
}

html.dark-mode td {
  border-color: #444;
}

html.dark-mode tr:nth-child(even) {
  background-color: #2a2a2a;
}

html.dark-mode tr:hover {
  background-color: #2c3e50;
}

html.dark-mode a,
html.dark-mode .page-footer a {
  color: #eee;
}

    .dialog-backdrop {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: rgba(0,0,0,0.5);
      display: none;
      justify-content: center;
      align-items: center;
      z-index: 10;
    }

    .dialog {
      background: white;
      padding: 20px;
      width: 90vw;
      height: 80vh;
      border-radius: 8px;
      box-shadow: 0 0 20px rgba(0,0,0,0.3);
      display: flex;
      flex-direction: column;
    }
    .dialog-content {
      display: flex;
      flex: 1;
      gap: 20px;
      margin-top: 10px;
    }
    .dialog h2 {
      margin-top: 0;
    }

    .textarea_dialog {
      width: 50%;
      height: 100%;
      resize: none;
      font-family: monospace;
      font-size: 14px;
      padding: 10px;
      box-sizing: border-box;
      border: 1px solid #ccc;
    }

    .iframe_dialog {
      width: 50%;
      height: 100%;
      border: 1px solid #ccc;
    }
    .controls_dialog {
      display: flex;
      justify-content: space-between;
      margin-top: 10px;
    }    
    button { padding: 0.5em 1em; background: green; color: white; border: none; cursor: pointer; }
    button:hover { background: #1e7e34; }
    .result_iframe { width:99%; height:200px; margin-top: 1em;  resize: both;border:1px solid #ccc;}        
</style>
</head>
<body> 
  <div class="container">
    <div class = "chapter-navi-section">
<a href="cplusplus-for-beginners-arrays-and-strings.htm" class="nav-button prev">←</a>
<a href='cplusplus-for-beginners.htm#pointers-and-references' class="nav-button toc-link">Index</a>
<a href="cplusplus-for-beginners-structures-and-enumerations.htm" class="nav-button next">→</a>
</div>

    <h1 class="book-title-chapter" id = 'top'>Pointers and References</h1>
    <h3 class="book-subtitle-chapter">C++ for Beginners</h3>   
    <!-- <h1 class ="chapter-title"></h1> -->
    <h2 id='pointer-basics-and-syntax'>7.1 Pointer Basics and Syntax</h2><p>In C++, <strong>pointers</strong> are one of the most powerful and fundamental features. A pointer is a special type of variable that <strong>stores the memory address</strong> of another variable. Understanding pointers is essential because they enable you to directly manipulate memory, interact with arrays efficiently, work with dynamic memory, and implement complex data structures.</p><h3 id="what-is-a-pointer">What is a Pointer?</h3><p>A <strong>pointer</strong> holds the <strong>address</strong> of another variable in memory, not the variable’s actual value. Think of a pointer as a signpost pointing to a specific location where data is stored.</p><p>For example, if you have an integer variable <code>x</code> stored at some memory location, a pointer to <code>x</code> stores that location's address.</p><h3 id="declaring-pointers">Declaring Pointers</h3><p>To declare a pointer, you specify the data type it points to, followed by an asterisk <code>*</code>, then the pointer name:</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-cpp">int* ptr;  // Pointer to an integer</code></pre>
</div><p>The <code>int*</code> means “pointer to an integer.” The type is important because the pointer needs to know how many bytes to access when dereferencing.</p><h3 id="assigning-addresses-to-pointers-the-address-of-operator">Assigning Addresses to Pointers: The Address-of Operator (<code>&amp;</code>)</h3><p>To make a pointer point to a variable, use the <strong>address-of operator <code>&amp;</code></strong>, which returns the memory address of a variable:</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-cpp">int x = 42;
int* ptr = &amp;x;  // ptr now holds the address of x</code></pre>
</div><p>Here:</p><ul>
 <li><code>x</code> is an integer variable.</li>
 <li><code>&amp;x</code> is the address of <code>x</code>.</li>
 <li><code>ptr</code> stores this address.</li>
</ul><h3 id="dereferencing-pointers-the-dereference-operator">Dereferencing Pointers: The Dereference Operator (<code>*</code>)</h3><p>To access or modify the value stored at the memory address a pointer holds, use the <strong>dereference operator <code>*</code></strong>:</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-cpp">int value = *ptr;  // Access the value pointed to by ptr (which is 42)
*ptr = 100;        // Change the value at ptr’s address to 100</code></pre>
</div><p>In the example:</p><ul>
 <li><code>*ptr</code> means “the value stored at the address in <code>ptr</code>.”</li>
 <li>Changing <code>*ptr</code> changes the value of <code>x</code> because <code>ptr</code> points to <code>x</code>.</li>
</ul><h3 id="example-pointer-basics-in-action">Example: Pointer Basics in Action</h3><div class="code-block"><button class="copy-button" onclick="copyCode(this)">📋</button>
 <pre><code class="language-cpp">#include &lt;iostream&gt;

int main() {
    int number = 10;
    int* p = &amp;number;  // Pointer p holds the address of number

    std::cout &lt;&lt; "Value of number: " &lt;&lt; number &lt;&lt; std::endl;
    std::cout &lt;&lt; "Address of number (&amp;number): " &lt;&lt; &amp;number &lt;&lt; std::endl;
    std::cout &lt;&lt; "Value of p (address stored): " &lt;&lt; p &lt;&lt; std::endl;
    std::cout &lt;&lt; "Value pointed to by p (*p): " &lt;&lt; *p &lt;&lt; std::endl;

    *p = 20;  // Modify number using the pointer
    std::cout &lt;&lt; "New value of number after *p = 20: " &lt;&lt; number &lt;&lt; std::endl;

    return 0;
}</code></pre>
</div><p><strong>Output:</strong></p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-bash">Value of number: 10
Address of number (&amp;number): 0x7ffcb2e1eac4
Value of p (address stored): 0x7ffcb2e1eac4
Value pointed to by p (*p): 10
New value of number after *p = 20: 20</code></pre>
</div><h3 id="important-pointer-concepts">Important Pointer Concepts</h3><p>Pointer Type Matters</p><p>The type of pointer (<code>int*</code>, <code>char*</code>, <code>double*</code>) tells the compiler how many bytes to read or write when dereferencing.</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-cpp">double d = 3.14;
double* dp = &amp;d;  // Points to a double (8 bytes on most systems)</code></pre>
</div><p>Trying to assign incompatible pointer types without casting will cause errors.</p><h3 id="uninitialized-pointers">Uninitialized Pointers</h3><p>Declaring a pointer without initializing it leads to an <strong>uninitialized pointer</strong>, which points to an unknown memory location. Accessing or dereferencing such pointers causes <strong>undefined behavior</strong> and often crashes your program.</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-cpp">int* p;    // Uninitialized pointer — dangerous!
std::cout &lt;&lt; *p;  // Undefined behavior! Don't do this.</code></pre>
</div><p><strong>Always initialize pointers</strong> before use:</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-cpp">int x = 5;
int* p = &amp;x;  // Safe initialization</code></pre>
</div><h3 id="null-pointers">Null Pointers</h3><p>A <strong>null pointer</strong> points to nothing. It is useful to indicate that a pointer doesn’t currently point to valid memory.</p><p>In C++, use <code>nullptr</code> (introduced in C++11) to represent null pointers:</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-cpp">int* p = nullptr;
if (p == nullptr) {
    std::cout &lt;&lt; "Pointer is null and safe to check before dereferencing." &lt;&lt; std::endl;
}</code></pre>
</div><p>Dereferencing a null pointer also causes undefined behavior, so always check for <code>nullptr</code> before dereferencing pointers that may be null.</p><h3 id="summary">Summary</h3><table>
 <thead>
  <tr>
   <th>Concept</th>
   <th>Description</th>
   <th>Example</th>
  </tr>
 </thead>
 <tbody>
  <tr>
   <td>Pointer declaration</td>
   <td>Variable that stores an address</td>
   <td><code>int* p;</code></td>
  </tr>
  <tr>
   <td>Address-of operator</td>
   <td>Gets memory address of a variable</td>
   <td><code>p = &amp;x;</code></td>
  </tr>
  <tr>
   <td>Dereference operator</td>
   <td>Accesses/modifies value at the address stored</td>
   <td><code>*p = 10;</code></td>
  </tr>
  <tr>
   <td>Uninitialized pointer</td>
   <td>Pointer without assigned address (dangerous)</td>
   <td><code>int* p;</code> (don't dereference)</td>
  </tr>
  <tr>
   <td>Null pointer</td>
   <td>Pointer set to point to no valid memory</td>
   <td><code>int* p = nullptr;</code></td>
  </tr>
 </tbody>
</table><h3 id="practical-tips-for-working-with-pointers">Practical Tips for Working with Pointers</h3><ul>
 <li><strong>Always initialize pointers</strong> either with a valid address or <code>nullptr</code>.</li>
 <li><strong>Check for <code>nullptr</code></strong> before dereferencing pointers that might be null.</li>
 <li>Avoid dangling pointers (pointers to memory that has been freed).</li>
 <li>Use pointers carefully; improper use is a common source of bugs and crashes.</li>
 <li>Use references or smart pointers in advanced C++ to reduce manual pointer errors (covered later).</li>
</ul><p>Pointers unlock powerful programming techniques by letting you directly manage memory and efficiently manipulate data. Mastering pointer basics is a key step toward becoming a proficient C++ programmer.</p><div class = "chapter-navi-section">
<a href="#top" class="nav-button prev">↑</a>
<a href='cplusplus-for-beginners.htm#pointers-and-references' class="nav-button toc-link">Index</a>
<a href="#bottom" class="nav-button next">↓</a>
</div>
<h2 id='pointer-arithmetic-and-arrays'>7.2 Pointer Arithmetic and Arrays</h2><p>One of the most powerful uses of pointers in C++ is <strong>working with arrays</strong>. Since arrays are stored in contiguous memory locations, pointers allow you to traverse, access, and manipulate array elements efficiently by performing arithmetic on addresses.</p><p>In this section, we'll explore the relationship between pointers and arrays, understand how pointer arithmetic works, and see practical examples demonstrating how to iterate through arrays using pointers. We'll also discuss important safety considerations like avoiding out-of-bounds access.</p><h3 id="the-relationship-between-arrays-and-pointers">The Relationship Between Arrays and Pointers</h3><p>In C++, the name of an array acts like a <strong>pointer to its first element</strong>. For example, consider this array:</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-cpp">int numbers[] = {10, 20, 30, 40, 50};</code></pre>
</div><ul>
 <li>The expression <code>numbers</code> (without an index) is equivalent to the address of the first element: <code>&amp;numbers[0]</code>.</li>
 <li>You can assign it to a pointer of the same type:</li>
</ul><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-cpp">int* ptr = numbers;  // Points to numbers[0]</code></pre>
</div><p>This means <code>ptr</code> and <code>numbers</code> both point to the first element of the array.</p><h3 id="pointer-arithmetic-basics">Pointer Arithmetic Basics</h3><p>Pointers hold memory addresses. Because arrays store elements contiguously, incrementing or decrementing a pointer moves it to the next or previous element of the array, not just the next byte.</p><ul>
 <li><strong>Incrementing a pointer (<code>ptr++</code>) moves it to the next element in the array.</strong></li>
 <li><strong>Decrementing a pointer (<code>ptr--</code>) moves it to the previous element.</strong></li>
</ul><p>For example:</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-cpp">int arr[] = {1, 2, 3};
int* p = arr;  // Points to arr[0]

p++;  // Now points to arr[1]
p++;  // Now points to arr[2]
p--;  // Back to arr[1]</code></pre>
</div><p>The pointer moves by the size of the element type it points to. For an <code>int</code> on most systems, that’s usually 4 bytes.</p><h3 id="accessing-array-elements-using-pointers">Accessing Array Elements Using Pointers</h3><p>You can access the value a pointer points to using the <strong>dereference operator <code>*</code></strong>:</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-cpp">int arr[] = {5, 10, 15};
int* p = arr;

std::cout &lt;&lt; *p &lt;&lt; std::endl;      // Outputs 5 (arr[0])
std::cout &lt;&lt; *(p + 1) &lt;&lt; std::endl; // Outputs 10 (arr[1])
std::cout &lt;&lt; *(p + 2) &lt;&lt; std::endl; // Outputs 15 (arr[2])</code></pre>
</div><p>Here, <code>p + 1</code> points to the second element, and so on.</p><h3 id="iterating-through-an-array-using-a-pointer">Iterating Through an Array Using a Pointer</h3><p>Instead of using array indices, you can use pointers to traverse an array:</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">📋</button>
 <pre><code class="language-cpp">#include &lt;iostream&gt;

int main() {
    int data[] = {100, 200, 300, 400, 500};
    int* ptr = data;                      // Points to data[0]
    int length = sizeof(data) / sizeof(data[0]);

    for (int i = 0; i &lt; length; i++) {
        std::cout &lt;&lt; *(ptr + i) &lt;&lt; " ";
    }
    std::cout &lt;&lt; std::endl;

    // Alternative: increment pointer directly
    for (int* p = data; p &lt; data + length; p++) {
        std::cout &lt;&lt; *p &lt;&lt; " ";
    }
    std::cout &lt;&lt; std::endl;

    return 0;
}</code></pre>
</div><p>Both loops print the array elements. The second loop shows a common idiom: using a pointer variable <code>p</code> to traverse from the start (<code>data</code>) to the end (<code>data + length</code>).</p><h3 id="pointer-and-array-notation-are-interchangeable">Pointer and Array Notation Are Interchangeable</h3><p>Because of the close relationship between arrays and pointers, you can use pointer arithmetic instead of array indexing:</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-cpp">int arr[3] = {7, 8, 9};
int* p = arr;

std::cout &lt;&lt; arr[1] &lt;&lt; std::endl;  // Outputs 8
std::cout &lt;&lt; *(p + 1) &lt;&lt; std::endl; // Also outputs 8</code></pre>
</div><p>Both <code>arr[1]</code> and <code>*(p + 1)</code> access the second element.</p><h3 id="caution-avoid-out-of-bounds-access">Caution: Avoid Out-of-Bounds Access</h3><p>Unlike higher-level languages, C++ <strong>does not check</strong> if a pointer goes beyond the array boundaries. Accessing memory outside the valid range is <strong>undefined behavior</strong> and can cause crashes or data corruption.</p><p>Example of dangerous code:</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-cpp">int numbers[3] = {1, 2, 3};
int* p = numbers;

std::cout &lt;&lt; *(p + 3) &lt;&lt; std::endl;  // Out-of-bounds! Undefined behavior.</code></pre>
</div><p>Here, <code>p + 3</code> points <strong>one element past</strong> the array end, which is invalid.</p><p><strong>Always ensure your pointers stay within the array bounds when performing arithmetic.</strong></p><h3 id="example-modifying-array-elements-using-pointers">Example: Modifying Array Elements Using Pointers</h3><p>Pointers can also be used to modify array elements:</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-cpp">int scores[] = {50, 60, 70};
int* p = scores;

for (int i = 0; i &lt; 3; i++) {
    *(p + i) += 10;  // Increase each score by 10
}

for (int i = 0; i &lt; 3; i++) {
    std::cout &lt;&lt; scores[i] &lt;&lt; " ";  // Outputs: 60 70 80
}
std::cout &lt;&lt; std::endl;</code></pre>
</div><p>The pointer-based loop increments each element’s value directly.</p><h3 id="summary">Summary</h3><table>
 <thead>
  <tr>
   <th>Concept</th>
   <th>Description</th>
   <th>Example</th>
  </tr>
 </thead>
 <tbody>
  <tr>
   <td>Array name as pointer</td>
   <td>Name of array points to first element</td>
   <td><code>int* p = arr;</code></td>
  </tr>
  <tr>
   <td>Pointer arithmetic</td>
   <td><code>p++</code> moves to next element, <code>p--</code> moves back</td>
   <td><code>*(p + 1)</code> accesses next element</td>
  </tr>
  <tr>
   <td>Iterating with pointers</td>
   <td>Use pointer increments to traverse an array</td>
   <td><code>for (int* p = arr; p &lt; arr + n; p++)</code></td>
  </tr>
  <tr>
   <td>Out-of-bounds danger</td>
   <td>Accessing beyond array size causes undefined behavior</td>
   <td>Avoid <code>*(p + n)</code> if array size is n</td>
  </tr>
  <tr>
   <td>Modifying via pointers</td>
   <td>Dereference pointer to change array contents</td>
   <td><code>*(p + i) = new_value;</code></td>
  </tr>
 </tbody>
</table><h3 id="conclusion">Conclusion</h3><p>Pointer arithmetic lets you efficiently traverse and manipulate arrays in C++. The close relationship between arrays and pointers is a cornerstone of C++ programming, enabling fast and flexible access to data.</p><p>However, with this power comes responsibility. Always ensure pointers remain within valid bounds to prevent undefined behavior. Mastering pointer arithmetic with arrays prepares you for advanced topics like dynamic arrays, pointer-to-pointer constructs, and low-level memory management covered in later chapters.</p><div class = "chapter-navi-section">
<a href="#top" class="nav-button prev">↑</a>
<a href='cplusplus-for-beginners.htm#pointers-and-references' class="nav-button toc-link">Index</a>
<a href="#bottom" class="nav-button next">↓</a>
</div>
<h2 id='references-and-reference-variables'>7.3 References and Reference Variables</h2><p>In C++, <strong>references</strong> provide a convenient and safer alternative to pointers in many situations. A reference is essentially an <strong>alias</strong> or another name for an existing variable. Once initialized, a reference refers to the same memory location as the original variable, allowing you to access or modify that variable through the reference.</p><p>In this section, we will explore what references are, how to declare and use them, their advantages over pointers for parameter passing, and key differences between references and pointers.</p><h3 id="what-is-a-reference">What Is a Reference?</h3><p>A <strong>reference variable</strong> is a reference (alias) to an existing variable. It must be initialized at declaration and cannot be changed to refer to another variable later.</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-cpp">int x = 10;
int&amp; ref = x;  // ref is a reference to x</code></pre>
</div><p>Here, <code>ref</code> and <code>x</code> refer to the <strong>same</strong> memory location. Changing one affects the other:</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-cpp">ref = 20;  // Changes x to 20
std::cout &lt;&lt; x;  // Outputs 20</code></pre>
</div><h3 id="syntax-for-declaring-references">Syntax for Declaring References</h3><p>The syntax for declaring a reference is:</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-cpp">type&amp; reference_name = variable;</code></pre>
</div><ul>
 <li>The ampersand (<code>&amp;</code>) after the type indicates a reference.</li>
 <li>Initialization is mandatory — you cannot have an uninitialized reference.</li>
 <li>After initialization, the reference <strong>cannot be reseated</strong> to refer to another variable.</li>
</ul><p>Example:</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-cpp">double value = 3.14;
double&amp; refValue = value;</code></pre>
</div><h3 id="how-are-references-different-from-pointers">How Are References Different from Pointers?</h3><table>
 <thead>
  <tr>
   <th>Feature</th>
   <th>Reference</th>
   <th>Pointer</th>
  </tr>
 </thead>
 <tbody>
  <tr>
   <td>Syntax</td>
   <td>Declared with <code>&amp;</code> after type</td>
   <td>Declared with <code>*</code> after type</td>
  </tr>
  <tr>
   <td>Initialization</td>
   <td>Must be initialized immediately</td>
   <td>Can be declared without initialization</td>
  </tr>
  <tr>
   <td>Nullability</td>
   <td>Cannot be null (must refer to valid variable)</td>
   <td>Can be null (<code>nullptr</code>)</td>
  </tr>
  <tr>
   <td>Reassignment</td>
   <td>Cannot be reassigned to refer to another variable</td>
   <td>Can point to different variables</td>
  </tr>
  <tr>
   <td>Dereferencing</td>
   <td>Implicit; no operator needed</td>
   <td>Requires <code>*</code> operator</td>
  </tr>
  <tr>
   <td>Usage</td>
   <td>Acts as an alias</td>
   <td>Holds memory address</td>
  </tr>
 </tbody>
</table><p>Because references cannot be null or reassigned, they are safer and easier to use in many cases, especially for function parameters.</p><h3 id="typical-use-case-passing-arguments-to-functions">Typical Use Case: Passing Arguments to Functions</h3><p>References are commonly used to pass variables <strong>by reference</strong> to functions, allowing the function to modify the original argument without copying it.</p><h3 id="pass-by-value-copy">Pass-by-value (copy):</h3><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-cpp">void increment(int n) {
    n = n + 1;  // Modifies local copy only
}

int main() {
    int x = 5;
    increment(x);
    std::cout &lt;&lt; x;  // Outputs 5 (unchanged)
}</code></pre>
</div><h3 id="pass-by-reference">Pass-by-reference:</h3><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-cpp">void increment(int&amp; n) {
    n = n + 1;  // Modifies original variable
}

int main() {
    int x = 5;
    increment(x);
    std::cout &lt;&lt; x;  // Outputs 6 (modified)
}</code></pre>
</div><p>Passing by reference avoids the overhead of copying large objects and allows functions to modify the caller’s variables safely.</p><h3 id="simple-reference-aliasing">Simple reference aliasing</h3><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-cpp">int a = 100;
int&amp; refA = a;  // refA is another name for a

std::cout &lt;&lt; a &lt;&lt; ", " &lt;&lt; refA &lt;&lt; std::endl;  // Outputs: 100, 100

refA = 200;  // Modify through reference
std::cout &lt;&lt; a &lt;&lt; std::endl;  // Outputs: 200</code></pre>
</div><h3 id="function-modifying-a-variable-by-reference">Function modifying a variable by reference</h3><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-cpp">void doubleValue(int&amp; num) {
    num *= 2;
}

int main() {
    int val = 7;
    doubleValue(val);
    std::cout &lt;&lt; val;  // Outputs 14
}</code></pre>
</div><h3 id="references-to-constants-const-references">References to Constants (<code>const</code> References)</h3><p>Sometimes you want to pass large objects by reference <strong>without allowing modification</strong>. This is done using <code>const</code> references:</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-cpp">void printValue(const int&amp; n) {
    std::cout &lt;&lt; n &lt;&lt; std::endl;
}

int main() {
    int x = 42;
    printValue(x);  // Safe; printValue cannot modify x
}</code></pre>
</div><p><code>const</code> references combine efficiency (no copying) with safety (no accidental changes).</p><h3 id="when-to-use-references-vs-pointers">When to Use References vs. Pointers</h3><table>
 <thead>
  <tr>
   <th>Scenario</th>
   <th>Use References</th>
   <th>Use Pointers</th>
  </tr>
 </thead>
 <tbody>
  <tr>
   <td>Function parameters</td>
   <td>Prefer references for clarity and safety</td>
   <td>Use pointers when null or reassignment needed</td>
  </tr>
  <tr>
   <td>Object aliasing</td>
   <td>Use references when alias is permanent</td>
   <td>Use pointers for optional or changeable aliases</td>
  </tr>
  <tr>
   <td>Dynamic memory management</td>
   <td>Not applicable</td>
   <td>Required for managing heap-allocated memory</td>
  </tr>
  <tr>
   <td>Nullable references</td>
   <td>Not possible</td>
   <td>Pointers can be null</td>
  </tr>
 </tbody>
</table><h3 id="summary">Summary</h3><ul>
 <li>A <strong>reference</strong> is an alias to an existing variable; it must be initialized and cannot be changed afterward.</li>
 <li>References simplify syntax by eliminating the need to dereference explicitly.</li>
 <li>They are safer than pointers because they cannot be null or uninitialized.</li>
 <li>Commonly used for <strong>pass-by-reference</strong> in functions, enabling efficient and clear code.</li>
 <li><code>const</code> references provide read-only access to variables, useful for preventing modification while avoiding copies.</li>
</ul><h3 id="final-note">Final Note</h3><p>References help make C++ code more readable and less error-prone compared to pointers in many situations. Once you are comfortable with pointers, mastering references is essential for writing clean and efficient C++ programs. In the next section, we will explore <strong>dynamic memory allocation</strong> and how pointers interact with memory on the heap.</p><div class = "chapter-navi-section">
<a href="#top" class="nav-button prev">↑</a>
<a href='cplusplus-for-beginners.htm#pointers-and-references' class="nav-button toc-link">Index</a>
<a href="#bottom" class="nav-button next">↓</a>
</div>
<h2 id='dynamic-memory-allocation-with-new-and-delete'>7.4 Dynamic Memory Allocation with <code>new</code> and <code>delete</code></h2><p>In C++, <strong>dynamic memory allocation</strong> allows your program to request and release memory during runtime, rather than relying solely on fixed-size variables defined at compile time. This flexibility is essential for handling data whose size or lifetime cannot be determined in advance, such as user input, data structures that grow or shrink, or large objects that shouldn’t be stored on the stack.</p><p>C++ provides the <strong><code>new</code></strong> and <strong><code>delete</code></strong> operators to allocate and deallocate memory on the <strong>heap</strong> (also called free store). This section explains how to use these operators, how to allocate both single variables and arrays dynamically, and how to avoid common pitfalls such as memory leaks and dangling pointers.</p><h3 id="why-dynamic-memory-allocation">Why Dynamic Memory Allocation?</h3><p>When you declare variables normally, such as:</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-cpp">int x = 5;
int arr[10];</code></pre>
</div><p>These variables are typically allocated on the <strong>stack</strong>, which is a limited, fast-access memory area. The size and lifetime of stack variables are fixed by the program structure.</p><p>However, sometimes:</p><ul>
 <li>You don’t know the size of an array beforehand.</li>
 <li>You want a variable to persist beyond the scope it was created in.</li>
 <li>You want to allocate large objects without overflowing the stack.</li>
</ul><p>This is where <strong>dynamic memory allocation</strong> comes in — it lets you <strong>allocate memory at runtime on the heap</strong>, which is a much larger pool of memory managed manually by your program.</p><h3 id="the-new-operator-allocating-memory">The <code>new</code> Operator: Allocating Memory</h3><p>The <code>new</code> operator dynamically allocates memory for a variable or array and returns a <strong>pointer</strong> to the allocated memory.</p><h3 id="allocating-a-single-variable">Allocating a single variable</h3><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-cpp">int* ptr = new int;   // Allocates memory for one int
*ptr = 42;            // Assign a value to the allocated memory

std::cout &lt;&lt; *ptr &lt;&lt; std::endl;  // Outputs 42</code></pre>
</div><p>Here:</p><ul>
 <li><code>new int</code> requests enough memory for one <code>int</code>.</li>
 <li>It returns a pointer to that memory.</li>
 <li>You must use the pointer to access or modify the value.</li>
</ul><p>You can also combine allocation and initialization:</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-cpp">int* ptr = new int(10);  // Allocate and initialize to 10</code></pre>
</div><h3 id="allocating-an-array">Allocating an array</h3><p>You can allocate an array dynamically by specifying the size inside square brackets <code>[]</code>:</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-cpp">int* arr = new int[5];  // Allocates an array of 5 integers

// Initialize elements
for (int i = 0; i &lt; 5; i++) {
    arr[i] = i * 10;
}</code></pre>
</div><p>The pointer <code>arr</code> points to the first element of the dynamically allocated array.</p><h3 id="the-delete-operator-releasing-memory">The <code>delete</code> Operator: Releasing Memory</h3><p>Memory allocated with <code>new</code> is <strong>not automatically freed</strong> when it goes out of scope. You must manually free it using <code>delete</code> to avoid <strong>memory leaks</strong> — situations where allocated memory remains reserved but inaccessible, wasting resources.</p><h3 id="deleting-a-single-variable">Deleting a single variable</h3><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-cpp">delete ptr;  // Frees memory allocated with new int
ptr = nullptr;  // Good practice: set pointer to nullptr after deletion</code></pre>
</div><h3 id="deleting-an-array">Deleting an array</h3><p>When deleting memory allocated for an array, use <code>delete[]</code>:</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-cpp">delete[] arr;  // Frees memory allocated with new int[]
arr = nullptr;  // Avoid dangling pointer</code></pre>
</div><h3 id="why-matching-new-and-delete-matters">Why Matching <code>new</code> and <code>delete</code> Matters</h3><p>Every <code>new</code> must have a corresponding <code>delete</code>, and every <code>new[]</code> must have a corresponding <code>delete[]</code>. Failing to do so causes:</p><ul>
 <li><strong>Memory leaks</strong>: Memory that’s never freed, eventually exhausting available memory.</li>
 <li><strong>Undefined behavior</strong>: Using <code>delete</code> instead of <code>delete[]</code> (or vice versa) can corrupt the heap and crash your program.</li>
</ul><h3 id="example-dynamic-allocation-and-deallocation">Example: Dynamic Allocation and Deallocation</h3><div class="code-block"><button class="copy-button" onclick="copyCode(this)">📋</button>
 <pre><code class="language-cpp">#include &lt;iostream&gt;

int main() {
    int* num = new int(99);
    std::cout &lt;&lt; "Value: " &lt;&lt; *num &lt;&lt; std::endl;

    delete num;  // Free memory
    num = nullptr;

    int size = 3;
    int* array = new int[size];

    for (int i = 0; i &lt; size; i++) {
        array[i] = i * i;
    }

    for (int i = 0; i &lt; size; i++) {
        std::cout &lt;&lt; array[i] &lt;&lt; " ";
    }
    std::cout &lt;&lt; std::endl;

    delete[] array;  // Free array memory
    array = nullptr;

    return 0;
}</code></pre>
</div><h3 id="common-pitfalls-and-best-practices">Common Pitfalls and Best Practices</h3><h4 id="memory-leaks">Memory Leaks</h4><p>If you lose all pointers to dynamically allocated memory without deleting it, the memory is <strong>leaked</strong>.</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-cpp">int* p = new int(10);
p = nullptr;  // The previously allocated memory is now lost, causing a leak</code></pre>
</div><p><strong>Best practice:</strong> Always delete what you allocate and avoid losing pointer references before deletion.</p><h4 id="dangling-pointers">Dangling Pointers</h4><p>A <strong>dangling pointer</strong> is a pointer pointing to memory that has been freed/deleted.</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-cpp">int* p = new int(5);
delete p;
std::cout &lt;&lt; *p;  // Undefined behavior: p is dangling</code></pre>
</div><p><strong>Best practice:</strong> After <code>delete</code>, set the pointer to <code>nullptr</code> to avoid accidentally using dangling pointers:</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-cpp">delete p;
p = nullptr;</code></pre>
</div><h4 id="double-deletion">Double Deletion</h4><p>Calling <code>delete</code> on the same pointer twice can cause crashes or corruption.</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-cpp">int* p = new int(3);
delete p;
delete p;  // Error: double deletion</code></pre>
</div><p><strong>Best practice:</strong> Setting pointers to <code>nullptr</code> after deletion prevents double deletion because deleting a null pointer is safe (does nothing):</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-cpp">delete p;
p = nullptr;
delete p;  // Safe; no effect</code></pre>
</div><h4 id="mixing-new-delete-and-new-delete">Mixing <code>new</code>/<code>delete</code> and <code>new[]</code>/<code>delete[]</code></h4><p>Using <code>delete</code> to free memory allocated with <code>new[]</code> (or vice versa) is undefined behavior.</p><p>Correct:</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-cpp">int* p1 = new int;
delete p1;

int* p2 = new int[5];
delete[] p2;</code></pre>
</div><p>Incorrect:</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-cpp">int* p2 = new int[5];
delete p2;  // Wrong! Use delete[]</code></pre>
</div><h3 id="summary">Summary</h3><table>
 <thead>
  <tr>
   <th>Concept</th>
   <th>Description</th>
   <th>Example</th>
  </tr>
 </thead>
 <tbody>
  <tr>
   <td>Dynamic allocation</td>
   <td>Allocate memory on the heap at runtime</td>
   <td><code>int* p = new int(10);</code></td>
  </tr>
  <tr>
   <td>Deallocation</td>
   <td>Free heap memory to avoid leaks</td>
   <td><code>delete p;</code> or <code>delete[] p;</code></td>
  </tr>
  <tr>
   <td>Single variable</td>
   <td>Use <code>new</code> and <code>delete</code></td>
   <td><code>int* p = new int; delete p;</code></td>
  </tr>
  <tr>
   <td>Arrays</td>
   <td>Use <code>new[]</code> and <code>delete[]</code></td>
   <td><code>int* arr = new int[10]; delete[] arr;</code></td>
  </tr>
  <tr>
   <td>Memory leak</td>
   <td>Forgetting to delete allocated memory</td>
   <td>Causes wasted memory</td>
  </tr>
  <tr>
   <td>Dangling pointer</td>
   <td>Pointer referring to deleted memory</td>
   <td>Access causes undefined behavior</td>
  </tr>
  <tr>
   <td>Best practice</td>
   <td>Set pointer to <code>nullptr</code> after deletion</td>
   <td><code>delete p; p = nullptr;</code></td>
  </tr>
 </tbody>
</table><h3 id="final-thoughts">Final Thoughts</h3><p>Dynamic memory allocation with <code>new</code> and <code>delete</code> gives you great power but also responsibility. Improper use can lead to subtle bugs and resource issues. As you gain experience, you will learn about safer alternatives like <strong>smart pointers</strong> (<code>std::unique_ptr</code>, <code>std::shared_ptr</code>) introduced in modern C++ that automate memory management and reduce errors.</p><p>For now, mastering manual dynamic memory management is essential to understand how C++ programs work “under the hood” and prepares you for advanced programming concepts ahead.</p><div class = "chapter-navi-section">
<a href="cplusplus-for-beginners-arrays-and-strings.htm" class="nav-button prev">←</a>
<a href='cplusplus-for-beginners.htm#pointers-and-references' class="nav-button toc-link">Index</a>
<a href="cplusplus-for-beginners-structures-and-enumerations.htm" class="nav-button next">→</a>
</div>
<section class="download-section">
  <div class="book-cover" style="background-color: #f9f6f1;border: 1px solid #ccc;"> 
    <div class="book-cover-title" style="font-size: 18px;color: #333;top: 20px;">C++ for Beginners</div>
    <div class="book-cover-author">readbytes</div>
    <div class="book-cover-bottom-stripe" style="background-color: #333;"></div>
    <img class="book-cover-icon" style="width: 90px;height: 90px;top: 70px;" src="data:image/png;base64,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"/>
  </div>
  <div class="download-info">
    <h2 id='bottom'>Download This Ebook</h2>
    <p class="format-label">Available formats:</p>
    <div class="download-buttons">
      <a href="cplusplus-for-beginners.pdf" class="download-button">📄 PDF</a>
      <a href="cplusplus-for-beginners.epub" class="download-button">📘 EPUB</a>
    </div>
  </div>
</section><div class='related-books'>
<h2>C++ Introduction Books</h2>
<div class='related-book-list'>
<a href="cplusplus-for-beginners.htm">
<div class="book-cover" style="background-color: #f9f6f1;border: 1px solid #ccc;"> 
    <div class="book-cover-title" style="font-size: 18px;color: #333;top: 20px;">C++ for Beginners</div>
    <div class="book-cover-author">readbytes</div>
    <div class="book-cover-bottom-stripe" style="background-color: #333;"></div>
    <img class="book-cover-icon" style="width: 90px;height: 90px;top: 70px;" src="data:image/png;base64,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"/>
  </div>
</a>


<a href="cplusplus-syntax.htm">
<div class="book-cover" style="background-color: #f9f6f1;border: 1px solid #ccc;"> 
    <div class="book-cover-title" style="font-size: 20px;color: #333;top: 20px;">C++ Syntax</div>
    <div class="book-cover-author">readbytes</div>
    <div class="book-cover-bottom-stripe" style="background-color: #333;"></div>
    <img class="book-cover-icon" style="width: 90px;height: 90px;top: 70px;" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFoAAABaCAYAAAA4qEECAAAFZ0lEQVR4Xu2dy4scVRSH8ye0iYtkERcmzgjT2OYBuhNREMVXBh/TgsYQx5ULDYTgVl3EFyg6uFJBV76IEXdKXAVBJCgISSTRGRmZiZlADBo6M5kp+3ZbnXt/p7q6btWtc++pqQPfpu/p7vP7UnSqi+m6GzbkrMbYO50u0Tqjgx5Kqe4brSa8+XplFf0UroQ3GbDltqNRs70Y3Tw5G22//2SXU0Fyy5MXc6GyqYyYWwd9WdfGbW9uxRe9vvlBtOvZKLrpwTOiUDO7QjlALxu3zWxFf5mq++RF/YU27/40au39lwSQAspygXICwhfRY2rhv5Z6URxcEuoAQUkuQV/oM7HwSN45vUoGlwaKKQOrI1t9zuhPaD19mQwtEZRSFrq71M/sqh3JMSikTHSH6LdXeoN6Ag4rlV3Ta0RG2aTKjhfU/6Q4rGRQAgf62QhKHnzjk3wKlwRK4EI7qq99g4wf3NR8nwwqmfE9s0QAF8olOarjB1QDDisZDM+NIbqhXYXDQaWDwbnRPj46xtkGDiodDM6N7nYgWl2hwkEl09r7DwnOzZbbr131G4iemFokw0oGQ/ug2XVKRI9PzpJhJYOhfdB66m8qevsDp8iwksHQPqi8aAzsi1o0E7VoJioteuzh30lgX1RaNIb1SS2aiVo0E5UVPTH1Fwnrk8qKxqC+qUUzUYtmwovoL49dioYV9uZhx/4VEjRmWM2fp70uYRc9qrA/DxhSZ1RhvyuCEL1wfiU6PXulB/bnAUPqnJnv8+cSTtEv7HeFd9G4XpyzJGQaWLjuisqJxoCjeOVjc572y7THBayim4+cNUKdONkhPUXBgKO495AxUrTvVdrjAq+ij//k/i9UMeAo7jlojFSLzsLE4/ZfuyspuvXYb0Yo16IxXBZQ9DOv0x4XsIqeOjRvhPri20ukpwgYLgt3HTBGir75kfa4gFU01h373f5ZA4bLChauu4BNdPtF82hWhT1FuHVfh4TLCtbR47SnKKWKTqu5hWXSXwQMZsOBGZzOLOzPA7voNz66QPpcgMHy8Py7OG2/sC8P7KLjurK8RvqLgMFsmDmC05mF/XkoVbTOjinz1E4V9uSl6I+AsF6YoT1FYROtwLpzeo705AFD2YKF6y5gFf3oQfPM48h3w8+jD3+4ZIDrOnGYtz7vgyHTuBvOo7/+nva4gFW0zTdDLFyPGdN+BBQXhkyDfDN8jfa4gFW0zbWOH365bIDrMXqYE7/2wZBpoOhKXOuwEZ0VDGTLuhD98+kO6bEFA9lyXxWvRyuwcN0GdccFDGTLe1+Z87Rfoj0uEC0aw+QBC9dd4V10XMsraz2wPw0Mk4WVq33WcID/C/tdwS766uqwiP3C/jQwTBZGFfa7gl204rnDC5hvUNg7DAySlWH1yTHa6xIvol2AQUKnFs2ESNHjk3MkSOiIFI0hJFCLZqIWzYQ40c0nLpAQEhAnGgNIoRbNRC2aCVGid6b8CCh0RInG4SVRi2YiUXSIN68ae8juR0ChkSg6xNux4eDSSLwdW4g3GMTBpZF4g0EFBvUNDi4N3a0SHeRNYCfaS2RwaWii+1s/xQ+oRQzsCxxaIoOjGe8fHdKNunFoaWzSdh/SRQd363kcXBrax4a5eVm8EMJmCmn33pDA5t2f0aMZRStUM4bnBAeXhu4SPfdKb/C54Q0OLomRklWFsoUTDi8F3d11N759A/o1quF5UzIcXgq6sy7n0GtiwZN6L4RCygIDSAB9oc/UwiOba+NIDBEy+tmF1ZGMhZ/ZijK3Qh3f8wcJEyJOt0LVC19UR12harbPOdncFzfWDQGVTb8KlwT6KlyNertqHffbVSdVo96A3ar+A5kzbYSE7G+UAAAAAElFTkSuQmCC"/>
  </div>
</a>


<a href="cplusplus-stl.htm">
<div class="book-cover" style="background-color: #f9f6f1;border: 1px solid #ccc;"> 
    <div class="book-cover-title" style="font-size: 20px;color: #333;top: 20px;">C++ STL</div>
    <div class="book-cover-author">readbytes</div>
    <div class="book-cover-bottom-stripe" style="background-color: #333;"></div>
    <img class="book-cover-icon" style="width: 90px;height: 90px;top: 70px;" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFoAAABaCAYAAAA4qEECAAADK0lEQVR4Xu2cvWsTcRjHo+DkIKiTjiJugqTJ0cG/QcRZ/wJXQTd3ByeHDiLJnS84dHMVBHUSRQUH90pNfmfb6CKi8fqSaj93ae4lzzV3+X7gS9vkeZ7f7/lwEDq0jYYQQgghxFzQ9t0wbTzf3WO/SAllpg3niAlQYJa0uu4W54kxeA96ZykwU4JwnTPFGGLyMqd3nTNFAnFx2cOZIiee//UK5TLsEQWg3D1ZHpxgvShATLCeajsoWKKNaAfuDyVvZuGhu8paURBK1lNtBAVLtBEULNFGULBEG0HBlRfNRUrMqwW/f473GZFQvxXWVQbPD5e4zEGlcXt4eHQvvrdbU2W4zEGn5Yd3+NoovHul4DKzHN69UnCZWQ7vXim8IHzJhWY1vLtIQSRujSInhTNEBppL345R6LiwV+SAUpPCHpETimVYLwpAuRJtBOVKtBHNR4OTFCzRRlCwRBtBwRJtBAVLtBEULNFGeN3wPiVvp/+OtVmJ5qzvmdl1z1kzV8Ql53+q0/6az765gBLyConqN9i/X9hfeyiAYX0S7cCtsi9NOKf2UADDesL6LOGsWsPlx+V8d/Vo3t5x4bzyGA4P8TK1TuBeU0FpxC5T83D/0uBF6h7uXxq8SN3D/Utj80OHl6ltgvAX9y+V2IUm53eUQZQvUT4nvJ8x/e/R14+RiBeeHz4bZfPn6PW3bT908Z7s4d6Vgwsxix13mj15iGb94Ows4bxKwWUY1heF89OGcyoHFypjOZ4zKV7gVjijUjSfrJ/hUqOwdtrwvH2yzN7KkbDUTsKfrLWgufTmSPzsf2F9ZeFitVtwVqBgiTaCgiXaCAqWaCMoWKKNoGCJNoKCJdoICpZoIyhYoo2gYIk2goIl2ggKlmgjKFiijaBgiTaCgiXagLbfu0jBW+m6NdaKAsQEj9Jxl1krChATvBPWiQJ4fviJgiV6yiw+3ThOuRI9ZbzA3aRYSZ4iFx73T1FqUtg3l1DKbrr9960gvBt9f207/Rst332I1U0Iz5tbKGaa4VlzTSQk8X84Fw3PEY3p/70KTxA7UFTeeB13ibPFf1BY1nCeEEIIIYQowl8t5mhjJHw+fQAAAABJRU5ErkJggg=="/>
  </div>
</a>



<a href='cplusplus.htm'><div class='book-cover' style='background-color: #f9f6f1;color: #111111;border: 1px solid #ccc;display: flex;justify-content: center;align-items: center;text-align: center;'>More C++ Books</div></a>
</div>
</div>
  </div>
  <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/prism.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
  
  <script>
    function copyCode(button) {
      const code = button.nextElementSibling.innerText;
      navigator.clipboard.writeText(code).then(() => {
        button.textContent = 'Copied!';
        setTimeout(() => { button.textContent = 'Copy'; }, 1500);
      });
    }
  </script>  
<div id="floatingLog" aria-live="polite" role="alert"></div>
<footer class="page-footer">
    <nav>
      <a href="https://readbytes.github.io">Home</a> | 
      Email:<script language="JavaScript" type="text/javascript">
var part1 = 'yinpeng';var part6 = '263';var part2 = Math.pow(2,6);var part3 = String.fromCharCode(part2);var part4 = 'hotmail dot com';var part5 = part1 + String.fromCharCode(part2) + part4;document.write(part1 + part6 + part3 + part4);
</script>
    </nav>
  <p>© 2025 — All rights reserved.</p>    
  </footer>

</body>
</html>