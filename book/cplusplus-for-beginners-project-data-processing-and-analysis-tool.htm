<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>C++ for Beginners Project: Data Processing and Analysis Tool</title>
<link rel='shortcut icon' href='https://java2s.com/style/favicon.ico'>
<link href="https://fonts.googleapis.com/css2?family=Merriweather&display=swap" rel="stylesheet" />
<link href="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet" />


  <script>
  const mode = localStorage.getItem('mode') || 'light';
  document.documentElement.classList.add(`${mode}-mode`);
  </script>   
<style> 
html {
  scroll-behavior: smooth;
}

body {
  font-family: 'Merriweather', serif;
  margin: 0;
  padding: 2rem 1rem;
  font-size: 15px;
  line-height: 1.5;
  transition: background-color 0.3s, color 0.3s;
}

.container {
  max-width: 700px;
  margin: 0 auto;
  padding: 1rem 2rem;
  box-shadow: 0 0 15px rgba(0,0,0,0.1);
}

h1, h2, h3 {
  font-weight: 600;
  margin-top: 2.5rem;
  margin-bottom: 1rem;
  line-height: 1.2;
}

h1 { font-size: 1.8rem; }
h2 { font-size: 1.4rem; }
h3 { font-size: 1.2rem; }

table {
  width: 100%;
  border-collapse: collapse;
  font-family: sans-serif;
  font-size: 1em;
  margin: 1em 0;
}

th, td {
  padding: 0.6em 1em;
  text-align: left;
  border: 1px solid;
}

tr:nth-child(even) {
  background-color: inherit;
}

tr:hover {
  background-color: inherit;
}

a {
  text-decoration: none;
  transition: color 0.2s;
}

a:hover {
  text-decoration: underline;
}

code {
  color: #d35400;
}

.book-title-chapter {
  font-family: 'Merriweather', serif;
  font-size: 2rem;
  font-weight: bold;
  text-align: center;
  margin-bottom: 2rem;
  border-bottom: 2px solid;
  padding-bottom: 0.5rem;
}

.book-subtitle-chapter {
  text-align: center;
  font-size: 1rem;
  margin-top: -1rem;
  margin-bottom: 2rem;
}

.related-books {
  margin-top: 40px;
}

.related-book-list {
  display: flex;
  flex-wrap: wrap;
  gap: 20px;
}

    .book-cover {
      width: 130px;
      height: 180px;
      font-family: Arial, sans-serif;
      position: relative;
      overflow: hidden;      
      line-height: normal;
      box-shadow: 2px 2px 4px rgba(0,0,0,0.1);
    }
    .book-cover-bottom-stripe {
      position: absolute;
      bottom: 0;
      left: 0;
      height: 5px;
      width: 100%;
    }
    .book-cover-title {
      position: absolute;
      width: 100%;
      text-align: center;
      font-weight: bold;
    }
     
    .book-cover-icon {
      position: absolute;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      align-items: center;
      justify-content: center; 
    }

    .book-cover-author {
      position: absolute;
      bottom: 10px;
      width: 100%;
      text-align: center;
      font-size: 8px;
      color: #333;
    }

.page-footer {
  margin-top: 4rem;
  padding: 1rem 0;
  text-align: center;
  font-size: 0.85rem;
  border-top: 1px solid;
}

.chapter-navi-section {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding-bottom: 10px;
}

.nav-link {
  color: inherit;
  text-decoration: none;
  opacity: 0.5;
  transition: opacity 0.3s ease, text-decoration 0.3s ease;
}

.nav-link:hover {
  opacity: 0.9;
  text-decoration: underline;
}

.prev { text-align: left; }
.toc-link { text-align: center; }
.next { text-align: right; }

.download-section {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 2rem;
  padding: 2rem 1rem;
  max-width: 600px;
  margin: 3rem auto;
  border-radius: 12px;
  box-shadow: 0 4px 10px rgba(0,0,0,0.05);
}

.download-info h2 {
  margin: 0 0 0.5rem;
  font-size: 1.2rem;
}

.format-label {
  margin: 0 0 0.5rem;
  font-size: 0.95rem;
}

.download-buttons {
  display: flex;
  gap: 1rem;
}

.download-button {
  background-color: #4A90E2;
  color: white;
  padding: 0.5em 1.2em;
  border-radius: 25px;
  font-size: 0.95rem;
  text-decoration: none;
  transition: background-color 0.3s ease;
}

.download-button:hover {
  background-color: #357ABD;
}

.code-block {
  position: relative;
  margin-bottom: 1em;
}

.copy-button {
  background: transparent;
  color: white;
  position: absolute;
  top: 8px;
  right: 8px;
  border: none;
  padding: 4px 8px;
  font-size: 12px;
  border-radius: 4px;
  cursor: pointer;
  z-index: 1;
}

.copy-button:hover {
  background-color: #0056b3;
}

.snippet-container {
  overflow: hidden;
}

.snippet-header {
  padding: 0.75rem 1rem;
  cursor: pointer;
  font-size: 1rem;
    background-color: #eeeeee;
    color:  #111111; 
    border-radius: 8px;
    cursor: pointer;
    box-shadow: 0 4px 6px rgba(0,0,0,0.1);  
}

.snippet-body {
  display: none;
  font-family: monospace;
}

.snippet-container.open .snippet-body {
  display: block;
}

.CodeMirror {
  border: 2px solid #ccc;
  border-radius: 4px;
  resize: vertical;
}

/* === Light Mode === */
html.light-mode {
  background-color: #f8f7f5;
  color: #333;
}

html.light-mode .container {
  background: white;
}

html.light-mode .book-title-chapter {
  color: #2c3e50;
  border-color: #ccc;
}
html.light-mode .book-subtitle-chapter{
  color: #888;
}

html.light-mode .page-footer,
html.light-mode .series-name,
html.light-mode .book-subtitle,
html.light-mode .format-label {
  color: #888;
}

html.light-mode .related-books h2 {
  color: #333;
  border-bottom: 2px solid #eee;
}

html.light-mode .book-title {
  color: #fff;
}

html.light-mode .book-cover {
  border: 1px solid #ccc;
}

html.light-mode th {
  background-color: #f2f2f2;
}

html.light-mode tr:nth-child(even) {
  background-color: #fafafa;
}

html.light-mode tr:hover {
  background-color: #e6f7ff;
}

html.light-mode a,
html.light-mode .page-footer a {
  color: #000;
}

/* === Dark Mode === */
html.dark-mode {
  background-color: #181818;
  color: #e0e0e0;
}

html.dark-mode .container {
  background: #222;
}

html.dark-mode .book-title-chapter {
  color: #ddd;
  border-color: #444;
}

html.dark-mode .snippet-header {
    background-color: #333;
    color:  #ddd; 
}


html.dark-mode .book-subtitle-chapter,
html.dark-mode .page-footer,
html.dark-mode .series-name,
html.dark-mode .book-subtitle,
html.dark-mode .book-footer,
html.dark-mode .format-label {
  color: #aaa;
}

html.dark-mode .related-books h2 {
  color: #ddd;
  border-bottom: 2px solid #333;
}

html.dark-mode .book-title {
  color: #fff;
}

html.dark-mode .book-cover {
  border: 1px solid #555;
}

html.dark-mode th {
  background-color: #333;
  color: #fff;
}

html.dark-mode td {
  border-color: #444;
}

html.dark-mode tr:nth-child(even) {
  background-color: #2a2a2a;
}

html.dark-mode tr:hover {
  background-color: #2c3e50;
}

html.dark-mode a,
html.dark-mode .page-footer a {
  color: #eee;
}

    .dialog-backdrop {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: rgba(0,0,0,0.5);
      display: none;
      justify-content: center;
      align-items: center;
      z-index: 10;
    }

    .dialog {
      background: white;
      padding: 20px;
      width: 90vw;
      height: 80vh;
      border-radius: 8px;
      box-shadow: 0 0 20px rgba(0,0,0,0.3);
      display: flex;
      flex-direction: column;
    }
    .dialog-content {
      display: flex;
      flex: 1;
      gap: 20px;
      margin-top: 10px;
    }
    .dialog h2 {
      margin-top: 0;
    }

    .textarea_dialog {
      width: 50%;
      height: 100%;
      resize: none;
      font-family: monospace;
      font-size: 14px;
      padding: 10px;
      box-sizing: border-box;
      border: 1px solid #ccc;
    }

    .iframe_dialog {
      width: 50%;
      height: 100%;
      border: 1px solid #ccc;
    }
    .controls_dialog {
      display: flex;
      justify-content: space-between;
      margin-top: 10px;
    }    
    button { padding: 0.5em 1em; background: green; color: white; border: none; cursor: pointer; }
    button:hover { background: #1e7e34; }
    .result_iframe { width:99%; height:200px; margin-top: 1em;  resize: both;border:1px solid #ccc;}        
</style>
</head>
<body> 
  <div class="container">
    <div class = "chapter-navi-section">
<a href="cplusplus-for-beginners-project-mini-game-e-g-tic-tac-toe-or-snake.htm" class="nav-button prev">←</a>
<a href='cplusplus-for-beginners.htm#project-data-processing-and-analysis-tool' class="nav-button toc-link">Index</a>
<a href="" class="nav-button next"></a>
</div>

    <h1 class="book-title-chapter" id = 'top'>Project: Data Processing and Analysis Tool</h1>
    <h3 class="book-subtitle-chapter">C++ for Beginners</h3>   
    <!-- <h1 class ="chapter-title"></h1> -->
    <h2 id='reading-and-processing-large-data-files'>23.1 Reading and Processing Large Data Files</h2><p>When building a data processing and analysis tool in C++, efficiently reading and parsing large data files is fundamental. Large files can be gigabytes in size and may not fit entirely in memory, so your program must handle input streams carefully to avoid crashes or performance bottlenecks.</p><p>This section covers key techniques to read large files using C++ file streams, parse common file formats like CSV and TSV, detect errors, and manage memory wisely. Practical code examples demonstrate chunked reading, parsing lines into data fields, and simple preprocessing steps.</p><h3 id="using-file-streams-for-large-files">Using File Streams for Large Files</h3><p>The primary way to read files in C++ is through the standard input file stream <code>std::ifstream</code>. It allows reading data sequentially, which is important for large files since you typically cannot or should not load the entire file into memory at once.</p><p>Example: Open and read a file line by line</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;fstream&gt;
#include &lt;string&gt;

void readFileLineByLine(const std::string&amp; filename) {
    std::ifstream file(filename);
    if (!file.is_open()) {
        std::cerr &lt;&lt; "Failed to open file: " &lt;&lt; filename &lt;&lt; "\n";
        return;
    }

    std::string line;
    while (std::getline(file, line)) {
        // Process each line here
        std::cout &lt;&lt; line &lt;&lt; "\n";
    }

    file.close();
}</code></pre>
</div><p>This reads the file one line at a time, making it memory efficient regardless of file size.</p><h3 id="handling-different-file-formats-csv-and-tsv">Handling Different File Formats: CSV and TSV</h3><p><strong>CSV (Comma-Separated Values)</strong> and <strong>TSV (Tab-Separated Values)</strong> are common plain-text formats where each line represents a data record, and fields are separated by commas or tabs.</p><p>To parse these formats, you need to:</p><ul>
 <li>Split each line into fields based on the delimiter (<code>,</code> for CSV, <code>\t</code> for TSV).</li>
 <li>Handle cases where fields might be quoted or contain delimiter characters.</li>
 <li>Convert fields into appropriate data types.</li>
</ul><h3 id="simple-parsing-by-delimiter">Simple Parsing by Delimiter</h3><p>For many simple cases, you can split lines on delimiter characters using <code>std::getline</code> with a custom delimiter.</p><p>Example: Parse a CSV line into fields:</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-cpp">#include &lt;sstream&gt;
#include &lt;vector&gt;

std::vector&lt;std::string&gt; parseCSVLine(const std::string&amp; line) {
    std::vector&lt;std::string&gt; fields;
    std::stringstream ss(line);
    std::string field;

    while (std::getline(ss, field, ',')) {
        fields.push_back(field);
    }

    return fields;
}</code></pre>
</div><p>This approach works for basic CSV files without quoted fields.</p><h3 id="chunked-reading-for-large-files">Chunked Reading for Large Files</h3><p>Sometimes reading line by line is sufficient, but for extremely large files, you might want to process the file in <strong>chunks</strong> — reading a block of data, then processing records inside that block before moving on.</p><p>This is useful when your data records might span multiple lines, or when using lower-level optimizations.</p><p>Example: Reading fixed-size chunks (buffered reading)</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-cpp">#include &lt;fstream&gt;
#include &lt;vector&gt;

void readFileInChunks(const std::string&amp; filename, std::size_t chunkSize = 4096) {
    std::ifstream file(filename, std::ios::binary);
    if (!file) {
        std::cerr &lt;&lt; "Cannot open file\n";
        return;
    }

    std::vector&lt;char&gt; buffer(chunkSize);
    while (file.read(buffer.data(), buffer.size()) || file.gcount() &gt; 0) {
        std::streamsize bytesRead = file.gcount();
        // Process buffer[0..bytesRead-1] here
        std::cout.write(buffer.data(), bytesRead);
    }
}</code></pre>
</div><p>This reads the file in 4 KB blocks and processes the raw bytes. For text files, you must handle cases where chunks split lines, which adds complexity.</p><h3 id="error-handling-and-validation">Error Handling and Validation</h3><p>When reading files, always check:</p><ul>
 <li>Whether the file opened successfully.</li>
 <li>Whether reads fail unexpectedly.</li>
 <li>Whether lines or fields conform to expected format.</li>
</ul><p>Example:</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-cpp">if (!file.is_open()) {
    throw std::runtime_error("Cannot open input file");
}
if (file.bad()) {
    std::cerr &lt;&lt; "I/O error while reading file\n";
}</code></pre>
</div><p>Validate data fields to catch corrupted or malformed data early.</p><h3 id="memory-considerations">Memory Considerations</h3><ul>
 <li>Avoid loading entire large files into memory.</li>
 <li>Use <strong>streaming</strong> approaches: process data as it is read.</li>
 <li>If you must store parsed data, consider container efficiency (<code>std::vector</code> vs <code>std::list</code>), and reserve capacity ahead of time when possible.</li>
 <li>For truly large datasets, consider using databases or memory-mapped files (outside scope here).</li>
</ul><h3 id="example-reading-and-preprocessing-csv-file">Example: Reading and Preprocessing CSV File</h3><p>This example reads a CSV file line by line, parses fields, and converts the first two fields to numeric values for analysis.</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">📋</button>
 <pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;fstream&gt;
#include &lt;sstream&gt;
#include &lt;string&gt;
#include &lt;vector&gt;

struct DataRecord {
    int id;
    double value;
    std::string label;
};

std::vector&lt;DataRecord&gt; readCSVData(const std::string&amp; filename) {
    std::vector&lt;DataRecord&gt; records;
    std::ifstream file(filename);
    if (!file.is_open()) {
        std::cerr &lt;&lt; "Error opening file\n";
        return records;
    }

    std::string line;
    // Optionally skip header line
    std::getline(file, line);

    while (std::getline(file, line)) {
        std::stringstream ss(line);
        std::string field;
        std::vector&lt;std::string&gt; fields;

        while (std::getline(ss, field, ',')) {
            fields.push_back(field);
        }

        if (fields.size() &lt; 3) continue;  // Skip invalid lines

        try {
            int id = std::stoi(fields[0]);
            double value = std::stod(fields[1]);
            std::string label = fields[2];

            records.push_back({id, value, label});
        } catch (const std::exception&amp; e) {
            std::cerr &lt;&lt; "Parsing error: " &lt;&lt; e.what() &lt;&lt; "\n";
            // Skip malformed line
        }
    }
    return records;
}

int main() {
    auto data = readCSVData("data.csv");
    std::cout &lt;&lt; "Loaded " &lt;&lt; data.size() &lt;&lt; " records.\n";

    // Example preprocessing: filter values &gt; threshold
    double threshold = 50.0;
    for (const auto&amp; record : data) {
        if (record.value &gt; threshold) {
            std::cout &lt;&lt; "ID: " &lt;&lt; record.id &lt;&lt; ", Value: " &lt;&lt; record.value
                      &lt;&lt; ", Label: " &lt;&lt; record.label &lt;&lt; "\n";
        }
    }
    return 0;
}</code></pre>
</div><p>This example shows:</p><ul>
 <li>Reading a CSV file line by line.</li>
 <li>Splitting lines into fields.</li>
 <li>Converting string fields to numeric types with error checking.</li>
 <li>Simple data filtering as a preprocessing step.</li>
</ul><h3 id="summary">Summary</h3><ul>
 <li>Use <code>std::ifstream</code> and line-by-line reading for memory-efficient input.</li>
 <li>Parse CSV, TSV, or other delimited formats by splitting lines on delimiters.</li>
 <li>Handle malformed data and file errors gracefully.</li>
 <li>For very large files, consider chunked reading but handle incomplete records carefully.</li>
 <li>Keep memory usage minimal by processing data as streams, avoiding loading entire files at once.</li>
 <li>Use exceptions or error flags to detect and report problems early.</li>
</ul><p>Efficient file reading and parsing lay the foundation for powerful data processing tools and enable handling real-world large datasets with confidence.</p><div class = "chapter-navi-section">
<a href="#top" class="nav-button prev">↑</a>
<a href='cplusplus-for-beginners.htm#project-data-processing-and-analysis-tool' class="nav-button toc-link">Index</a>
<a href="#bottom" class="nav-button next">↓</a>
</div>
<h2 id='using-stl-algorithms-and-data-structures'>23.2 Using STL Algorithms and Data Structures</h2><p>In building a data processing and analysis tool, efficiently organizing and manipulating your data is key. The C++ Standard Template Library (STL) offers versatile containers such as <code>vector</code>, <code>map</code>, and <code>unordered_map</code>, along with powerful algorithms like <code>sort</code>, <code>accumulate</code>, and <code>find_if</code>. These allow you to perform common data processing tasks—grouping, filtering, searching, and summarizing—with concise, readable, and high-performance code.</p><p>This section demonstrates how to harness STL containers and algorithms to transform raw data into meaningful insights.</p><h3 id="choosing-stl-containers-for-data-storage">Choosing STL Containers for Data Storage</h3><p>Before analyzing data, you must decide how to store it.</p><ul>
 <li><strong><code>std::vector</code></strong>: Dynamic array for ordered sequences. Ideal for datasets you want to process sequentially or sort.</li>
 <li><strong><code>std::map</code></strong>: Sorted associative container mapping keys to values. Useful for grouping data by keys in sorted order.</li>
 <li><strong><code>std::unordered_map</code></strong>: Hash table-based mapping with faster average lookup. Great when order is not required but quick access is.</li>
</ul><h3 id="example-dataset-structure">Example Dataset Structure</h3><p>Suppose you have a dataset of <code>DataRecord</code>s (from the previous chapter):</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-cpp">struct DataRecord {
    int id;
    double value;
    std::string category;
};</code></pre>
</div><p>We will perform grouping, filtering, and summarizing based on <code>category</code> and <code>value</code>.</p><h3 id="grouping-data-with-std-map">Grouping Data with <code>std::map</code></h3><p>To group records by their category and compute aggregates like sums or counts, <code>std::map</code> is very useful.</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-cpp">#include &lt;map&gt;
#include &lt;string&gt;
#include &lt;vector&gt;
#include &lt;iostream&gt;

void groupByCategory(const std::vector&lt;DataRecord&gt;&amp; records) {
    std::map&lt;std::string, double&gt; sumByCategory;

    for (const auto&amp; record : records) {
        sumByCategory[record.category] += record.value;  // accumulate sums per category
    }

    // Display results
    for (const auto&amp; [category, total] : sumByCategory) {
        std::cout &lt;&lt; "Category: " &lt;&lt; category &lt;&lt; ", Total Value: " &lt;&lt; total &lt;&lt; "\n";
    }
}</code></pre>
</div><p>Here, each category string maps to the sum of values belonging to that category.</p><h3 id="fast-lookup-with-std-unordered-map">Fast Lookup with <code>std::unordered_map</code></h3><p>If order of categories does not matter but you want faster access, use <code>std::unordered_map</code>:</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-cpp">#include &lt;unordered_map&gt;

void fastLookupCategory(const std::vector&lt;DataRecord&gt;&amp; records) {
    std::unordered_map&lt;std::string, int&gt; countByCategory;

    for (const auto&amp; record : records) {
        countByCategory[record.category]++;
    }

    for (const auto&amp; [category, count] : countByCategory) {
        std::cout &lt;&lt; "Category: " &lt;&lt; category &lt;&lt; ", Count: " &lt;&lt; count &lt;&lt; "\n";
    }
}</code></pre>
</div><p>This counts how many records belong to each category.</p><h3 id="sorting-data-with-std-sort">Sorting Data with <code>std::sort</code></h3><p>Suppose you want to sort records by their value in descending order to identify top performers.</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-cpp">#include &lt;algorithm&gt;

void sortByValue(std::vector&lt;DataRecord&gt;&amp; records) {
    std::sort(records.begin(), records.end(),
              [](const DataRecord&amp; a, const DataRecord&amp; b) {
                  return a.value &gt; b.value;  // descending order
              });
}</code></pre>
</div><p>You can then process or display the sorted vector.</p><h3 id="summarizing-data-with-std-accumulate">Summarizing Data with <code>std::accumulate</code></h3><p>To compute a total or average of a numeric field, <code>std::accumulate</code> is very handy.</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-cpp">#include &lt;numeric&gt;

double totalValue(const std::vector&lt;DataRecord&gt;&amp; records) {
    return std::accumulate(records.begin(), records.end(), 0.0,
                           [](double sum, const DataRecord&amp; rec) {
                               return sum + rec.value;
                           });
}</code></pre>
</div><p>To calculate an average, divide by the number of records after checking it's not zero.</p><h3 id="filtering-data-with-std-copy-if-and-std-remove-if">Filtering Data with <code>std::copy_if</code> and <code>std::remove_if</code></h3><p>You can filter records matching specific criteria with <code>std::copy_if</code>:</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-cpp">#include &lt;algorithm&gt;

std::vector&lt;DataRecord&gt; filterByThreshold(const std::vector&lt;DataRecord&gt;&amp; records, double threshold) {
    std::vector&lt;DataRecord&gt; filtered;
    std::copy_if(records.begin(), records.end(), std::back_inserter(filtered),
                 [threshold](const DataRecord&amp; rec) {
                     return rec.value &gt; threshold;
                 });
    return filtered;
}</code></pre>
</div><p>Alternatively, to remove elements from the original container (in-place), use <code>std::remove_if</code> followed by <code>erase</code>:</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-cpp">void removeLowValues(std::vector&lt;DataRecord&gt;&amp; records, double threshold) {
    auto it = std::remove_if(records.begin(), records.end(),
                             [threshold](const DataRecord&amp; rec) {
                                 return rec.value &lt;= threshold;
                             });
    records.erase(it, records.end());
}</code></pre>
</div><h3 id="searching-with-std-find-if">Searching with <code>std::find_if</code></h3><p>To find the first record matching a condition:</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-cpp">auto it = std::find_if(records.begin(), records.end(),
                       [](const DataRecord&amp; rec) {
                           return rec.category == "Important" &amp;&amp; rec.value &gt; 100;
                       });

if (it != records.end()) {
    std::cout &lt;&lt; "Found record with id " &lt;&lt; it-&gt;id &lt;&lt; " meeting criteria.\n";
} else {
    std::cout &lt;&lt; "No matching record found.\n";
}</code></pre>
</div><h3 id="combining-stl-algorithms-for-complex-queries">Combining STL Algorithms for Complex Queries</h3><p>STL algorithms can be composed to perform multi-step analyses clearly.</p><p>Example: Find the category with the highest total value.</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-cpp">std::map&lt;std::string, double&gt; sumByCategory;
for (const auto&amp; rec : records) {
    sumByCategory[rec.category] += rec.value;
}

auto maxPair = std::max_element(sumByCategory.begin(), sumByCategory.end(),
                                [](const auto&amp; a, const auto&amp; b) {
                                    return a.second &lt; b.second;
                                });

if (maxPair != sumByCategory.end()) {
    std::cout &lt;&lt; "Category with highest total value: " &lt;&lt; maxPair-&gt;first
              &lt;&lt; " = " &lt;&lt; maxPair-&gt;second &lt;&lt; "\n";
}</code></pre>
</div><h3 id="practical-tips">Practical Tips</h3><ul>
 <li><p>When possible, reserve space in vectors upfront to minimize reallocations:</p>
  <div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
   <pre><code class="language-cpp">std::vector&lt;DataRecord&gt; data;
data.reserve(10000); // for large datasets</code></pre>
  </div></li>
 <li><p>Choose <code>map</code> if you need sorted keys, <code>unordered_map</code> for speed.</p></li>
 <li><p>Use lambdas for concise custom predicates in algorithms.</p></li>
 <li><p>Combine STL algorithms with range-based <code>for</code> loops for elegant code.</p></li>
</ul><h3 id="summary">Summary</h3><ul>
 <li>Use <strong><code>vector</code></strong> for flexible ordered collections of data records.</li>
 <li>Use <strong><code>map</code></strong> and <strong><code>unordered_map</code></strong> for grouping and fast lookups by keys.</li>
 <li>Apply <strong><code>sort</code></strong> to order data by criteria.</li>
 <li>Use <strong><code>accumulate</code></strong> for summing or aggregating numeric data.</li>
 <li>Use <strong><code>copy_if</code>, <code>remove_if</code>, and <code>find_if</code></strong> for filtering and searching datasets.</li>
 <li>Combining STL containers and algorithms enables concise, efficient data analysis pipelines.</li>
</ul><p>Mastering STL’s data structures and algorithms will empower you to build powerful and maintainable data processing tools with minimal code complexity.</p><div class = "chapter-navi-section">
<a href="#top" class="nav-button prev">↑</a>
<a href='cplusplus-for-beginners.htm#project-data-processing-and-analysis-tool' class="nav-button toc-link">Index</a>
<a href="#bottom" class="nav-button next">↓</a>
</div>
<h2 id='basic-multithreading-for-performance'>23.3 Basic Multithreading for Performance</h2><p>As datasets grow larger, processing them sequentially can become slow and inefficient. C++ supports <strong>multithreading</strong>, allowing your program to run multiple tasks concurrently on different CPU cores. This can significantly improve the performance of data processing tools by parallelizing compute-intensive tasks like parsing, filtering, and aggregation.</p><p>This section introduces simple multithreading concepts and techniques to parallelize your data processing tasks, including thread creation, dividing workloads, and synchronizing shared results safely. Practical examples demonstrate how to split data processing across threads and combine outcomes correctly.</p><h3 id="why-use-multithreading">Why Use Multithreading?</h3><p>Modern computers typically have multiple CPU cores. Multithreading leverages this hardware by running independent tasks simultaneously, reducing overall execution time.</p><p>For example, if you have a million data records to analyze, you can divide them into chunks and process each chunk on a separate thread, then combine the partial results. This can make your tool much faster compared to a single-threaded approach.</p><h3 id="creating-threads-in-c">Creating Threads in C</h3><p>The C++ Standard Library offers <code>std::thread</code> to create and manage threads easily.</p><p>Basic example creating and running a thread:</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">📋</button>
 <pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;thread&gt;

void printMessage() {
    std::cout &lt;&lt; "Hello from thread!\n";
}

int main() {
    std::thread t(printMessage);  // Start thread running printMessage()
    t.join();  // Wait for thread to finish before exiting main
    return 0;
}</code></pre>
</div><p>The <code>join()</code> call ensures the main thread waits for the new thread to finish, preventing premature exit.</p><h3 id="partitioning-workload">Partitioning Workload</h3><p>To use multithreading for data processing, split your dataset into parts, then assign each part to a thread.</p><p>Example: Suppose you have a vector of records and want to sum their values in parallel.</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-cpp">#include &lt;vector&gt;
#include &lt;thread&gt;
#include &lt;numeric&gt;
#include &lt;iostream&gt;

struct DataRecord {
    double value;
    // Other fields...
};

void partialSum(const std::vector&lt;DataRecord&gt;&amp; data, size_t start, size_t end, double&amp; result) {
    result = 0.0;
    for (size_t i = start; i &lt; end; ++i) {
        result += data[i].value;
    }
}

int main() {
    std::vector&lt;DataRecord&gt; data(1000000, {1.0}); // Sample data: 1 million records with value 1.0

    size_t mid = data.size() / 2;
    double sum1 = 0.0, sum2 = 0.0;

    std::thread t1(partialSum, std::ref(data), 0, mid, std::ref(sum1));
    std::thread t2(partialSum, std::ref(data), mid, data.size(), std::ref(sum2));

    t1.join();
    t2.join();

    double totalSum = sum1 + sum2;
    std::cout &lt;&lt; "Total sum: " &lt;&lt; totalSum &lt;&lt; "\n";
}</code></pre>
</div><p><strong>Explanation:</strong></p><ul>
 <li>The vector is split into two halves.</li>
 <li>Two threads compute the partial sums concurrently.</li>
 <li>Using <code>std::ref</code> to pass references so results are stored correctly.</li>
 <li>The main thread waits for both threads with <code>join()</code>, then combines results.</li>
</ul><h3 id="synchronization-and-data-safety">Synchronization and Data Safety</h3><p>When threads share data, <strong>race conditions</strong> may occur if multiple threads read/write simultaneously.</p><p>In the example above, each thread writes its own separate <code>sum</code> variable, so no synchronization is needed.</p><p>However, if threads update shared data structures, use synchronization primitives like <code>std::mutex</code> to avoid data corruption.</p><p>Example:</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-cpp">#include &lt;mutex&gt;

std::mutex mtx;
double globalSum = 0.0;

void threadSafePartialSum(const std::vector&lt;DataRecord&gt;&amp; data, size_t start, size_t end) {
    double localSum = 0.0;
    for (size_t i = start; i &lt; end; ++i) {
        localSum += data[i].value;
    }
    std::lock_guard&lt;std::mutex&gt; lock(mtx); // Lock mutex during update
    globalSum += localSum;
}</code></pre>
</div><p>Using <code>std::lock_guard</code> ensures the mutex is unlocked automatically when the scope ends, avoiding deadlocks.</p><h3 id="using-a-thread-pool-for-more-threads">Using a Thread Pool for More Threads</h3><p>Manually managing many threads can get complicated. For more advanced use cases, thread pools manage a fixed number of threads and distribute tasks efficiently.</p><p>Although the C++ standard library does not include thread pools (until C++23’s <code>std::jthread</code>), you can implement simple pools or use third-party libraries.</p><p>For beginners, splitting the work into a few threads, as shown above, is usually sufficient.</p><h3 id="handling-exceptions-in-threads">Handling Exceptions in Threads</h3><p>If a thread throws an exception, it must be handled inside that thread. Otherwise, <code>std::terminate()</code> is called.</p><p>Wrap thread functions in try-catch blocks for safety:</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-cpp">void safePartialSum(...) {
    try {
        // Processing code...
    } catch (const std::exception&amp; e) {
        std::cerr &lt;&lt; "Thread error: " &lt;&lt; e.what() &lt;&lt; "\n";
    }
}</code></pre>
</div><h3 id="example-parallel-filtering">Example: Parallel Filtering</h3><p>Suppose you want to filter records with values above a threshold using two threads:</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-cpp">#include &lt;vector&gt;
#include &lt;thread&gt;
#include &lt;iostream&gt;

void filterRange(const std::vector&lt;DataRecord&gt;&amp; input, size_t start, size_t end,
                 double threshold, std::vector&lt;DataRecord&gt;&amp; output) {
    for (size_t i = start; i &lt; end; ++i) {
        if (input[i].value &gt; threshold) {
            output.push_back(input[i]);  // Note: vector push_back not thread-safe
        }
    }
}

int main() {
    std::vector&lt;DataRecord&gt; data(100000, {1.0});
    double threshold = 0.5;

    std::vector&lt;DataRecord&gt; filtered1, filtered2;

    std::thread t1(filterRange, std::ref(data), 0, data.size() / 2, threshold, std::ref(filtered1));
    std::thread t2(filterRange, std::ref(data), data.size() / 2, data.size(), threshold, std::ref(filtered2));

    t1.join();
    t2.join();

    // Combine results
    filtered1.insert(filtered1.end(), filtered2.begin(), filtered2.end());

    std::cout &lt;&lt; "Filtered count: " &lt;&lt; filtered1.size() &lt;&lt; "\n";
}</code></pre>
</div><p><strong>Note:</strong> Each thread writes to its own vector to avoid race conditions, then results are merged after threads finish.</p><h3 id="best-practices">Best Practices</h3><ul>
 <li><strong>Divide work evenly</strong> to balance thread workloads.</li>
 <li><strong>Avoid sharing writable data</strong> without synchronization.</li>
 <li>Use <strong>thread-safe containers or local buffers</strong> to prevent conflicts.</li>
 <li><strong>Join threads</strong> before accessing their results.</li>
 <li>Start with a small number of threads (e.g., equal to hardware concurrency).</li>
 <li>Profile your program: not all tasks benefit from parallelism due to overhead.</li>
</ul><h3 id="summary">Summary</h3><ul>
 <li>Multithreading enables running data processing tasks concurrently to improve performance.</li>
 <li>Use <code>std::thread</code> to create threads and assign parts of data to each.</li>
 <li>Synchronize shared data access with <code>std::mutex</code> to prevent race conditions.</li>
 <li>Design thread functions to work on local or partitioned data.</li>
 <li>Join threads before combining results.</li>
 <li>Handle exceptions within threads carefully.</li>
 <li>Parallelize operations like summing, filtering, and aggregation by splitting input data.</li>
</ul><p>By carefully applying these multithreading concepts, your data processing tool can scale to handle large datasets more quickly and efficiently, fully utilizing modern multi-core processors.</p><div class = "chapter-navi-section">
<a href="cplusplus-for-beginners-project-mini-game-e-g-tic-tac-toe-or-snake.htm" class="nav-button prev">←</a>
<a href='cplusplus-for-beginners.htm#project-data-processing-and-analysis-tool' class="nav-button toc-link">Index</a>
<a href="" class="nav-button next"></a>
</div>
<section class="download-section">
  <div class="book-cover" style="background-color: #f9f6f1;border: 1px solid #ccc;"> 
    <div class="book-cover-title" style="font-size: 18px;color: #333;top: 20px;">C++ for Beginners</div>
    <div class="book-cover-author">readbytes</div>
    <div class="book-cover-bottom-stripe" style="background-color: #333;"></div>
    <img class="book-cover-icon" style="width: 90px;height: 90px;top: 70px;" src="data:image/png;base64,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"/>
  </div>
  <div class="download-info">
    <h2 id='bottom'>Download This Ebook</h2>
    <p class="format-label">Available formats:</p>
    <div class="download-buttons">
      <a href="cplusplus-for-beginners.pdf" class="download-button">📄 PDF</a>
      <a href="cplusplus-for-beginners.epub" class="download-button">📘 EPUB</a>
    </div>
  </div>
</section><div class='related-books'>
<h2>C++ Introduction Books</h2>
<div class='related-book-list'>
<a href="cplusplus-for-beginners.htm">
<div class="book-cover" style="background-color: #f9f6f1;border: 1px solid #ccc;"> 
    <div class="book-cover-title" style="font-size: 18px;color: #333;top: 20px;">C++ for Beginners</div>
    <div class="book-cover-author">readbytes</div>
    <div class="book-cover-bottom-stripe" style="background-color: #333;"></div>
    <img class="book-cover-icon" style="width: 90px;height: 90px;top: 70px;" src="data:image/png;base64,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"/>
  </div>
</a>


<a href="cplusplus-syntax.htm">
<div class="book-cover" style="background-color: #f9f6f1;border: 1px solid #ccc;"> 
    <div class="book-cover-title" style="font-size: 20px;color: #333;top: 20px;">C++ Syntax</div>
    <div class="book-cover-author">readbytes</div>
    <div class="book-cover-bottom-stripe" style="background-color: #333;"></div>
    <img class="book-cover-icon" style="width: 90px;height: 90px;top: 70px;" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFoAAABaCAYAAAA4qEECAAAFZ0lEQVR4Xu2dy4scVRSH8ye0iYtkERcmzgjT2OYBuhNREMVXBh/TgsYQx5ULDYTgVl3EFyg6uFJBV76IEXdKXAVBJCgISSTRGRmZiZlADBo6M5kp+3ZbnXt/p7q6btWtc++pqQPfpu/p7vP7UnSqi+m6GzbkrMbYO50u0Tqjgx5Kqe4brSa8+XplFf0UroQ3GbDltqNRs70Y3Tw5G22//2SXU0Fyy5MXc6GyqYyYWwd9WdfGbW9uxRe9vvlBtOvZKLrpwTOiUDO7QjlALxu3zWxFf5mq++RF/YU27/40au39lwSQAspygXICwhfRY2rhv5Z6URxcEuoAQUkuQV/oM7HwSN45vUoGlwaKKQOrI1t9zuhPaD19mQwtEZRSFrq71M/sqh3JMSikTHSH6LdXeoN6Ag4rlV3Ta0RG2aTKjhfU/6Q4rGRQAgf62QhKHnzjk3wKlwRK4EI7qq99g4wf3NR8nwwqmfE9s0QAF8olOarjB1QDDisZDM+NIbqhXYXDQaWDwbnRPj46xtkGDiodDM6N7nYgWl2hwkEl09r7DwnOzZbbr131G4iemFokw0oGQ/ug2XVKRI9PzpJhJYOhfdB66m8qevsDp8iwksHQPqi8aAzsi1o0E7VoJioteuzh30lgX1RaNIb1SS2aiVo0E5UVPTH1Fwnrk8qKxqC+qUUzUYtmwovoL49dioYV9uZhx/4VEjRmWM2fp70uYRc9qrA/DxhSZ1RhvyuCEL1wfiU6PXulB/bnAUPqnJnv8+cSTtEv7HeFd9G4XpyzJGQaWLjuisqJxoCjeOVjc572y7THBayim4+cNUKdONkhPUXBgKO495AxUrTvVdrjAq+ij//k/i9UMeAo7jlojFSLzsLE4/ZfuyspuvXYb0Yo16IxXBZQ9DOv0x4XsIqeOjRvhPri20ukpwgYLgt3HTBGir75kfa4gFU01h373f5ZA4bLChauu4BNdPtF82hWhT1FuHVfh4TLCtbR47SnKKWKTqu5hWXSXwQMZsOBGZzOLOzPA7voNz66QPpcgMHy8Py7OG2/sC8P7KLjurK8RvqLgMFsmDmC05mF/XkoVbTOjinz1E4V9uSl6I+AsF6YoT1FYROtwLpzeo705AFD2YKF6y5gFf3oQfPM48h3w8+jD3+4ZIDrOnGYtz7vgyHTuBvOo7/+nva4gFW0zTdDLFyPGdN+BBQXhkyDfDN8jfa4gFW0zbWOH365bIDrMXqYE7/2wZBpoOhKXOuwEZ0VDGTLuhD98+kO6bEFA9lyXxWvRyuwcN0GdccFDGTLe1+Z87Rfoj0uEC0aw+QBC9dd4V10XMsraz2wPw0Mk4WVq33WcID/C/tdwS766uqwiP3C/jQwTBZGFfa7gl204rnDC5hvUNg7DAySlWH1yTHa6xIvol2AQUKnFs2ESNHjk3MkSOiIFI0hJFCLZqIWzYQ40c0nLpAQEhAnGgNIoRbNRC2aCVGid6b8CCh0RInG4SVRi2YiUXSIN68ae8juR0ChkSg6xNux4eDSSLwdW4g3GMTBpZF4g0EFBvUNDi4N3a0SHeRNYCfaS2RwaWii+1s/xQ+oRQzsCxxaIoOjGe8fHdKNunFoaWzSdh/SRQd363kcXBrax4a5eVm8EMJmCmn33pDA5t2f0aMZRStUM4bnBAeXhu4SPfdKb/C54Q0OLomRklWFsoUTDi8F3d11N759A/o1quF5UzIcXgq6sy7n0GtiwZN6L4RCygIDSAB9oc/UwiOba+NIDBEy+tmF1ZGMhZ/ZijK3Qh3f8wcJEyJOt0LVC19UR12harbPOdncFzfWDQGVTb8KlwT6KlyNertqHffbVSdVo96A3ar+A5kzbYSE7G+UAAAAAElFTkSuQmCC"/>
  </div>
</a>


<a href="cplusplus-stl.htm">
<div class="book-cover" style="background-color: #f9f6f1;border: 1px solid #ccc;"> 
    <div class="book-cover-title" style="font-size: 20px;color: #333;top: 20px;">C++ STL</div>
    <div class="book-cover-author">readbytes</div>
    <div class="book-cover-bottom-stripe" style="background-color: #333;"></div>
    <img class="book-cover-icon" style="width: 90px;height: 90px;top: 70px;" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFoAAABaCAYAAAA4qEECAAADK0lEQVR4Xu2cvWsTcRjHo+DkIKiTjiJugqTJ0cG/QcRZ/wJXQTd3ByeHDiLJnS84dHMVBHUSRQUH90pNfmfb6CKi8fqSaj93ae4lzzV3+X7gS9vkeZ7f7/lwEDq0jYYQQgghxFzQ9t0wbTzf3WO/SAllpg3niAlQYJa0uu4W54kxeA96ZykwU4JwnTPFGGLyMqd3nTNFAnFx2cOZIiee//UK5TLsEQWg3D1ZHpxgvShATLCeajsoWKKNaAfuDyVvZuGhu8paURBK1lNtBAVLtBEULNFGULBEG0HBlRfNRUrMqwW/f473GZFQvxXWVQbPD5e4zEGlcXt4eHQvvrdbU2W4zEGn5Yd3+NoovHul4DKzHN69UnCZWQ7vXim8IHzJhWY1vLtIQSRujSInhTNEBppL345R6LiwV+SAUpPCHpETimVYLwpAuRJtBOVKtBHNR4OTFCzRRlCwRBtBwRJtBAVLtBEULNFGeN3wPiVvp/+OtVmJ5qzvmdl1z1kzV8Ql53+q0/6az765gBLyConqN9i/X9hfeyiAYX0S7cCtsi9NOKf2UADDesL6LOGsWsPlx+V8d/Vo3t5x4bzyGA4P8TK1TuBeU0FpxC5T83D/0uBF6h7uXxq8SN3D/Utj80OHl6ltgvAX9y+V2IUm53eUQZQvUT4nvJ8x/e/R14+RiBeeHz4bZfPn6PW3bT908Z7s4d6Vgwsxix13mj15iGb94Ows4bxKwWUY1heF89OGcyoHFypjOZ4zKV7gVjijUjSfrJ/hUqOwdtrwvH2yzN7KkbDUTsKfrLWgufTmSPzsf2F9ZeFitVtwVqBgiTaCgiXaCAqWaCMoWKKNoGCJNoKCJdoICpZoIyhYoo2gYIk2goIl2ggKlmgjKFiijaBgiTaCgiXagLbfu0jBW+m6NdaKAsQEj9Jxl1krChATvBPWiQJ4fviJgiV6yiw+3ThOuRI9ZbzA3aRYSZ4iFx73T1FqUtg3l1DKbrr9960gvBt9f207/Rst332I1U0Iz5tbKGaa4VlzTSQk8X84Fw3PEY3p/70KTxA7UFTeeB13ibPFf1BY1nCeEEIIIYQowl8t5mhjJHw+fQAAAABJRU5ErkJggg=="/>
  </div>
</a>



<a href='cplusplus.htm'><div class='book-cover' style='background-color: #f9f6f1;color: #111111;border: 1px solid #ccc;display: flex;justify-content: center;align-items: center;text-align: center;'>More C++ Books</div></a>
</div>
</div>
  </div>
  <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/prism.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
  
  <script>
    function copyCode(button) {
      const code = button.nextElementSibling.innerText;
      navigator.clipboard.writeText(code).then(() => {
        button.textContent = 'Copied!';
        setTimeout(() => { button.textContent = 'Copy'; }, 1500);
      });
    }
  </script>  
<div id="floatingLog" aria-live="polite" role="alert"></div>
<footer class="page-footer">
    <nav>
      <a href="https://readbytes.github.io">Home</a> | 
      Email:<script language="JavaScript" type="text/javascript">
var part1 = 'yinpeng';var part6 = '263';var part2 = Math.pow(2,6);var part3 = String.fromCharCode(part2);var part4 = 'hotmail dot com';var part5 = part1 + String.fromCharCode(part2) + part4;document.write(part1 + part6 + part3 + part4);
</script>
    </nav>
  <p>© 2025 — All rights reserved.</p>    
  </footer>

</body>
</html>