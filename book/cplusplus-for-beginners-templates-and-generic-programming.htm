<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>C++ for Beginners Templates and Generic Programming</title>
<link rel='shortcut icon' href='https://readbytes.github.io/images/favicon.ico'>
<link href="https://fonts.googleapis.com/css2?family=Merriweather&display=swap" rel="stylesheet" />
<link href="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet" />
<script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/prism.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/codemirror.min.css" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/codemirror.min.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/theme/dracula.min.css"><style>
html {scroll-behavior: smooth;}  
body {font-family: 'Merriweather', serif;;margin: 0;padding: 2rem 1rem;font-size: 15px;line-height: 1.5;transition: background-color 0.3s, color 0.3s;}
.container {max-width: 750px;margin: 0 auto;padding: 1rem 2rem;}
.light-mode {background-color: #f8f7f5;color: #333;} 
.dark-mode {background-color: #121212;color: #e0e0e0;}
a { text-decoration: none;transition: color 0.2s;}
a:hover {text-decoration: underline;}
.light-mode a {color: #555;}
.dark-mode a {color: #aaa;}
</style><style>
.related-book-list {display: flex;flex-wrap: wrap;gap: 20px;}
.related-books {margin-top: 40px;}
.related-books h2 {font-size: 22px;margin-bottom: 20px;border-bottom: 2px solid #eee;padding-bottom: 8px;}
.light-mode .related-books h2 {color: #333;border-color: #eee;}
.dark-mode .related-books h2 {color: #ddd;border-color: #333;}
</style><style>
.book-cover {width: 130px;height: 180px;font-family: Arial, sans-serif;position: relative;overflow: hidden;box-shadow: 2px 2px 4px rgba(0,0,0,0.1);}
.book-cover-bottom-stripe {position: absolute;bottom: 0;left: 0;height: 5px;width: 100%;}
.book-cover-title {position: absolute;width: 100%;text-align: center;font-weight: bold;}
.book-cover-icon {position: absolute;left: 50%;transform: translateX(-50%);display: flex;align-items: center;justify-content: center;}
.book-cover-author {position: absolute;bottom: 10px;width: 100%;text-align: center;font-size: 8px;color: #333;}
</style><style>
.book-title-toc {font-size: 32px;font-weight: bold; }
.book-subtitle-toc {font-size: 18px;margin-top: 8px;font-style: italic;}
.book-header {text-align: center;margin-bottom: 40px;}

.toc-container {border-radius: 10px;padding: 30px;margin-bottom: 40px;box-shadow: 0 8px 20px rgba(0,0,0,0.05);}
h1 {font-size: 24px;text-align: center;margin-bottom: 30px;letter-spacing: 1px;padding-bottom: 10px;}
.toc-list,.toc-section-list {list-style: none;padding: 0;margin: 0;}
.toc-section-list {padding-left: 18px;margin-top: 6px;margin-bottom: 20px; }
.toc-chapter {padding: 20px 0;}
.chapter-title,.toc-section {display: flex;justify-content: space-between;padding-top: 4px;}
.chapter-title {font-size: 17px;font-weight: bold;}
.chapter-page,.section-page {font-style: italic;}
 
 
.light-mode .book-title-toc,.light-mode .chapter-title,.light-mode .book-name {color: #222;}
.light-mode .book-subtitle-toc,.light-mode .book-sub,.light-mode .chapter-page,.light-mode .section-page {color: #666;}
.light-mode .toc-container { background: #fff;border: 1px solid #ddd;}
.light-mode h1 {border-bottom: 2px solid #eee;color: #222;}
.light-mode .toc-section {  color: #444;}

.light-mode .book-cover { border: 1px solid #ccc;box-shadow: 0 6px 12px rgba(0, 0, 0, 0.15);}
.light-mode .book-title,.light-mode .series-name {color: #fff;}
.light-mode .book-subtitle,.light-mode .book-footer {color: #aaa;}

.dark-mode .book-title-toc,.dark-mode .chapter-title,.dark-mode .book-name {color: #f5f5f5;}
.dark-mode .book-subtitle-toc,.dark-mode .book-sub,.dark-mode .chapter-page,.dark-mode .section-page {color: #aaa;}
.dark-mode .toc-container {background: #1e1e1e;border: 1px solid #444;}

.dark-mode h1 {border-bottom: 2px solid #333;color: #eee;}
.dark-mode .toc-section {color: #bbb;}

.dark-mode .related-books h2 {color: #ddd;border-bottom: 2px solid #333;}
.dark-mode .book-title,.dark-mode .series-name {color: #fff;}
.dark-mode .book-subtitle,.dark-mode .book-footer {color: #bbb;}
.dark-mode .toc-section {color: #ddd;}

@media (max-width: 600px) {
  .chapter-title,
  .toc-section {
    flex-direction: column;
    align-items: flex-start;
  }

  .chapter-page,
  .section-page {
    margin-top: 4px;
  }
}

</style><style>
.light-mode .container {box-shadow: 0 0 15px rgba(0,0,0,0.1);}
.dark-mode .container {box-shadow: 0 0 15px rgba(255, 255, 255, 0.05);}

h1, h2, h3 {font-weight: 600;margin-top: 2.5rem;margin-bottom: 1rem;line-height: 1.2;}
h1 { font-size: 1.8rem; }
h2 { font-size: 1.4rem; }
h3 { font-size: 1.2rem; }

table {width: 100%;border-collapse: collapse;font-family: sans-serif;font-size: 1em;margin: 1em 0;}
th, td {padding: 0.6em 1em;text-align: left;border: 1px solid;}
tr:nth-child(even) {  background-color: inherit;}
tr:hover { background-color: inherit;}

code {color: #d35400;}

.chapter-navi-section {display: flex;justify-content: space-between;align-items: center;padding-bottom: 10px;padding-top: 10px;}
.nav-link {color: inherit;text-decoration: none;opacity: 0.5;transition: opacity 0.3s ease, text-decoration 0.3s ease;}
.nav-link:hover {opacity: 0.9;text-decoration: underline;}
.prev { text-align: left; }
.toc-link { text-align: center; }
.next { text-align: right; }

.download-section {display: flex;align-items: center;justify-content: center;gap: 2rem;padding: 2rem 1rem;max-width: 600px;margin: 3rem auto;border-radius: 12px;box-shadow: 0 4px 10px rgba(0,0,0,0.05);}
.download-info h2 {margin: 0 0 0.5rem;font-size: 1.2rem;}
.format-label {margin: 0 0 0.5rem;font-size: 0.95rem;}
.download-buttons {display: flex;gap: 1rem;}
.download-button {background-color: #4A90E2;color: white;padding: 0.5em 1.2em;border-radius: 25px;font-size: 0.95rem;text-decoration: none;transition: background-color 0.3s ease;}
.download-button:hover {background-color: #357ABD;}

.code-block {position: relative;margin-bottom: 1em;}
.copy-button {background: transparent;color: white;position: absolute;top: 8px;right: 8px;border: none;padding: 4px 8px;font-size: 12px;border-radius: 4px;cursor: pointer;z-index: 1;}
.copy-button:hover {background-color: #0056b3;}

.snippet-container {overflow: hidden;}
.snippet-header {padding: 0.75rem 1rem;cursor: pointer;font-size: 1rem;background-color: #eeeeee;color:  #111111; border-radius: 8px;cursor: pointer;box-shadow: 0 4px 6px rgba(0,0,0,0.1); }
.snippet-body {display: none;font-family: monospace;}
.snippet-container.open .snippet-body {display: block;}

.CodeMirror {border: 2px solid #ccc;border-radius: 4px;resize: vertical;}

.light-mode .format-label {color: #888;}
.light-mode th {background-color: #f2f2f2;}
.light-mode tr:nth-child(even) {background-color: #fafafa;}
.light-mode tr:hover {background-color: #e6f7ff;}

.dark-mode .snippet-header {background-color: #333;color:  #ddd; }
.dark-mode .format-label {color: #aaa;}
.dark-mode th {background-color: #333;color: #fff;}
.dark-mode td {border-color: #444;}
.dark-mode tr:nth-child(even) {background-color: #2a2a2a;}
.dark-mode tr:hover {background-color: #2c3e50;}


.button-group-run-edit {display: flex;width: 100%;gap: 1rem;}
.button-run-edit {flex: 1;padding: 1rem;font-size: 1rem;font-weight: 600;border: none;border-radius: 8px;cursor: pointer;transition: background 0.3s, color 0.3s;}

.light-mode .button-run-edit {background-color: #f0f0f0;color: #222;box-shadow: 0 0 10px rgba(0, 0, 0, 0.05);}
.light-mode .button-run-edit:hover {background-color: #e0e0e0;}

.dark-mode .button-run-edit {background-color: #2a2a2a;color: #f5f5f5;box-shadow: 0 0 10px rgba(255, 255, 255, 0.05);}
.dark-mode .button-run-edit:hover {background-color: #3a3a3a;}

button { padding: 0.5em 1em; background: green; color: white; border: none; cursor: pointer; }
button:hover { background: #1e7e34; }
.result_iframe { width:99%; margin-top: 1em;  resize: both;background-color: #515b63;border:1px solid #ccc;}   

.dialog-backdrop {position: fixed;top: 0;left: 0;width: 100vw;height: 100vh;background: rgba(0,0,0,0.5);display: none;justify-content: center;align-items: center;z-index: 10;}
.dialog {background: #90979e;padding: 20px;width: 90vw;height: 80vh;border-radius: 8px;box-shadow: 0 0 20px rgba(0,0,0,0.3);display: flex;flex-direction: column;}
.dialog-content {display: flex;gap: 20px;margin-top: 10px;height: calc(100% - 40px);}
.editor-container, .preview-container {flex: 1;height: 100%;max-height: 100%;overflow: hidden; }
.result_iframe_dialog {width: 100%;height: 100%;resize: both;border:1px solid #ccc;overflow: auto; }   
.CodeMirror {width: 100% !important;height: 100% !important;}
</style>
</head>
<body>
<script>const mode = localStorage.getItem('mode') || 'light';document.documentElement.classList.add(`${mode}-mode`);</script>  
<div class="container"><div class = "chapter-navi-section">
<a href="cplusplus-for-beginners-inheritance-and-polymorphism.htm" class="nav-button prev">←</a>
<a href='cplusplus-for-beginners.htm#templates-and-generic-programming' class="nav-button toc-link">Index</a>
<a href="cplusplus-for-beginners-exception-handling.htm" class="nav-button next">→</a>
</div>
<div class='book-header'><h1 class='book-title-toc' id = 'top'>Templates and Generic Programming</h1><h3 class='book-subtitle-toc'>C++ for Beginners</h3></div><h2 id='function-templates'>12.1 Function Templates</h2><p>In C++, <strong>function templates</strong> offer a powerful way to write generic, type-independent functions that can work with any data type. Instead of writing multiple versions of a function for different types, you write a single template, and the compiler generates the appropriate function code based on the types used in each function call. This technique promotes code reuse, reduces redundancy, and makes your programs more flexible.</p><h3 id="what-is-a-function-template">What is a Function Template?</h3><p>A <strong>function template</strong> is essentially a blueprint for creating functions. You define it using the keyword <code>template</code> followed by a template parameter list enclosed in angle brackets (<code>&lt;&gt;</code>). The compiler uses this template to generate concrete functions when you call the function with specific types.</p><h3 id="syntax-of-a-function-template">Syntax of a Function Template</h3><div class="code-block">
 <button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-cpp">template &lt;typename T&gt;
T functionName(T param1, T param2) {
    // function body
}</code></pre>
</div><p>Here, <code>T</code> is a <strong>template parameter</strong> representing a placeholder for a data type. When you call the function with particular argument types, the compiler substitutes <code>T</code> with the actual type(s) and creates the function.</p><h3 id="example-1-generic-swap-function">Example 1: Generic Swap Function</h3><p>One of the simplest and most common examples of a function template is a generic swap function that exchanges the values of two variables.</p><div class="code-block">
 <button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-cpp">template &lt;typename T&gt;
void swapValues(T&amp; a, T&amp; b) {
    T temp = a;
    a = b;
    b = temp;
}</code></pre>
</div><p><strong>Explanation:</strong></p><ul>
 <li><code>template &lt;typename T&gt;</code> declares that <code>T</code> is a placeholder type.</li>
 <li>The function <code>swapValues</code> takes two references of type <code>T</code>.</li>
 <li>It swaps the values using a temporary variable of type <code>T</code>.</li>
</ul><h3 id="using-the-function-template">Using the Function Template</h3><div class="code-block">
 <button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-cpp">int main() {
    int x = 10, y = 20;
    swapValues(x, y);
    std::cout &lt;&lt; "x = " &lt;&lt; x &lt;&lt; ", y = " &lt;&lt; y &lt;&lt; std::endl;

    double a = 1.5, b = 2.5;
    swapValues(a, b);
    std::cout &lt;&lt; "a = " &lt;&lt; a &lt;&lt; ", b = " &lt;&lt; b &lt;&lt; std::endl;

    return 0;
}</code></pre>
</div><p><strong>Output:</strong></p><div class="code-block">
 <button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-bash">x = 20, y = 10
a = 2.5, b = 1.5</code></pre>
</div><p>The same <code>swapValues</code> function works for both <code>int</code> and <code>double</code> without writing separate functions.</p><h3 id="template-argument-deduction">Template Argument Deduction</h3><p>The compiler automatically deduces the template parameter types by inspecting the types of the function arguments you pass. This means you usually do not have to specify the template type explicitly.</p><div class="code-block">
 <button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-cpp">swapValues(5, 10);  // Compiler deduces T as int
swapValues(3.14, 2.71);  // T deduced as double</code></pre>
</div><p>However, if needed, you can explicitly specify the template arguments:</p><div class="code-block">
 <button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-cpp">swapValues&lt;int&gt;(5, 10);</code></pre>
</div><h3 id="example-2-generic-max-function">Example 2: Generic Max Function</h3><p>Let's create a function template to return the maximum of two values:</p><div class="code-block">
 <button class="copy-button" onclick="copyCode(this)">📋</button>
 <pre><code class="language-cpp">#include &lt;iostream&gt; 
template &lt;typename T&gt;
T maxValue(T a, T b) {
    return (a &gt; b) ? a : b;
}

int main() {
    std::cout &lt;&lt; maxValue(10, 20) &lt;&lt; std::endl;        // Outputs 20
    std::cout &lt;&lt; maxValue(3.14, 2.71) &lt;&lt; std::endl;    // Outputs 3.14
    std::cout &lt;&lt; maxValue('a', 'z') &lt;&lt; std::endl;      // Outputs 'z'
    return 0;
}</code></pre>
</div><h3 id="example-3-generic-sorting-function-simplified">Example 3: Generic Sorting Function (Simplified)</h3><p>Function templates can also be used to write generic algorithms. Here is a simplified example of a bubble sort function template that sorts an array of any type:</p><div class="code-block">
 <button class="copy-button" onclick="copyCode(this)">📋</button>
 <pre><code class="language-cpp">#include &lt;iostream&gt;

template &lt;typename T&gt;
void bubbleSort(T arr[], int size) {
    for (int i = 0; i &lt; size - 1; ++i) {
        for (int j = 0; j &lt; size - i -1; ++j) {
            if (arr[j] &gt; arr[j + 1]) {
                T temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;
            }
        }
    }
}
 
int main() {
    int numbers[] = {5, 3, 8, 6, 2};
    int size = sizeof(numbers) / sizeof(numbers[0]);

    bubbleSort(numbers, size);

    for (int i = 0; i &lt; size; ++i) {
        std::cout &lt;&lt; numbers[i] &lt;&lt; " ";
    }

    return 0;
}</code></pre>
</div><p><strong>Output:</strong></p><div class="code-block">
 <button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-bash">2 3 5 6 8</code></pre>
</div><p>This sorting function works with any type <code>T</code> that supports the <code>&gt;</code> operator.</p><h3 id="limitations-of-function-templates">Limitations of Function Templates</h3><p>While function templates are versatile, there are some limitations and considerations:</p><ul>
 <li><strong>Type Requirements:</strong> The operations inside the template function must be valid for the template type. For example, in <code>maxValue</code>, the <code>&gt;</code> operator must be defined for type <code>T</code>.</li>
 <li><strong>Code Bloat:</strong> Each instantiation of the template with a different type generates a separate copy of the function, which can increase the final executable size.</li>
 <li><strong>Special Behavior Needed:</strong> Sometimes, you want to implement a function template for most types but customize behavior for specific types.</li>
</ul><h3 id="template-specialization">Template Specialization</h3><p>To handle special cases, C++ allows <strong>template specialization</strong> — providing a different implementation of a function template for a particular type.</p><h3 id="example-specialized-swap-for-const-char">Example: Specialized Swap for <code>const char*</code></h3><p>The generic swap template swaps objects using assignment. But swapping <code>const char*</code> pointers swaps addresses, not the strings they point to. You may want to specialize the swap function for <code>const char*</code> to swap the strings instead.</p><div class="code-block">
 <button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-cpp">template &lt;&gt;
void swapValues&lt;const char*&gt;(const char*&amp; a, const char*&amp; b) {
    char temp[100];
    strcpy(temp, a);
    strcpy((char*)a, b);
    strcpy((char*)b, temp);
}</code></pre>
</div><p><strong>Note:</strong> This example is simplified and uses <code>strcpy</code> for illustration. In practice, <code>std::string</code> is preferred for safe string handling.</p><h3 id="summary">Summary</h3><ul>
 <li><strong>Function templates</strong> enable writing generic functions that work with any data type.</li>
 <li>The syntax uses <code>template &lt;typename T&gt;</code> before the function definition.</li>
 <li>Template parameters are usually <strong>deduced automatically</strong> by the compiler based on function arguments.</li>
 <li>Common examples include generic <code>swap</code>, <code>max</code>, and sorting functions.</li>
 <li>Templates require that the operations used inside are valid for the types substituted.</li>
 <li><strong>Template specialization</strong> allows you to provide customized implementations for specific types.</li>
 <li>Using function templates can greatly reduce code duplication and increase flexibility.</li>
</ul><p>By mastering function templates, you gain a fundamental tool for generic programming in C++, setting the stage for exploring class templates, STL containers, and more advanced topics covered in this chapter.</p><div class = "chapter-navi-section">
<a href="#top" class="nav-button prev">↑</a>
<a href='cplusplus-for-beginners.htm#templates-and-generic-programming' class="nav-button toc-link">Index</a>
<a href="#bottom" class="nav-button next">↓</a>
</div>
<h2 id='class-templates'>12.2 Class Templates</h2><p>In C++, <strong>class templates</strong> extend the power of templates to user-defined types, allowing you to create <strong>generic classes</strong> that can work with any data type. This means you can design a class once and reuse it with different types without rewriting code for each type.</p><p>Class templates are fundamental for building flexible, reusable components like containers, smart pointers, or any data structures that need to work with a variety of types. Understanding class templates is a crucial step toward mastering generic programming in C++.</p><h3 id="what-is-a-class-template">What is a Class Template?</h3><p>A <strong>class template</strong> is a blueprint for creating classes parameterized by one or more types. Instead of specifying a fixed type for members, methods, or parameters, you use <strong>template parameters</strong> as placeholders.</p><h3 id="syntax-of-a-class-template">Syntax of a Class Template</h3><div class="code-block">
 <button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-cpp">template &lt;typename T&gt;
class ClassName {
    // Members using T
};</code></pre>
</div><ul>
 <li>The <code>template &lt;typename T&gt;</code> line declares a template with a type parameter <code>T</code>.</li>
 <li>The class definition uses <code>T</code> as a type placeholder.</li>
 <li>When you instantiate the template, you provide the actual type to replace <code>T</code>.</li>
</ul><h3 id="example-1-generic-stack-class">Example 1: Generic Stack Class</h3><p>Let's create a simple generic stack class that can store elements of any type:</p><div class="code-block">
 <button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-cpp">#include &lt;iostream&gt;

template &lt;typename T&gt;
class Stack {
private:
    static const int maxSize = 100;
    T data[maxSize];
    int top;

public:
    Stack() : top(-1) {}

    bool push(const T&amp; item) {
        if (top &gt;= maxSize - 1) {
            std::cout &lt;&lt; "Stack overflow\n";
            return false;
        }
        data[++top] = item;
        return true;
    }

    bool pop() {
        if (top &lt; 0) {
            std::cout &lt;&lt; "Stack underflow\n";
            return false;
        }
        --top;
        return true;
    }

    T peek() const {
        if (top &lt; 0) {
            throw std::out_of_range("Stack is empty");
        }
        return data[top];
    }

    bool isEmpty() const {
        return top == -1;
    }
};</code></pre>
</div><h3 id="explanation">Explanation:</h3><ul>
 <li><code>template &lt;typename T&gt;</code> declares the class template with type parameter <code>T</code>.</li>
 <li>The stack uses a fixed-size array of type <code>T</code> to store elements.</li>
 <li>Methods <code>push</code>, <code>pop</code>, <code>peek</code>, and <code>isEmpty</code> operate on elements of type <code>T</code>.</li>
 <li>The stack can be instantiated with any data type (e.g., <code>int</code>, <code>double</code>, or user-defined types).</li>
</ul><h3 id="using-the-generic-stack">Using the Generic Stack</h3><div class="code-block">
 <button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-cpp">int main() {
    Stack&lt;int&gt; intStack;
    intStack.push(10);
    intStack.push(20);
    std::cout &lt;&lt; "Top element: " &lt;&lt; intStack.peek() &lt;&lt; std::endl;

    Stack&lt;std::string&gt; stringStack;
    stringStack.push("Hello");
    stringStack.push("World");
    std::cout &lt;&lt; "Top element: " &lt;&lt; stringStack.peek() &lt;&lt; std::endl;

    return 0;
}</code></pre>
</div><p><strong>Output:</strong></p><div class="code-block">
 <button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-bash">Top element: 20
Top element: World</code></pre>
</div><p>Here, the same <code>Stack</code> class works with both <code>int</code> and <code>std::string</code> without any changes to the class code.</p><h3 id="template-parameters-and-multiple-types">Template Parameters and Multiple Types</h3><p>Class templates can have multiple type parameters:</p><div class="code-block">
 <button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-cpp">template &lt;typename T, typename U&gt;
class Pair {
public:
    T first;
    U second;

    Pair(const T&amp; a, const U&amp; b) : first(a), second(b) {}
};</code></pre>
</div><p>Usage:</p><div class="code-block">
 <button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-cpp">Pair&lt;int, std::string&gt; p(1, "apple");
std::cout &lt;&lt; p.first &lt;&lt; ", " &lt;&lt; p.second &lt;&lt; std::endl;</code></pre>
</div><h3 id="template-member-functions">Template Member Functions</h3><p>Member functions of a class template can be defined inside or outside the class.</p><h3 id="inside-the-class-inline">Inside the class (inline):</h3><div class="code-block">
 <button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-cpp">template &lt;typename T&gt;
class Box {
    T value;
public:
    void setValue(const T&amp; val) { value = val; }
    T getValue() const { return value; }
};</code></pre>
</div><h3 id="outside-the-class">Outside the class:</h3><p>When defining member functions outside the class, you must repeat the template declaration and specify the class as a template:</p><div class="code-block">
 <button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-cpp">template &lt;typename T&gt;
void Box&lt;T&gt;::setValue(const T&amp; val) {
    value = val;
}

template &lt;typename T&gt;
T Box&lt;T&gt;::getValue() const {
    return value;
}</code></pre>
</div><h3 id="instantiating-class-templates">Instantiating Class Templates</h3><p>You create instances (objects) of a class template by specifying the actual type(s) in angle brackets:</p><div class="code-block">
 <button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-cpp">Stack&lt;int&gt; s1;            // Stack of integers
Stack&lt;double&gt; s2;         // Stack of doubles
Pair&lt;std::string, int&gt; p("Age", 30);  // Pair of string and int</code></pre>
</div><p>The compiler generates the appropriate class definition and member functions for each type used.</p><h3 id="requirements-for-template-parameters">Requirements for Template Parameters</h3><p>Types used as template arguments must support operations used in the class:</p><ul>
 <li>For example, if your class uses the assignment operator, the type must be assignable.</li>
 <li>If your class compares elements using <code>&lt;</code> or <code>==</code>, the type must support these operators.</li>
 <li>This is often called the "concept" or "type requirements" of a template parameter.</li>
</ul><p>If a type doesn't meet the requirements, you'll get compiler errors.</p><h3 id="example-2-generic-array-class">Example 2: Generic Array Class</h3><p>Here's a generic dynamic array class with minimal functionality:</p><div class="code-block">
 <button class="copy-button" onclick="copyCode(this)">📋</button>
 <pre><code class="language-cpp">#include &lt;iostream&gt;

template &lt;typename T&gt;
class Array {
private:
    T* elements;
    int size;

public:
    Array(int s) : size(s) {
        elements = new T[size];
    }

    ~Array() {
        delete[] elements;
    }

    void set(int index, const T&amp; value) {
        if (index &gt;= 0 &amp;&amp; index &lt; size) {
            elements[index] = value;
        }
    }

    T get(int index) const {
        if (index &gt;= 0 &amp;&amp; index &lt; size) {
            return elements[index];
        }
        throw std::out_of_range("Index out of range");
    }

    int getSize() const {
        return size;
    }
};
 
int main() {
    Array&lt;int&gt; arr(5);
    for (int i = 0; i &lt; arr.getSize(); ++i) {
        arr.set(i, i * 10);
    }
    for (int i = 0; i &lt; arr.getSize(); ++i) {
        std::cout &lt;&lt; arr.get(i) &lt;&lt; " ";
    }
    return 0;
}</code></pre>
</div><p>Output:</p><div class="code-block">
 <button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-bash">0 10 20 30 40</code></pre>
</div><p>This class can be instantiated with any type that supports assignment and default construction.</p><h3 id="summary">Summary</h3><ul>
 <li><strong>Class templates</strong> define generic classes parameterized by types using <code>template &lt;typename T&gt;</code>.</li>
 <li>They enable writing reusable, type-independent data structures and classes.</li>
 <li>Template parameters can be one or multiple types.</li>
 <li>Member functions can be defined inside or outside the class template.</li>
 <li>When instantiating class templates, you specify the actual type(s) in angle brackets.</li>
 <li>Template arguments must satisfy type requirements based on the operations used inside the class.</li>
 <li>Examples like generic <code>Stack</code> and <code>Array</code> classes show practical use of class templates for storing and manipulating data of various types.</li>
</ul><p>Class templates are the foundation of generic programming in C++. Mastering them unlocks the power of the Standard Template Library (STL) and helps you write clean, maintainable, and efficient code that adapts to many types.</p><div class = "chapter-navi-section">
<a href="#top" class="nav-button prev">↑</a>
<a href='cplusplus-for-beginners.htm#templates-and-generic-programming' class="nav-button toc-link">Index</a>
<a href="#bottom" class="nav-button next">↓</a>
</div>
<h2 id='template-specialization'>12.3 Template Specialization</h2><p>Templates in C++ provide a powerful mechanism to write generic, reusable code. However, sometimes you want to <strong>customize</strong> the behavior of a template for specific types or arguments. This is where <strong>template specialization</strong> comes in. Template specialization allows you to define alternate implementations of a template for particular cases, enhancing flexibility, correctness, and efficiency.</p><h3 id="what-is-template-specialization">What is Template Specialization?</h3><p>Template specialization means providing a <strong>customized version</strong> of a template when certain template arguments meet specific criteria. Instead of using the generic template definition, the compiler selects the specialized version for those arguments.</p><p>There are two main types of specialization:</p><ul>
 <li><strong>Full specialization:</strong> Specialize the template for a specific set of template arguments.</li>
 <li><strong>Partial specialization:</strong> Specialize the template for a subset or pattern of template arguments.</li>
</ul><h3 id="full-template-specialization">Full Template Specialization</h3><p><strong>Full specialization</strong> occurs when you define a completely separate implementation of a template for a specific type or set of types.</p><h3 id="syntax">Syntax</h3><p>Suppose you have a generic class template:</p><div class="code-block">
 <button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-cpp">template &lt;typename T&gt;
class Calculator {
public:
    static void info() {
        std::cout &lt;&lt; "Generic Calculator\n";
    }
};</code></pre>
</div><p>You can fully specialize it for <code>int</code> like this:</p><div class="code-block">
 <button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-cpp">template &lt;&gt;
class Calculator&lt;int&gt; {
public:
    static void info() {
        std::cout &lt;&lt; "Integer Calculator\n";
    }
};</code></pre>
</div><p>Notice the empty angle brackets <code>&lt;&gt;</code> after <code>template</code>, which indicates a specialization, and the specific type <code>int</code> inside the angle brackets after the class name.</p><h3 id="example-usage">Example Usage</h3><div class="code-block">
 <button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-cpp">int main() {
    Calculator&lt;double&gt;::info();  // Output: Generic Calculator
    Calculator&lt;int&gt;::info();     // Output: Integer Calculator
    return 0;
}</code></pre>
</div><p>Here, when <code>Calculator&lt;int&gt;</code> is instantiated, the specialized version is used, while for <code>Calculator&lt;double&gt;</code>, the generic version applies.</p><h3 id="partial-template-specialization">Partial Template Specialization</h3><p>Partial specialization lets you specialize templates for a <strong>subset of template arguments</strong> or according to a pattern, rather than fully specifying all arguments.</p><p>Partial specialization is only allowed for <strong>class templates</strong> (not function templates).</p><h3 id="syntax-example">Syntax Example</h3><p>Suppose you have a template class with two parameters:</p><div class="code-block">
 <button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-cpp">template &lt;typename T1, typename T2&gt;
class Pair {
public:
    void display() {
        std::cout &lt;&lt; "Generic Pair\n";
    }
};</code></pre>
</div><p>You can partially specialize for the case when both template parameters are the <strong>same type</strong>:</p><div class="code-block">
 <button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-cpp">template &lt;typename T&gt;
class Pair&lt;T, T&gt; {
public:
    void display() {
        std::cout &lt;&lt; "Pair with two identical types\n";
    }
};</code></pre>
</div><h3 id="example-usage">Example Usage</h3><div class="code-block">
 <button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-cpp">int main() {
    Pair&lt;int, double&gt; p1;
    p1.display();   // Output: Generic Pair

    Pair&lt;int, int&gt; p2;
    p2.display();   // Output: Pair with two identical types

    return 0;
}</code></pre>
</div><p>In this example, the compiler uses the partial specialization for pairs where both types are the same, while using the generic template otherwise.</p><h3 id="specialization-for-pointers">Specialization for Pointers</h3><p>Partial specialization can be very useful for pointer types:</p><div class="code-block">
 <button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-cpp">template &lt;typename T&gt;
class Wrapper {
public:
    void identify() {
        std::cout &lt;&lt; "Generic type\n";
    }
};

// Partial specialization for pointer types
template &lt;typename T&gt;
class Wrapper&lt;T*&gt; {
public:
    void identify() {
        std::cout &lt;&lt; "Pointer type\n";
    }
};</code></pre>
</div><h3 id="usage">Usage</h3><div class="code-block">
 <button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-cpp">Wrapper&lt;int&gt; w1;
w1.identify();    // Output: Generic type

Wrapper&lt;int*&gt; w2;
w2.identify();    // Output: Pointer type</code></pre>
</div><p>Here, <code>Wrapper&lt;int*&gt;</code> uses the specialized implementation for pointer types.</p><h3 id="when-to-use-template-specialization">When to Use Template Specialization?</h3><p>Template specialization is valuable in many practical scenarios:</p><ol>
 <li><strong>Type-specific behavior:</strong> For example, a generic container might need a special implementation for <code>bool</code> because storing bits can be optimized.</li>
 <li><strong>Optimizations:</strong> Some types may allow faster or more efficient algorithms, so specialized versions can boost performance.</li>
 <li><strong>Correctness:</strong> Certain types require unique handling (e.g., deep copy semantics for pointers or resources).</li>
 <li><strong>Interfacing with legacy code:</strong> You might specialize templates to work properly with third-party or system types.</li>
</ol><h3 id="example-specialized-print-function-template">Example: Specialized <code>print</code> Function Template</h3><p>Consider a generic function template that prints values:</p><div class="code-block">
 <button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-cpp">template &lt;typename T&gt;
void print(const T&amp; value) {
    std::cout &lt;&lt; "Value: " &lt;&lt; value &lt;&lt; std::endl;
}</code></pre>
</div><p>This works fine for many types, but suppose you want a different format when printing <code>bool</code> values:</p><div class="code-block">
 <button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-cpp">// Full specialization for bool
template &lt;&gt;
void print&lt;bool&gt;(const bool&amp; value) {
    std::cout &lt;&lt; "Boolean: " &lt;&lt; (value ? "true" : "false") &lt;&lt; std::endl;
}</code></pre>
</div><p>Usage:</p><div class="code-block">
 <button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-cpp">int main() {
    print(42);        // Output: Value: 42
    print(true);      // Output: Boolean: true
    return 0;
}</code></pre>
</div><p>This shows how you can specialize a function template for <code>bool</code> without affecting other types.</p><h3 id="summary">Summary</h3><ul>
 <li><strong>Template specialization</strong> customizes template behavior for particular types or template arguments.</li>
 <li><strong>Full specialization</strong> completely overrides the template for specific types.</li>
 <li><strong>Partial specialization</strong> customizes templates for a subset or pattern of arguments, only for class templates.</li>
 <li>Specialization is useful for optimization, correctness, and type-specific behavior.</li>
 <li>Common uses include handling pointer types, integral types, or special cases like <code>bool</code>.</li>
 <li>Understanding specialization helps you write flexible and efficient generic code.</li>
</ul><p>Mastering template specialization opens the door to advanced C++ programming, allowing you to build versatile libraries and applications that adapt smoothly to diverse data types.</p><div class = "chapter-navi-section">
<a href="#top" class="nav-button prev">↑</a>
<a href='cplusplus-for-beginners.htm#templates-and-generic-programming' class="nav-button toc-link">Index</a>
<a href="#bottom" class="nav-button next">↓</a>
</div>
<h2 id='using-standard-template-library-stl-basics'>12.4 Using Standard Template Library (STL) Basics</h2><p>The <strong>Standard Template Library (STL)</strong> is one of C++’s most powerful features, offering a rich collection of generic classes and functions designed to simplify common programming tasks. Built upon templates, the STL provides reusable, efficient, and flexible components that save you from writing boilerplate code, enabling you to focus on solving your problem rather than reinventing data structures and algorithms.</p><p>In this section, we will introduce the core parts of the STL: <strong>containers</strong>, <strong>iterators</strong>, and <strong>algorithms</strong>, and show practical examples of how templates empower the STL to work seamlessly with different data types.</p><h3 id="what-is-the-stl">What is the STL?</h3><p>The STL is a library that implements <strong>generic programming</strong> concepts. It includes:</p><ul>
 <li><strong>Containers:</strong> Data structures such as arrays, lists, queues, stacks, maps, and more, implemented as template classes.</li>
 <li><strong>Iterators:</strong> Objects that provide a standardized way to access elements within containers, abstracting pointer-like behavior.</li>
 <li><strong>Algorithms:</strong> Template functions that perform operations like searching, sorting, counting, and manipulating container elements.</li>
</ul><p>Because all STL components are template-based, they work uniformly with any data type, whether built-in or user-defined, without rewriting code for each type.</p><h3 id="common-stl-containers">Common STL Containers</h3><h4 id="std-vector"><code>std::vector</code></h4><p>A <strong>dynamic array</strong> that can resize automatically. It stores elements contiguously in memory, providing fast random access.</p><div class="code-block">
 <button class="copy-button" onclick="copyCode(this)">📋</button>
 <pre><code class="language-cpp">#include &lt;vector&gt;
#include &lt;iostream&gt;

int main() {
    std::vector&lt;int&gt; numbers;  // Vector of integers

    // Adding elements
    numbers.push_back(10);
    numbers.push_back(20);
    numbers.push_back(30);

    // Access elements
    for (size_t i = 0; i &lt; numbers.size(); ++i) {
        std::cout &lt;&lt; numbers[i] &lt;&lt; " ";
    }
    // Output: 10 20 30
    return 0;
}</code></pre>
</div><h4 id="std-list"><code>std::list</code></h4><p>A <strong>doubly linked list</strong> allowing efficient insertions and deletions at any position but slower random access compared to <code>vector</code>.</p><div class="code-block">
 <button class="copy-button" onclick="copyCode(this)">📋</button>
 <pre><code class="language-cpp">#include &lt;list&gt;
#include &lt;iostream&gt;

int main() {
    std::list&lt;std::string&gt; names = {"Alice", "Bob", "Charlie"};

    // Insert element at beginning
    names.push_front("Zara");

    for (const auto&amp; name : names) {
        std::cout &lt;&lt; name &lt;&lt; " ";
    }
    // Output: Zara Alice Bob Charlie
    return 0;
}</code></pre>
</div><h4 id="std-map"><code>std::map</code></h4><p>An <strong>associative container</strong> that stores key-value pairs in sorted order, allowing fast lookups by key.</p><div class="code-block">
 <button class="copy-button" onclick="copyCode(this)">📋</button>
 <pre><code class="language-cpp">#include &lt;map&gt;
#include &lt;iostream&gt;

int main() {
    std::map&lt;int, std::string&gt; idToName;

    idToName[101] = "John";
    idToName[102] = "Emily";

    // Accessing by key
    std::cout &lt;&lt; idToName[101] &lt;&lt; std::endl;  // Output: John

    return 0;
}</code></pre>
</div><h4 id="iterators-accessing-container-elements">Iterators: Accessing Container Elements</h4><p>Iterators provide a <strong>uniform interface</strong> to traverse elements in any container, similar to pointers.</p><h4 id="example-using-iterators-with-std-vector">Example: Using Iterators with <code>std::vector</code></h4><div class="code-block">
 <button class="copy-button" onclick="copyCode(this)">📋</button>
 <pre><code class="language-cpp">#include &lt;vector&gt;
#include &lt;iostream&gt;

int main() {
    std::vector&lt;int&gt; data = {1, 2, 3, 4, 5};

    // Using iterator to traverse vector
    for (std::vector&lt;int&gt;::iterator it = data.begin(); it != data.end(); ++it) {
        std::cout &lt;&lt; *it &lt;&lt; " ";  // Dereference iterator to get element
    }
    // Output: 1 2 3 4 5
    return 0;
}</code></pre>
</div><p>Modern C++ allows simpler iteration with range-based for loops, which internally use iterators:</p><div class="code-block">
 <button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-cpp">for (int value : data) {
    std::cout &lt;&lt; value &lt;&lt; " ";
}</code></pre>
</div><h3 id="stl-algorithms-generic-operations">STL Algorithms: Generic Operations</h3><p>STL provides many <strong>template functions</strong> for common operations, applicable to any container supporting the required iterator category.</p><h3 id="example-sorting-a-vector">Example: Sorting a Vector</h3><div class="code-block">
 <button class="copy-button" onclick="copyCode(this)">📋</button>
 <pre><code class="language-cpp">#include &lt;vector&gt;
#include &lt;algorithm&gt;  // For std::sort
#include &lt;iostream&gt;

int main() {
    std::vector&lt;int&gt; nums = {5, 2, 8, 1, 4};

    std::sort(nums.begin(), nums.end());

    for (int n : nums) {
        std::cout &lt;&lt; n &lt;&lt; " ";
    }
    // Output: 1 2 4 5 8
    return 0;
}</code></pre>
</div><h3 id="example-finding-an-element">Example: Finding an Element</h3><div class="code-block">
 <button class="copy-button" onclick="copyCode(this)">📋</button>
 <pre><code class="language-cpp">#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;iostream&gt;

int main() {
    std::vector&lt;std::string&gt; fruits = {"apple", "banana", "cherry"};

    auto it = std::find(fruits.begin(), fruits.end(), "banana");

    if (it != fruits.end()) {
        std::cout &lt;&lt; "Found: " &lt;&lt; *it &lt;&lt; std::endl;
    } else {
        std::cout &lt;&lt; "Not found" &lt;&lt; std::endl;
    }

    return 0;
}</code></pre>
</div><h3 id="how-templates-simplify-stl">How Templates Simplify STL</h3><p>Thanks to templates, the STL containers and algorithms can:</p><ul>
 <li>Work with <strong>any data type</strong>, including user-defined classes.</li>
 <li>Be <strong>efficient</strong> because templates allow compile-time type resolution, avoiding overhead.</li>
 <li>Promote <strong>code reuse</strong> by providing a single implementation that handles various data types.</li>
 <li>Allow <strong>custom behavior</strong> by letting you define comparison operators or provide function objects for algorithms.</li>
</ul><h3 id="practical-example-using-std-vector-and-algorithms-together">Practical Example: Using <code>std::vector</code> and Algorithms Together</h3><p>Let's write a simple program to store student grades, sort them, and display the top grades.</p><div class="code-block">
 <button class="copy-button" onclick="copyCode(this)">📋</button>
 <pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

int main() {
    std::vector&lt;int&gt; grades = {85, 92, 78, 90, 88};

    // Sort grades in descending order using a lambda function
    std::sort(grades.begin(), grades.end(), [](int a, int b) {
        return a &gt; b;
    });

    std::cout &lt;&lt; "Top grades: ";
    for (int grade : grades) {
        std::cout &lt;&lt; grade &lt;&lt; " ";
    }
    // Output: Top grades: 92 90 88 85 78
    return 0;
}</code></pre>
</div><p>This example demonstrates how containers, iterators, and algorithms work together to accomplish a common task with minimal code.</p><h3 id="summary">Summary</h3><ul>
 <li>The STL is a powerful <strong>generic programming</strong> library built with templates.</li>
 <li>It provides <strong>containers</strong> like <code>vector</code>, <code>list</code>, and <code>map</code> to store data flexibly.</li>
 <li><strong>Iterators</strong> allow uniform traversal of container elements, abstracting pointer-like operations.</li>
 <li><strong>Algorithms</strong> are template functions performing common tasks like sorting, searching, and modifying collections.</li>
 <li>Templates enable the STL to be <strong>type-independent</strong>, efficient, and easy to use.</li>
 <li>Mastering STL basics helps you write concise, robust C++ code with less effort.</li>
</ul><p>As you continue learning, exploring the full STL will significantly boost your productivity and deepen your understanding of C++'s powerful capabilities.</p><div class = "chapter-navi-section">
<a href="cplusplus-for-beginners-inheritance-and-polymorphism.htm" class="nav-button prev">←</a>
<a href='cplusplus-for-beginners.htm#templates-and-generic-programming' class="nav-button toc-link">Index</a>
<a href="cplusplus-for-beginners-exception-handling.htm" class="nav-button next">→</a>
</div>
<section class="download-section">
  <div class="book-cover" style="background-color: #f9f6f1;border: 1px solid #ccc;"> 
    <div class="book-cover-title" style="font-size: 18px;color: #333;top: 20px;">C++ for Beginners</div>
    <div class="book-cover-author">readbytes</div>
    <div class="book-cover-bottom-stripe" style="background-color: #333;"></div>
    <img class="book-cover-icon" style="width: 90px;height: 90px;top: 70px;" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFoAAABaCAYAAAA4qEECAAAKvUlEQVR4Xu1de3BUVx2OOjqjo+Mo2ezmnc2DvNoGjBSKgAIm0EIKRShQaFINhaQ8QiFSsIhBKUlrqUKthNaURyUpj0yLLU3Fos447TiMCvIPVnnMdNpCYRApJGFIwnp/d++5nP3Ouffu3Wz2cZNv5hvY3/mdc77fd8+93NcuCQkxDq/b1a3QZ8Qsd9K72GcIQQLNLMxI8TWvr/W1Nq1W+XLDct/SOfcKpivswrGGIAFv2r5nfmiLW9csUvvtbVybjeMOQYNiUF+oBsvIxsr1eFw416BFOA3mOa98nN/wZNcEnHPQYaBMZqybP10zOzkT5x40GGiTGSunfUedB+cfFFAKPxYJkxnZRkUdjgcV/dKGpYIhA0nN7GrU4lgoxd6K5GpmnDVxzOBa1VRsm3LRgUb0h6sWzhBiMtLcDQkJn0VNjkOW21UX7tVMV43BjjlojtVUZE6yWzAgVM4r086VFU4bWyq0yzhojMbCzZifbrxap4weobZdunjRd8+IuwzzkENGA2nls9WKbSx+7dNPfQyyPBnVvkmuXajNMVAKfMqWGRo3LV2gx3duXKHHERQbU5wnjIXU+t9CfY6B0epE8kay/B3rH9PjdJiQYXfLb4IaP9uTpOahPseAihue6hEKNzKZwD4T8zPSOFvloDwyEsfl+dDU8c43etsTjwqFG5kcKmiMvY2rhPEZf7JknvON/u1muQHhMpnQ/Kvn1bFefVqch/iL+mrnGy27IgynyQxzZ96vjrmmapYw344f+4/3qM8x8K+yet1Y4tmTx3z/u3IFfQoLzp4+rc8z/Vul+t/rK2c632h+9dKf61avAntuY/XypRgyBF203LhxA8MqclM86lwtzdt9D33vAV0D6nMMeJOtgBvFDN3d3UHnEoaM5mDH6Mq5DwadS1g4Z/aQ0Qx5af57HHW1S7BJCjtjlwzPHTI6GIzIz8OQLTAdqM8xYAUWZKZj7bZAY3R3dWE4aAwKo/dsWhmwqjs7r3MWWOPq1au2DhMI1tfxRvMXKOzmjl08cO9UDJni5InjAQYzDVlu11zU6AiwIomPTJ/Ur5VpB2gyt7F7UWPcI9Pt9vKF8gX/6Z0/oDdhhWxex75U4zV4xWBUfk5Qq3pOxTQ1jy5OCDu0G0dWGFkwXGo028ioM+5BReUZ3IumthP/+Dt6JEDb3XX+dP2TmCKA8uhdapyTM/ozqDWuYbSqiJX3+XfjcINtEJyPN9pxq9qsYL7ocMHKZOKMCaOcZXROcmKpVdHhNHtx1cOWJvNzot64RTCriy+8P2bffWex2p8ujHBsGSk3NTV1GGqOS1AxhRmpQpFGZGZPGjsGfTQF69fWVC+MaUStTx9qjktQMbMnjxWKNGPFuNtPRKxWOJ+H41iR9UPNcQkqZPuPaoQizTi+pFA3+EjHW2CtHKEY7ah3PKiQ0YXWbxDxNFvJ/AomXvzkgh5vbRQf/prRaSt6q53VVv+w/+GpDFO+7X/55dYfa32zxhUIphNftPFNAseYzMBMwEJ5NtTM1806eeIEeqyC2grTParRLJfhxV+/IJhObDG5MnSc0QRWGL1ygMUy3pWXw9kqgnLIZGb0fy9fxhQd+1tbhfGJ9BKPY01mwKKJXR1vBHw2A7XzRtvB7w8fFubWzHbW/Q4CX+CNt98UiCYsrqrUjXpwRoVu9PPL+n9/5M9HjwrzEXM9Xy9G3XEDK4OR5w+0CQYQv5mXJj0+hwNHOjoC5sIaYh52DDYjjcEfNvBVMjbP1i3PBsRDQdwZTYLpKxJoWihEo3msXeV/6Cvj9m1bA3KtsE3ZUHFlNIml997QsFBYVeZ/xkgm71lXLhhNn4sy/Kd9jD3v1PiyJca3NDcH9EVoeTexnpgEKwoNC5U01j2FGYbHZ7YRzNh3tFbZu/yX3DwRFMN6YhIpKSlfCqfJRN5IdWx4czQYo5Fdby+Ob6NJ6N35uYJZ/SEazWPlYzUhGS1b0VuamrR44mWsK6ZQXFz8hXCv5uqpZbqRBxvuE8yhz3QXDo20IvWjc2kcixFriykwkWhWf0jjjc5P183JVs5i0Bw6/qKRVsQNxsbqfOt3sW92uE0m0phW5kws8QpGmvHia983HIufF+uLCXg9SaujYXRF2Xf1Fcg4aUS2YC5PlsejcWODYLTCHqwz6mDi0SjG52oeFWJWrCqfrBvdvlE8Psswe7o/j+f4OzIFow+1twf0Q/3n9u5WP2OdUQeJ6u54QzCL2KUd9zBuRepT4k3RzaGrTLuYPd3/OhkSQbErh9qF+bHOqMPKSKt2GamP2WEjFNxf7j/UIGT6KJbtcR3GWqOGLLerVyYURZ9RdkeMm3EgjJYBj8/8/DG1qpkgFCoTjXEZWS6SBx8/euRIQJtdGGk7G2vHaRJz/fAhQSjPC9o9Zozz5M3bsO4J3Yje3l7BaEJXV5ewMYjt+/dhqimozyft+wQ9TBPWGzVYGciLxhgjrZ5zZ86gByrKJ/iffluBvkGLphN3vrQDUwNgpitmjC52ub5sJhRFH/pZgzQuM5I3a7NyHLWLjz/6UDA9Pz01IGdL4+b4MFoR8p6ZUJ652u8k8bHTr+wUTH7z9dd1Y3avFe8/h4oL58/7bmjfGmBg86BWRrU9MTEf6444SAjd1EGBRsSi1FUGvy5ToHxmBjCGA7Ix6c+P9rcKOnl93iTXFaw74iAhy2dWCAKNKDNahkuXLvmKs7MCjKGvF4cK3tyD+14NGPcvv9wi6OT1EbHuiAONs8PnauU332V4/9SpALPswqhvhXYBY1RHkbZ3Yd0Rh5HAYEh9i7yZWLsKatu7exeG1XhPTw+GgwIzdMkjVdhkaHZL/ePOMNoIrHAZ7WBUcZHQn3H+rJkBuexHVGQ6se6IQybMjCXKCqY/L792IGjT+vr6dHNu3ryJzaagPv/59/u+l3c0C0YT6R9yzEfNcWc0K47/uwys7ZmnNgkxO6CNYrcP5Y8uyBN0Y90RBZ1fBmP0D6b4n/vxuWYGVC9coOcbMTc1GbtJwfLpQoUu5a2AOmPDaJdrPIpCMuF0YYKxYND2yh6h8C01/rMVnnSv+pZyiOFB8XGlI9Wb/JhPbHhyXUA+64Pz0WesPaJQBFSjKBQoa6fYmpV1WKOK2mr/8zwkjsGzaZG8D/Gfx4/jFKanihQbruwtqFcp93NYf8TgdScusjJBRqMiGaiNXa6PzPEK/a24sWqhYPiGtbfvBpqBcj8+0CbojerrvFkeV1UoRjPxsrt1H37wgdqG+f0hms6IuH7tmnRuimUlu6Zi/RFDbmLiN2TCguGzS/z/idhI7seo2PO9ny+uFvL7Q5mpq1csw5CaN/6OImn/LLdrBdYfUYRqNF8ET6sHCKGQjd3Z2Yneqvjre+/qOdiX9c9yu+uw9ojCSFysETco8nHlKhH78H2z3cMmY+0RRbwYzZNe+/rXrhbfudY9QpuMVGNCtL9URCIK0lIEcU6iZnR04U1KKovHVR0sh2s3mrDuqICEVE8tF0Ra8dgL24RYrJFqy8j46tew5qggNfUrw0hQsGcMf9vu/5WvaO0JNO/BhvVCHMk0Yr1RhSLoFIlaNsP8sRYT31C5QGiLFJkGRn7PovcH+TasMyaQlpb2RV4k/SM5seROoTAsHElnBbR3hEJ6UdGKzMDS0oTPo7aYNlgGr/ajgrFK1DvQ+D8MyloZgHbpRwAAAABJRU5ErkJggg=="/>
  </div>
  <div class="download-info">
    <h2 id='bottom'>Download This Ebook</h2>
    <p class="format-label">Available formats:</p>
    <div class="download-buttons">
      <a href="cplusplus-for-beginners.pdf" class="download-button">📄 PDF</a>
      <a href="cplusplus-for-beginners.epub" class="download-button">📘 EPUB</a>
    </div>
  </div>
</section><div class='related-books'>
<h2>C++ Introduction Books</h2>
<div class='related-book-list'>
<a href="cplusplus-for-beginners.htm">
<div class="book-cover" style="background-color: #f9f6f1;border: 1px solid #ccc;"> 
    <div class="book-cover-title" style="font-size: 18px;color: #333;top: 20px;">C++ for Beginners</div>
    <div class="book-cover-author">readbytes</div>
    <div class="book-cover-bottom-stripe" style="background-color: #333;"></div>
    <img class="book-cover-icon" style="width: 90px;height: 90px;top: 70px;" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFoAAABaCAYAAAA4qEECAAAKvUlEQVR4Xu1de3BUVx2OOjqjo+Mo2ezmnc2DvNoGjBSKgAIm0EIKRShQaFINhaQ8QiFSsIhBKUlrqUKthNaURyUpj0yLLU3Fos447TiMCvIPVnnMdNpCYRApJGFIwnp/d++5nP3Ouffu3Wz2cZNv5hvY3/mdc77fd8+93NcuCQkxDq/b1a3QZ8Qsd9K72GcIQQLNLMxI8TWvr/W1Nq1W+XLDct/SOfcKpivswrGGIAFv2r5nfmiLW9csUvvtbVybjeMOQYNiUF+oBsvIxsr1eFw416BFOA3mOa98nN/wZNcEnHPQYaBMZqybP10zOzkT5x40GGiTGSunfUedB+cfFFAKPxYJkxnZRkUdjgcV/dKGpYIhA0nN7GrU4lgoxd6K5GpmnDVxzOBa1VRsm3LRgUb0h6sWzhBiMtLcDQkJn0VNjkOW21UX7tVMV43BjjlojtVUZE6yWzAgVM4r086VFU4bWyq0yzhojMbCzZifbrxap4weobZdunjRd8+IuwzzkENGA2nls9WKbSx+7dNPfQyyPBnVvkmuXajNMVAKfMqWGRo3LV2gx3duXKHHERQbU5wnjIXU+t9CfY6B0epE8kay/B3rH9PjdJiQYXfLb4IaP9uTpOahPseAihue6hEKNzKZwD4T8zPSOFvloDwyEsfl+dDU8c43etsTjwqFG5kcKmiMvY2rhPEZf7JknvON/u1muQHhMpnQ/Kvn1bFefVqch/iL+mrnGy27IgynyQxzZ96vjrmmapYw344f+4/3qM8x8K+yet1Y4tmTx3z/u3IFfQoLzp4+rc8z/Vul+t/rK2c632h+9dKf61avAntuY/XypRgyBF203LhxA8MqclM86lwtzdt9D33vAV0D6nMMeJOtgBvFDN3d3UHnEoaM5mDH6Mq5DwadS1g4Z/aQ0Qx5af57HHW1S7BJCjtjlwzPHTI6GIzIz8OQLTAdqM8xYAUWZKZj7bZAY3R3dWE4aAwKo/dsWhmwqjs7r3MWWOPq1au2DhMI1tfxRvMXKOzmjl08cO9UDJni5InjAQYzDVlu11zU6AiwIomPTJ/Ur5VpB2gyt7F7UWPcI9Pt9vKF8gX/6Z0/oDdhhWxex75U4zV4xWBUfk5Qq3pOxTQ1jy5OCDu0G0dWGFkwXGo028ioM+5BReUZ3IumthP/+Dt6JEDb3XX+dP2TmCKA8uhdapyTM/ozqDWuYbSqiJX3+XfjcINtEJyPN9pxq9qsYL7ocMHKZOKMCaOcZXROcmKpVdHhNHtx1cOWJvNzot64RTCriy+8P2bffWex2p8ujHBsGSk3NTV1GGqOS1AxhRmpQpFGZGZPGjsGfTQF69fWVC+MaUStTx9qjktQMbMnjxWKNGPFuNtPRKxWOJ+H41iR9UPNcQkqZPuPaoQizTi+pFA3+EjHW2CtHKEY7ah3PKiQ0YXWbxDxNFvJ/AomXvzkgh5vbRQf/prRaSt6q53VVv+w/+GpDFO+7X/55dYfa32zxhUIphNftPFNAseYzMBMwEJ5NtTM1806eeIEeqyC2grTParRLJfhxV+/IJhObDG5MnSc0QRWGL1ygMUy3pWXw9kqgnLIZGb0fy9fxhQd+1tbhfGJ9BKPY01mwKKJXR1vBHw2A7XzRtvB7w8fFubWzHbW/Q4CX+CNt98UiCYsrqrUjXpwRoVu9PPL+n9/5M9HjwrzEXM9Xy9G3XEDK4OR5w+0CQYQv5mXJj0+hwNHOjoC5sIaYh52DDYjjcEfNvBVMjbP1i3PBsRDQdwZTYLpKxJoWihEo3msXeV/6Cvj9m1bA3KtsE3ZUHFlNIml997QsFBYVeZ/xkgm71lXLhhNn4sy/Kd9jD3v1PiyJca3NDcH9EVoeTexnpgEKwoNC5U01j2FGYbHZ7YRzNh3tFbZu/yX3DwRFMN6YhIpKSlfCqfJRN5IdWx4czQYo5Fdby+Ob6NJ6N35uYJZ/SEazWPlYzUhGS1b0VuamrR44mWsK6ZQXFz8hXCv5uqpZbqRBxvuE8yhz3QXDo20IvWjc2kcixFriykwkWhWf0jjjc5P183JVs5i0Bw6/qKRVsQNxsbqfOt3sW92uE0m0phW5kws8QpGmvHia983HIufF+uLCXg9SaujYXRF2Xf1Fcg4aUS2YC5PlsejcWODYLTCHqwz6mDi0SjG52oeFWJWrCqfrBvdvlE8Psswe7o/j+f4OzIFow+1twf0Q/3n9u5WP2OdUQeJ6u54QzCL2KUd9zBuRepT4k3RzaGrTLuYPd3/OhkSQbErh9qF+bHOqMPKSKt2GamP2WEjFNxf7j/UIGT6KJbtcR3GWqOGLLerVyYURZ9RdkeMm3EgjJYBj8/8/DG1qpkgFCoTjXEZWS6SBx8/euRIQJtdGGk7G2vHaRJz/fAhQSjPC9o9Zozz5M3bsO4J3Yje3l7BaEJXV5ewMYjt+/dhqimozyft+wQ9TBPWGzVYGciLxhgjrZ5zZ86gByrKJ/iffluBvkGLphN3vrQDUwNgpitmjC52ub5sJhRFH/pZgzQuM5I3a7NyHLWLjz/6UDA9Pz01IGdL4+b4MFoR8p6ZUJ652u8k8bHTr+wUTH7z9dd1Y3avFe8/h4oL58/7bmjfGmBg86BWRrU9MTEf6444SAjd1EGBRsSi1FUGvy5ToHxmBjCGA7Ix6c+P9rcKOnl93iTXFaw74iAhy2dWCAKNKDNahkuXLvmKs7MCjKGvF4cK3tyD+14NGPcvv9wi6OT1EbHuiAONs8PnauU332V4/9SpALPswqhvhXYBY1RHkbZ3Yd0Rh5HAYEh9i7yZWLsKatu7exeG1XhPTw+GgwIzdMkjVdhkaHZL/ePOMNoIrHAZ7WBUcZHQn3H+rJkBuexHVGQ6se6IQybMjCXKCqY/L792IGjT+vr6dHNu3ryJzaagPv/59/u+l3c0C0YT6R9yzEfNcWc0K47/uwys7ZmnNgkxO6CNYrcP5Y8uyBN0Y90RBZ1fBmP0D6b4n/vxuWYGVC9coOcbMTc1GbtJwfLpQoUu5a2AOmPDaJdrPIpCMuF0YYKxYND2yh6h8C01/rMVnnSv+pZyiOFB8XGlI9Wb/JhPbHhyXUA+64Pz0WesPaJQBFSjKBQoa6fYmpV1WKOK2mr/8zwkjsGzaZG8D/Gfx4/jFKanihQbruwtqFcp93NYf8TgdScusjJBRqMiGaiNXa6PzPEK/a24sWqhYPiGtbfvBpqBcj8+0CbojerrvFkeV1UoRjPxsrt1H37wgdqG+f0hms6IuH7tmnRuimUlu6Zi/RFDbmLiN2TCguGzS/z/idhI7seo2PO9ny+uFvL7Q5mpq1csw5CaN/6OImn/LLdrBdYfUYRqNF8ET6sHCKGQjd3Z2Yneqvjre+/qOdiX9c9yu+uw9ojCSFysETco8nHlKhH78H2z3cMmY+0RRbwYzZNe+/rXrhbfudY9QpuMVGNCtL9URCIK0lIEcU6iZnR04U1KKovHVR0sh2s3mrDuqICEVE8tF0Ra8dgL24RYrJFqy8j46tew5qggNfUrw0hQsGcMf9vu/5WvaO0JNO/BhvVCHMk0Yr1RhSLoFIlaNsP8sRYT31C5QGiLFJkGRn7PovcH+TasMyaQlpb2RV4k/SM5seROoTAsHElnBbR3hEJ6UdGKzMDS0oTPo7aYNlgGr/ajgrFK1DvQ+D8MyloZgHbpRwAAAABJRU5ErkJggg=="/>
  </div>
</a>


<a href="cplusplus-syntax.htm">
<div class="book-cover" style="background-color: #f9f6f1;border: 1px solid #ccc;"> 
    <div class="book-cover-title" style="font-size: 20px;color: #333;top: 20px;">C++ Syntax</div>
    <div class="book-cover-author">readbytes</div>
    <div class="book-cover-bottom-stripe" style="background-color: #333;"></div>
    <img class="book-cover-icon" style="width: 90px;height: 90px;top: 70px;" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFoAAABaCAYAAAA4qEECAAAFZ0lEQVR4Xu2dy4scVRSH8ye0iYtkERcmzgjT2OYBuhNREMVXBh/TgsYQx5ULDYTgVl3EFyg6uFJBV76IEXdKXAVBJCgISSTRGRmZiZlADBo6M5kp+3ZbnXt/p7q6btWtc++pqQPfpu/p7vP7UnSqi+m6GzbkrMbYO50u0Tqjgx5Kqe4brSa8+XplFf0UroQ3GbDltqNRs70Y3Tw5G22//2SXU0Fyy5MXc6GyqYyYWwd9WdfGbW9uxRe9vvlBtOvZKLrpwTOiUDO7QjlALxu3zWxFf5mq++RF/YU27/40au39lwSQAspygXICwhfRY2rhv5Z6URxcEuoAQUkuQV/oM7HwSN45vUoGlwaKKQOrI1t9zuhPaD19mQwtEZRSFrq71M/sqh3JMSikTHSH6LdXeoN6Ag4rlV3Ta0RG2aTKjhfU/6Q4rGRQAgf62QhKHnzjk3wKlwRK4EI7qq99g4wf3NR8nwwqmfE9s0QAF8olOarjB1QDDisZDM+NIbqhXYXDQaWDwbnRPj46xtkGDiodDM6N7nYgWl2hwkEl09r7DwnOzZbbr131G4iemFokw0oGQ/ug2XVKRI9PzpJhJYOhfdB66m8qevsDp8iwksHQPqi8aAzsi1o0E7VoJioteuzh30lgX1RaNIb1SS2aiVo0E5UVPTH1Fwnrk8qKxqC+qUUzUYtmwovoL49dioYV9uZhx/4VEjRmWM2fp70uYRc9qrA/DxhSZ1RhvyuCEL1wfiU6PXulB/bnAUPqnJnv8+cSTtEv7HeFd9G4XpyzJGQaWLjuisqJxoCjeOVjc572y7THBayim4+cNUKdONkhPUXBgKO495AxUrTvVdrjAq+ij//k/i9UMeAo7jlojFSLzsLE4/ZfuyspuvXYb0Yo16IxXBZQ9DOv0x4XsIqeOjRvhPri20ukpwgYLgt3HTBGir75kfa4gFU01h373f5ZA4bLChauu4BNdPtF82hWhT1FuHVfh4TLCtbR47SnKKWKTqu5hWXSXwQMZsOBGZzOLOzPA7voNz66QPpcgMHy8Py7OG2/sC8P7KLjurK8RvqLgMFsmDmC05mF/XkoVbTOjinz1E4V9uSl6I+AsF6YoT1FYROtwLpzeo705AFD2YKF6y5gFf3oQfPM48h3w8+jD3+4ZIDrOnGYtz7vgyHTuBvOo7/+nva4gFW0zTdDLFyPGdN+BBQXhkyDfDN8jfa4gFW0zbWOH365bIDrMXqYE7/2wZBpoOhKXOuwEZ0VDGTLuhD98+kO6bEFA9lyXxWvRyuwcN0GdccFDGTLe1+Z87Rfoj0uEC0aw+QBC9dd4V10XMsraz2wPw0Mk4WVq33WcID/C/tdwS766uqwiP3C/jQwTBZGFfa7gl204rnDC5hvUNg7DAySlWH1yTHa6xIvol2AQUKnFs2ESNHjk3MkSOiIFI0hJFCLZqIWzYQ40c0nLpAQEhAnGgNIoRbNRC2aCVGid6b8CCh0RInG4SVRi2YiUXSIN68ae8juR0ChkSg6xNux4eDSSLwdW4g3GMTBpZF4g0EFBvUNDi4N3a0SHeRNYCfaS2RwaWii+1s/xQ+oRQzsCxxaIoOjGe8fHdKNunFoaWzSdh/SRQd363kcXBrax4a5eVm8EMJmCmn33pDA5t2f0aMZRStUM4bnBAeXhu4SPfdKb/C54Q0OLomRklWFsoUTDi8F3d11N759A/o1quF5UzIcXgq6sy7n0GtiwZN6L4RCygIDSAB9oc/UwiOba+NIDBEy+tmF1ZGMhZ/ZijK3Qh3f8wcJEyJOt0LVC19UR12harbPOdncFzfWDQGVTb8KlwT6KlyNertqHffbVSdVo96A3ar+A5kzbYSE7G+UAAAAAElFTkSuQmCC"/>
  </div>
</a>


<a href="cplusplus-stl.htm">
<div class="book-cover" style="background-color: #f9f6f1;border: 1px solid #ccc;"> 
    <div class="book-cover-title" style="font-size: 20px;color: #333;top: 20px;">C++ STL</div>
    <div class="book-cover-author">readbytes</div>
    <div class="book-cover-bottom-stripe" style="background-color: #333;"></div>
    <img class="book-cover-icon" style="width: 90px;height: 90px;top: 70px;" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFoAAABaCAYAAAA4qEECAAADK0lEQVR4Xu2cvWsTcRjHo+DkIKiTjiJugqTJ0cG/QcRZ/wJXQTd3ByeHDiLJnS84dHMVBHUSRQUH90pNfmfb6CKi8fqSaj93ae4lzzV3+X7gS9vkeZ7f7/lwEDq0jYYQQgghxFzQ9t0wbTzf3WO/SAllpg3niAlQYJa0uu4W54kxeA96ZykwU4JwnTPFGGLyMqd3nTNFAnFx2cOZIiee//UK5TLsEQWg3D1ZHpxgvShATLCeajsoWKKNaAfuDyVvZuGhu8paURBK1lNtBAVLtBEULNFGULBEG0HBlRfNRUrMqwW/f473GZFQvxXWVQbPD5e4zEGlcXt4eHQvvrdbU2W4zEGn5Yd3+NoovHul4DKzHN69UnCZWQ7vXim8IHzJhWY1vLtIQSRujSInhTNEBppL345R6LiwV+SAUpPCHpETimVYLwpAuRJtBOVKtBHNR4OTFCzRRlCwRBtBwRJtBAVLtBEULNFGeN3wPiVvp/+OtVmJ5qzvmdl1z1kzV8Ql53+q0/6az765gBLyConqN9i/X9hfeyiAYX0S7cCtsi9NOKf2UADDesL6LOGsWsPlx+V8d/Vo3t5x4bzyGA4P8TK1TuBeU0FpxC5T83D/0uBF6h7uXxq8SN3D/Utj80OHl6ltgvAX9y+V2IUm53eUQZQvUT4nvJ8x/e/R14+RiBeeHz4bZfPn6PW3bT908Z7s4d6Vgwsxix13mj15iGb94Ows4bxKwWUY1heF89OGcyoHFypjOZ4zKV7gVjijUjSfrJ/hUqOwdtrwvH2yzN7KkbDUTsKfrLWgufTmSPzsf2F9ZeFitVtwVqBgiTaCgiXaCAqWaCMoWKKNoGCJNoKCJdoICpZoIyhYoo2gYIk2goIl2ggKlmgjKFiijaBgiTaCgiXagLbfu0jBW+m6NdaKAsQEj9Jxl1krChATvBPWiQJ4fviJgiV6yiw+3ThOuRI9ZbzA3aRYSZ4iFx73T1FqUtg3l1DKbrr9960gvBt9f207/Rst332I1U0Iz5tbKGaa4VlzTSQk8X84Fw3PEY3p/70KTxA7UFTeeB13ibPFf1BY1nCeEEIIIYQowl8t5mhjJHw+fQAAAABJRU5ErkJggg=="/>
  </div>
</a>



<a href='cplusplus.htm'><div class='book-cover' style='background-color: #f9f6f1;color: #111111;border: 1px solid #ccc;display: flex;justify-content: center;align-items: center;text-align: center;'>More C++ Books</div></a>
</div>
</div><script>
function copyCode(button) {const code = button.nextElementSibling.innerText;navigator.clipboard.writeText(code).then(() => {button.textContent = 'Copied!';setTimeout(() => { button.textContent = 'Copy'; }, 1500);});}
</script></div>
<style>
.site-footer {margin-top: 60px;padding: 20px 0;border-top: 1px solid #eee;text-align: center;font-size: 14px;}
.site-footer a {text-decoration: none;}
.light-mode .site-footer {color: #777;border-color: #eee;}
.dark-mode .site-footer {color: #888;border-color: #333;}
.light-mode .site-footer a {color: #555;}
.dark-mode .site-footer a {color: #aaa;}
.site-footer a:hover {text-decoration: underline;}    
</style>
<footer class="site-footer">
<nav><a href="https://readbytes.github.io">Home</a> |Email:<script type="text/javascript">
var part1 = 'yinpeng';var part6 = '263';var part2 = Math.pow(2,6);var part3 = String.fromCharCode(part2);var part4 = 'hotmail dot com';var part5 = part1 + String.fromCharCode(part2) + part4;document.write(part1 + part6 + part3 + part4);
</script>
| <a id="mode-toggle" href="#">Toggle Dark Mode</a>
</nav><p>© 2025 — All rights reserved.</p></footer>
<script>
const toggleButton = document.getElementById('mode-toggle');
const body = document.body;
const savedMode = localStorage.getItem('mode') || 'light';
body.classList.add(savedMode + '-mode');
toggleButton.addEventListener('click', () => {
      const isDark = body.classList.contains('dark-mode');
      body.classList.toggle('dark-mode', !isDark);
      body.classList.toggle('light-mode', isDark);
      localStorage.setItem('mode', isDark ? 'light' : 'dark');
});
function copyCode(button) {const code = button.nextElementSibling.innerText;navigator.clipboard.writeText(code).then(() => {button.textContent = 'Copied!';setTimeout(() => { button.textContent = 'Copy'; }, 1500);});}
</script>
</body>
</html>