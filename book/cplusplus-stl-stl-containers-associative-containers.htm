<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>C++ STL STL Containers: Associative Containers</title>
<link rel='shortcut icon' href='https://readbytes.github.io/images/favicon.ico'>
<link href="https://fonts.googleapis.com/css2?family=Merriweather&display=swap" rel="stylesheet" />
<link href="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet" />
<script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/prism.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/codemirror.min.css" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/codemirror.min.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/theme/dracula.min.css"><style>
html {scroll-behavior: smooth;}  
body {font-family: 'Merriweather', serif;;margin: 0;padding: 2rem 1rem;font-size: 15px;line-height: 1.5;transition: background-color 0.3s, color 0.3s;}
.container {max-width: 750px;margin: 0 auto;padding: 1rem 2rem;}
.light-mode {background-color: #f8f7f5;color: #333;} 
.dark-mode {background-color: #121212;color: #e0e0e0;}
a { text-decoration: none;transition: color 0.2s;}
a:hover {text-decoration: underline;}
.light-mode a {color: #555;}
.dark-mode a {color: #aaa;}
</style><style>
.related-book-list {display: flex;flex-wrap: wrap;gap: 20px;}
.related-books {margin-top: 40px;}
.related-books h2 {font-size: 22px;margin-bottom: 20px;border-bottom: 2px solid #eee;padding-bottom: 8px;}
.light-mode .related-books h2 {color: #333;border-color: #eee;}
.dark-mode .related-books h2 {color: #ddd;border-color: #333;}
</style><style>
.book-cover {width: 130px;height: 180px;font-family: Arial, sans-serif;position: relative;overflow: hidden;box-shadow: 2px 2px 4px rgba(0,0,0,0.1);}
.book-cover-bottom-stripe {position: absolute;bottom: 0;left: 0;height: 5px;width: 100%;}
.book-cover-title {position: absolute;width: 100%;text-align: center;font-weight: bold;}
.book-cover-icon {position: absolute;left: 50%;transform: translateX(-50%);display: flex;align-items: center;justify-content: center;}
.book-cover-author {position: absolute;bottom: 10px;width: 100%;text-align: center;font-size: 8px;color: #333;}
</style><style>
.book-title-toc {font-size: 32px;font-weight: bold; }
.book-subtitle-toc {font-size: 18px;margin-top: 8px;font-style: italic;}
.book-header {text-align: center;margin-bottom: 40px;}

.toc-container {border-radius: 10px;padding: 30px;margin-bottom: 40px;box-shadow: 0 8px 20px rgba(0,0,0,0.05);}
h1 {font-size: 24px;text-align: center;margin-bottom: 30px;letter-spacing: 1px;padding-bottom: 10px;}
.toc-list,.toc-section-list {list-style: none;padding: 0;margin: 0;}
.toc-section-list {padding-left: 18px;margin-top: 6px;margin-bottom: 20px; }
.toc-chapter {padding: 20px 0;}
.chapter-title,.toc-section {display: flex;justify-content: space-between;padding-top: 4px;}
.chapter-title {font-size: 17px;font-weight: bold;}
.chapter-page,.section-page {font-style: italic;}
 
 
.light-mode .book-title-toc,.light-mode .chapter-title,.light-mode .book-name {color: #222;}
.light-mode .book-subtitle-toc,.light-mode .book-sub,.light-mode .chapter-page,.light-mode .section-page {color: #666;}
.light-mode .toc-container { background: #fff;border: 1px solid #ddd;}
.light-mode h1 {border-bottom: 2px solid #eee;color: #222;}
.light-mode .toc-section {  color: #444;}

.light-mode .book-cover { border: 1px solid #ccc;box-shadow: 0 6px 12px rgba(0, 0, 0, 0.15);}
.light-mode .book-title,.light-mode .series-name {color: #fff;}
.light-mode .book-subtitle,.light-mode .book-footer {color: #aaa;}

.dark-mode .book-title-toc,.dark-mode .chapter-title,.dark-mode .book-name {color: #f5f5f5;}
.dark-mode .book-subtitle-toc,.dark-mode .book-sub,.dark-mode .chapter-page,.dark-mode .section-page {color: #aaa;}
.dark-mode .toc-container {background: #1e1e1e;border: 1px solid #444;}

.dark-mode h1 {border-bottom: 2px solid #333;color: #eee;}
.dark-mode .toc-section {color: #bbb;}

.dark-mode .related-books h2 {color: #ddd;border-bottom: 2px solid #333;}
.dark-mode .book-title,.dark-mode .series-name {color: #fff;}
.dark-mode .book-subtitle,.dark-mode .book-footer {color: #bbb;}
.dark-mode .toc-section {color: #ddd;}

@media (max-width: 600px) {
  .chapter-title,
  .toc-section {
    flex-direction: column;
    align-items: flex-start;
  }

  .chapter-page,
  .section-page {
    margin-top: 4px;
  }
}

</style><style>
.light-mode .container {box-shadow: 0 0 15px rgba(0,0,0,0.1);}
.dark-mode .container {box-shadow: 0 0 15px rgba(255, 255, 255, 0.05);}

h1, h2, h3 {font-weight: 600;margin-top: 2.5rem;margin-bottom: 1rem;line-height: 1.2;}
h1 { font-size: 1.8rem; }
h2 { font-size: 1.4rem; }
h3 { font-size: 1.2rem; }

table {width: 100%;border-collapse: collapse;font-family: sans-serif;font-size: 1em;margin: 1em 0;}
th, td {padding: 0.6em 1em;text-align: left;border: 1px solid;}
tr:nth-child(even) {  background-color: inherit;}
tr:hover { background-color: inherit;}

code {color: #d35400;}

.chapter-navi-section {display: flex;justify-content: space-between;align-items: center;padding-bottom: 10px;padding-top: 10px;}
.nav-link {color: inherit;text-decoration: none;opacity: 0.5;transition: opacity 0.3s ease, text-decoration 0.3s ease;}
.nav-link:hover {opacity: 0.9;text-decoration: underline;}
.prev { text-align: left; }
.toc-link { text-align: center; }
.next { text-align: right; }

.download-section {display: flex;align-items: center;justify-content: center;gap: 2rem;padding: 2rem 1rem;max-width: 600px;margin: 3rem auto;border-radius: 12px;box-shadow: 0 4px 10px rgba(0,0,0,0.05);}
.download-info h2 {margin: 0 0 0.5rem;font-size: 1.2rem;}
.format-label {margin: 0 0 0.5rem;font-size: 0.95rem;}
.download-buttons {display: flex;gap: 1rem;}
.download-button {background-color: #4A90E2;color: white;padding: 0.5em 1.2em;border-radius: 25px;font-size: 0.95rem;text-decoration: none;transition: background-color 0.3s ease;}
.download-button:hover {background-color: #357ABD;}

.code-block {position: relative;margin-bottom: 1em;}
.copy-button {background: transparent;color: white;position: absolute;top: 8px;right: 8px;border: none;padding: 4px 8px;font-size: 12px;border-radius: 4px;cursor: pointer;z-index: 1;}
.copy-button:hover {background-color: #0056b3;}

.snippet-container {overflow: hidden;}
.snippet-header {padding: 0.75rem 1rem;cursor: pointer;font-size: 1rem;background-color: #eeeeee;color:  #111111; border-radius: 8px;cursor: pointer;box-shadow: 0 4px 6px rgba(0,0,0,0.1); }
.snippet-body {display: none;font-family: monospace;}
.snippet-container.open .snippet-body {display: block;}

.CodeMirror {border: 2px solid #ccc;border-radius: 4px;resize: vertical;}

.light-mode .format-label {color: #888;}
.light-mode th {background-color: #f2f2f2;}
.light-mode tr:nth-child(even) {background-color: #fafafa;}
.light-mode tr:hover {background-color: #e6f7ff;}

.dark-mode .snippet-header {background-color: #333;color:  #ddd; }
.dark-mode .format-label {color: #aaa;}
.dark-mode th {background-color: #333;color: #fff;}
.dark-mode td {border-color: #444;}
.dark-mode tr:nth-child(even) {background-color: #2a2a2a;}
.dark-mode tr:hover {background-color: #2c3e50;}


.button-group-run-edit {display: flex;width: 100%;gap: 1rem;}
.button-run-edit {flex: 1;padding: 1rem;font-size: 1rem;font-weight: 600;border: none;border-radius: 8px;cursor: pointer;transition: background 0.3s, color 0.3s;}

.light-mode .button-run-edit {background-color: #f0f0f0;color: #222;box-shadow: 0 0 10px rgba(0, 0, 0, 0.05);}
.light-mode .button-run-edit:hover {background-color: #e0e0e0;}

.dark-mode .button-run-edit {background-color: #2a2a2a;color: #f5f5f5;box-shadow: 0 0 10px rgba(255, 255, 255, 0.05);}
.dark-mode .button-run-edit:hover {background-color: #3a3a3a;}

button { padding: 0.5em 1em; background: green; color: white; border: none; cursor: pointer; }
button:hover { background: #1e7e34; }
.result_iframe { width:99%; margin-top: 1em;  resize: both;background-color: #515b63;border:1px solid #ccc;}   

.dialog-backdrop {position: fixed;top: 0;left: 0;width: 100vw;height: 100vh;background: rgba(0,0,0,0.5);display: none;justify-content: center;align-items: center;z-index: 10;}
.dialog {background: #90979e;padding: 20px;width: 90vw;height: 80vh;border-radius: 8px;box-shadow: 0 0 20px rgba(0,0,0,0.3);display: flex;flex-direction: column;}
.dialog-content {display: flex;gap: 20px;margin-top: 10px;height: calc(100% - 40px);}
.editor-container, .preview-container {flex: 1;height: 100%;max-height: 100%;overflow: hidden; }
.result_iframe_dialog {width: 100%;height: 100%;resize: both;border:1px solid #ccc;overflow: auto; }   
.CodeMirror {width: 100% !important;height: 100% !important;}
</style>
</head>
<body>
<script>const mode = localStorage.getItem('mode') || 'light';document.documentElement.classList.add(`${mode}-mode`);</script>  
<div class="container"><div class = "chapter-navi-section">
<a href="cplusplus-stl-stl-containers-sequence-containers-basics.htm" class="nav-button prev">←</a>
<a href='cplusplus-stl.htm#stl-containers-associative-containers' class="nav-button toc-link">Index</a>
<a href="cplusplus-stl-unordered-containers-hash-based-containers.htm" class="nav-button next">→</a>
</div>
<div class='book-header'><h1 class='book-title-toc' id = 'top'>STL Containers: Associative Containers</h1><h3 class='book-subtitle-toc'>C++ STL</h3></div><h2 id='overview-of-associative-containers'>3.1 Overview of Associative Containers</h2><p>Associative containers are a core part of the C++ Standard Template Library (STL) designed to store <strong>elements organized by keys</strong>, enabling <strong>fast and efficient lookup, insertion, and deletion</strong>. Unlike sequence containers, which store elements in a linear order, associative containers automatically <strong>keep their elements sorted</strong> based on the keys, allowing quick searching through balanced tree structures.</p><h4 id="what-are-associative-containers">What Are Associative Containers?</h4><p>Associative containers store data as <strong>key-value pairs</strong> or <strong>unique keys</strong>, depending on the container type. They manage their elements in a way that keeps the keys in sorted order internally—this guarantees efficient operations such as finding or inserting an element with logarithmic time complexity (<code>O(log n)</code>).</p><p>Because the containers keep the keys sorted automatically, you do <strong>not</strong> need to sort the data yourself before performing lookups or other operations.</p><h4 id="main-types-of-associative-containers">Main Types of Associative Containers</h4><ol>
 <li><p><strong><code>std::set</code></strong></p>
  <ul>
   <li>Stores <strong>unique keys</strong> (no duplicates).</li>
   <li>The keys themselves are the elements.</li>
   <li>Example: A collection of unique user IDs.</li>
  </ul></li>
 <li><p><strong><code>std::multiset</code></strong></p>
  <ul>
   <li>Stores <strong>keys that may appear multiple times</strong> (duplicates allowed).</li>
   <li>Useful when you want to track counts or multiple instances of the same key.</li>
  </ul></li>
 <li><p><strong><code>std::map</code></strong></p>
  <ul>
   <li>Stores <strong>key-value pairs</strong> with <strong>unique keys</strong>.</li>
   <li>Keys are used to access their associated values.</li>
   <li>Example: A phonebook mapping names (keys) to phone numbers (values).</li>
  </ul></li>
 <li><p><strong><code>std::multimap</code></strong></p>
  <ul>
   <li>Similar to <code>map</code> but allows <strong>duplicate keys</strong>.</li>
   <li>Multiple values can be associated with the same key.</li>
   <li>Example: Storing multiple phone numbers for the same person.</li>
  </ul></li>
</ol><h4 id="unique-keys-vs-duplicate-keys">Unique Keys vs Duplicate Keys</h4><ul>
 <li><strong>Unique-key containers</strong> (<code>set</code>, <code>map</code>) guarantee that each key appears only once.</li>
 <li><strong>Duplicate-key containers</strong> (<code>multiset</code>, <code>multimap</code>) allow multiple elements with the same key.</li>
</ul><p>This distinction helps choose the right container based on whether your data allows duplicates or not.</p><p>Associative containers are powerful tools when you need <strong>fast, ordered retrieval</strong> of data keyed by unique or repeating values. They underpin many practical applications like databases, indexing, and caching, where efficient search and sorted data management are essential. In the following sections, we will explore these containers in detail along with practical usage examples.</p><div class = "chapter-navi-section">
<a href="#top" class="nav-button prev">↑</a>
<a href='cplusplus-stl.htm#stl-containers-associative-containers' class="nav-button toc-link">Index</a>
<a href="#bottom" class="nav-button next">↓</a>
</div>
<h2 id='std-set-and-std-multiset-ordered-unique-and-duplicate-keys'>3.2 <code>std::set</code> and <code>std::multiset</code>: Ordered Unique and Duplicate Keys</h2><p>The <strong><code>std::set</code></strong> and <strong><code>std::multiset</code></strong> containers are associative containers that store <strong>sorted keys</strong>, but they differ in how they handle duplicates.</p><h4 id="std-set-unique-sorted-keys"><code>std::set</code>: Unique Sorted Keys</h4><p>A <code>std::set</code> stores <strong>unique elements</strong> in sorted order. If you try to insert an element that already exists, the set ignores it, ensuring no duplicates are present.</p><p><strong>Example:</strong></p><div class="code-block">
 <button class="copy-button" onclick="copyCode(this)">📋</button>
 <pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;set&gt;

int main() {
    std::set&lt;int&gt; unique_numbers;

    unique_numbers.insert(5);
    unique_numbers.insert(1);
    unique_numbers.insert(3);
    unique_numbers.insert(5);  // Duplicate, will be ignored

    std::cout &lt;&lt; "Set elements: ";
    for (int n : unique_numbers) {
        std::cout &lt;&lt; n &lt;&lt; " ";
    }
    std::cout &lt;&lt; std::endl;

    // Searching for an element
    if (unique_numbers.find(3) != unique_numbers.end()) {
        std::cout &lt;&lt; "3 found in set." &lt;&lt; std::endl;
    }

    return 0;
}</code></pre>
</div><p>Output:</p><div class="code-block">
 <button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-bash">Set elements: 1 3 5 
3 found in set.</code></pre>
</div><h4 id="std-multiset-allowing-duplicate-keys"><code>std::multiset</code>: Allowing Duplicate Keys</h4><p>Unlike <code>set</code>, a <code>std::multiset</code> allows <strong>multiple identical keys</strong>. Elements are still stored in sorted order, but duplicates are preserved.</p><p><strong>Example:</strong></p><div class="code-block">
 <button class="copy-button" onclick="copyCode(this)">📋</button>
 <pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;set&gt;

int main() {
    std::multiset&lt;int&gt; numbers;

    numbers.insert(5);
    numbers.insert(1);
    numbers.insert(3);
    numbers.insert(5);  // Duplicate allowed

    std::cout &lt;&lt; "Multiset elements: ";
    for (int n : numbers) {
        std::cout &lt;&lt; n &lt;&lt; " ";
    }
    std::cout &lt;&lt; std::endl;

    return 0;
}</code></pre>
</div><p>Output:</p><div class="code-block">
 <button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-bash">Multiset elements: 1 3 5 5</code></pre>
</div><h4 id="typical-use-cases">Typical Use Cases</h4><ul>
 <li>Use <code>std::set</code> when you need to <strong>maintain a collection of unique elements</strong>, such as unique user IDs, distinct words, or configuration options.</li>
 <li>Use <code>std::multiset</code> when you need to <strong>track frequencies or allow duplicates</strong>, like counting occurrences of words or storing multiple values that can be equal.</li>
</ul><h4 id="performance-characteristics">Performance Characteristics</h4><p>Both <code>set</code> and <code>multiset</code> typically implement balanced binary search trees (like red-black trees), providing:</p><ul>
 <li><strong>Insertion, removal, and lookup</strong> in <strong><code>O(log n)</code></strong> time.</li>
 <li>Automatic sorting of elements.</li>
 <li>No direct random access (you must iterate or search via keys).</li>
</ul><p>In summary, <code>std::set</code> and <code>std::multiset</code> are powerful tools when you want sorted collections with or without duplicates, offering efficient search and ordered iteration.</p><div class = "chapter-navi-section">
<a href="#top" class="nav-button prev">↑</a>
<a href='cplusplus-stl.htm#stl-containers-associative-containers' class="nav-button toc-link">Index</a>
<a href="#bottom" class="nav-button next">↓</a>
</div>
<h2 id='std-map-and-std-multimap-key-value-storage'>3.3 <code>std::map</code> and <code>std::multimap</code>: Key-Value Storage</h2><p>The <strong><code>std::map</code></strong> and <strong><code>std::multimap</code></strong> containers are associative containers designed to store <strong>key-value pairs</strong> in sorted order based on their keys. They differ mainly in how they handle duplicate keys: <code>map</code> allows only <strong>unique keys</strong>, while <code>multimap</code> permits <strong>multiple entries with the same key</strong>.</p><h4 id="std-map-unique-keys-with-associated-values"><code>std::map</code>: Unique Keys with Associated Values</h4><p>A <code>std::map</code> stores pairs where each <strong>key is unique</strong> and mapped to a single value. It maintains the keys in sorted order internally, enabling efficient lookup, insertion, and deletion, all with average logarithmic time complexity (<code>O(log n)</code>).</p><p><strong>Example:</strong></p><div class="code-block">
 <button class="copy-button" onclick="copyCode(this)">📋</button>
 <pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;map&gt;

int main() {
    std::map&lt;std::string, int&gt; phonebook;

    // Inserting key-value pairs
    phonebook["Alice"] = 12345;
    phonebook["Bob"] = 67890;
    phonebook.insert({"Charlie", 54321});

    // Lookup by key
    std::string name = "Bob";
    if (phonebook.find(name) != phonebook.end()) {
        std::cout &lt;&lt; name &lt;&lt; "'s number is " &lt;&lt; phonebook[name] &lt;&lt; std::endl;
    }

    // Iterating over all entries (sorted by key)
    std::cout &lt;&lt; "Phonebook entries:\n";
    for (const auto&amp; entry : phonebook) {
        std::cout &lt;&lt; entry.first &lt;&lt; ": " &lt;&lt; entry.second &lt;&lt; "\n";
    }

    return 0;
}</code></pre>
</div><p>Output:</p><div class="code-block">
 <button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-bash">Bob's number is 67890
Phonebook entries:
Alice: 12345
Bob: 67890
Charlie: 54321</code></pre>
</div><h4 id="std-multimap-allowing-duplicate-keys"><code>std::multimap</code>: Allowing Duplicate Keys</h4><p><code>std::multimap</code> allows multiple key-value pairs with the <strong>same key</strong>, making it useful when a key may correspond to multiple values.</p><p><strong>Example:</strong></p><div class="code-block">
 <button class="copy-button" onclick="copyCode(this)">📋</button>
 <pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;map&gt;

int main() {
    std::multimap&lt;std::string, int&gt; phonebook;

    phonebook.insert({"Alice", 12345});
    phonebook.insert({"Bob", 67890});
    phonebook.insert({"Bob", 11111});  // Duplicate key allowed

    std::cout &lt;&lt; "Bob's numbers:\n";
    auto range = phonebook.equal_range("Bob");
    for (auto it = range.first; it != range.second; ++it) {
        std::cout &lt;&lt; it-&gt;second &lt;&lt; "\n";
    }

    return 0;
}</code></pre>
</div><p>Output:</p><div class="code-block">
 <button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-bash">Bob's numbers:
67890
11111</code></pre>
</div><h4 id="underlying-structure">Underlying Structure</h4><p>Both <code>map</code> and <code>multimap</code> are typically implemented as <strong>balanced binary search trees</strong> (e.g., red-black trees). This structure keeps keys sorted and ensures:</p><ul>
 <li>Efficient <strong>insertion</strong>, <strong>deletion</strong>, and <strong>lookup</strong> in <code>O(log n)</code> time.</li>
 <li>Ordered iteration by key.</li>
 <li>No direct random access (elements must be accessed via iterators or by key search).</li>
</ul><h4 id="common-use-cases">Common Use Cases</h4><ul>
 <li><strong><code>std::map</code></strong> is ideal for implementing dictionaries, symbol tables, or any scenario where each key maps to a single unique value.</li>
 <li><strong><code>std::multimap</code></strong> suits cases like a phonebook where a person might have multiple phone numbers or when multiple values naturally share the same key.</li>
</ul><p>In summary, <code>map</code> and <code>multimap</code> provide powerful, ordered key-value storage with predictable performance, making them essential tools for associative data management in C++.</p><div class = "chapter-navi-section">
<a href="#top" class="nav-button prev">↑</a>
<a href='cplusplus-stl.htm#stl-containers-associative-containers' class="nav-button toc-link">Index</a>
<a href="#bottom" class="nav-button next">↓</a>
</div>
<h2 id='insertion-deletion-and-lookup-operations'>3.4 Insertion, Deletion, and Lookup Operations</h2><p>Associative containers like <code>std::set</code>, <code>std::multiset</code>, <code>std::map</code>, and <code>std::multimap</code> provide powerful methods to <strong>insert</strong>, <strong>delete</strong>, and <strong>find</strong> elements efficiently. Understanding how to use these operations correctly is crucial for working effectively with these containers.</p><h4 id="insertion">Insertion</h4><ul>
 <li><strong><code>insert()</code></strong> is the primary method to add elements.</li>
 <li>For <strong><code>set</code> and <code>map</code></strong>, <code>insert()</code> returns a pair containing an iterator to the inserted element (or the existing element if it was a duplicate) and a bool indicating success.</li>
 <li>For <strong><code>multiset</code> and <code>multimap</code></strong>, duplicates are allowed, so all inserts succeed.</li>
</ul><p><strong>Example:</strong></p><div class="code-block">
 <button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-cpp">std::set&lt;int&gt; s;
auto result = s.insert(10);  // Inserts 10
if (!result.second) {
    std::cout &lt;&lt; "Element already exists\n";
}

std::multiset&lt;int&gt; ms;
ms.insert(10);
ms.insert(10);  // Allowed duplicate</code></pre>
</div><h4 id="deletion">Deletion</h4><ul>
 <li><p>Use <strong><code>erase()</code></strong> to remove elements.</p></li>
 <li><p>You can erase by:</p>
  <ul>
   <li><strong>Key:</strong> <code>container.erase(key)</code> removes all matching elements (for <code>set</code> and <code>map</code>, this is one element since keys are unique).</li>
   <li><strong>Iterator:</strong> <code>container.erase(iterator)</code> removes the element at that position.</li>
   <li><strong>Range:</strong> <code>container.erase(startIterator, endIterator)</code> removes a range of elements.</li>
  </ul></li>
</ul><p><strong>Example:</strong></p><div class="code-block">
 <button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-cpp">std::set&lt;int&gt; s = {1, 2, 3, 4};
s.erase(2);  // Removes key 2

auto it = s.find(3);
if (it != s.end()) {
    s.erase(it);  // Removes element at iterator it
}</code></pre>
</div><h4 id="lookup">Lookup</h4><ul>
 <li><strong><code>find(key)</code></strong> returns an iterator to the element if found, or <code>end()</code> if not.</li>
 <li>For <code>multimap</code> and <code>multiset</code>, <code>equal_range(key)</code> returns a pair of iterators representing the range of matching elements.</li>
</ul><p><strong>Example:</strong></p><div class="code-block">
 <button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-cpp">std::map&lt;std::string, int&gt; m = {{"apple", 5}, {"banana", 3}};
auto it = m.find("banana");
if (it != m.end()) {
    std::cout &lt;&lt; "Found banana with value " &lt;&lt; it-&gt;second &lt;&lt; "\n";
} else {
    std::cout &lt;&lt; "Banana not found\n";
}</code></pre>
</div><h4 id="iterator-invalidation-rules">Iterator Invalidation Rules</h4><ul>
 <li>For associative containers, <strong>insertion and deletion do not invalidate iterators</strong> to other elements, except for iterators to erased elements.</li>
 <li>This means you can safely iterate while inserting or deleting other elements.</li>
</ul><h4 id="common-mistakes-to-avoid">Common Mistakes to Avoid</h4><ul>
 <li><strong>Ignoring return values from <code>insert()</code></strong> — especially with <code>set</code> and <code>map</code>, since duplicates won’t be inserted.</li>
 <li><strong>Erasing elements by invalid iterators</strong> — always check if an iterator is valid before erasing.</li>
 <li><strong>Assuming random access</strong> — associative containers don’t support indexing like arrays or vectors.</li>
 <li>Using <strong><code>find()</code> result without checking</strong> if it equals <code>end()</code> — always verify before dereferencing.</li>
</ul><p>Mastering these basic operations will make your use of associative containers robust and efficient. In the next section, we’ll explore practical examples to deepen your understanding.</p><div class = "chapter-navi-section">
<a href="#top" class="nav-button prev">↑</a>
<a href='cplusplus-stl.htm#stl-containers-associative-containers' class="nav-button toc-link">Index</a>
<a href="#bottom" class="nav-button next">↓</a>
</div>
<h2 id='practical-examples-counting-unique-words-phonebook'>3.5 Practical Examples: Counting Unique Words, Phonebook</h2><p>To see associative containers in action, let’s explore two common real-world applications: <strong>counting word frequencies</strong> in a text, and building a simple <strong>phonebook</strong>. We will use <code>std::map</code> (and briefly mention <code>std::unordered_map</code>) for efficient key-value storage.</p><h4 id="example-1-counting-unique-words">Example 1: Counting Unique Words</h4><p>Suppose you want to count how many times each word appears in a paragraph. <code>std::map&lt;std::string, int&gt;</code> is perfect for this because it stores words as keys and their counts as values, automatically sorted by the word.</p><div class="code-block">
 <button class="copy-button" onclick="copyCode(this)">📋</button>
 <pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;map&gt;
#include &lt;sstream&gt;

int main() {
    std::string text = "hello world hello STL hello map world";
    std::map&lt;std::string, int&gt; wordCount;

    std::istringstream iss(text);
    std::string word;

    // Read each word and update count
    while (iss &gt;&gt; word) {
        ++wordCount[word];  // Increment count for the word
    }

    // Print the results
    std::cout &lt;&lt; "Word frequencies:\n";
    for (const auto&amp; pair : wordCount) {
        std::cout &lt;&lt; pair.first &lt;&lt; ": " &lt;&lt; pair.second &lt;&lt; "\n";
    }

    return 0;
}</code></pre>
</div><p><strong>Explanation:</strong></p><ul>
 <li>We use an input string stream (<code>std::istringstream</code>) to split the text into words.</li>
 <li>Each word is used as a key in the map, and the associated value is incremented.</li>
 <li>Finally, we iterate over the map to display words in alphabetical order with their counts.</li>
</ul><blockquote>
 <p><strong>Note:</strong> If you don’t require the sorted order, <code>std::unordered_map</code> offers faster average insertion and lookup (<code>O(1)</code>), but the order of keys is not maintained.</p>
</blockquote><h4 id="example-2-simple-phonebook-application">Example 2: Simple Phonebook Application</h4><p>A phonebook stores names and associated phone numbers. Using <code>std::map&lt;std::string, std::string&gt;</code>, we can easily manage the entries with fast lookup.</p><div class="code-block">
 <button class="copy-button" onclick="copyCode(this)">📋</button>
 <pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;map&gt;

int main() {
    std::map&lt;std::string, std::string&gt; phonebook;

    // Insert entries
    phonebook["Alice"] = "555-1234";
    phonebook["Bob"] = "555-5678";
    phonebook.insert({"Charlie", "555-8765"});

    // Lookup a number
    std::string name = "Bob";
    auto it = phonebook.find(name);
    if (it != phonebook.end()) {
        std::cout &lt;&lt; name &lt;&lt; "'s phone number is " &lt;&lt; it-&gt;second &lt;&lt; "\n";
    } else {
        std::cout &lt;&lt; name &lt;&lt; " not found in the phonebook.\n";
    }

    // Iterate and print all entries
    std::cout &lt;&lt; "\nFull phonebook:\n";
    for (const auto&amp; entry : phonebook) {
        std::cout &lt;&lt; entry.first &lt;&lt; ": " &lt;&lt; entry.second &lt;&lt; "\n";
    }

    return 0;
}</code></pre>
</div><p><strong>Explanation:</strong></p><ul>
 <li>We add entries using both <code>operator[]</code> and <code>insert()</code>.</li>
 <li><code>find()</code> locates a key and returns an iterator; if the key doesn’t exist, it returns <code>end()</code>.</li>
 <li>Iteration displays all contacts sorted by name.</li>
</ul><h3 id="summary">Summary</h3><p>These examples demonstrate how associative containers simplify managing collections keyed by strings or other types. Counting word frequencies or building lookup tables like phonebooks are common tasks that benefit from their <strong>automatic sorting</strong>, <strong>fast search</strong>, and <strong>easy insertion/deletion</strong>. Mastering these patterns will empower you to solve many practical programming challenges efficiently.</p><div class = "chapter-navi-section">
<a href="cplusplus-stl-stl-containers-sequence-containers-basics.htm" class="nav-button prev">←</a>
<a href='cplusplus-stl.htm#stl-containers-associative-containers' class="nav-button toc-link">Index</a>
<a href="cplusplus-stl-unordered-containers-hash-based-containers.htm" class="nav-button next">→</a>
</div>
<section class="download-section">
  <div class="book-cover" style="background-color: #f9f6f1;border: 1px solid #ccc;"> 
    <div class="book-cover-title" style="font-size: 20px;color: #333;top: 20px;">C++ STL</div>
    <div class="book-cover-author">readbytes</div>
    <div class="book-cover-bottom-stripe" style="background-color: #333;"></div>
    <img class="book-cover-icon" style="width: 90px;height: 90px;top: 70px;" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFoAAABaCAYAAAA4qEECAAADK0lEQVR4Xu2cvWsTcRjHo+DkIKiTjiJugqTJ0cG/QcRZ/wJXQTd3ByeHDiLJnS84dHMVBHUSRQUH90pNfmfb6CKi8fqSaj93ae4lzzV3+X7gS9vkeZ7f7/lwEDq0jYYQQgghxFzQ9t0wbTzf3WO/SAllpg3niAlQYJa0uu4W54kxeA96ZykwU4JwnTPFGGLyMqd3nTNFAnFx2cOZIiee//UK5TLsEQWg3D1ZHpxgvShATLCeajsoWKKNaAfuDyVvZuGhu8paURBK1lNtBAVLtBEULNFGULBEG0HBlRfNRUrMqwW/f473GZFQvxXWVQbPD5e4zEGlcXt4eHQvvrdbU2W4zEGn5Yd3+NoovHul4DKzHN69UnCZWQ7vXim8IHzJhWY1vLtIQSRujSInhTNEBppL345R6LiwV+SAUpPCHpETimVYLwpAuRJtBOVKtBHNR4OTFCzRRlCwRBtBwRJtBAVLtBEULNFGeN3wPiVvp/+OtVmJ5qzvmdl1z1kzV8Ql53+q0/6az765gBLyConqN9i/X9hfeyiAYX0S7cCtsi9NOKf2UADDesL6LOGsWsPlx+V8d/Vo3t5x4bzyGA4P8TK1TuBeU0FpxC5T83D/0uBF6h7uXxq8SN3D/Utj80OHl6ltgvAX9y+V2IUm53eUQZQvUT4nvJ8x/e/R14+RiBeeHz4bZfPn6PW3bT908Z7s4d6Vgwsxix13mj15iGb94Ows4bxKwWUY1heF89OGcyoHFypjOZ4zKV7gVjijUjSfrJ/hUqOwdtrwvH2yzN7KkbDUTsKfrLWgufTmSPzsf2F9ZeFitVtwVqBgiTaCgiXaCAqWaCMoWKKNoGCJNoKCJdoICpZoIyhYoo2gYIk2goIl2ggKlmgjKFiijaBgiTaCgiXagLbfu0jBW+m6NdaKAsQEj9Jxl1krChATvBPWiQJ4fviJgiV6yiw+3ThOuRI9ZbzA3aRYSZ4iFx73T1FqUtg3l1DKbrr9960gvBt9f207/Rst332I1U0Iz5tbKGaa4VlzTSQk8X84Fw3PEY3p/70KTxA7UFTeeB13ibPFf1BY1nCeEEIIIYQowl8t5mhjJHw+fQAAAABJRU5ErkJggg=="/>
  </div>
  <div class="download-info">
    <h2 id='bottom'>Download This Ebook</h2>
    <p class="format-label">Available formats:</p>
    <div class="download-buttons">
      <a href="cplusplus-stl.pdf" class="download-button">📄 PDF</a>
      <a href="cplusplus-stl.epub" class="download-button">📘 EPUB</a>
    </div>
  </div>
</section><div class='related-books'>
<h2>C++ Introduction Books</h2>
<div class='related-book-list'>
<a href="cplusplus-for-beginners.htm">
<div class="book-cover" style="background-color: #f9f6f1;border: 1px solid #ccc;"> 
    <div class="book-cover-title" style="font-size: 18px;color: #333;top: 20px;">C++ for Beginners</div>
    <div class="book-cover-author">readbytes</div>
    <div class="book-cover-bottom-stripe" style="background-color: #333;"></div>
    <img class="book-cover-icon" style="width: 90px;height: 90px;top: 70px;" src="data:image/png;base64,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"/>
  </div>
</a>


<a href="cplusplus-syntax.htm">
<div class="book-cover" style="background-color: #f9f6f1;border: 1px solid #ccc;"> 
    <div class="book-cover-title" style="font-size: 20px;color: #333;top: 20px;">C++ Syntax</div>
    <div class="book-cover-author">readbytes</div>
    <div class="book-cover-bottom-stripe" style="background-color: #333;"></div>
    <img class="book-cover-icon" style="width: 90px;height: 90px;top: 70px;" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFoAAABaCAYAAAA4qEECAAAFZ0lEQVR4Xu2dy4scVRSH8ye0iYtkERcmzgjT2OYBuhNREMVXBh/TgsYQx5ULDYTgVl3EFyg6uFJBV76IEXdKXAVBJCgISSTRGRmZiZlADBo6M5kp+3ZbnXt/p7q6btWtc++pqQPfpu/p7vP7UnSqi+m6GzbkrMbYO50u0Tqjgx5Kqe4brSa8+XplFf0UroQ3GbDltqNRs70Y3Tw5G22//2SXU0Fyy5MXc6GyqYyYWwd9WdfGbW9uxRe9vvlBtOvZKLrpwTOiUDO7QjlALxu3zWxFf5mq++RF/YU27/40au39lwSQAspygXICwhfRY2rhv5Z6URxcEuoAQUkuQV/oM7HwSN45vUoGlwaKKQOrI1t9zuhPaD19mQwtEZRSFrq71M/sqh3JMSikTHSH6LdXeoN6Ag4rlV3Ta0RG2aTKjhfU/6Q4rGRQAgf62QhKHnzjk3wKlwRK4EI7qq99g4wf3NR8nwwqmfE9s0QAF8olOarjB1QDDisZDM+NIbqhXYXDQaWDwbnRPj46xtkGDiodDM6N7nYgWl2hwkEl09r7DwnOzZbbr131G4iemFokw0oGQ/ug2XVKRI9PzpJhJYOhfdB66m8qevsDp8iwksHQPqi8aAzsi1o0E7VoJioteuzh30lgX1RaNIb1SS2aiVo0E5UVPTH1Fwnrk8qKxqC+qUUzUYtmwovoL49dioYV9uZhx/4VEjRmWM2fp70uYRc9qrA/DxhSZ1RhvyuCEL1wfiU6PXulB/bnAUPqnJnv8+cSTtEv7HeFd9G4XpyzJGQaWLjuisqJxoCjeOVjc572y7THBayim4+cNUKdONkhPUXBgKO495AxUrTvVdrjAq+ij//k/i9UMeAo7jlojFSLzsLE4/ZfuyspuvXYb0Yo16IxXBZQ9DOv0x4XsIqeOjRvhPri20ukpwgYLgt3HTBGir75kfa4gFU01h373f5ZA4bLChauu4BNdPtF82hWhT1FuHVfh4TLCtbR47SnKKWKTqu5hWXSXwQMZsOBGZzOLOzPA7voNz66QPpcgMHy8Py7OG2/sC8P7KLjurK8RvqLgMFsmDmC05mF/XkoVbTOjinz1E4V9uSl6I+AsF6YoT1FYROtwLpzeo705AFD2YKF6y5gFf3oQfPM48h3w8+jD3+4ZIDrOnGYtz7vgyHTuBvOo7/+nva4gFW0zTdDLFyPGdN+BBQXhkyDfDN8jfa4gFW0zbWOH365bIDrMXqYE7/2wZBpoOhKXOuwEZ0VDGTLuhD98+kO6bEFA9lyXxWvRyuwcN0GdccFDGTLe1+Z87Rfoj0uEC0aw+QBC9dd4V10XMsraz2wPw0Mk4WVq33WcID/C/tdwS766uqwiP3C/jQwTBZGFfa7gl204rnDC5hvUNg7DAySlWH1yTHa6xIvol2AQUKnFs2ESNHjk3MkSOiIFI0hJFCLZqIWzYQ40c0nLpAQEhAnGgNIoRbNRC2aCVGid6b8CCh0RInG4SVRi2YiUXSIN68ae8juR0ChkSg6xNux4eDSSLwdW4g3GMTBpZF4g0EFBvUNDi4N3a0SHeRNYCfaS2RwaWii+1s/xQ+oRQzsCxxaIoOjGe8fHdKNunFoaWzSdh/SRQd363kcXBrax4a5eVm8EMJmCmn33pDA5t2f0aMZRStUM4bnBAeXhu4SPfdKb/C54Q0OLomRklWFsoUTDi8F3d11N759A/o1quF5UzIcXgq6sy7n0GtiwZN6L4RCygIDSAB9oc/UwiOba+NIDBEy+tmF1ZGMhZ/ZijK3Qh3f8wcJEyJOt0LVC19UR12harbPOdncFzfWDQGVTb8KlwT6KlyNertqHffbVSdVo96A3ar+A5kzbYSE7G+UAAAAAElFTkSuQmCC"/>
  </div>
</a>


<a href="cplusplus-stl.htm">
<div class="book-cover" style="background-color: #f9f6f1;border: 1px solid #ccc;"> 
    <div class="book-cover-title" style="font-size: 20px;color: #333;top: 20px;">C++ STL</div>
    <div class="book-cover-author">readbytes</div>
    <div class="book-cover-bottom-stripe" style="background-color: #333;"></div>
    <img class="book-cover-icon" style="width: 90px;height: 90px;top: 70px;" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFoAAABaCAYAAAA4qEECAAADK0lEQVR4Xu2cvWsTcRjHo+DkIKiTjiJugqTJ0cG/QcRZ/wJXQTd3ByeHDiLJnS84dHMVBHUSRQUH90pNfmfb6CKi8fqSaj93ae4lzzV3+X7gS9vkeZ7f7/lwEDq0jYYQQgghxFzQ9t0wbTzf3WO/SAllpg3niAlQYJa0uu4W54kxeA96ZykwU4JwnTPFGGLyMqd3nTNFAnFx2cOZIiee//UK5TLsEQWg3D1ZHpxgvShATLCeajsoWKKNaAfuDyVvZuGhu8paURBK1lNtBAVLtBEULNFGULBEG0HBlRfNRUrMqwW/f473GZFQvxXWVQbPD5e4zEGlcXt4eHQvvrdbU2W4zEGn5Yd3+NoovHul4DKzHN69UnCZWQ7vXim8IHzJhWY1vLtIQSRujSInhTNEBppL345R6LiwV+SAUpPCHpETimVYLwpAuRJtBOVKtBHNR4OTFCzRRlCwRBtBwRJtBAVLtBEULNFGeN3wPiVvp/+OtVmJ5qzvmdl1z1kzV8Ql53+q0/6az765gBLyConqN9i/X9hfeyiAYX0S7cCtsi9NOKf2UADDesL6LOGsWsPlx+V8d/Vo3t5x4bzyGA4P8TK1TuBeU0FpxC5T83D/0uBF6h7uXxq8SN3D/Utj80OHl6ltgvAX9y+V2IUm53eUQZQvUT4nvJ8x/e/R14+RiBeeHz4bZfPn6PW3bT908Z7s4d6Vgwsxix13mj15iGb94Ows4bxKwWUY1heF89OGcyoHFypjOZ4zKV7gVjijUjSfrJ/hUqOwdtrwvH2yzN7KkbDUTsKfrLWgufTmSPzsf2F9ZeFitVtwVqBgiTaCgiXaCAqWaCMoWKKNoGCJNoKCJdoICpZoIyhYoo2gYIk2goIl2ggKlmgjKFiijaBgiTaCgiXagLbfu0jBW+m6NdaKAsQEj9Jxl1krChATvBPWiQJ4fviJgiV6yiw+3ThOuRI9ZbzA3aRYSZ4iFx73T1FqUtg3l1DKbrr9960gvBt9f207/Rst332I1U0Iz5tbKGaa4VlzTSQk8X84Fw3PEY3p/70KTxA7UFTeeB13ibPFf1BY1nCeEEIIIYQowl8t5mhjJHw+fQAAAABJRU5ErkJggg=="/>
  </div>
</a>



<a href='cplusplus.htm'><div class='book-cover' style='background-color: #f9f6f1;color: #111111;border: 1px solid #ccc;display: flex;justify-content: center;align-items: center;text-align: center;'>More C++ Books</div></a>
</div>
</div><script>
function copyCode(button) {const code = button.nextElementSibling.innerText;navigator.clipboard.writeText(code).then(() => {button.textContent = 'Copied!';setTimeout(() => { button.textContent = 'Copy'; }, 1500);});}
</script></div>
<style>
.site-footer {margin-top: 60px;padding: 20px 0;border-top: 1px solid #eee;text-align: center;font-size: 14px;}
.site-footer a {text-decoration: none;}
.light-mode .site-footer {color: #777;border-color: #eee;}
.dark-mode .site-footer {color: #888;border-color: #333;}
.light-mode .site-footer a {color: #555;}
.dark-mode .site-footer a {color: #aaa;}
.site-footer a:hover {text-decoration: underline;}    
</style>
<footer class="site-footer">
<nav><a href="https://readbytes.github.io">Home</a> |Email:<script type="text/javascript">
var part1 = 'yinpeng';var part6 = '263';var part2 = Math.pow(2,6);var part3 = String.fromCharCode(part2);var part4 = 'hotmail dot com';var part5 = part1 + String.fromCharCode(part2) + part4;document.write(part1 + part6 + part3 + part4);
</script>
| <a id="mode-toggle" href="#">Toggle Dark Mode</a>
</nav><p>© 2025 — All rights reserved.</p></footer>
<script>
const toggleButton = document.getElementById('mode-toggle');
const body = document.body;
const savedMode = localStorage.getItem('mode') || 'light';
body.classList.add(savedMode + '-mode');
toggleButton.addEventListener('click', () => {
      const isDark = body.classList.contains('dark-mode');
      body.classList.toggle('dark-mode', !isDark);
      body.classList.toggle('light-mode', isDark);
      localStorage.setItem('mode', isDark ? 'light' : 'dark');
});
function copyCode(button) {const code = button.nextElementSibling.innerText;navigator.clipboard.writeText(code).then(() => {button.textContent = 'Copied!';setTimeout(() => { button.textContent = 'Copy'; }, 1500);});}
</script>
</body>
</html>