<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>C for Beginners Dynamic Memory Management</title>
<link rel='shortcut icon' href='https://readbytes.github.io/images/favicon.ico'>
<link href="https://fonts.googleapis.com/css2?family=Merriweather&display=swap" rel="stylesheet" />
<link href="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet" />
<script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/prism.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/codemirror.min.css" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/codemirror.min.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/theme/dracula.min.css"><style>
html {scroll-behavior: smooth;}  
body {font-family: 'Merriweather', serif;;margin: 0;padding: 2rem 1rem;font-size: 15px;line-height: 1.5;transition: background-color 0.3s, color 0.3s;}
.container {max-width: 750px;margin: 0 auto;padding: 1rem 2rem;}
.light-mode {background-color: #f8f7f5;color: #333;} 
.dark-mode {background-color: #121212;color: #e0e0e0;}
a { text-decoration: none;transition: color 0.2s;}
a:hover {text-decoration: underline;}
.light-mode a {color: #555;}
.dark-mode a {color: #aaa;}
</style><style>
.related-book-list {display: flex;flex-wrap: wrap;gap: 20px;}
.related-books {margin-top: 40px;}
.related-books h2 {font-size: 22px;margin-bottom: 20px;border-bottom: 2px solid #eee;padding-bottom: 8px;}
.light-mode .related-books h2 {color: #333;border-color: #eee;}
.dark-mode .related-books h2 {color: #ddd;border-color: #333;}
</style><style>
.book-cover {width: 130px;height: 180px;font-family: Arial, sans-serif;position: relative;overflow: hidden;box-shadow: 2px 2px 4px rgba(0,0,0,0.1);}
.book-cover-bottom-stripe {position: absolute;bottom: 0;left: 0;height: 5px;width: 100%;}
.book-cover-title {position: absolute;width: 100%;text-align: center;font-weight: bold;}
.book-cover-icon {position: absolute;left: 50%;transform: translateX(-50%);display: flex;align-items: center;justify-content: center;}
.book-cover-author {position: absolute;bottom: 10px;width: 100%;text-align: center;font-size: 8px;color: #333;}
</style><style>
.book-title-toc {font-size: 32px;font-weight: bold; }
.book-subtitle-toc {font-size: 18px;margin-top: 8px;font-style: italic;}
.book-header {text-align: center;margin-bottom: 40px;}

.toc-container {border-radius: 10px;padding: 30px;margin-bottom: 40px;box-shadow: 0 8px 20px rgba(0,0,0,0.05);}
h1 {font-size: 24px;text-align: center;margin-bottom: 30px;letter-spacing: 1px;padding-bottom: 10px;}
.toc-list,.toc-section-list {list-style: none;padding: 0;margin: 0;}
.toc-section-list {padding-left: 18px;margin-top: 6px;margin-bottom: 20px; }
.toc-chapter {padding: 20px 0;}
.chapter-title,.toc-section {display: flex;justify-content: space-between;padding-top: 4px;}
.chapter-title {font-size: 17px;font-weight: bold;}
.chapter-page,.section-page {font-style: italic;}
 
 
.light-mode .book-title-toc,.light-mode .chapter-title,.light-mode .book-name {color: #222;}
.light-mode .book-subtitle-toc,.light-mode .book-sub,.light-mode .chapter-page,.light-mode .section-page {color: #666;}
.light-mode .toc-container { background: #fff;border: 1px solid #ddd;}
.light-mode h1 {border-bottom: 2px solid #eee;color: #222;}
.light-mode .toc-section {  color: #444;}

.light-mode .book-cover { border: 1px solid #ccc;box-shadow: 0 6px 12px rgba(0, 0, 0, 0.15);}
.light-mode .book-title,.light-mode .series-name {color: #fff;}
.light-mode .book-subtitle,.light-mode .book-footer {color: #aaa;}

.dark-mode .book-title-toc,.dark-mode .chapter-title,.dark-mode .book-name {color: #f5f5f5;}
.dark-mode .book-subtitle-toc,.dark-mode .book-sub,.dark-mode .chapter-page,.dark-mode .section-page {color: #aaa;}
.dark-mode .toc-container {background: #1e1e1e;border: 1px solid #444;}

.dark-mode h1 {border-bottom: 2px solid #333;color: #eee;}
.dark-mode .toc-section {color: #bbb;}

.dark-mode .related-books h2 {color: #ddd;border-bottom: 2px solid #333;}
.dark-mode .book-title,.dark-mode .series-name {color: #fff;}
.dark-mode .book-subtitle,.dark-mode .book-footer {color: #bbb;}
.dark-mode .toc-section {color: #ddd;}

@media (max-width: 600px) {
  .chapter-title,
  .toc-section {
    flex-direction: column;
    align-items: flex-start;
  }

  .chapter-page,
  .section-page {
    margin-top: 4px;
  }
}

</style><style>
.light-mode .container {box-shadow: 0 0 15px rgba(0,0,0,0.1);}
.dark-mode .container {box-shadow: 0 0 15px rgba(255, 255, 255, 0.05);}

h1, h2, h3 {font-weight: 600;margin-top: 2.5rem;margin-bottom: 1rem;line-height: 1.2;}
h1 { font-size: 1.8rem; }
h2 { font-size: 1.4rem; }
h3 { font-size: 1.2rem; }

table {width: 100%;border-collapse: collapse;font-family: sans-serif;font-size: 1em;margin: 1em 0;}
th, td {padding: 0.6em 1em;text-align: left;border: 1px solid;}
tr:nth-child(even) {  background-color: inherit;}
tr:hover { background-color: inherit;}

code {color: #d35400;}

.chapter-navi-section {display: flex;justify-content: space-between;align-items: center;padding-bottom: 10px;padding-top: 10px;}
.nav-link {color: inherit;text-decoration: none;opacity: 0.5;transition: opacity 0.3s ease, text-decoration 0.3s ease;}
.nav-link:hover {opacity: 0.9;text-decoration: underline;}
.prev { text-align: left; }
.toc-link { text-align: center; }
.next { text-align: right; }

.download-section {display: flex;align-items: center;justify-content: center;gap: 2rem;padding: 2rem 1rem;max-width: 600px;margin: 3rem auto;border-radius: 12px;box-shadow: 0 4px 10px rgba(0,0,0,0.05);}
.download-info h2 {margin: 0 0 0.5rem;font-size: 1.2rem;}
.format-label {margin: 0 0 0.5rem;font-size: 0.95rem;}
.download-buttons {display: flex;gap: 1rem;}
.download-button {background-color: #4A90E2;color: white;padding: 0.5em 1.2em;border-radius: 25px;font-size: 0.95rem;text-decoration: none;transition: background-color 0.3s ease;}
.download-button:hover {background-color: #357ABD;}

.code-block {position: relative;margin-bottom: 1em;}
.copy-button {background: transparent;color: white;position: absolute;top: 8px;right: 8px;border: none;padding: 4px 8px;font-size: 12px;border-radius: 4px;cursor: pointer;z-index: 1;}
.copy-button:hover {background-color: #0056b3;}

.snippet-container {overflow: hidden;}
.snippet-header {padding: 0.75rem 1rem;cursor: pointer;font-size: 1rem;background-color: #eeeeee;color:  #111111; border-radius: 8px;cursor: pointer;box-shadow: 0 4px 6px rgba(0,0,0,0.1); }
.snippet-body {display: none;font-family: monospace;}
.snippet-container.open .snippet-body {display: block;}

.CodeMirror {border: 2px solid #ccc;border-radius: 4px;resize: vertical;}

.light-mode .format-label {color: #888;}
.light-mode th {background-color: #f2f2f2;}
.light-mode tr:nth-child(even) {background-color: #fafafa;}
.light-mode tr:hover {background-color: #e6f7ff;}

.dark-mode .snippet-header {background-color: #333;color:  #ddd; }
.dark-mode .format-label {color: #aaa;}
.dark-mode th {background-color: #333;color: #fff;}
.dark-mode td {border-color: #444;}
.dark-mode tr:nth-child(even) {background-color: #2a2a2a;}
.dark-mode tr:hover {background-color: #2c3e50;}


.button-group-run-edit {display: flex;width: 100%;gap: 1rem;}
.button-run-edit {flex: 1;padding: 1rem;font-size: 1rem;font-weight: 600;border: none;border-radius: 8px;cursor: pointer;transition: background 0.3s, color 0.3s;}

.light-mode .button-run-edit {background-color: #f0f0f0;color: #222;box-shadow: 0 0 10px rgba(0, 0, 0, 0.05);}
.light-mode .button-run-edit:hover {background-color: #e0e0e0;}

.dark-mode .button-run-edit {background-color: #2a2a2a;color: #f5f5f5;box-shadow: 0 0 10px rgba(255, 255, 255, 0.05);}
.dark-mode .button-run-edit:hover {background-color: #3a3a3a;}

button { padding: 0.5em 1em; background: green; color: white; border: none; cursor: pointer; }
button:hover { background: #1e7e34; }
.result_iframe { width:99%; margin-top: 1em;  resize: both;background-color: #515b63;border:1px solid #ccc;}   

.dialog-backdrop {position: fixed;top: 0;left: 0;width: 100vw;height: 100vh;background: rgba(0,0,0,0.5);display: none;justify-content: center;align-items: center;z-index: 10;}
.dialog {background: #90979e;padding: 20px;width: 90vw;height: 80vh;border-radius: 8px;box-shadow: 0 0 20px rgba(0,0,0,0.3);display: flex;flex-direction: column;}
.dialog-content {display: flex;gap: 20px;margin-top: 10px;height: calc(100% - 40px);}
.editor-container, .preview-container {flex: 1;height: 100%;max-height: 100%;overflow: hidden; }
.result_iframe_dialog {width: 100%;height: 100%;resize: both;border:1px solid #ccc;overflow: auto; }   
.CodeMirror {width: 100% !important;height: 100% !important;}
</style>
</head>
<body>
<script>const mode = localStorage.getItem('mode') || 'light';document.documentElement.classList.add(`${mode}-mode`);</script>  
<div class="container"><div class = "chapter-navi-section">
<a href="c-for-beginners-pointers-and-memory-addressing.htm" class="nav-button prev">←</a>
<a href='c-for-beginners.htm#dynamic-memory-management' class="nav-button toc-link">Index</a>
<a href="c-for-beginners-structures-and-unions.htm" class="nav-button next">→</a>
</div>
<div class='book-header'><h1 class='book-title-toc' id = 'top'>Dynamic Memory Management</h1><h3 class='book-subtitle-toc'>C for Beginners</h3></div><h2 id='malloc-calloc-realloc-free'>8.1 <code>malloc</code>, <code>calloc</code>, <code>realloc</code>, <code>free</code></h2><p>In C, <strong>dynamic memory management</strong> allows you to allocate, resize, and free memory during program execution, rather than relying only on fixed-size, compile-time arrays. This is essential for creating flexible programs that adapt to varying data sizes, such as user input or growing data structures.</p><p>The C standard library provides four key functions to manage dynamic memory:</p><ul>
 <li><code>malloc()</code></li>
 <li><code>calloc()</code></li>
 <li><code>realloc()</code></li>
 <li><code>free()</code></li>
</ul><p>Understanding these functions is fundamental to efficient memory handling and avoiding common bugs like memory leaks or segmentation faults.</p><h3 id="malloc-allocate-memory-block"><code>malloc()</code>: Allocate Memory Block</h3><p>The <code>malloc()</code> function (short for <strong>memory allocation</strong>) reserves a block of memory of a specified size (in bytes) and returns a pointer to the beginning of that block.</p><p><strong>Syntax:</strong></p><div class="code-block">
 <button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-c">void *malloc(size_t size);</code></pre>
</div><ul>
 <li><code>size</code> specifies how many bytes to allocate.</li>
 <li>Returns a <code>void*</code> pointer to the allocated memory, or <code>NULL</code> if allocation fails.</li>
 <li>The allocated memory contains <strong>garbage values</strong> (uninitialized).</li>
</ul><p><strong>Example:</strong> Allocating an array of 10 integers using <code>malloc</code>:</p><div class="code-block">
 <button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main() {
    int *arr = (int *)malloc(10 * sizeof(int));  // Allocate memory for 10 ints

    if (arr == NULL) {  // Always check if malloc succeeded
        printf("Memory allocation failed\n");
        return 1;
    }

    for (int i = 0; i &lt; 10; i++) {
        arr[i] = i * 2;  // Initialize array elements
    }

    for (int i = 0; i &lt; 10; i++) {
        printf("%d ", arr[i]);
    }
    printf("\n");

    free(arr);  // Free allocated memory
    return 0;
}</code></pre>
</div><h3 id="calloc-allocate-and-zero-initialize"><code>calloc()</code>: Allocate and Zero-Initialize</h3><p><code>calloc()</code> (<strong>contiguous allocation</strong>) works like <code>malloc()</code> but <strong>initializes the allocated memory to zero</strong>.</p><p><strong>Syntax:</strong></p><div class="code-block">
 <button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-c">void *calloc(size_t num, size_t size);</code></pre>
</div><ul>
 <li>Allocates memory for <code>num</code> elements, each of size <code>size</code>.</li>
 <li>Returns a pointer to the zero-initialized block, or <code>NULL</code> if it fails.</li>
</ul><p><strong>Example:</strong> Allocate and zero-initialize an array of 5 doubles:</p><div class="code-block">
 <button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-c">double *arr = (double *)calloc(5, sizeof(double));
if (arr == NULL) {
    // Handle error
}</code></pre>
</div><p>The memory for <code>arr</code> contains zeros, so you don't have to manually initialize it.</p><h3 id="realloc-resize-previously-allocated-memory"><code>realloc()</code>: Resize Previously Allocated Memory</h3><p>Sometimes you allocate memory but later realize you need more or less space. <code>realloc()</code> allows resizing the allocated memory block without losing existing data (up to the minimum of old and new sizes).</p><p><strong>Syntax:</strong></p><div class="code-block">
 <button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-c">void *realloc(void *ptr, size_t new_size);</code></pre>
</div><ul>
 <li><code>ptr</code>: Pointer previously returned by <code>malloc()</code>, <code>calloc()</code>, or <code>realloc()</code>.</li>
 <li><code>new_size</code>: New size in bytes.</li>
 <li>Returns a pointer to the resized block or <code>NULL</code> if allocation fails (original pointer remains valid).</li>
</ul><p><strong>Example:</strong> Resize the earlier allocated integer array from 10 to 20 elements:</p><div class="code-block">
 <button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-c">int *arr = (int *)malloc(10 * sizeof(int));
// Initialize arr...

int *temp = (int *)realloc(arr, 20 * sizeof(int));
if (temp == NULL) {
    printf("Reallocation failed\n");
    free(arr);  // Free original if realloc fails
    return 1;
} else {
    arr = temp;  // Use resized array
}</code></pre>
</div><h3 id="free-release-allocated-memory"><code>free()</code>: Release Allocated Memory</h3><p>Whenever you allocate memory dynamically, you must release it once you’re done using it, to avoid <strong>memory leaks</strong> — situations where memory remains allocated but is no longer accessible.</p><p><strong>Syntax:</strong></p><div class="code-block">
 <button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-c">void free(void *ptr);</code></pre>
</div><ul>
 <li><code>ptr</code> is a pointer to previously allocated memory.</li>
 <li>After calling <code>free()</code>, the memory is returned to the system.</li>
 <li>Do <strong>not</strong> use the pointer after freeing it (dangling pointer).</li>
</ul><h3 id="important-notes-and-best-practices">Important Notes and Best Practices</h3><ul>
 <li><strong>Always check if <code>malloc()</code>, <code>calloc()</code>, or <code>realloc()</code> returns <code>NULL</code>.</strong> Failing to check can lead to crashes or undefined behavior.</li>
 <li>When casting the result of allocation functions to another pointer type (e.g., <code>(int *)</code>), note that in C, this cast is optional but common practice for clarity.</li>
 <li><strong>Never forget to <code>free()</code> dynamically allocated memory</strong> — especially in long-running programs or those with many allocations.</li>
 <li>After freeing memory, it’s a good habit to set the pointer to <code>NULL</code> to avoid accidental dereferencing:</li>
</ul><div class="code-block">
 <button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-c">free(arr);
arr = NULL;</code></pre>
</div><ul>
 <li>Use <code>calloc()</code> when you want memory initialized to zero, such as for arrays where default zero values are required.</li>
 <li><code>realloc()</code> is very useful for dynamic arrays where the size is unknown upfront, but be mindful that the returned pointer may differ from the original.</li>
 <li>If <code>realloc()</code> fails, the original memory remains valid — avoid losing the pointer without freeing.</li>
</ul><h3 id="practical-example-dynamic-array-input">Practical Example: Dynamic Array Input</h3><div class="code-block">
 <button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main() {
    int *arr = NULL;
    int capacity = 2;
    int size = 0;

    arr = (int *)malloc(capacity * sizeof(int));
    if (arr == NULL) {
        printf("Memory allocation failed\n");
        return 1;
    }

    int input;
    printf("Enter integers (negative to stop):\n");
    while (1) {
        scanf("%d", &amp;input);
        if (input &lt; 0) break;

        if (size == capacity) {
            capacity *= 2;
            int *temp = (int *)realloc(arr, capacity * sizeof(int));
            if (temp == NULL) {
                printf("Reallocation failed\n");
                free(arr);
                return 1;
            }
            arr = temp;
        }
        arr[size++] = input;
    }

    printf("You entered:\n");
    for (int i = 0; i &lt; size; i++) {
        printf("%d ", arr[i]);
    }
    printf("\n");

    free(arr);
    return 0;
}</code></pre>
</div><p>This program dynamically grows the array as the user enters values, demonstrating <code>malloc()</code>, <code>realloc()</code>, and <code>free()</code> in practice.</p><h3 id="summary">Summary</h3><table>
 <thead>
  <tr>
   <th>Function</th>
   <th>Purpose</th>
   <th>Key Points</th>
  </tr>
 </thead>
 <tbody>
  <tr>
   <td><code>malloc()</code></td>
   <td>Allocate uninitialized memory block</td>
   <td>Check for <code>NULL</code>, returns <code>void*</code></td>
  </tr>
  <tr>
   <td><code>calloc()</code></td>
   <td>Allocate zero-initialized memory block</td>
   <td>Useful for arrays/structs</td>
  </tr>
  <tr>
   <td><code>realloc()</code></td>
   <td>Resize previously allocated block</td>
   <td>Can move memory, handle <code>NULL</code></td>
  </tr>
  <tr>
   <td><code>free()</code></td>
   <td>Release allocated memory</td>
   <td>Prevent memory leaks</td>
  </tr>
 </tbody>
</table><h3 id="conclusion">Conclusion</h3><p>Mastering <code>malloc()</code>, <code>calloc()</code>, <code>realloc()</code>, and <code>free()</code> is essential for effective memory management in C. These functions provide the flexibility to build dynamic data structures and manage resources efficiently. Always remember to check for allocation failures and free memory when it’s no longer needed. Proper dynamic memory management leads to robust, efficient, and leak-free programs.</p><div class = "chapter-navi-section">
<a href="#top" class="nav-button prev">↑</a>
<a href='c-for-beginners.htm#dynamic-memory-management' class="nav-button toc-link">Index</a>
<a href="#bottom" class="nav-button next">↓</a>
</div>
<h2 id='memory-leaks-and-best-practices'>8.2 Memory Leaks and Best Practices</h2><p>When programming in C, managing memory correctly is one of the most important — and challenging — responsibilities. Unlike some modern languages that automatically handle memory cleanup (like Python or Java), C requires the programmer to explicitly allocate and free memory. Failure to do so properly can lead to <strong>memory leaks</strong>, which degrade program performance and may eventually cause crashes or system instability.</p><h3 id="what-is-a-memory-leak">What is a Memory Leak?</h3><p>A <strong>memory leak</strong> occurs when a program allocates memory dynamically (using <code>malloc()</code>, <code>calloc()</code>, or <code>realloc()</code>) but <strong>fails to release it back to the system</strong> using <code>free()</code>. The allocated memory remains reserved and inaccessible, reducing the available memory for the program and other processes.</p><p>Imagine your program requests memory repeatedly but never returns it — over time, the operating system runs out of free memory, and the program or even the entire system can slow down or crash.</p><h3 id="how-memory-leaks-occur">How Memory Leaks Occur</h3><p>Here are some common scenarios that cause memory leaks:</p><ol>
 <li><strong>Forgetting to call <code>free()</code></strong></li>
</ol><div class="code-block">
 <button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-c">int *arr = malloc(10 * sizeof(int));
// Use the array
// Missing free(arr);</code></pre>
</div><p>Here, the allocated memory is never freed, causing a leak.</p><ol start="2">
 <li><strong>Losing track of allocated memory</strong></li>
</ol><div class="code-block">
 <button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-c">int *ptr = malloc(20 * sizeof(int));
ptr = malloc(30 * sizeof(int));  // Previous allocation lost</code></pre>
</div><p>In this case, the first allocated block of 20 integers is not freed before <code>ptr</code> is reassigned to a new block of 30 integers. The original memory is "orphaned," causing a leak.</p><ol start="3">
 <li><strong>Returning pointers to local (stack) variables instead of heap memory</strong></li>
</ol><p>This is a related error that causes undefined behavior and not exactly a leak, but improper pointer management can also contribute to leaks.</p><h3 id="impact-of-memory-leaks">Impact of Memory Leaks</h3><p>Memory leaks may seem harmless for small or short-running programs, but they can cause serious problems:</p><ul>
 <li><strong>Gradual slowdown:</strong> As free memory decreases, your program’s performance may degrade.</li>
 <li><strong>Crashes:</strong> Exhaustion of memory may cause segmentation faults or aborts.</li>
 <li><strong>System instability:</strong> In systems with limited resources (e.g., embedded devices), leaks may affect the entire system.</li>
</ul><p>Therefore, <strong>detecting and fixing memory leaks is vital</strong> for writing robust, efficient software.</p><h3 id="best-practices-to-avoid-memory-leaks">Best Practices to Avoid Memory Leaks</h3><p>Here are some essential tips and practices to prevent memory leaks:</p><h4 id="always-pair-allocation-and-deallocation">Always Pair Allocation and Deallocation</h4><p>Every time you call <code>malloc()</code>, <code>calloc()</code>, or <code>realloc()</code>, ensure there is a matching <code>free()</code> when the memory is no longer needed.</p><p>Example:</p><div class="code-block">
 <button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-c">int *data = malloc(100 * sizeof(int));
if (data == NULL) {
    // Handle error
}
// Use data...
free(data);  // Free when done</code></pre>
</div><p>It helps to think of memory management as a contract: every allocation implies a responsibility to free.</p><h4 id="initialize-pointers-to-null">Initialize Pointers to <code>NULL</code></h4><p>Initializing pointers to <code>NULL</code> reduces the chance of freeing invalid or uninitialized pointers:</p><div class="code-block">
 <button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-c">int *ptr = NULL;
ptr = malloc(10 * sizeof(int));
if (ptr != NULL) {
    // Use ptr
    free(ptr);
    ptr = NULL;  // Avoid dangling pointer
}</code></pre>
</div><p>Setting pointers to <code>NULL</code> after freeing them avoids accidental usage of "dangling" pointers — pointers that refer to freed memory.</p><h4 id="avoid-losing-pointers-to-allocated-memory">Avoid Losing Pointers to Allocated Memory</h4><p>If you need to reassign a pointer that owns dynamically allocated memory, free the old memory first:</p><div class="code-block">
 <button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-c">int *ptr = malloc(20 * sizeof(int));
if (ptr == NULL) exit(1);

// Later...
int *temp = malloc(30 * sizeof(int));
if (temp == NULL) {
    free(ptr);
    exit(1);
}
free(ptr);
ptr = temp;</code></pre>
</div><p>Never overwrite a pointer without freeing its current memory first, or you risk leaking the original block.</p><h4 id="use-tools-for-leak-detection">Use Tools for Leak Detection</h4><p>Manual detection of leaks is hard, especially in complex programs. Tools like <strong>Valgrind</strong> (Linux/Mac) or <strong>Dr. Memory</strong> (Windows) can automatically detect memory leaks by monitoring your program’s allocation and deallocation.</p><p>Example Valgrind usage:</p><div class="code-block">
 <button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-bash">valgrind --leak-check=full ./your_program</code></pre>
</div><p>Valgrind will report memory still allocated at program exit, helping you identify where leaks occur.</p><h4 id="write-clear-maintainable-code">Write Clear, Maintainable Code</h4><p>Good code structure reduces errors:</p><ul>
 <li>Use <strong>functions</strong> to allocate and free memory, isolating responsibility.</li>
 <li>Document ownership rules: who allocates, who frees.</li>
 <li>Keep allocations and frees close in logic flow when possible.</li>
 <li>Comment your code to clarify memory management intent.</li>
</ul><h3 id="example-memory-leak-and-fix">Example: Memory Leak and Fix</h3><p><strong>Leaky Code:</strong></p><div class="code-block">
 <button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

void leaky_function() {
    int *arr = malloc(10 * sizeof(int));
    if (arr == NULL) return;
    // Use arr...
    // Missing free(arr);
}

int main() {
    for (int i = 0; i &lt; 1000; i++) {
        leaky_function();  // Each call leaks 10 ints
    }
    return 0;
}</code></pre>
</div><p><strong>Fixed Code:</strong></p><div class="code-block">
 <button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-c">void fixed_function() {
    int *arr = malloc(10 * sizeof(int));
    if (arr == NULL) return;
    // Use arr...
    free(arr);  // Properly freed
}</code></pre>
</div><h3 id="summary-table">Summary Table</h3><table>
 <thead>
  <tr>
   <th>Practice</th>
   <th>Description</th>
  </tr>
 </thead>
 <tbody>
  <tr>
   <td>Pair every allocation with free</td>
   <td>Always release allocated memory</td>
  </tr>
  <tr>
   <td>Initialize pointers to <code>NULL</code></td>
   <td>Prevent dangling pointers</td>
  </tr>
  <tr>
   <td>Avoid pointer overwrites</td>
   <td>Free old memory before pointer reassignment</td>
  </tr>
  <tr>
   <td>Use memory-checking tools</td>
   <td>Detect leaks with Valgrind, Dr. Memory, or similar</td>
  </tr>
  <tr>
   <td>Write maintainable code</td>
   <td>Clear ownership and structured memory management</td>
  </tr>
 </tbody>
</table><h3 id="conclusion">Conclusion</h3><p>Memory leaks are a common and dangerous problem in C programming. They occur when allocated memory is not freed properly, leading to wasted resources, degraded performance, and potential crashes. By adopting best practices—such as pairing every allocation with a corresponding free, carefully managing pointers, and utilizing memory debugging tools—you can write safer and more efficient C programs.</p><p>Consistent attention to memory management not only prevents leaks but also makes your code easier to maintain and debug. As you grow in your C programming journey, mastering these practices will become a key part of your skill set.</p><div class = "chapter-navi-section">
<a href="#top" class="nav-button prev">↑</a>
<a href='c-for-beginners.htm#dynamic-memory-management' class="nav-button toc-link">Index</a>
<a href="#bottom" class="nav-button next">↓</a>
</div>
<h2 id='building-dynamic-arrays'>8.3 Building Dynamic Arrays</h2><p>In C, dynamic arrays allow programs to handle datasets that grow or shrink during runtime—unlike static arrays, which require fixed sizes at compile-time. Building a dynamic array manually involves using <code>malloc()</code> and <code>realloc()</code> to allocate and resize memory as needed. This technique is foundational in implementing higher-level data structures like lists, stacks, and queues.</p><h3 id="key-concepts">Key Concepts</h3><p>When constructing a dynamic array, we must manage:</p><ul>
 <li><strong>Size</strong>: The current number of elements stored.</li>
 <li><strong>Capacity</strong>: The total number of elements the allocated memory can hold before resizing is needed.</li>
</ul><p>This pattern allows us to expand the array only when necessary, reducing the overhead of frequent memory operations.</p><h3 id="basic-strategy">Basic Strategy</h3><ol>
 <li>Start with a small allocated array using <code>malloc()</code>.</li>
 <li>As elements are added, check if the size has reached capacity.</li>
 <li>If full, use <code>realloc()</code> to allocate a larger block—usually doubling the capacity.</li>
 <li>Add the new element and update the size counter.</li>
 <li>At the end, <code>free()</code> the allocated memory.</li>
</ol><h3 id="example-storing-user-inputs">Example: Storing User Inputs</h3><p>Here’s a simple program that stores a list of integers entered by the user. The list grows as needed using <code>realloc()</code>.</p><div class="code-block">
 <button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main() {
    int *arr = NULL;
    int size = 0;
    int capacity = 2;
    int input;

    // Allocate initial memory
    arr = (int *)malloc(capacity * sizeof(int));
    if (arr == NULL) {
        printf("Memory allocation failed.\n");
        return 1;
    }

    printf("Enter integers (negative number to stop):\n");
    while (1) {
        scanf("%d", &amp;input);
        if (input &lt; 0) break;

        // Resize if needed
        if (size == capacity) {
            capacity *= 2;
            int *temp = realloc(arr, capacity * sizeof(int));
            if (temp == NULL) {
                printf("Reallocation failed.\n");
                free(arr);
                return 1;
            }
            arr = temp;
        }

        arr[size++] = input;
    }

    // Print stored numbers
    printf("You entered: ");
    for (int i = 0; i &lt; size; i++) {
        printf("%d ", arr[i]);
    }
    printf("\n");

    free(arr); // Clean up memory
    return 0;
}</code></pre>
</div><h3 id="explanation">Explanation</h3><ul>
 <li><strong>Initial Allocation</strong>: We start with space for 2 integers.</li>
 <li><strong>Size vs Capacity</strong>: <code>size</code> tracks how many elements have been added, and <code>capacity</code> tracks the current total capacity of the array.</li>
 <li><strong>Reallocation</strong>: When <code>size == capacity</code>, we double the capacity and use <code>realloc()</code> to extend the array.</li>
 <li><strong>Safety Checks</strong>: After <code>malloc()</code> and <code>realloc()</code>, we check if the pointer is <code>NULL</code> in case of failure.</li>
 <li><strong>Memory Cleanup</strong>: Before the program exits, we <code>free()</code> the allocated memory to avoid leaks.</li>
</ul><h3 id="resizing-strategy">Resizing Strategy</h3><p>A common approach for resizing is <strong>doubling the capacity</strong>. This provides <strong>amortized linear time</strong> for insertions: though some insertions are slow (requiring a reallocation and copy), most are fast.</p><p>Other strategies include:</p><ul>
 <li>Fixed-size increments (e.g., +10): simple but may result in frequent reallocations.</li>
 <li>Power-of-two growth (e.g., 1 → 2 → 4 → 8 → …): balances memory use and performance.</li>
 <li>Custom thresholds based on memory constraints.</li>
</ul><p>You should choose the strategy based on your application’s needs.</p><h3 id="preserving-data-with-realloc">Preserving Data with <code>realloc()</code></h3><p>One benefit of <code>realloc()</code> is that it copies existing data to the new block if the block is moved. If possible, the system may also expand the memory in place, avoiding a copy. Either way, it’s essential to store the return value in a <strong>temporary pointer</strong> and check for <code>NULL</code>:</p><div class="code-block">
 <button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-c">int *temp = realloc(arr, new_capacity * sizeof(int));
if (temp == NULL) {
    // Failed: original arr still valid
    free(arr); // Or handle error gracefully
    return 1;
}
arr = temp; // Use resized block</code></pre>
</div><p>This pattern prevents you from losing access to the original memory if the reallocation fails.</p><h3 id="dynamic-array-of-strings">Dynamic Array of Strings</h3><p>You can also build a dynamic array of <code>char*</code> (strings). Here’s a simplified version:</p><div class="code-block">
 <button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

int main() {
    char **words = NULL;
    int size = 0, capacity = 2;
    char buffer[100];

    words = malloc(capacity * sizeof(char *));
    if (words == NULL) return 1;

    printf("Enter words (type 'exit' to stop):\n");
    while (1) {
        scanf("%s", buffer);
        if (strcmp(buffer, "exit") == 0) break;

        if (size == capacity) {
            capacity *= 2;
            char **temp = realloc(words, capacity * sizeof(char *));
            if (temp == NULL) {
                printf("Realloc failed.\n");
                for (int i = 0; i &lt; size; i++) free(words[i]);
                free(words);
                return 1;
            }
            words = temp;
        }

        words[size] = malloc(strlen(buffer) + 1);
        if (words[size] == NULL) return 1;
        strcpy(words[size], buffer);
        size++;
    }

    printf("You entered:\n");
    for (int i = 0; i &lt; size; i++) {
        printf("%s\n", words[i]);
        free(words[i]);
    }
    free(words);

    return 0;
}</code></pre>
</div><p>This example demonstrates handling an array of dynamically allocated strings and carefully freeing all resources.</p><h3 id="tips-and-best-practices">Tips and Best Practices</h3><table>
 <thead>
  <tr>
   <th>Practice</th>
   <th>Description</th>
  </tr>
 </thead>
 <tbody>
  <tr>
   <td>Track size and capacity separately</td>
   <td>Avoids buffer overflows</td>
  </tr>
  <tr>
   <td>Always check for allocation failures</td>
   <td>Prevents crashes</td>
  </tr>
  <tr>
   <td>Use <code>realloc()</code> safely</td>
   <td>Assign result to a temp pointer</td>
  </tr>
  <tr>
   <td>Free all memory before exiting</td>
   <td>Prevents memory leaks</td>
  </tr>
  <tr>
   <td>Initialize unused pointers to <code>NULL</code></td>
   <td>Helps catch errors early</td>
  </tr>
 </tbody>
</table><h3 id="conclusion">Conclusion</h3><p>Building dynamic arrays in C gives your programs the flexibility to handle varying amounts of data efficiently. By combining <code>malloc()</code>, <code>realloc()</code>, and <code>free()</code>, along with good memory management practices, you can implement scalable and safe data structures tailored to your needs. As your programs grow in complexity, mastering these techniques will allow you to write more dynamic, responsive, and robust software.</p><div class = "chapter-navi-section">
<a href="c-for-beginners-pointers-and-memory-addressing.htm" class="nav-button prev">←</a>
<a href='c-for-beginners.htm#dynamic-memory-management' class="nav-button toc-link">Index</a>
<a href="c-for-beginners-structures-and-unions.htm" class="nav-button next">→</a>
</div>
<section class="download-section">
  <div class="book-cover" style="background-color: #f9f6f1;border: 1px solid #ccc;"> 
    <div class="book-cover-title" style="font-size: 18px;color: #333;top: 20px;">C for Beginners</div>
    <div class="book-cover-author">readbytes</div>
    <div class="book-cover-bottom-stripe" style="background-color: #333;"></div>
    <img class="book-cover-icon" style="width: 90px;height: 90px;top: 70px;" src="data:image/png;base64,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"/>
  </div>
  <div class="download-info">
    <h2 id='bottom'>Download This Ebook</h2>
    <p class="format-label">Available formats:</p>
    <div class="download-buttons">
      <a href="c-for-beginners.pdf" class="download-button">📄 PDF</a>
      <a href="c-for-beginners.epub" class="download-button">📘 EPUB</a>
    </div>
  </div>
</section><div class='related-books'>
<h2>C Introduction Books</h2>
<div class='related-book-list'>
<a href="c-for-beginners.htm">
<div class="book-cover" style="background-color: #f9f6f1;border: 1px solid #ccc;"> 
    <div class="book-cover-title" style="font-size: 18px;color: #333;top: 20px;">C for Beginners</div>
    <div class="book-cover-author">readbytes</div>
    <div class="book-cover-bottom-stripe" style="background-color: #333;"></div>
    <img class="book-cover-icon" style="width: 90px;height: 90px;top: 70px;" src="data:image/png;base64,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"/>
  </div>
</a>


<a href="c-pointers.htm">
<div class="book-cover" style="background-color: #f9f6f1;border: 1px solid #ccc;"> 
    <div class="book-cover-title" style="font-size: 22px;color: #333;top: 20px;">C Pointers</div>
    <div class="book-cover-author">readbytes</div>
    <div class="book-cover-bottom-stripe" style="background-color: #333;"></div>
    <img class="book-cover-icon" style="width: 90px;height: 90px;top: 70px;" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFoAAABaCAYAAAA4qEECAAAD5ElEQVR4Xu2dwYoUVxhGr7hQn0F8AyH4Cq5cCwFxk2cQ3GXR1TK+QN5AssnWrRsfwWR0LbhJxKXoIhBQK2Olb5/v1tdV0/fHOPwHDtj/PbdudYHOuKpSkiRJkovFUP744qevvuSyZSin1d5TLlvGs85/7re553OzO3DfJXDPRd97bobylxy49HC2tZvylvkem/Je9uz8wHyPTfmzsWeng23toXs+Ch5GHWypgy11sKUOtjQMHkQdbKmDLXWwpQ62NAweRB1sqYMtdbClDrY0DB5EHWypgy11sKUOtjQMHkQdbKmDLXWwpQ62NAweRB1sqYMtdbClDrY0DB5EHWypgy11sKUOtjQMHkQdbKmDLXWwpQ62NAweRB1sqYMtdbClDrY0SZIkSZI18CdpGqMM0hhlkMYogzRGGaQxyiCNUQZpjDJIY5RBGqMM0hhlkMYogzRGGaQxyiCNUQZpjDJIY5RBT5fAPfO+W7xvabe2PUYZ9HQpQ7kjeynh+lzLNbqmPUYZ9NR/iYcH1uevdagnXJ/8pVxZ1PVQBj1d8iUmfi7XZW3ns+pKO7TTc3t0PZRBT5d8ibVNDTvXsxnKr0waTT9l0NMlX2Ji/GvMNTZDeYrP/0hbr9ecp+mpDHp66EscWh/dlgfS1LCv14fypPrz3ar5u5rXvV6rlzLo6Rq4t3WNafZjuSyz1p6zB31J2pr9Xq/VSxn0dAlDuSr7WtfYltfN+fj79dye8UHvf/4dn9nr+b2UQU9rlszpo/LDbFczt8YHTbTXe+ilDHpaU8+35adq/lj2tfY75vZND7p1raF8lDVep6cy6GnNmrVW4xjK8+Y+/6Bbvd5DL2XQ0xqujb8FTGzKfVl/UK5Ve180rWmdWz/oobz5b74p92Z63mM/ZdDTGq4dWndrkyflRrPZzeoHPf6bf+tfeZ3WNXorg57WcO3M29X6zebeuf+UaHfSmO0/6Dl3va71UgY9reGaa1qzOVvtxKb8Jn1L7o9QBmmMMkhjlEEaowzSGGWQxiiDNEYZpDHKII1RBmmMMkhjlEEaowzSGGWQxiiDNEYZpDHKII0xSZIkSZI18CcpdbClDrbUwZY62NIweBB1sKUOttTBljrY0jB4EHWwpQ621MGWOtjSMHgQdbClDrbUwZY62NIweBB1sKUOttTBljrY0jB4EHWwpQ621MGWOtjSMHgQdbClDrbUwZY62NIweBB1sKUOttTBljrY0jB4EHWwpQ621MGWOtjSMKJeSjZe13HMS8m23+NLyUZ44JIbnuCei773aPZfpLjuJYzbI17CeNyLI+tzX3HZsn/uuntOkiRJ/vd8BnnbnC2TD9qmAAAAAElFTkSuQmCC"/>
  </div>
</a>



<a href='c.htm'><div class='book-cover' style='background-color: #f9f6f1;color: #111111;border: 1px solid #ccc;display: flex;justify-content: center;align-items: center;text-align: center;'>More C Books</div></a>
</div>
</div><script>
function copyCode(button) {const code = button.nextElementSibling.innerText;navigator.clipboard.writeText(code).then(() => {button.textContent = 'Copied!';setTimeout(() => { button.textContent = 'Copy'; }, 1500);});}
</script></div>
<style>
.site-footer {margin-top: 60px;padding: 20px 0;border-top: 1px solid #eee;text-align: center;font-size: 14px;}
.site-footer a {text-decoration: none;}
.light-mode .site-footer {color: #777;border-color: #eee;}
.dark-mode .site-footer {color: #888;border-color: #333;}
.light-mode .site-footer a {color: #555;}
.dark-mode .site-footer a {color: #aaa;}
.site-footer a:hover {text-decoration: underline;}    
</style>
<footer class="site-footer">
<nav><a href="https://readbytes.github.io">Home</a> |Email:<script type="text/javascript">
var part1 = 'yinpeng';var part6 = '263';var part2 = Math.pow(2,6);var part3 = String.fromCharCode(part2);var part4 = 'hotmail dot com';var part5 = part1 + String.fromCharCode(part2) + part4;document.write(part1 + part6 + part3 + part4);
</script>
| <a id="mode-toggle" href="#">Toggle Dark Mode</a>
</nav><p>© 2025 — All rights reserved.</p></footer>
<script>
const toggleButton = document.getElementById('mode-toggle');
const body = document.body;
const savedMode = localStorage.getItem('mode') || 'light';
body.classList.add(savedMode + '-mode');
toggleButton.addEventListener('click', () => {
      const isDark = body.classList.contains('dark-mode');
      body.classList.toggle('dark-mode', !isDark);
      body.classList.toggle('light-mode', isDark);
      localStorage.setItem('mode', isDark ? 'light' : 'dark');
});
function copyCode(button) {const code = button.nextElementSibling.innerText;navigator.clipboard.writeText(code).then(() => {button.textContent = 'Copied!';setTimeout(() => { button.textContent = 'Copy'; }, 1500);});}
</script>
</body>
</html>