<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Java IO and NIO Security and IO</title>
<link rel='shortcut icon' href='https://readbytes.github.io/images/favicon.ico'>
<link href="https://fonts.googleapis.com/css2?family=Merriweather&display=swap" rel="stylesheet" />
<link href="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet" />
<script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/prism.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/codemirror.min.css" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/codemirror.min.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/theme/dracula.min.css"><style>
html {scroll-behavior: smooth;}  
body {font-family: 'Merriweather', serif;;margin: 0;padding: 2rem 1rem;font-size: 15px;line-height: 1.5;transition: background-color 0.3s, color 0.3s;}
.container {max-width: 750px;margin: 0 auto;padding: 1rem 2rem;}
.light-mode {background-color: #f8f7f5;color: #333;} 
.dark-mode {background-color: #121212;color: #e0e0e0;}
a { text-decoration: none;transition: color 0.2s;}
a:hover {text-decoration: underline;}
.light-mode a {color: #555;}
.dark-mode a {color: #aaa;}
</style><style>
.related-book-list {display: flex;flex-wrap: wrap;gap: 20px;}
.related-books {margin-top: 40px;}
.related-books h2 {font-size: 22px;margin-bottom: 20px;border-bottom: 2px solid #eee;padding-bottom: 8px;}
.light-mode .related-books h2 {color: #333;border-color: #eee;}
.dark-mode .related-books h2 {color: #ddd;border-color: #333;}
</style><style>
.book-cover {width: 130px;height: 180px;font-family: Arial, sans-serif;position: relative;overflow: hidden;box-shadow: 2px 2px 4px rgba(0,0,0,0.1);}
.book-cover-bottom-stripe {position: absolute;bottom: 0;left: 0;height: 5px;width: 100%;}
.book-cover-title {position: absolute;width: 100%;text-align: center;font-weight: bold;}
.book-cover-icon {position: absolute;left: 50%;transform: translateX(-50%);display: flex;align-items: center;justify-content: center;}
.book-cover-author {position: absolute;bottom: 10px;width: 100%;text-align: center;font-size: 8px;color: #333;}
</style><style>
.book-title-toc {font-size: 32px;font-weight: bold; }
.book-subtitle-toc {font-size: 18px;margin-top: 8px;font-style: italic;}
.book-header {text-align: center;margin-bottom: 40px;}

.toc-container {border-radius: 10px;padding: 30px;margin-bottom: 40px;box-shadow: 0 8px 20px rgba(0,0,0,0.05);}
h1 {font-size: 24px;text-align: center;margin-bottom: 30px;letter-spacing: 1px;padding-bottom: 10px;}
.toc-list,.toc-section-list {list-style: none;padding: 0;margin: 0;}
.toc-section-list {padding-left: 18px;margin-top: 6px;margin-bottom: 20px; }
.toc-chapter {padding: 20px 0;}
.chapter-title,.toc-section {display: flex;justify-content: space-between;padding-top: 4px;}
.chapter-title {font-size: 17px;font-weight: bold;}
.chapter-page,.section-page {font-style: italic;}
 
 
.light-mode .book-title-toc,.light-mode .chapter-title,.light-mode .book-name {color: #222;}
.light-mode .book-subtitle-toc,.light-mode .book-sub,.light-mode .chapter-page,.light-mode .section-page {color: #666;}
.light-mode .toc-container { background: #fff;border: 1px solid #ddd;}
.light-mode h1 {border-bottom: 2px solid #eee;color: #222;}
.light-mode .toc-section {  color: #444;}

.light-mode .book-cover { border: 1px solid #ccc;box-shadow: 0 6px 12px rgba(0, 0, 0, 0.15);}
.light-mode .book-title,.light-mode .series-name {color: #fff;}
.light-mode .book-subtitle,.light-mode .book-footer {color: #aaa;}

.dark-mode .book-title-toc,.dark-mode .chapter-title,.dark-mode .book-name {color: #f5f5f5;}
.dark-mode .book-subtitle-toc,.dark-mode .book-sub,.dark-mode .chapter-page,.dark-mode .section-page {color: #aaa;}
.dark-mode .toc-container {background: #1e1e1e;border: 1px solid #444;}

.dark-mode h1 {border-bottom: 2px solid #333;color: #eee;}
.dark-mode .toc-section {color: #bbb;}

.dark-mode .related-books h2 {color: #ddd;border-bottom: 2px solid #333;}
.dark-mode .book-title,.dark-mode .series-name {color: #fff;}
.dark-mode .book-subtitle,.dark-mode .book-footer {color: #bbb;}
.dark-mode .toc-section {color: #ddd;}

@media (max-width: 600px) {
  .chapter-title,
  .toc-section {
    flex-direction: column;
    align-items: flex-start;
  }

  .chapter-page,
  .section-page {
    margin-top: 4px;
  }
}

</style><style>
.light-mode .container {box-shadow: 0 0 15px rgba(0,0,0,0.1);}
.dark-mode .container {box-shadow: 0 0 15px rgba(255, 255, 255, 0.05);}

h1, h2, h3 {font-weight: 600;margin-top: 2.5rem;margin-bottom: 1rem;line-height: 1.2;}
h1 { font-size: 1.8rem; }
h2 { font-size: 1.4rem; }
h3 { font-size: 1.2rem; }

table {width: 100%;border-collapse: collapse;font-family: sans-serif;font-size: 1em;margin: 1em 0;}
th, td {padding: 0.6em 1em;text-align: left;border: 1px solid;}
tr:nth-child(even) {  background-color: inherit;}
tr:hover { background-color: inherit;}

code {color: #d35400;}

.chapter-navi-section {display: flex;justify-content: space-between;align-items: center;padding-bottom: 10px;padding-top: 10px;}
.nav-link {color: inherit;text-decoration: none;opacity: 0.5;transition: opacity 0.3s ease, text-decoration 0.3s ease;}
.nav-link:hover {opacity: 0.9;text-decoration: underline;}
.prev { text-align: left; }
.toc-link { text-align: center; }
.next { text-align: right; }

.download-section {display: flex;align-items: center;justify-content: center;gap: 2rem;padding: 2rem 1rem;max-width: 600px;margin: 3rem auto;border-radius: 12px;box-shadow: 0 4px 10px rgba(0,0,0,0.05);}
.download-info h2 {margin: 0 0 0.5rem;font-size: 1.2rem;}
.format-label {margin: 0 0 0.5rem;font-size: 0.95rem;}
.download-buttons {display: flex;gap: 1rem;}
.download-button {background-color: #4A90E2;color: white;padding: 0.5em 1.2em;border-radius: 25px;font-size: 0.95rem;text-decoration: none;transition: background-color 0.3s ease;}
.download-button:hover {background-color: #357ABD;}

.code-block {position: relative;margin-bottom: 1em;}
.copy-button {background: transparent;color: white;position: absolute;top: 8px;right: 8px;border: none;padding: 4px 8px;font-size: 12px;border-radius: 4px;cursor: pointer;z-index: 1;}
.copy-button:hover {background-color: #0056b3;}

.snippet-container {overflow: hidden;}
.snippet-header {padding: 0.75rem 1rem;cursor: pointer;font-size: 1rem;background-color: #eeeeee;color:  #111111; border-radius: 8px;cursor: pointer;box-shadow: 0 4px 6px rgba(0,0,0,0.1); }
.snippet-body {display: none;font-family: monospace;}
.snippet-container.open .snippet-body {display: block;}

.CodeMirror {border: 2px solid #ccc;border-radius: 4px;resize: vertical;}

.light-mode .format-label {color: #888;}
.light-mode th {background-color: #f2f2f2;}
.light-mode tr:nth-child(even) {background-color: #fafafa;}
.light-mode tr:hover {background-color: #e6f7ff;}

.dark-mode .snippet-header {background-color: #333;color:  #ddd; }
.dark-mode .format-label {color: #aaa;}
.dark-mode th {background-color: #333;color: #fff;}
.dark-mode td {border-color: #444;}
.dark-mode tr:nth-child(even) {background-color: #2a2a2a;}
.dark-mode tr:hover {background-color: #2c3e50;}


.button-group-run-edit {display: flex;width: 100%;gap: 1rem;}
.button-run-edit {flex: 1;padding: 1rem;font-size: 1rem;font-weight: 600;border: none;border-radius: 8px;cursor: pointer;transition: background 0.3s, color 0.3s;}

.light-mode .button-run-edit {background-color: #f0f0f0;color: #222;box-shadow: 0 0 10px rgba(0, 0, 0, 0.05);}
.light-mode .button-run-edit:hover {background-color: #e0e0e0;}

.dark-mode .button-run-edit {background-color: #2a2a2a;color: #f5f5f5;box-shadow: 0 0 10px rgba(255, 255, 255, 0.05);}
.dark-mode .button-run-edit:hover {background-color: #3a3a3a;}

button { padding: 0.5em 1em; background: green; color: white; border: none; cursor: pointer; }
button:hover { background: #1e7e34; }
.result_iframe { width:99%; margin-top: 1em;  resize: both;background-color: #515b63;border:1px solid #ccc;}   

.dialog-backdrop {position: fixed;top: 0;left: 0;width: 100vw;height: 100vh;background: rgba(0,0,0,0.5);display: none;justify-content: center;align-items: center;z-index: 10;}
.dialog {background: #90979e;padding: 20px;width: 90vw;height: 80vh;border-radius: 8px;box-shadow: 0 0 20px rgba(0,0,0,0.3);display: flex;flex-direction: column;}
.dialog-content {display: flex;gap: 20px;margin-top: 10px;height: calc(100% - 40px);}
.editor-container, .preview-container {flex: 1;height: 100%;max-height: 100%;overflow: hidden; }
.result_iframe_dialog {width: 100%;height: 100%;resize: both;border:1px solid #ccc;overflow: auto; }   
.CodeMirror {width: 100% !important;height: 100% !important;}
</style>
</head>
<body>
<script>const mode = localStorage.getItem('mode') || 'light';document.documentElement.classList.add(`${mode}-mode`);</script>  
<div class="container"><div class = "chapter-navi-section">
<a href="java-io-and-nio-performance-and-tuning.htm" class="nav-button prev">←</a>
<a href='java-io-and-nio.htm#security-and-io' class="nav-button toc-link">Index</a>
<a href="java-io-and-nio-new-features-and-future-of-java-io-nio.htm" class="nav-button next">→</a>
</div>
<div class='book-header'><h1 class='book-title-toc' id = 'top'>Security and IO</h1><h3 class='book-subtitle-toc'>Java IO and NIO</h3></div><h2 id='io-security-basics'>12.1 IO Security Basics</h2><p>Input/output (IO) operations are foundational to nearly every Java application, enabling programs to read and write files, communicate over networks, and serialize data for storage or transmission. However, IO operations also introduce significant security risks if not handled carefully. Attackers often exploit insecure IO practices to gain unauthorized access, execute malicious code, or compromise data integrity and confidentiality.</p><p>This introduction explores why IO is a common source of security vulnerabilities in Java applications, highlights fundamental security principles like least privilege and input validation, and provides examples of common IO vulnerabilities alongside mitigation techniques.</p><h3 id="why-io-operations-present-security-risks">Why IO Operations Present Security Risks</h3><p>IO operations in Java interact with external resources outside the JVM’s internal control—such as the filesystem, network sockets, and external data streams. These interactions inherently increase the attack surface:</p><ul>
 <li><strong>File system access</strong> can expose sensitive files or allow unauthorized file modification.</li>
 <li><strong>Network communication</strong> can be intercepted, manipulated, or spoofed.</li>
 <li><strong>Serialization and deserialization</strong> of objects can be exploited to inject malicious data or execute arbitrary code.</li>
</ul><p>Since IO often deals with untrusted data—files uploaded by users, network input, or serialized objects—any lapse in validating or securing these operations can lead to serious security breaches.</p><h3 id="core-principles-for-securing-io-in-java">Core Principles for Securing IO in Java</h3><h4 id="least-privilege">Least Privilege</h4><p>Limit the permissions of your Java application and its components to the minimum necessary for their IO tasks. For example:</p><ul>
 <li>Use Java Security Manager policies (where applicable) to restrict file or network access.</li>
 <li>Run your application under an OS user account with limited file system privileges.</li>
 <li>Avoid granting write access to directories unless absolutely required.</li>
</ul><p>Least privilege reduces the potential impact if an attacker exploits an IO vulnerability.</p><h4 id="input-validation-and-sanitization">Input Validation and Sanitization</h4><p>All data read through IO channels must be treated as untrusted. Rigorously validate and sanitize input before processing:</p><ul>
 <li>For <strong>file paths</strong>, prevent directory traversal attacks by canonicalizing paths and restricting access to safe directories.</li>
 <li>For <strong>network data</strong>, check message formats, lengths, and character sets.</li>
 <li>For <strong>serialized objects</strong>, use safe deserialization techniques (see below).</li>
</ul><p>Reject or sanitize malformed or unexpected data to prevent injection attacks, buffer overflows, or crashes.</p><h4 id="secure-defaults-and-explicit-configuration">Secure Defaults and Explicit Configuration</h4><p>Java IO APIs often have default behaviors that may not be secure in all contexts. Adopt secure defaults such as:</p><ul>
 <li>Using <strong>secure protocols</strong> (e.g., TLS) for network communication.</li>
 <li>Setting file permissions explicitly after creating files or directories.</li>
 <li>Avoiding deserialization of untrusted data or using validation hooks.</li>
 <li>Closing IO resources promptly to avoid resource leaks that attackers can exploit.</li>
</ul><h3 id="common-io-related-vulnerabilities-and-mitigation-strategies">Common IO-Related Vulnerabilities and Mitigation Strategies</h3><h4 id="vulnerability-1-directory-traversal">Vulnerability 1: Directory Traversal</h4><p><strong>Description:</strong> An attacker crafts a filename containing sequences like <code>../</code> to access files outside the intended directory.</p><p><strong>Example:</strong></p><div class="code-block">
 <button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-java">String baseDir = "/app/data/";
String requestedFile = "../../etc/passwd";
File file = new File(baseDir, requestedFile);</code></pre>
</div><p>If unchecked, this may read the system’s password file.</p><p><strong>Mitigation:</strong></p><ul>
 <li>Use <code>File#getCanonicalPath()</code> to resolve the absolute path.</li>
 <li>Verify that the resolved path starts with the intended base directory.</li>
</ul><div class="code-block">
 <button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-java">File requested = new File(baseDir, requestedFile);
String canonicalBase = new File(baseDir).getCanonicalPath();
String canonicalRequested = requested.getCanonicalPath();

if (!canonicalRequested.startsWith(canonicalBase)) {
    throw new SecurityException("Invalid file path");
}</code></pre>
</div><h3 id="vulnerability-2-insecure-network-communication">Vulnerability 2: Insecure Network Communication</h3><p><strong>Description:</strong> Data sent over plaintext sockets can be intercepted or altered by attackers.</p><p><strong>Mitigation:</strong></p><ul>
 <li>Use secure channels like <strong>TLS/SSL</strong> via <code>SSLSocket</code> or <code>HttpsURLConnection</code>.</li>
 <li>Validate server certificates to prevent man-in-the-middle attacks.</li>
 <li>Authenticate and authorize clients as needed.</li>
</ul><div class="code-block">
 <button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-java">SSLSocketFactory factory = (SSLSocketFactory) SSLSocketFactory.getDefault();
try (SSLSocket socket = (SSLSocket) factory.createSocket(host, port)) {
    // Secure communication
}</code></pre>
</div><h3 id="vulnerability-3-unsafe-deserialization">Vulnerability 3: Unsafe Deserialization</h3><p><strong>Description:</strong> Java deserialization allows reconstruction of objects from byte streams. Attackers can craft malicious byte streams to execute arbitrary code during deserialization.</p><p><strong>Mitigation:</strong></p><ul>
 <li>Avoid deserializing untrusted data.</li>
 <li>Use a whitelist of allowed classes with <code>ObjectInputFilter</code> (Java 9+).</li>
 <li>Consider safer alternatives like JSON or XML parsing with strict schemas.</li>
</ul><div class="code-block">
 <button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-java">ObjectInputStream ois = new ObjectInputStream(inputStream);
ObjectInputFilter filter = ObjectInputFilter.Config.createFilter("com.example.MySafeClass;!*");
ois.setObjectInputFilter(filter);
Object obj = ois.readObject();</code></pre>
</div><h3 id="vulnerability-4-resource-exhaustion">Vulnerability 4: Resource Exhaustion</h3><p><strong>Description:</strong> Poor IO handling can cause resource leaks, such as open file descriptors or sockets, leading to denial of service.</p><p><strong>Mitigation:</strong></p><ul>
 <li>Use <strong>try-with-resources</strong> to ensure streams and channels close properly.</li>
 <li>Limit buffer sizes and validate data lengths to avoid memory exhaustion.</li>
 <li>Monitor and log resource usage.</li>
</ul><div class="code-block">
 <button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-java">try (BufferedReader reader = new BufferedReader(new FileReader(file))) {
    // Read file safely
}</code></pre>
</div><h3 id="summary-best-practices-for-secure-io-in-java">Summary: Best Practices for Secure IO in Java</h3><table>
 <thead>
  <tr>
   <th>Principle</th>
   <th>Best Practice</th>
  </tr>
 </thead>
 <tbody>
  <tr>
   <td><strong>Least Privilege</strong></td>
   <td>Limit filesystem and network permissions</td>
  </tr>
  <tr>
   <td><strong>Input Validation</strong></td>
   <td>Sanitize paths, verify data formats</td>
  </tr>
  <tr>
   <td><strong>Secure Defaults</strong></td>
   <td>Use encrypted communication and safe deserialization</td>
  </tr>
  <tr>
   <td><strong>Resource Management</strong></td>
   <td>Close IO resources promptly with try-with-resources</td>
  </tr>
 </tbody>
</table><h3 id="conclusion">Conclusion</h3><p>IO operations in Java are inherently risky due to their interaction with external resources and untrusted data. Following security principles—least privilege, rigorous input validation, secure defaults, and proper resource management—greatly reduces the attack surface.</p><p>Common vulnerabilities like directory traversal, insecure network communication, unsafe deserialization, and resource exhaustion can be mitigated through careful coding and the use of modern Java security features.</p><p>By adopting these security-conscious IO practices, Java developers can build applications that are robust, reliable, and resistant to common IO-related attacks.</p><div class = "chapter-navi-section">
<a href="#top" class="nav-button prev">↑</a>
<a href='java-io-and-nio.htm#security-and-io' class="nav-button toc-link">Index</a>
<a href="#bottom" class="nav-button next">↓</a>
</div>
<h2 id='secure-file-access-and-permissions'>12.2 Secure File Access and Permissions</h2><p>File access is a common yet sensitive operation in Java applications. Improper handling of file permissions can lead to unauthorized reading, modification, or deletion of critical data, exposing the application and its environment to security risks. Securing file access means ensuring that your Java program only accesses files it is authorized to, and that files are protected against unintended or malicious changes.</p><p>This section covers how to check and enforce file permissions using Java’s <code>File</code> class and the more advanced <code>java.nio.file.attribute</code> package, the role of security managers in access control, and practical coding techniques to prevent unauthorized file operations.</p><h3 id="understanding-file-permissions-in-java">Understanding File Permissions in Java</h3><p>Java provides multiple layers for managing file access:</p><ul>
 <li><strong>File system permissions:</strong> These are OS-level permissions that restrict who can read, write, or execute files.</li>
 <li><strong>Java API-level checks:</strong> Methods that check the accessibility of files before attempting operations.</li>
 <li><strong>Security Manager (deprecated in newer Java versions):</strong> A Java-level policy mechanism to restrict file access within the JVM.</li>
</ul><h3 id="checking-file-permissions-with-the-file-class">Checking File Permissions with the <code>File</code> Class</h3><p>The <code>java.io.File</code> class offers simple methods to check file permissions:</p><ul>
 <li><code>canRead()</code> — Returns <code>true</code> if the file is readable.</li>
 <li><code>canWrite()</code> — Returns <code>true</code> if the file is writable.</li>
 <li><code>canExecute()</code> — Returns <code>true</code> if the file is executable.</li>
</ul><h3 id="example-checking-permissions">Example: Checking Permissions</h3><div class="code-block">
 <button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-java">File file = new File("/path/to/file.txt");

if (file.exists()) {
    System.out.println("File exists");
    System.out.println("Readable: " + file.canRead());
    System.out.println("Writable: " + file.canWrite());
    System.out.println("Executable: " + file.canExecute());
} else {
    System.out.println("File does not exist.");
}</code></pre>
</div><p>While these methods help to inspect permissions, they are often insufficient for enforcing strict security policies because they reflect the current OS permissions, and you may want more fine-grained control or to modify permissions programmatically.</p><h3 id="managing-file-permissions-with-java-nio-file-attribute">Managing File Permissions with <code>java.nio.file.attribute</code></h3><p>Java 7 introduced the <code>java.nio.file</code> package, including the <code>attribute</code> subpackage, which provides a more flexible and powerful way to inspect and modify file attributes and permissions.</p><h3 id="using-posixfilepermission">Using <code>PosixFilePermission</code></h3><p>On POSIX-compliant systems (Linux, Unix, macOS), you can read and change file permissions using <code>PosixFilePermission</code>:</p><div class="code-block">
 <button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-Java">import java.nio.file.*;
import java.nio.file.attribute.*;
import java.util.Set;

Path path = Paths.get("/path/to/file.txt");

// Read permissions
Set&lt;PosixFilePermission&gt; perms = Files.getPosixFilePermissions(path);
System.out.println("Current permissions: " + PosixFilePermissions.toString(perms));

// Add owner write permission
perms.add(PosixFilePermission.OWNER_WRITE);

// Remove group write permission
perms.remove(PosixFilePermission.GROUP_WRITE);

// Set the new permissions
Files.setPosixFilePermissions(path, perms);
System.out.println("Permissions updated.");</code></pre>
</div><p>This approach allows you to enforce minimum necessary permissions explicitly and prevent unwanted access.</p><h3 id="using-acls-on-windows">Using ACLs on Windows</h3><p>On Windows, the <code>AclFileAttributeView</code> can be used to manipulate Access Control Lists (ACLs):</p><div class="code-block">
 <button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-Java">import java.nio.file.*;
import java.nio.file.attribute.*;
import java.util.List;

Path path = Paths.get("C:\\path\\to\\file.txt");

AclFileAttributeView aclView = Files.getFileAttributeView(path, AclFileAttributeView.class);
List&lt;AclEntry&gt; aclEntries = aclView.getAcl();

for (AclEntry entry : aclEntries) {
    System.out.println(entry.principal() + ": " + entry.permissions());
}

// Modify ACLs as needed (requires detailed knowledge of Windows ACL)</code></pre>
</div><p>This allows precise control over which users or groups can access or modify the file.</p><h3 id="enforcing-file-access-using-the-security-manager-legacy">Enforcing File Access Using the Security Manager (Legacy)</h3><p><strong>Note:</strong> The <code>SecurityManager</code> and its associated file permission checks are deprecated and slated for removal in future Java versions, but understanding them is helpful in legacy contexts.</p><p>The <code>SecurityManager</code> can restrict file operations by enforcing policies based on <code>java.io.FilePermission</code>. For example, you can configure a security policy file to grant or deny read/write access to specific files or directories.</p><p>Example security policy entry:</p><div class="code-block">
 <button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-bash">grant codeBase "file:/myapp/-" {
    permission java.io.FilePermission "/myapp/data/-", "read,write";
    permission java.io.FilePermission "/myapp/config/config.xml", "read";
};</code></pre>
</div><p>With the Security Manager enabled, Java checks these permissions before allowing file operations, throwing <code>SecurityException</code> if denied.</p><h3 id="preventing-unauthorized-file-access-best-practices">Preventing Unauthorized File Access: Best Practices</h3><ol>
 <li><p><strong>Validate and sanitize file paths:</strong> Prevent directory traversal by canonicalizing paths and restricting access to allowed directories.</p>
  <div class="code-block">
   <button class="copy-button" onclick="copyCode(this)">▯</button>
   <pre><code class="language-Java">File baseDir = new File("/app/data/");
File requested = new File(baseDir, userInputPath);

String canonicalBase = baseDir.getCanonicalPath();
String canonicalRequested = requested.getCanonicalPath();

if (!canonicalRequested.startsWith(canonicalBase)) {
    throw new SecurityException("Access denied: invalid file path");
}</code></pre>
  </div></li>
 <li><p><strong>Check permissions before operations:</strong> Use <code>File.canRead()</code> and <code>File.canWrite()</code> to verify access, but don’t rely solely on these—handle exceptions robustly.</p></li>
 <li><p><strong>Set secure file permissions after creating files:</strong> For example, create a file and then restrict access to owner only.</p>
  <div class="code-block">
   <button class="copy-button" onclick="copyCode(this)">▯</button>
   <pre><code class="language-Java">Path newFile = Files.createFile(Paths.get("/app/data/newfile.txt"));
Set&lt;PosixFilePermission&gt; perms = PosixFilePermissions.fromString("rw-------");
Files.setPosixFilePermissions(newFile, perms);</code></pre>
  </div></li>
 <li><p><strong>Use try-with-resources and handle exceptions:</strong> Ensure streams and channels close properly to avoid resource leaks that might cause file locks.</p></li>
 <li><p><strong>Avoid running as an administrator or root:</strong> Run your Java process under a least-privilege OS user to limit potential damage.</p></li>
</ol><h3 id="secure-file-handling-code-example">Secure File Handling Code Example</h3><p>Here is an example demonstrating secure reading of a user-requested file, with path validation and permission checking:</p><div class="code-block">
 <button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-java">import java.io.*;
import java.nio.file.*;

public class SecureFileReader {

    private final Path baseDirectory;

    public SecureFileReader(String baseDir) {
        this.baseDirectory = Paths.get(baseDir).toAbsolutePath().normalize();
    }

    public String readFile(String userProvidedPath) throws IOException {
        Path requestedFile = baseDirectory.resolve(userProvidedPath).normalize();

        if (!requestedFile.startsWith(baseDirectory)) {
            throw new SecurityException("Unauthorized file access attempt");
        }

        if (!Files.exists(requestedFile) || !Files.isReadable(requestedFile)) {
            throw new FileNotFoundException("File not found or not readable");
        }

        try (BufferedReader reader = Files.newBufferedReader(requestedFile)) {
            StringBuilder content = new StringBuilder();
            String line;
            while ((line = reader.readLine()) != null) {
                content.append(line).append("\n");
            }
            return content.toString();
        }
    }

    public static void main(String[] args) {
        try {
            SecureFileReader sfr = new SecureFileReader("/app/data");
            String content = sfr.readFile("example.txt");
            System.out.println("File content:\n" + content);
        } catch (Exception e) {
            System.err.println("Error: " + e.getMessage());
        }
    }
}</code></pre>
</div><p>This code ensures the requested file resides under a base directory, checks read permissions, and safely reads the file.</p><h3 id="conclusion">Conclusion</h3><p>Securing file access in Java requires a combination of OS-level permissions and application-level checks. The <code>File</code> class provides simple permission inspection, while the <code>java.nio.file.attribute</code> package offers advanced control over file attributes and access rights. Although the Security Manager can enforce security policies, modern applications rely more on OS user permissions and explicit permission handling.</p><p>By validating file paths, verifying permissions before access, setting restrictive file attributes, and carefully managing file IO operations, you can greatly reduce the risk of unauthorized file access and modification in your Java applications.</p><div class = "chapter-navi-section">
<a href="#top" class="nav-button prev">↑</a>
<a href='java-io-and-nio.htm#security-and-io' class="nav-button toc-link">Index</a>
<a href="#bottom" class="nav-button next">↓</a>
</div>
<h2 id='secure-network-communication-with-nio'>12.3 Secure Network Communication with NIO</h2><p>Network communication in Java NIO offers scalable, non-blocking IO operations, which are ideal for high-performance servers and clients. However, by default, NIO channels transmit data in plaintext, exposing them to eavesdropping, tampering, and man-in-the-middle attacks. To secure NIO-based networking, Java provides the <code>SSLEngine</code> API, which allows integrating SSL/TLS encryption and authentication while preserving the non-blocking nature of NIO.</p><p>This section explains how to implement secure network communication using Java NIO and <code>SSLEngine</code>. We cover:</p><ul>
 <li>The role of <code>SSLEngine</code> in TLS integration.</li>
 <li>Setting up a secure <code>SocketChannel</code> with <code>SSLEngine</code>.</li>
 <li>Performing the SSL/TLS handshake in a non-blocking context.</li>
 <li>Encrypting and decrypting application data.</li>
 <li>Key Java code examples for each step.</li>
</ul><h3 id="why-use-sslengine-for-tls-in-java-nio">Why Use <code>SSLEngine</code> for TLS in Java NIO?</h3><p>Traditional SSL/TLS support in Java (e.g., <code>SSLSocket</code>) is blocking and tightly coupled to socket IO. <code>SSLEngine</code> separates TLS protocol handling from actual IO and is designed for integration with non-blocking transport layers like <code>SocketChannel</code>. It allows developers to:</p><ul>
 <li>Perform TLS handshake and data encryption/decryption manually.</li>
 <li>Manage encrypted and decrypted buffers explicitly.</li>
 <li>Integrate with selectors and non-blocking IO workflows.</li>
 <li>Support scalable secure servers or clients.</li>
</ul><h3 id="overview-how-sslengine-works-with-nio">Overview: How <code>SSLEngine</code> Works with NIO</h3><p>The key concept is that <code>SSLEngine</code> handles TLS protocol logic on byte buffers:</p><ul>
 <li><strong>Application data</strong> buffers contain plaintext data to send or receive.</li>
 <li><strong>Network data</strong> buffers contain encrypted TLS packets to be sent or received on the network.</li>
</ul><p>The developer drives the handshake and data processing by repeatedly calling <code>wrap()</code> and <code>unwrap()</code> methods on <code>SSLEngine</code>, moving data between these buffers and the underlying <code>SocketChannel</code>.</p><h3 id="setting-up-a-secure-nio-channel-using-socketchannel-and-sslengine">Setting Up a Secure NIO Channel Using <code>SocketChannel</code> and <code>SSLEngine</code></h3><h4 id="step-1-initialize-ssl-context-and-create-sslengine">Step 1: Initialize SSL Context and Create SSLEngine</h4><p>First, create an <code>SSLContext</code> initialized with key and trust managers, then create an <code>SSLEngine</code> configured as client or server.</p><div class="code-block">
 <button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-Java">import javax.net.ssl.*;

SSLContext sslContext = SSLContext.getInstance("TLS");
sslContext.init(keyManagers, trustManagers, null);

SSLEngine sslEngine = sslContext.createSSLEngine(host, port);
sslEngine.setUseClientMode(true); // or false if server</code></pre>
</div><p>Here, <code>keyManagers</code> and <code>trustManagers</code> manage certificates and trust chains.</p><h4 id="step-2-create-bytebuffers-for-encrypted-and-plain-data">Step 2: Create ByteBuffers for Encrypted and Plain Data</h4><p>You must allocate buffers for outgoing (encrypted) and incoming (encrypted) network data, and for outgoing and incoming application (plaintext) data.</p><div class="code-block">
 <button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-Java">SSLSession session = sslEngine.getSession();

ByteBuffer appData = ByteBuffer.allocate(session.getApplicationBufferSize());
ByteBuffer netData = ByteBuffer.allocate(session.getPacketBufferSize());
ByteBuffer peerAppData = ByteBuffer.allocate(session.getApplicationBufferSize());
ByteBuffer peerNetData = ByteBuffer.allocate(session.getPacketBufferSize());</code></pre>
</div><ul>
 <li><code>appData</code>: plaintext data to send.</li>
 <li><code>netData</code>: encrypted data to send.</li>
 <li><code>peerNetData</code>: encrypted data received from network.</li>
 <li><code>peerAppData</code>: decrypted data received from peer.</li>
</ul><h3 id="step-3-establish-non-blocking-socketchannel">Step 3: Establish Non-Blocking SocketChannel</h3><p>Create and configure the <code>SocketChannel</code> for non-blocking mode and connect it.</p><div class="code-block">
 <button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-Java">SocketChannel socketChannel = SocketChannel.open();
socketChannel.configureBlocking(false);
socketChannel.connect(new InetSocketAddress(host, port));

// Use Selector to wait for connect completion and subsequent read/write readiness.</code></pre>
</div><h3 id="step-4-perform-the-tls-handshake">Step 4: Perform the TLS Handshake</h3><p>The handshake involves several <code>SSLEngineResult.HandshakeStatus</code> states and requires driving <code>wrap()</code> and <code>unwrap()</code> calls:</p><div class="code-block">
 <button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-Java">sslEngine.beginHandshake();
SSLEngineResult.HandshakeStatus handshakeStatus = sslEngine.getHandshakeStatus();

while (handshakeStatus != SSLEngineResult.HandshakeStatus.FINISHED &amp;&amp;
       handshakeStatus != SSLEngineResult.HandshakeStatus.NOT_HANDSHAKING) {

    switch (handshakeStatus) {
        case NEED_UNWRAP:
            if (socketChannel.read(peerNetData) &lt; 0) {
                throw new IOException("Channel closed during handshake");
            }
            peerNetData.flip();
            SSLEngineResult unwrapResult = sslEngine.unwrap(peerNetData, peerAppData);
            peerNetData.compact();
            handshakeStatus = unwrapResult.getHandshakeStatus();
            break;

        case NEED_WRAP:
            netData.clear();
            SSLEngineResult wrapResult = sslEngine.wrap(appData, netData);
            handshakeStatus = wrapResult.getHandshakeStatus();
            netData.flip();
            while (netData.hasRemaining()) {
                socketChannel.write(netData);
            }
            break;

        case NEED_TASK:
            Runnable task;
            while ((task = sslEngine.getDelegatedTask()) != null) {
                task.run();
            }
            handshakeStatus = sslEngine.getHandshakeStatus();
            break;

        default:
            throw new IllegalStateException("Invalid handshake status: " + handshakeStatus);
    }
}</code></pre>
</div><ul>
 <li><strong>NEED_UNWRAP:</strong> Read encrypted data from the socket and decrypt it.</li>
 <li><strong>NEED_WRAP:</strong> Encrypt data and send it.</li>
 <li><strong>NEED_TASK:</strong> Run delegated tasks (CPU-intensive operations like certificate validation).</li>
 <li>Loop until handshake finishes.</li>
</ul><h3 id="step-5-secure-data-exchange-after-handshake">Step 5: Secure Data Exchange After Handshake</h3><p>After a successful handshake, application data can be exchanged securely using <code>wrap()</code> and <code>unwrap()</code>:</p><p><strong>Sending data:</strong></p><div class="code-block">
 <button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-Java">appData.clear();
appData.put("Hello secure world".getBytes(StandardCharsets.UTF_8));
appData.flip();

netData.clear();
SSLEngineResult result = sslEngine.wrap(appData, netData);
netData.flip();

while (netData.hasRemaining()) {
    socketChannel.write(netData);
}</code></pre>
</div><p><strong>Receiving data:</strong></p><div class="code-block">
 <button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-Java">peerNetData.clear();
int bytesRead = socketChannel.read(peerNetData);
if (bytesRead &gt; 0) {
    peerNetData.flip();
    peerAppData.clear();
    SSLEngineResult result = sslEngine.unwrap(peerNetData, peerAppData);
    peerNetData.compact();

    peerAppData.flip();
    byte[] receivedBytes = new byte[peerAppData.remaining()];
    peerAppData.get(receivedBytes);
    System.out.println("Received: " + new String(receivedBytes, StandardCharsets.UTF_8));
}</code></pre>
</div><p>The <code>wrap()</code> method encrypts plaintext data into TLS packets, and <code>unwrap()</code> decrypts received TLS packets into plaintext.</p><p>Here's a <strong>complete, single runnable Java example</strong> that:</p><ul>
 <li>Creates an SSL/TLS connection using <code>SocketChannel</code> and <code>SSLEngine</code></li>
 <li>Performs a full handshake</li>
 <li>Sends and receives secure data</li>
 <li>Uses a self-contained trust manager (for demo purposes only)</li>
</ul><p>⚠️ <strong>Note:</strong> For a real secure deployment, you'd load proper certificates. This example uses a <strong>dummy trust manager</strong> that accepts all certificates for simplicity.</p><h3 id="complete-runnable-java-example-client-side">Complete Runnable Java Example (Client-Side)</h3><div class="snippet-container" id="JM9F3">
 <div class="snippet-header" onclick="toggleSnippet('JM9F3')">
  Click to view full runnable Code
 </div>
 <div class="snippet-body">
  <div class="code-block">
   <button class="copy-button" onclick="copyCode(this)">▯</button>
   <pre><code class="language-java">import javax.net.ssl.*;
import java.io.IOException;
import java.net.InetSocketAddress;
import java.nio.ByteBuffer;
import java.nio.channels.SocketChannel;
import java.nio.charset.StandardCharsets;
import java.security.SecureRandom;
import java.security.cert.X509Certificate;

public class SecureNioClient {

    public static void main(String[] args) throws Exception {
        String host = "localhost";
        int port = 8443;

        // Step 1: Create SSLContext with dummy TrustManager (INSECURE - for demo only)
        TrustManager[] trustAll = new TrustManager[] {
            new X509TrustManager() {
                public X509Certificate[] getAcceptedIssuers() { return null; }
                public void checkClientTrusted(X509Certificate[] certs, String authType) { }
                public void checkServerTrusted(X509Certificate[] certs, String authType) { }
            }
        };

        SSLContext sslContext = SSLContext.getInstance("TLS");
        sslContext.init(null, trustAll, new SecureRandom());

        SSLEngine sslEngine = sslContext.createSSLEngine(host, port);
        sslEngine.setUseClientMode(true);
        sslEngine.beginHandshake();

        SSLSession session = sslEngine.getSession();

        // Step 2: Allocate Buffers
        ByteBuffer appData = ByteBuffer.allocate(session.getApplicationBufferSize());
        ByteBuffer netData = ByteBuffer.allocate(session.getPacketBufferSize());
        ByteBuffer peerAppData = ByteBuffer.allocate(session.getApplicationBufferSize());
        ByteBuffer peerNetData = ByteBuffer.allocate(session.getPacketBufferSize());

        // Step 3: Open SocketChannel
        SocketChannel socketChannel = SocketChannel.open();
        socketChannel.configureBlocking(false);
        socketChannel.connect(new InetSocketAddress(host, port));

        while (!socketChannel.finishConnect()) {
            Thread.sleep(50); // Wait for connection
        }

        // Step 4: TLS Handshake
        SSLEngineResult.HandshakeStatus handshakeStatus = sslEngine.getHandshakeStatus();

        while (handshakeStatus != SSLEngineResult.HandshakeStatus.FINISHED &amp;&amp;
               handshakeStatus != SSLEngineResult.HandshakeStatus.NOT_HANDSHAKING) {

            switch (handshakeStatus) {
                case NEED_UNWRAP:
                    if (socketChannel.read(peerNetData) &lt; 0) {
                        throw new IOException("Channel closed during handshake");
                    }
                    peerNetData.flip();
                    SSLEngineResult unwrapResult = sslEngine.unwrap(peerNetData, peerAppData);
                    peerNetData.compact();
                    handshakeStatus = unwrapResult.getHandshakeStatus();
                    break;

                case NEED_WRAP:
                    netData.clear();
                    SSLEngineResult wrapResult = sslEngine.wrap(ByteBuffer.allocate(0), netData);
                    handshakeStatus = wrapResult.getHandshakeStatus();
                    netData.flip();
                    while (netData.hasRemaining()) {
                        socketChannel.write(netData);
                    }
                    break;

                case NEED_TASK:
                    Runnable task;
                    while ((task = sslEngine.getDelegatedTask()) != null) {
                        task.run();
                    }
                    handshakeStatus = sslEngine.getHandshakeStatus();
                    break;

                default:
                    throw new IllegalStateException("Unexpected handshake status: " + handshakeStatus);
            }
        }

        System.out.println("TLS Handshake completed.");

        // Step 5: Send Secure Data
        String message = "Hello secure world!";
        appData.clear();
        appData.put(message.getBytes(StandardCharsets.UTF_8));
        appData.flip();

        netData.clear();
        SSLEngineResult wrapResult = sslEngine.wrap(appData, netData);
        netData.flip();

        while (netData.hasRemaining()) {
            socketChannel.write(netData);
        }

        System.out.println("Sent: " + message);

        // Step 6: Receive Secure Response
        peerNetData.clear();
        int bytesRead = socketChannel.read(peerNetData);

        if (bytesRead &gt; 0) {
            peerNetData.flip();
            peerAppData.clear();
            SSLEngineResult result = sslEngine.unwrap(peerNetData, peerAppData);
            peerNetData.compact();

            peerAppData.flip();
            byte[] receivedBytes = new byte[peerAppData.remaining()];
            peerAppData.get(receivedBytes);
            System.out.println("Received: " + new String(receivedBytes, StandardCharsets.UTF_8));
        }

        // Cleanup
        sslEngine.closeOutbound();
        socketChannel.close();
    }
}</code></pre>
  </div>
 </div>
</div><h3 id="requirements-to-run">Requirements to Run</h3><ul>
 <li>Java 11+</li>
 <li>A TLS server running at <code>localhost:8443</code> (can be a simple echo server)</li>
 <li>Add real trust/key managers for production use (instead of the dummy trust manager)</li>
</ul><h3 id="warning">Warning</h3><p>This demo uses a <strong>dummy <code>X509TrustManager</code> that accepts all certificates</strong>, which is insecure and should <strong>never</strong> be used in production. Always validate certificates using a properly configured trust store.</p><h3 id="key-points-and-considerations">Key Points and Considerations</h3><ul>
 <li><strong>Buffer sizing:</strong> Use buffer sizes from <code>sslEngine.getSession()</code> to avoid buffer overflows or underflows.</li>
 <li><strong>Handling <code>BUFFER_OVERFLOW</code> and <code>BUFFER_UNDERFLOW</code>:</strong> Check <code>SSLEngineResult.Status</code> and adjust buffer sizes or read more data accordingly.</li>
 <li><strong>Non-blocking and selector integration:</strong> Coordinate channel readiness (read/write) with handshake and data wrap/unwrap cycles.</li>
 <li><strong>Exception handling:</strong> Handle IOExceptions and <code>SSLException</code> to gracefully close connections on failure.</li>
 <li><strong>Closing SSL connections:</strong> Use <code>sslEngine.closeOutbound()</code> and perform a proper SSL/TLS close_notify handshake.</li>
</ul><h3 id="minimal-secure-client-example-outline">Minimal Secure Client Example Outline</h3><div class="code-block">
 <button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-java">// 1. Setup SSLContext, SSLEngine (client mode)
// 2. Create non-blocking SocketChannel and connect
// 3. Perform handshake loop as described
// 4. After handshake, wrap application data and write to channel
// 5. Read encrypted data, unwrap, and process plaintext
// 6. Close connection gracefully with SSL/TLS close_notify</code></pre>
</div><h3 id="summary">Summary</h3><p>Integrating SSL/TLS into Java NIO applications requires explicit management of encrypted and decrypted buffers via the <code>SSLEngine</code> API. While this adds complexity compared to traditional blocking SSL sockets, it enables scalable, secure network applications with non-blocking IO.</p><p>The process involves:</p><ul>
 <li>Creating and configuring an <code>SSLEngine</code>.</li>
 <li>Allocating appropriate buffers for TLS packet and application data.</li>
 <li>Driving the SSL/TLS handshake with coordinated wrap and unwrap calls.</li>
 <li>Encrypting and decrypting data securely during communication.</li>
</ul><p>Mastering <code>SSLEngine</code> unlocks the ability to build high-performance, secure Java servers and clients that benefit from both TLS security and NIO scalability.</p><div class = "chapter-navi-section">
<a href="#top" class="nav-button prev">↑</a>
<a href='java-io-and-nio.htm#security-and-io' class="nav-button toc-link">Index</a>
<a href="#bottom" class="nav-button next">↓</a>
</div>
<h2 id='handling-sensitive-data-streams'>12.4 Handling Sensitive Data Streams</h2><p>Java IO streams are essential for reading and writing data, but handling sensitive information—like passwords, encryption keys, or personal user data—requires extra care. Without proper precautions, sensitive data may be inadvertently exposed through plaintext storage, memory leaks, or insecure transmission channels.</p><p>This guide covers best practices for securely handling sensitive data in Java IO streams, focusing on:</p><ul>
 <li>Avoiding plaintext persistence of secrets.</li>
 <li>Encrypting data before storage or transmission.</li>
 <li>Securely clearing buffers to minimize in-memory data exposure.</li>
 <li>Using Java’s cryptographic APIs, including <code>CipherInputStream</code> and <code>CipherOutputStream</code>.</li>
 <li>Example code demonstrating encryption and decryption with streams.</li>
</ul><h3 id="why-secure-handling-matters">Why Secure Handling Matters</h3><p>Sensitive data such as passwords, API keys, credit card information, or personally identifiable information (PII) are attractive targets for attackers. Common risks when handling sensitive data via IO streams include:</p><ul>
 <li>Writing secrets directly to disk in plaintext, leaving them accessible to unauthorized users.</li>
 <li>Transmitting sensitive data over unencrypted channels, exposing it to interception.</li>
 <li>Leaving sensitive data in memory buffers, increasing the risk of extraction through memory dumps or side-channel attacks.</li>
 <li>Poorly managing keys or cryptographic material, weakening overall security.</li>
</ul><p>Following secure IO practices reduces these risks and helps comply with privacy regulations and security standards.</p><h3 id="best-practices-for-secure-io-handling-of-sensitive-data">Best Practices for Secure IO Handling of Sensitive Data</h3><h4 id="avoid-writing-plaintext-secrets-to-disk">Avoid Writing Plaintext Secrets to Disk</h4><p>Never store raw passwords, keys, or tokens in plaintext files. If persistent storage is necessary:</p><ul>
 <li>Use strong encryption to protect data at rest.</li>
 <li>Restrict file permissions to limit access.</li>
 <li>Avoid logging sensitive data accidentally.</li>
</ul><h4 id="encrypt-data-before-writing-to-disk-or-transmitting">Encrypt Data Before Writing to Disk or Transmitting</h4><p>Encrypt sensitive data with a robust symmetric cipher (e.g., AES) before writing it to disk or sending over the network. Decrypt only when necessary.</p><ul>
 <li>Use a well-tested cryptographic provider (<code>javax.crypto</code>).</li>
 <li>Manage encryption keys securely (never hardcode keys).</li>
 <li>Consider authenticated encryption (e.g., AES-GCM) to ensure confidentiality and integrity.</li>
</ul><h4 id="securely-clear-buffers-after-use">Securely Clear Buffers After Use</h4><p>Buffers holding sensitive data in memory should be cleared immediately after use to prevent lingering secrets:</p><ul>
 <li>Overwrite byte arrays or char arrays with zeros or random data.</li>
 <li>Avoid using immutable objects (like <code>String</code>) for sensitive data, since they cannot be erased from memory.</li>
</ul><h4 id="use-cipherinputstream-and-cipheroutputstream-for-stream-encryption">Use <code>CipherInputStream</code> and <code>CipherOutputStream</code> for Stream Encryption</h4><p>These classes allow you to transparently encrypt or decrypt data as it flows through Java IO streams.</p><h3 id="encrypting-and-decrypting-data-with-java-io-streams">Encrypting and Decrypting Data with Java IO Streams</h3><p>Here’s how to implement stream encryption and decryption securely with <code>CipherOutputStream</code> and <code>CipherInputStream</code>.</p><h3 id="setup-create-an-aes-key-and-cipher">Setup: Create an AES Key and Cipher</h3><div class="code-block">
 <button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-Java">import javax.crypto.Cipher;
import javax.crypto.KeyGenerator;
import javax.crypto.SecretKey;
import javax.crypto.spec.GCMParameterSpec;
import javax.crypto.CipherInputStream;
import javax.crypto.CipherOutputStream;
import java.io.*;
import java.security.SecureRandom;

public class SecureStreamExample {

    private static final String AES = "AES";
    private static final String TRANSFORMATION = "AES/GCM/NoPadding";
    private static final int GCM_TAG_LENGTH = 16; // bytes
    private static final int GCM_IV_LENGTH = 12;  // bytes

    // Generate a random AES key
    public static SecretKey generateKey() throws Exception {
        KeyGenerator keyGen = KeyGenerator.getInstance(AES);
        keyGen.init(256); // Use 256-bit AES key (requires JCE Unlimited Strength)
        return keyGen.generateKey();
    }

    // Generate a secure random IV (nonce)
    public static byte[] generateIV() {
        byte[] iv = new byte[GCM_IV_LENGTH];
        new SecureRandom().nextBytes(iv);
        return iv;
    }</code></pre>
</div><h3 id="encrypt-data-to-file-using-cipheroutputstream">Encrypt Data to File Using <code>CipherOutputStream</code></h3><div class="code-block">
 <button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-Java">public static void encryptToFile(byte[] plaintext, File outputFile, SecretKey key) throws Exception {
        byte[] iv = generateIV();

        Cipher cipher = Cipher.getInstance(TRANSFORMATION);
        GCMParameterSpec spec = new GCMParameterSpec(GCM_TAG_LENGTH * 8, iv);
        cipher.init(Cipher.ENCRYPT_MODE, key, spec);

        try (FileOutputStream fos = new FileOutputStream(outputFile);
             // Write IV at the beginning of the file for later decryption
             BufferedOutputStream bos = new BufferedOutputStream(fos);
             CipherOutputStream cos = new CipherOutputStream(bos, cipher)) {

            bos.write(iv);  // prepend IV for use during decryption
            cos.write(plaintext);
        }

        // Securely clear plaintext buffer
        java.util.Arrays.fill(plaintext, (byte) 0);
    }</code></pre>
</div><p>This method:</p><ul>
 <li>Generates a secure random IV.</li>
 <li>Prepends the IV to the output file (needed for decryption).</li>
 <li>Wraps the <code>FileOutputStream</code> in a <code>CipherOutputStream</code> for transparent encryption.</li>
 <li>Overwrites the plaintext buffer after writing.</li>
</ul><h3 id="decrypt-data-from-file-using-cipherinputstream">Decrypt Data from File Using <code>CipherInputStream</code></h3><div class="code-block">
 <button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-Java">public static byte[] decryptFromFile(File inputFile, SecretKey key) throws Exception {
        try (FileInputStream fis = new FileInputStream(inputFile);
             BufferedInputStream bis = new BufferedInputStream(fis)) {

            // Read the IV from the file header
            byte[] iv = new byte[GCM_IV_LENGTH];
            if (bis.read(iv) != GCM_IV_LENGTH) {
                throw new IllegalStateException("Invalid input file format");
            }

            Cipher cipher = Cipher.getInstance(TRANSFORMATION);
            GCMParameterSpec spec = new GCMParameterSpec(GCM_TAG_LENGTH * 8, iv);
            cipher.init(Cipher.DECRYPT_MODE, key, spec);

            try (CipherInputStream cis = new CipherInputStream(bis, cipher);
                 ByteArrayOutputStream baos = new ByteArrayOutputStream()) {

                byte[] buffer = new byte[4096];
                int bytesRead;
                while ((bytesRead = cis.read(buffer)) != -1) {
                    baos.write(buffer, 0, bytesRead);
                }

                byte[] decrypted = baos.toByteArray();

                // Securely clear intermediate buffer
                java.util.Arrays.fill(buffer, (byte) 0);

                return decrypted;
            }
        }
    }
}</code></pre>
</div><p>This method:</p><ul>
 <li>Reads the IV from the start of the file.</li>
 <li>Initializes a cipher for decryption.</li>
 <li>Wraps the input stream in a <code>CipherInputStream</code> to decrypt transparently.</li>
 <li>Reads decrypted data into a byte array.</li>
 <li>Clears temporary buffers after use.</li>
</ul><div class="snippet-container" id="6NBKY">
 <div class="snippet-header" onclick="toggleSnippet('6NBKY')">
  Click to view full runnable Code
 </div>
 <div class="snippet-body">
  <div class="code-block">
   <button class="copy-button" onclick="copyCode(this)">▯</button>
   <pre><code class="language-java">import javax.crypto.Cipher;
import javax.crypto.CipherInputStream;
import javax.crypto.CipherOutputStream;
import javax.crypto.KeyGenerator;
import javax.crypto.SecretKey;
import javax.crypto.spec.GCMParameterSpec;
import java.io.*;
import java.security.SecureRandom;
import java.util.Arrays;

public class SecureStreamExample {

    private static final String AES = "AES";
    private static final String TRANSFORMATION = "AES/GCM/NoPadding";
    private static final int GCM_TAG_LENGTH = 16; // in bytes
    private static final int GCM_IV_LENGTH = 12;  // in bytes

    public static void main(String[] args) throws Exception {
        SecretKey key = generateKey();
        File file = new File("encrypted.dat");

        String message = "This is a top-secret message.";
        byte[] plaintext = message.getBytes();

        encryptToFile(plaintext, file, key);
        byte[] decrypted = decryptFromFile(file, key);

        System.out.println("Decrypted message: " + new String(decrypted));
    }

    // Generate a 256-bit AES key
    public static SecretKey generateKey() throws Exception {
        KeyGenerator keyGen = KeyGenerator.getInstance(AES);
        keyGen.init(256);
        return keyGen.generateKey();
    }

    // Generate secure random IV
    public static byte[] generateIV() {
        byte[] iv = new byte[GCM_IV_LENGTH];
        new SecureRandom().nextBytes(iv);
        return iv;
    }

    // Encrypt data and write to file
    public static void encryptToFile(byte[] plaintext, File outputFile, SecretKey key) throws Exception {
        byte[] iv = generateIV();

        Cipher cipher = Cipher.getInstance(TRANSFORMATION);
        GCMParameterSpec spec = new GCMParameterSpec(GCM_TAG_LENGTH * 8, iv);
        cipher.init(Cipher.ENCRYPT_MODE, key, spec);

        try (FileOutputStream fos = new FileOutputStream(outputFile);
             BufferedOutputStream bos = new BufferedOutputStream(fos)) {

            bos.write(iv); // prepend IV

            try (CipherOutputStream cos = new CipherOutputStream(bos, cipher)) {
                cos.write(plaintext);
            }
        }

        Arrays.fill(plaintext, (byte) 0); // Clear sensitive data
    }

    // Decrypt data from file
    public static byte[] decryptFromFile(File inputFile, SecretKey key) throws Exception {
        try (FileInputStream fis = new FileInputStream(inputFile);
             BufferedInputStream bis = new BufferedInputStream(fis)) {

            byte[] iv = new byte[GCM_IV_LENGTH];
            if (bis.read(iv) != GCM_IV_LENGTH) {
                throw new IllegalStateException("Invalid file format: IV missing");
            }

            Cipher cipher = Cipher.getInstance(TRANSFORMATION);
            GCMParameterSpec spec = new GCMParameterSpec(GCM_TAG_LENGTH * 8, iv);
            cipher.init(Cipher.DECRYPT_MODE, key, spec);

            try (CipherInputStream cis = new CipherInputStream(bis, cipher);
                 ByteArrayOutputStream baos = new ByteArrayOutputStream()) {

                byte[] buffer = new byte[4096];
                int bytesRead;
                while ((bytesRead = cis.read(buffer)) != -1) {
                    baos.write(buffer, 0, bytesRead);
                }

                Arrays.fill(buffer, (byte) 0);
                return baos.toByteArray();
            }
        }
    }
}</code></pre>
  </div>
 </div>
</div><h3 id="additional-tips-for-secure-stream-handling">Additional Tips for Secure Stream Handling</h3><ul>
 <li><strong>Avoid using <code>String</code> for secrets:</strong> Store sensitive data in mutable <code>char[]</code> or <code>byte[]</code> so you can overwrite it.</li>
 <li><strong>Use try-with-resources:</strong> Always close streams promptly to flush and release resources.</li>
 <li><strong>Use authenticated encryption:</strong> Modes like AES-GCM provide both confidentiality and integrity.</li>
 <li><strong>Secure key management:</strong> Store keys securely (e.g., hardware security modules, encrypted key stores) and never hardcode them.</li>
 <li><strong>Limit buffer sizes:</strong> Large buffers increase memory footprint; choose sizes balancing performance and security.</li>
</ul><h3 id="summary">Summary</h3><p>Handling sensitive data securely in Java IO streams involves:</p><ul>
 <li>Never writing secrets in plaintext to disk or network.</li>
 <li>Using Java Cryptography Architecture (<code>javax.crypto</code>) to encrypt and decrypt data with <code>CipherOutputStream</code> and <code>CipherInputStream</code>.</li>
 <li>Generating secure random IVs/nonces and using authenticated encryption modes.</li>
 <li>Securely clearing memory buffers after use to minimize exposure.</li>
 <li>Managing encryption keys carefully and restricting access to encrypted files.</li>
</ul><p>By following these practices and using the Java cryptographic APIs properly, you can protect sensitive data throughout its lifecycle in your Java applications.</p><div class = "chapter-navi-section">
<a href="java-io-and-nio-performance-and-tuning.htm" class="nav-button prev">←</a>
<a href='java-io-and-nio.htm#security-and-io' class="nav-button toc-link">Index</a>
<a href="java-io-and-nio-new-features-and-future-of-java-io-nio.htm" class="nav-button next">→</a>
</div>
<section class="download-section">
  <div class="book-cover" style="background-color: #f9f6f1;border: 1px solid #ccc;"> 
    <div class="book-cover-title" style="font-size: 18px;color: #333;top: 20px;">Java IO and NIO</div>
    <div class="book-cover-author">readbytes</div>
    <div class="book-cover-bottom-stripe" style="background-color: #333;"></div>
    <img class="book-cover-icon" style="width: 80px;height: 90px;top: 60px;" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFoAAABaCAYAAAA4qEECAAADAElEQVR4Xu2Zu6oTURSGjze0UfANtLAUzgOI4DOItc+VKk1uJ12aadNa21vbCpYK4wQmcPiYzL5k7eXM2f8HP0JYa/3ZX2PEmxshxAPi7u6uLRH2VA3lWId9VdK27WOKsQ47q6RpmucUYx12VolEOyHRToyJ5mwI7ufeeZBItBMS7YREOyHRTki0ExLthEQ7IdFOSLQTEu2ERDsxJtoq7KwSiXZCop04Ho9PKcY67KwWirEO+6qGcqzCHhGBJDoh0U5ItAP7/f6bRDtAyV3+ckYYQNHr9fo1Z8SVtG37iKI5Mzv4IKuwJwXeuvbef4ePsQ77YuGdLp85MysGHmQa9sXAG7l3JgUfZB32heh+0t3yRvfZD87NDj7KOuwLwf2cG5OEj7IO+8bg7imr1eoV55Lh0VC4bwE7cru4n3Jns9l85d7YPmdCSV8oADtyu7gfe4fzMbucCyV9oQDsyO3i/tid7i+395xjuHMfzoaSvlAAduR2cf/+ne7PT/x8JL94mwzsjCZ5wTN8XAjuTynT/nKJcH9KmfaXS4T7U8q0v1wi3J9Skr8cH3cJ7l3I98Ph8HLg86SuM9zPvRMDO0JJXwjQ/Wx6yx3kI3cGZqK6CPdz78TAjlDSF0ZYLpcvOH9O0zQX/xnL2ZiuIbifeycGdoSSvjACZ2N2TnA+do9wP/dODOwIhfvZ8HCfn5wbYmDPNOybLXxYn9+cu8TArmnYN1v4sNTHcdc67JslfFTOw7hvHfbNEj6q+3n3gTMheMM67JsdfNA1j+Idq7BnlvBR2+32DWfElazX63cUzRlhACVLdCEk2QmJdmC3232RaAcoucsfzogAAxJNwp6qoRzrsK9aKMY6i8XiGTurhGKsc/ofGHZWCcVYR6J7KMY6Et1DMedwLgT3JRpQjEQXgmIkuhAUI9GFoBiJLgTFSHQhKEaiC0ExEl0IipHoQlCMRBeCYiS6EBQj0YWgGOtIdA/FWEeieyjGOhLdQzHW2e/3T9hZJRRjHfZVDeVYhT1CiDnzD27IzgFe/xOvAAAAAElFTkSuQmCC"/>
  </div>
  <div class="download-info">
    <h2 id='bottom'>Download This Ebook</h2>
    <p class="format-label">Available formats:</p>
    <div class="download-buttons">
      <a href="java-io-and-nio.pdf" class="download-button">📄 PDF</a>
      <a href="java-io-and-nio.epub" class="download-button">📘 EPUB</a>
    </div>
  </div>
</section><div class='related-books'>
<h2>Java In-Depth Books</h2>
<div class='related-book-list'>
<a href="java-io-and-nio.htm">
<div class="book-cover" style="background-color: #f9f6f1;border: 1px solid #ccc;"> 
    <div class="book-cover-title" style="font-size: 18px;color: #333;top: 20px;">Java IO and NIO</div>
    <div class="book-cover-author">readbytes</div>
    <div class="book-cover-bottom-stripe" style="background-color: #333;"></div>
    <img class="book-cover-icon" style="width: 80px;height: 90px;top: 60px;" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFoAAABaCAYAAAA4qEECAAADAElEQVR4Xu2Zu6oTURSGjze0UfANtLAUzgOI4DOItc+VKk1uJ12aadNa21vbCpYK4wQmcPiYzL5k7eXM2f8HP0JYa/3ZX2PEmxshxAPi7u6uLRH2VA3lWId9VdK27WOKsQ47q6RpmucUYx12VolEOyHRToyJ5mwI7ufeeZBItBMS7YREOyHRTki0ExLthEQ7IdFOSLQTEu2ERDsxJtoq7KwSiXZCop04Ho9PKcY67KwWirEO+6qGcqzCHhGBJDoh0U5ItAP7/f6bRDtAyV3+ckYYQNHr9fo1Z8SVtG37iKI5Mzv4IKuwJwXeuvbef4ePsQ77YuGdLp85MysGHmQa9sXAG7l3JgUfZB32heh+0t3yRvfZD87NDj7KOuwLwf2cG5OEj7IO+8bg7imr1eoV55Lh0VC4bwE7cru4n3Jns9l85d7YPmdCSV8oADtyu7gfe4fzMbucCyV9oQDsyO3i/tid7i+395xjuHMfzoaSvlAAduR2cf/+ne7PT/x8JL94mwzsjCZ5wTN8XAjuTynT/nKJcH9KmfaXS4T7U8q0v1wi3J9Skr8cH3cJ7l3I98Ph8HLg86SuM9zPvRMDO0JJXwjQ/Wx6yx3kI3cGZqK6CPdz78TAjlDSF0ZYLpcvOH9O0zQX/xnL2ZiuIbifeycGdoSSvjACZ2N2TnA+do9wP/dODOwIhfvZ8HCfn5wbYmDPNOybLXxYn9+cu8TArmnYN1v4sNTHcdc67JslfFTOw7hvHfbNEj6q+3n3gTMheMM67JsdfNA1j+Idq7BnlvBR2+32DWfElazX63cUzRlhACVLdCEk2QmJdmC3232RaAcoucsfzogAAxJNwp6qoRzrsK9aKMY6i8XiGTurhGKsc/ofGHZWCcVYR6J7KMY6Et1DMedwLgT3JRpQjEQXgmIkuhAUI9GFoBiJLgTFSHQhKEaiC0ExEl0IipHoQlCMRBeCYiS6EBQj0YWgGOtIdA/FWEeieyjGOhLdQzHW2e/3T9hZJRRjHfZVDeVYhT1CiDnzD27IzgFe/xOvAAAAAElFTkSuQmCC"/>
  </div>
</a>


<a href="java-collections.htm">
<div class="book-cover" style="background-color: #f9f6f1;border: 1px solid #ccc;"> 
    <div class="book-cover-title" style="font-size: 18px;color: #333;top: 20px;">Java Collections</div>
    <div class="book-cover-author">readbytes</div>
    <div class="book-cover-bottom-stripe" style="background-color: #333;"></div>
    <img class="book-cover-icon" style="width: 80px;height: 90px;top: 60px;" src='data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFoAAABaCAYAAAA4qEECAAADAElEQVR4Xu2dQYrUUBRFIw50JI7FrYgrcAPOXYPORHci7sah4EAQFyA6dNKosZK2Ee8/dOclP7/+i/fAmaR+Xr17KehJV2oYjDHGGGM6YRxzmgZdPKvdMt4vl03vLU15ZsYnsORB7Apd7mh2gS51VM/K+LVc6LA+0/QNKZax9RnvlG+C/tI7+6PYuYLV0MHoc72rX8ZvsP9Gq6BDyWzo/jXcjA4sfKN39E+RoYaf9F2CFAPFjGiG3b0Y5r9111LcJGZEM7QW0UNqRjTDWXwQXCojmoEk9MxmHwWGZ0QzkMT4ujy31b/D4UU8uITp/J4uRDOQxPiyPFfDy+HwQnFoCdPZFi5AM5BE/0VP51r5brgRzUASexU9/piG60VxEdO5lt6AZiCJ3Yoep+Fw8Z8DS5gHNfLncCOagSSWFE2M38tzanFBXcS9k/OwBi5AM5DE2qIn9JxaXFAXM33S5oE7+nFYhGYgiRxFX7FH4V+GEJqBJHIV3QGagSRcdBDNQBIuOohmIAkXHUQzkISLDqIZSMJFB9EMJOGig2gGknDRQTQDSbjoIJqBJHIUfffkPLCC74dNaAaSyFH0PKyiL4bVaAaS6L/oedAOrkQzkISLDqIZSMJFB9EMJNF/0bdPzsMquxLNQBL9Fz3x4eQ8sJIb0AwkkaPoK56efLvSV0MVNANJ5Cq6AzQDSbjoIJqBJFx0EM1AEi46iGYgCRcdRDOQhIsOohlIwkUH0Qwk4aKDaAaScNFBNANJuOggmoEkXHQQzUASLjqIZiAJFx1EM5CEiw6iGUjCRQfRDCSxtuh2X63oDM1AEkuKXmtxQc2IZiCJ3Yqu9vW3ztAMJLFX0ZfD4YXiUDI0A0m46CCagSTyfOm+EzQDSeiZzT4ODM+IZjiLD4NLZUQztBbRQ2pGNMPu1nh4lR/H9sfP+i5BioFgNnT/Gm5GB6Ib/im8Nf0+MtMPgb3Wquhwqw1Vwg/qbkix0EHtAl3qaHaDfx6kIf7Bm8YUyyY1Dbp4Fo0xxhhj/kd+A/PkOH57kF8HAAAAAElFTkSuQmCC'/>
  </div>
</a>


<a href="java-regex.htm">
<div class="book-cover" style="background-color: #f9f6f1;border: 1px solid #ccc;"> 
    <div class="book-cover-title" style="font-size: 18px;color: #333;top: 20px;">Java Regex</div>
    <div class="book-cover-author">readbytes</div>
    <div class="book-cover-bottom-stripe" style="background-color: #333;"></div>
    <img class="book-cover-icon" style="width: 80px;height: 90px;top: 60px;" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFoAAABaCAYAAAA4qEECAAAFo0lEQVR4Xu2d3WscVRiH+y/YXuuFkov6H9je2huvlAQvFalCEW8qiFRFQcGrmoJ4U5TSLWglFqRIlJqCH6XWalM/0lrT1O1ukt3sV5qPTZrP3XHfLTM983vPztc5s+zZPQ88N5l3Z9inwzA70Dl79iQks29oM7N3yBkoW98ZO6RC62ANdvDBtYF9lJEcxHNi+CWnOvmXs5rN9aX03eg74vcWxV6xObX3iUdxp2P7DzqDztiTB1lsaoX9InF631BJ3NH408N4vIFn/NCwL/aZVjPsGAj+a1mCwV7YUwqeyZZoxDqz8ZpsiYfY7mzQNdtGVkdsiH3b2Mj6CIztbrB3F+qMHxqRh84Iv/gsehDO6oe/IN0/ju0/gPOWhNAPO3ZW27M5HXyhTwtP4Sx68S4f9NRPuJbgnEURsa0Xmp5QWfQyMfLwqZ8XunrtT5yzKEKPWFnoem4O5xKxsVbS5vbmMu7eKOr5OUnovHro1ep0KppKPT+vP/TGWpkF0qWp2NBdwobuEjY0MnXbcb4cd5xCGbco0XOhb8wuOhdnGp4//7fl254ah9/urAZ6KrQYGL01V0sndLPJw8pUxJjQ5OXsBh5KjVZjFjRIBXoqdKWcZXHRK/kGHi45GDJMBXoqNFku3WVx0V9nNcTGiK7nLgRvT0jPhSZLacfGeK7Xb4bPJaQnQz+InWNx0USXEQzn+vsUTvKZfgxNFhfyLC4a68x+7QMejrwieVqJM+QX3+BUZHo6NDlfnGNx0auzdPsQAQxHXprEKT7jqkDPhyZni/MsLhopNoY7kcEJPuN6bBQnY2FEaDJXLLC4aGhsjIfgdtdX3sHJ2BgTmswVwmMHXrMxoBgb/+76snpkwqjQZKnusLhox7uRryd4yDA1YVxoYmG1yeKi0jP7nzs8ZJAaMTI0UVhJEPvN4zxmJzVjbGhidik8tu8ygjE7mQJGha7XZvBQTnYxPHb7zF6o8qAyU8KY0Gv37uJhPGZq4bEXpnI8KpoiRoTe3lzBQzCmq51j59aabSu/3OBxSU23cEH0fOgHT+ej8W+Fx3Yju9YuXO16ZCKV0DvVSWfrzlnm+tyP/pCVW2xGNAlibIzsunT+p65GJroamhRD4zbVyC7TFR4XXf7qIn4sVVIJ3bj9meNce0OqGLM5+Rbb7jMhePmQWXzqWWf15Of40dRIJfTmwmV2hiY1LhhUJkV2Xfn4FO4iFXo+NBkVDCpTjOzFPvEp7ko7RoQmw8CgMjGw6PJourGNCU12AoPKXHpvlMVFl4+fxF1rw6jQJIJBZbpgWJnLH34i7F0fxoamnzEYVKZI6ZkXWViZS+9+5PucDowNjUFlIlt/3GRRO7n4+vv4cSWMDI1BZcpYP/89Cxpk7cgx3EVijAuNQWV2AkOSbZpN9nfX6uHkP5xE+i50EBgRwe1e7BeO4mhs+ip0GBjw/nc/4AibCZqNQ9+EjgLGI50G/yzOeLMK9EXoqBQPPMfixYm9cek3HIuM8aHjgvFcmzs7OMpm2v8oCTE6dBJ2q/dYPC/29rZvFrcPZGgVdss1FtCLvX6/PVN5/lW2beBC62C3VGURw2z/D66EGBdaJ7vFMosZpAoDHZqIGluVgQ/dJuAnuI7IhA0NVEaOtOMuHrVP74zEhu4SNnSXkIdWfHnVbr3AAunSVOjkZaF1vI4NA+nQZKSvY7MvGNSP9AWDpEUvYlv7EtgU8UK7Sz/Z0Ongnc34/mi7apA+xNWHxND21fOa8S4buHiZu4GWJbKo8W2nxRTE0PasVkdsiZ3b2NjqhEYmaNkhGzs5Yrszjzz+GPb1QQtq2djxEZu17pvL2FWK70M2dijYC3sGgmc2LUtk8SPeXcQ6kxFcdo+kG/FBR+tSqCK4U1F6QlW7/rezms33pfTdxKdwMrGXMhm7XLWo/uWqZdgF2OPxPxXwJpKIkhiiAAAAAElFTkSuQmCC"/>
  </div>
</a>


<a href="java-functional-programming.htm">
<div class="book-cover" style="background-color: #f9f6f1;border: 1px solid #ccc;"> 
    <div class="book-cover-title" style="font-size: 18px;color: #333;top: 20px;">Java Functional Programming</div>
    <div class="book-cover-author">readbytes</div>
    <div class="book-cover-bottom-stripe" style="background-color: #333;"></div>
    <img class="book-cover-icon" style="width: 80px;height: 80px;top: 80px;" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFoAAABaCAYAAAA4qEECAAADzUlEQVR4Xu2bO4sUURCFlxVBzfwLJkb+A1MxEgMRDBQDRTBRwchARk00MRFBAwNBzEQwMBfEBz7wbWIkiIGJoInio9wZdmZ7T1V3V91bPVhaH3xJ973n3jk2vdO968JCkiRJkiRRIYphWOgI/zB/uyHBDxHFUODmIxkK3HwkQ4Gbj2QY6BDffCTDgBuPZhhw49EMA248miGgW3zj0QwBbjqiIcBNRzQEuOlohoA+8Y1HMgy4cauJEizO5EZMS0RoUSjPYKIEi7OaKMHirCZKsDiTi5iWiNAmoTyDiRIszmqiBIsz+QXTklZYeQYTJXSUl2cxUYLFWU2UYHEmb2Na0gorz2CihJ7w8iwmSrA4q4kSLM7kYUxLWmHlGUyU0C9ensVECRZnNQS4abPPMNEOy7S4BdN00L5GxmU8q4cuNXL24tll2KYrLIXW8yyLJdAJnkP3cFQ/9FzIGeEgHOBgCZhh1Qod5xkzH+PoduiVMH/qqDkQT3q4trGAEpZh1AId4/OZb3EWh14K89DRdDCecNIKzjdp+IelHcL8Nj/g7BU6r2R0+3gCHvRyN26tHdoszDdoAef2KpQt3pN7ZAc81YLzrFrAuSrfNOY/Es4rZAdcfbCywS7YPIvfMa0buiBkaFz6ATn+POy4xmvjhfGgsxpwjsUSigsr8el0UTzh7c9Vn5FBe4Q5BkuZXKFCnqsPmwviyQHsAsdarWF8tWGem/dxMRwwkG3gOJMvMM1O7S8aRJtX8hQ2aCDbwHEWvXAte3pPlmCDBxKhK3yMRU9cbiOKp0k+aQg3+K7pTdUPyHeYVgELL9At7/zqLA9KH0YmNh5qqqHPwgJWLzby8JxBb1y+Wxve+vXCwguc5Lzmxy164lLy1IL32SJ0Qwi3+k04ZtSLqttFm3dxlUJY8Lzdijsqo+QtnFqPK5u2CcFz1APT++RSPe7ZLHSO1qL6zYiXmu/WXdAaIXRO1lD8mnSpsOKHmpu4CyMscB5W/m8rlqex8TBS+lBTDQYObS2Y16vwxFfydbAaDBzaWmgXz2y14/46fg3Kxre5E2cXwoKH8geuXIb4hzNo11u4ZVRX9kmcVQELH0hP6BTPnym9T26h8559Gkc7wBYZQG/oLF+D/WZEgfht5AyOcoLeC4s5OwR0oLHGVTyrh643cvbjWWewGFc/4mr/MXRQKMjJBMCCvEwAWsdL8jARwJKqvYMrJDNYWRUmHWBZNSY9YGGlJj1gYUWew9REhBVnNFFCX3l5FhMDWJ7WpAAssc+kAiyzzcQJLHbibxyVJEmSJMk/xB+4wdarC+OVAQAAAABJRU5ErkJggg=="/>
  </div>
</a>


<a href="java-streams.htm">
<div class="book-cover" style="background-color: #f9f6f1;border: 1px solid #ccc;"> 
    <div class="book-cover-title" style="font-size: 18px;color: #333;top: 20px;">Java Streams</div>
    <div class="book-cover-author">readbytes</div>
    <div class="book-cover-bottom-stripe" style="background-color: #333;"></div>
    <img class="book-cover-icon" style="width: 80px;height: 80px;top: 60px;" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFoAAABaCAYAAAA4qEECAAACbklEQVR4Xu3cP4oUQRiG8S8xEzESDI1MPIRHEQQPYTK9iCyewMxrGIiCoaFnWFkMTIwUxD894KI8VbNdVdNfzdR87w+eRKa2ul+WVZM1G8+3ud+d+mhBvbZ0DO/uWEAcoVfhcIBehcQRvAvt1dz7gjjaVfxcrhcmxTiwvkudcGAN7YQDa2gnHFhDO+HAGtoJB24ZmmdzhcdBWobh2VzhcZCWYXg2V3gcpGUYns0VHgdpGYZnc4XHQVqG4dlc4XGQlmF4Nld4HKRlGJ7NFR4HaRmGZ3MN48Hcu7lLS19ihI7SPUsfdPSOCh/ulDoKfKhT7KC2P3P5QKfawfBBTr2D4ENEqDs+QJS64uWR6ubc0ssj1Q0vjlYXvLS1X3Mv5x7NPTyi+Jy5uuClNY2Az5zL3RtLLy1pJHz2XO544VLbHw+j4TvkcscLlxoR3yGXO154XaPie+Ry9djSC69rVHyPXK62/xTjhbu6+HtmRHyXXK6iDH1wGroTDd2Jhu5EQ3eioTvR0J1o6E40tAMOt1YCHGitBDjQWglwoLUS4EBrJcCB1kqAA62VwFOnREREROSIPbP7/CNZ28Y+2KT/hPjbjnyVOPl/ZA3tZLLzZGiN7YAD/+smPyqt0nH1Xe2Cw7LndpdHpBZH3ZXs4YndSAbdleyBYy4ljTjkUtKAI5a0sS/8MrKEI5YmFTZ2mQxYmlTgeDVt7DO/nOzC8WqTApPdSoarTQpM9ikZrjYpMNmPZLjapMDZ/JcZh6tNCkx2OxmuNinE4WraDPnbZw5ksp/JgKVJJQ5YmjTgiEvJHib7mgyaS1Yy2dtk3DP7zo9F9wfJyGVFhM8g5gAAAABJRU5ErkJggg=="/>
  </div>
</a>



<a href='java.htm'><div class='book-cover' style='background-color: #f9f6f1;color: #111111;border: 1px solid #ccc;display: flex;justify-content: center;align-items: center;text-align: center;'>More Java Books</div></a>
</div>
</div><script>
function copyCode(button) {const code = button.nextElementSibling.innerText;navigator.clipboard.writeText(code).then(() => {button.textContent = 'Copied!';setTimeout(() => { button.textContent = 'Copy'; }, 1500);});}
</script><script>
function toggleSnippet(id) {const box = document.getElementById(id);box.classList.toggle("open");}  
</script></div>
<style>
.site-footer {margin-top: 60px;padding: 20px 0;border-top: 1px solid #eee;text-align: center;font-size: 14px;}
.site-footer a {text-decoration: none;}
.light-mode .site-footer {color: #777;border-color: #eee;}
.dark-mode .site-footer {color: #888;border-color: #333;}
.light-mode .site-footer a {color: #555;}
.dark-mode .site-footer a {color: #aaa;}
.site-footer a:hover {text-decoration: underline;}    
</style>
<footer class="site-footer">
<nav><a href="https://readbytes.github.io">Home</a> |Email:<script type="text/javascript">
var part1 = 'yinpeng';var part6 = '263';var part2 = Math.pow(2,6);var part3 = String.fromCharCode(part2);var part4 = 'hotmail dot com';var part5 = part1 + String.fromCharCode(part2) + part4;document.write(part1 + part6 + part3 + part4);
</script>
| <a id="mode-toggle" href="#">Toggle Dark Mode</a>
</nav><p>© 2025 — All rights reserved.</p></footer>
<script>
const toggleButton = document.getElementById('mode-toggle');
const body = document.body;
const savedMode = localStorage.getItem('mode') || 'light';
body.classList.add(savedMode + '-mode');
toggleButton.addEventListener('click', () => {
      const isDark = body.classList.contains('dark-mode');
      body.classList.toggle('dark-mode', !isDark);
      body.classList.toggle('light-mode', isDark);
      localStorage.setItem('mode', isDark ? 'light' : 'dark');
});
function copyCode(button) {const code = button.nextElementSibling.innerText;navigator.clipboard.writeText(code).then(() => {button.textContent = 'Copied!';setTimeout(() => { button.textContent = 'Copy'; }, 1500);});}
</script>
</body>
</html>