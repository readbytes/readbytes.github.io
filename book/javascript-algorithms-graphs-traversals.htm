<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>JavaScript Algorithms Graphs: Traversals</title>
<link rel='shortcut icon' href='https://java2s.com/style/favicon.ico'>
<link href="https://fonts.googleapis.com/css2?family=Merriweather&display=swap" rel="stylesheet" />
<link href="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet" />

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/codemirror.min.css" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/theme/material.css"> <!-- Dark theme -->
<script src="https://cdn.jsdelivr.net/npm/typescript@5/lib/typescript.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/codemirror.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/mode/htmlmixed/htmlmixed.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/mode/xml/xml.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/mode/css/css.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/mode/javascript/javascript.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/mode/javascript/typescript.min.js"></script>
<style>
    #floatingLog {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(20, 20, 20, 0.95);
      color: white;
      font-family: monospace;
      font-size: 14px;
      padding: 16px 20px;
      border-radius: 8px;
      box-shadow: 0 4px 16px rgba(0, 0, 0, 0.4);
      max-width: 80%;
      max-height: 200px;
      overflow-y: auto;
      display: none;
      z-index: 9999;
      pointer-events: none;
      white-space: pre-wrap;
      text-align: center;
    }
</style>
<script>
  const codeMirrorMap = new Map();
  const iframeMap = new Map();
  
 

  let dismissTimer;
  function showFloatingLog(message) {
	const floatingLog = document.getElementById('floatingLog');

    if (floatingLog.style.display !== 'block') {
      floatingLog.textContent = '';
      floatingLog.style.display = 'block'; 
    }

    floatingLog.textContent += message + '\n';
    floatingLog.scrollTop = floatingLog.scrollHeight; 
    clearTimeout(dismissTimer);
    dismissTimer = setTimeout(() => {
      floatingLog.style.display = 'none';
      floatingLog.textContent = '';
    }, 2000);
  }
  window.addEventListener('message', (event) => {
	    if (!iframeMap.has(event.source)) return;

	    if (event.data?.type === 'console-log') {
	      showFloatingLog(event.data.message);
	    }
  });  
  function renderIframe(button,textarea_id, iframe_id) {
      const html = codeMirrorMap.get(textarea_id).getValue();
      const iframe = document.getElementById(iframe_id);
  
      const oldIframe = iframe;
      const newIframe = document.createElement('iframe');
      newIframe.className ="result_iframe";
      
      newIframe.id = iframe_id;
      oldIframe.replaceWith(newIframe);
 

      // Track the iframe in the map
      iframeMap.set(newIframe.contentWindow, button);

      const overrideScript = `
        <script>
          (function() {
            const originalLog = console.log;
            console.log = function(...args) {
              originalLog.apply(console, args);
              window.parent.postMessage({
                type: 'console-log',
                message: args.map(a => {
                  try { return JSON.stringify(a); }
                  catch { return String(a); }
                }).join(' ')
              }, '*');
            };
          })();
        <\/script>
      `;

      const iframeHTML = `
        <!DOCTYPE html>
        <html>
        <body>
          ${overrideScript}
          ${html}
        </body>
        </html>
      `;
 
      const doc = newIframe.contentDocument || newIframe.contentWindow.document;
      doc.open();
      doc.write(iframeHTML);
      doc.close();

      
  }
  function renderIframeForClientTypescript(textarea_id, iframe_id) {
      let code = codeMirrorMap.get(textarea_id).getValue();
      code = ts.transpile(code);
      const iframe = document.getElementById(iframe_id);
      const doc = iframe.contentDocument || iframe.contentWindow.document;

const html = `
  <!DOCTYPE html>
  <html>
    <head>
      <title>Output</title>
      <style>
        body { font-family: monospace; padding: 1em; background: #f4f4f4; color: #222; }
        pre { white-space: pre-wrap; word-break: break-word; }
        .error { color: red; }
      </style>
    </head>
    <body>
      <pre id="log"></pre>
      <script>
        (function(){
          const logEl = document.getElementById('log');
          const origLog = console.log;
          const origError = console.error;

          console.log = (...args) => {
            logEl.textContent += args.join(' ') + '\\n';
            origLog.apply(console, args);
          };
          console.table = (...args) => {
            logEl.textContent += args.join(' ') + '\\n';
            origLog.apply(console, args);
          };

          console.error = (...args) => {
            logEl.innerHTML +='<span class="error">' + args.join(' ') + '</span>';
            origError.apply(console, args);
          };
          window.addEventListener("error", function (event) {
              console.error("Caught by event listener:", event.message);
          });    
          try {             
              ${code};
          } catch (err) {
            console.error(err.stack || err.message);
          }
        })();
      <\/script>
    </body>
  </html>
`;

      iframe.style.display = "block";
      iframe.srcdoc = html;  
  }

    function renderIframeForClientJavascript(textarea_id, iframe_id) {
        const code = codeMirrorMap.get(textarea_id).getValue();
        const iframe = document.getElementById(iframe_id);
        const doc = iframe.contentDocument || iframe.contentWindow.document;

  const html = `
    <!DOCTYPE html>
    <html>
      <head>
        <title>Output</title>
        <style>
          body { font-family: monospace; padding: 1em; background: #1e1e1e; color: #eee; }
          pre { white-space: pre-wrap; word-break: break-word; }
          .error { color: red; }
        </style>
      </head>
      <body>
        <pre id="log"></pre>
        <script>
          (function(){
            const logEl = document.getElementById('log');
            const origLog = console.log;
            const origError = console.error;

            console.log = (...args) => {
              logEl.textContent += args.join(' ') + '\\n';
              origLog.apply(console, args);
            };
            console.table = (...args) => {
              logEl.textContent += args.join(' ') + '\\n';
              origLog.apply(console, args);
            };

            console.error = (...args) => {
              logEl.innerHTML +='<span class="error">' + args.join(' ') + '</span>';
              origError.apply(console, args);
            };
            window.addEventListener("error", function (event) {
                console.error("Caught by event listener:", event.message);
            });    
            try {
             ${code}; 
            } catch (err) {
              console.error(err.stack || err.message);
            }
          })();
        <\/script>
      </body>
    </html>
  `;
        iframe.style.display = "block";
        iframe.srcdoc = html;  
    }
    function toggleSnippetAndRefresh(id, textarea_id) {
      const box = document.getElementById(id);
      box.classList.toggle("open");
      codeMirrorMap.get(textarea_id).refresh();
    }

  </script>
  <script>
  const mode = localStorage.getItem('mode') || 'light';
  document.documentElement.classList.add(`${mode}-mode`);
  </script>   
<style> 
html {
  scroll-behavior: smooth;
}

body {
  font-family: 'Merriweather', serif;
  margin: 0;
  padding: 2rem 1rem;
  font-size: 15px;
  line-height: 1.5;
  transition: background-color 0.3s, color 0.3s;
}

.container {
  max-width: 700px;
  margin: 0 auto;
  padding: 1rem 2rem;
  box-shadow: 0 0 15px rgba(0,0,0,0.1);
}

h1, h2, h3 {
  font-weight: 600;
  margin-top: 2.5rem;
  margin-bottom: 1rem;
  line-height: 1.2;
}

h1 { font-size: 1.8rem; }
h2 { font-size: 1.4rem; }
h3 { font-size: 1.2rem; }

table {
  width: 100%;
  border-collapse: collapse;
  font-family: sans-serif;
  font-size: 1em;
  margin: 1em 0;
}

th, td {
  padding: 0.6em 1em;
  text-align: left;
  border: 1px solid;
}

tr:nth-child(even) {
  background-color: inherit;
}

tr:hover {
  background-color: inherit;
}

a {
  text-decoration: none;
  transition: color 0.2s;
}

a:hover {
  text-decoration: underline;
}

code {
  color: #d35400;
}

.book-title-chapter {
  font-family: 'Merriweather', serif;
  font-size: 2rem;
  font-weight: bold;
  text-align: center;
  margin-bottom: 2rem;
  border-bottom: 2px solid;
  padding-bottom: 0.5rem;
}

.book-subtitle-chapter {
  text-align: center;
  font-size: 1rem;
  margin-top: -1rem;
  margin-bottom: 2rem;
}

.related-books {
  margin-top: 40px;
}

.related-book-list {
  display: flex;
  flex-wrap: wrap;
  gap: 20px;
}

    .book-cover {
      width: 130px;
      height: 180px;
      font-family: Arial, sans-serif;
      position: relative;
      overflow: hidden;      
      line-height: normal;
      box-shadow: 2px 2px 4px rgba(0,0,0,0.1);
    }
    .book-cover-bottom-stripe {
      position: absolute;
      bottom: 0;
      left: 0;
      height: 5px;
      width: 100%;
    }
    .book-cover-title {
      position: absolute;
      width: 100%;
      text-align: center;
      font-weight: bold;
    }
     
    .book-cover-icon {
      position: absolute;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      align-items: center;
      justify-content: center; 
    }

    .book-cover-author {
      position: absolute;
      bottom: 10px;
      width: 100%;
      text-align: center;
      font-size: 8px;
      color: #333;
    }

.page-footer {
  margin-top: 4rem;
  padding: 1rem 0;
  text-align: center;
  font-size: 0.85rem;
  border-top: 1px solid;
}

.chapter-navi-section {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding-bottom: 10px;
}

.nav-link {
  color: inherit;
  text-decoration: none;
  opacity: 0.5;
  transition: opacity 0.3s ease, text-decoration 0.3s ease;
}

.nav-link:hover {
  opacity: 0.9;
  text-decoration: underline;
}

.prev { text-align: left; }
.toc-link { text-align: center; }
.next { text-align: right; }

.download-section {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 2rem;
  padding: 2rem 1rem;
  max-width: 600px;
  margin: 3rem auto;
  border-radius: 12px;
  box-shadow: 0 4px 10px rgba(0,0,0,0.05);
}

.download-info h2 {
  margin: 0 0 0.5rem;
  font-size: 1.2rem;
}

.format-label {
  margin: 0 0 0.5rem;
  font-size: 0.95rem;
}

.download-buttons {
  display: flex;
  gap: 1rem;
}

.download-button {
  background-color: #4A90E2;
  color: white;
  padding: 0.5em 1.2em;
  border-radius: 25px;
  font-size: 0.95rem;
  text-decoration: none;
  transition: background-color 0.3s ease;
}

.download-button:hover {
  background-color: #357ABD;
}

.code-block {
  position: relative;
  margin-bottom: 1em;
}

.copy-button {
  background: transparent;
  color: white;
  position: absolute;
  top: 8px;
  right: 8px;
  border: none;
  padding: 4px 8px;
  font-size: 12px;
  border-radius: 4px;
  cursor: pointer;
  z-index: 1;
}

.copy-button:hover {
  background-color: #0056b3;
}

.snippet-container {
  overflow: hidden;
}

.snippet-header {
  padding: 0.75rem 1rem;
  cursor: pointer;
  font-size: 1rem;
    background-color: #eeeeee;
    color:  #111111; 
    border-radius: 8px;
    cursor: pointer;
    box-shadow: 0 4px 6px rgba(0,0,0,0.1);  
}

.snippet-body {
  display: none;
  font-family: monospace;
}

.snippet-container.open .snippet-body {
  display: block;
}

.CodeMirror {
  border: 2px solid #ccc;
  border-radius: 4px;
  resize: vertical;
}

/* === Light Mode === */
html.light-mode {
  background-color: #f8f7f5;
  color: #333;
}

html.light-mode .container {
  background: white;
}

html.light-mode .book-title-chapter {
  color: #2c3e50;
  border-color: #ccc;
}
html.light-mode .book-subtitle-chapter{
  color: #888;
}

html.light-mode .page-footer,
html.light-mode .series-name,
html.light-mode .book-subtitle,
html.light-mode .format-label {
  color: #888;
}

html.light-mode .related-books h2 {
  color: #333;
  border-bottom: 2px solid #eee;
}

html.light-mode .book-title {
  color: #fff;
}

html.light-mode .book-cover {
  border: 1px solid #ccc;
}

html.light-mode th {
  background-color: #f2f2f2;
}

html.light-mode tr:nth-child(even) {
  background-color: #fafafa;
}

html.light-mode tr:hover {
  background-color: #e6f7ff;
}

html.light-mode a,
html.light-mode .page-footer a {
  color: #000;
}

/* === Dark Mode === */
html.dark-mode {
  background-color: #181818;
  color: #e0e0e0;
}

html.dark-mode .container {
  background: #222;
}

html.dark-mode .book-title-chapter {
  color: #ddd;
  border-color: #444;
}

html.dark-mode .snippet-header {
    background-color: #333;
    color:  #ddd; 
}


html.dark-mode .book-subtitle-chapter,
html.dark-mode .page-footer,
html.dark-mode .series-name,
html.dark-mode .book-subtitle,
html.dark-mode .book-footer,
html.dark-mode .format-label {
  color: #aaa;
}

html.dark-mode .related-books h2 {
  color: #ddd;
  border-bottom: 2px solid #333;
}

html.dark-mode .book-title {
  color: #fff;
}

html.dark-mode .book-cover {
  border: 1px solid #555;
}

html.dark-mode th {
  background-color: #333;
  color: #fff;
}

html.dark-mode td {
  border-color: #444;
}

html.dark-mode tr:nth-child(even) {
  background-color: #2a2a2a;
}

html.dark-mode tr:hover {
  background-color: #2c3e50;
}

html.dark-mode a,
html.dark-mode .page-footer a {
  color: #eee;
}

    .dialog-backdrop {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: rgba(0,0,0,0.5);
      display: none;
      justify-content: center;
      align-items: center;
      z-index: 10;
    }

    .dialog {
      background: white;
      padding: 20px;
      width: 90vw;
      height: 80vh;
      border-radius: 8px;
      box-shadow: 0 0 20px rgba(0,0,0,0.3);
      display: flex;
      flex-direction: column;
    }
    .dialog-content {
      display: flex;
      flex: 1;
      gap: 20px;
      margin-top: 10px;
    }
    .dialog h2 {
      margin-top: 0;
    }

    .textarea_dialog {
      width: 50%;
      height: 100%;
      resize: none;
      font-family: monospace;
      font-size: 14px;
      padding: 10px;
      box-sizing: border-box;
      border: 1px solid #ccc;
    }

    .iframe_dialog {
      width: 50%;
      height: 100%;
      border: 1px solid #ccc;
    }
    .controls_dialog {
      display: flex;
      justify-content: space-between;
      margin-top: 10px;
    }    
    button { padding: 0.5em 1em; background: green; color: white; border: none; cursor: pointer; }
    button:hover { background: #1e7e34; }
    .result_iframe { width:99%; height:200px; margin-top: 1em;  resize: both;border:1px solid #ccc;}        
</style>
</head>
<body> 
  <div class="container">
    <div class = "chapter-navi-section">
<a href="javascript-algorithms-graph-representations.htm" class="nav-button prev">←</a>
<a href='javascript-algorithms.htm#graphs-traversals' class="nav-button toc-link">Index</a>
<a href="javascript-algorithms-graph-shortest-paths.htm" class="nav-button next">→</a>
</div>

    <h1 class="book-title-chapter" id = 'top'>Graphs: Traversals</h1>
    <h3 class="book-subtitle-chapter">JavaScript Algorithms</h3>   
    <!-- <h1 class ="chapter-title"></h1> -->
    <h2 id='breadth-first-search-bfs'>14.1 Breadth-First Search (BFS)</h2><p><strong>Breadth-First Search (BFS)</strong> is a fundamental graph traversal algorithm that explores nodes in a <strong>level-order</strong> manner. Starting from a given source node, it visits all immediate neighbors first, then their neighbors, and so on. This strategy makes BFS ideal for <strong>shortest path discovery</strong> in unweighted graphs and for exploring all nodes reachable from a source.</p><h3 id="bfs-fundamentals">BFS Fundamentals</h3><p>BFS works by systematically visiting nodes in the order they are discovered, maintaining a <strong>queue</strong> to track which nodes to visit next. This ensures that nodes are visited in the order of their <strong>distance</strong> (in edges) from the source node.</p><h4 id="algorithm-overview">Algorithm Overview:</h4><ol>
 <li><p>Start from a source node.</p></li>
 <li><p>Enqueue it and mark it as visited.</p></li>
 <li><p>While the queue is not empty:</p>
  <ul>
   <li>Dequeue the front node.</li>
   <li>Visit all unvisited neighbors and enqueue them.</li>
  </ul></li>
</ol><div class="snippet-container" id="<!DOCTYPE html>
<html lang=&quot;en&quot;>
<head>
  <meta charset=&quot;UTF-8&quot; />
  <title>BFS Graph Visualization</title>
  <style>
    body { font-family: sans-serif; text-align: center; padding: 20px; }
    canvas { border: 1px solid #ccc; background: #f9f9f9; }
    button { font-size: 16px; padding: 8px 12px; margin: 10px; }
  </style>
</head>
<body>
  <h2>Breadth-First Search (BFS) Visualization</h2>
  <button onclick=&quot;runBFS()&quot;>Run BFS</button>
  <canvas id=&quot;canvas&quot; width=&quot;600&quot; height=&quot;600&quot;></canvas>

  <script>
    const canvas = document.getElementById(&quot;canvas&quot;);
    const ctx = canvas.getContext(&quot;2d&quot;);

    // Predefined nodes with fixed positions
    const nodes = [
      { label: 'A', x: 150, y: 100 },
      { label: 'B', x: 300, y: 100 },
      { label: 'C', x: 450, y: 100 },
      { label: 'D', x: 150, y: 250 },
      { label: 'E', x: 300, y: 250 },
      { label: 'F', x: 450, y: 250 },
      { label: 'G', x: 300, y: 400 }
    ];

    // Edges between nodes (undirected)
    const edges = [
      ['A', 'B'], ['A', 'D'], ['B', 'C'], ['B', 'E'],
      ['C', 'F'], ['D', 'E'], ['E', 'F'], ['E', 'G']
    ];

    // Build adjacency list
    const adjList = {};
    for (const node of nodes) {
      adjList[node.label] = [];
    }
    for (const [from, to] of edges) {
      adjList[from].push(to);
      adjList[to].push(from);
    }

    let bfsOrder = [];

    function runBFS() {
      bfsOrder = [];
      const visited = new Set();
      const queue = ['A'];
      visited.add('A');

      while (queue.length > 0) {
        const current = queue.shift();
        bfsOrder.push(current);
        for (const neighbor of adjList[current]) {
          if (!visited.has(neighbor)) {
            visited.add(neighbor);
            queue.push(neighbor);
          }
        }
      }
      animateBFS(0);
    }

    // Animate BFS traversal by highlighting visited nodes
    function animateBFS(index) {
      if (index >= bfsOrder.length) return;
      drawGraph(bfsOrder.slice(0, index + 1));
      setTimeout(() => animateBFS(index + 1), 800);
    }

    // Draw the graph with optional highlighted nodes
    function drawGraph(highlighted = []) {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // Draw edges
      ctx.strokeStyle = &quot;#999&quot;;
      for (const [from, to] of edges) {
        const fromNode = nodes.find(n => n.label === from);
        const toNode = nodes.find(n => n.label === to);
        ctx.beginPath();
        ctx.moveTo(fromNode.x, fromNode.y);
        ctx.lineTo(toNode.x, toNode.y);
        ctx.stroke();
      }

      // Draw nodes
      for (const node of nodes) {
        ctx.beginPath();
        ctx.arc(node.x, node.y, 25, 0, 2 * Math.PI);
        ctx.fillStyle = highlighted.includes(node.label) ? &quot;#27ae60&quot; : &quot;#3498db&quot;; // green when visited
        ctx.fill();
        ctx.stroke();

        ctx.fillStyle = &quot;#fff&quot;;
        ctx.font = &quot;16px Arial&quot;;
        ctx.textAlign = &quot;center&quot;;
        ctx.textBaseline = &quot;middle&quot;;
        ctx.fillText(node.label, node.x, node.y);
      }
    }

    drawGraph();
  </script>
</body>
</html>ID"><textarea id="AYWcl" style="display: none;">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
  &lt;meta charset="UTF-8" /&gt;
  &lt;title&gt;BFS Graph Visualization&lt;/title&gt;
  &lt;style&gt;
    body { font-family: sans-serif; text-align: center; padding: 20px; }
    canvas { border: 1px solid #ccc; background: #f9f9f9; }
    button { font-size: 16px; padding: 8px 12px; margin: 10px; }
  &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;h2&gt;Breadth-First Search (BFS) Visualization&lt;/h2&gt;
  &lt;button onclick="runBFS()"&gt;Run BFS&lt;/button&gt;
  &lt;canvas id="canvas" width="600" height="600"&gt;&lt;/canvas&gt;

  &lt;script&gt;
    const canvas = document.getElementById("canvas");
    const ctx = canvas.getContext("2d");

    // Predefined nodes with fixed positions
    const nodes = [
      { label: 'A', x: 150, y: 100 },
      { label: 'B', x: 300, y: 100 },
      { label: 'C', x: 450, y: 100 },
      { label: 'D', x: 150, y: 250 },
      { label: 'E', x: 300, y: 250 },
      { label: 'F', x: 450, y: 250 },
      { label: 'G', x: 300, y: 400 }
    ];

    // Edges between nodes (undirected)
    const edges = [
      ['A', 'B'], ['A', 'D'], ['B', 'C'], ['B', 'E'],
      ['C', 'F'], ['D', 'E'], ['E', 'F'], ['E', 'G']
    ];

    // Build adjacency list
    const adjList = {};
    for (const node of nodes) {
      adjList[node.label] = [];
    }
    for (const [from, to] of edges) {
      adjList[from].push(to);
      adjList[to].push(from);
    }

    let bfsOrder = [];

    function runBFS() {
      bfsOrder = [];
      const visited = new Set();
      const queue = ['A'];
      visited.add('A');

      while (queue.length &gt; 0) {
        const current = queue.shift();
        bfsOrder.push(current);
        for (const neighbor of adjList[current]) {
          if (!visited.has(neighbor)) {
            visited.add(neighbor);
            queue.push(neighbor);
          }
        }
      }
      animateBFS(0);
    }

    // Animate BFS traversal by highlighting visited nodes
    function animateBFS(index) {
      if (index &gt;= bfsOrder.length) return;
      drawGraph(bfsOrder.slice(0, index + 1));
      setTimeout(() =&gt; animateBFS(index + 1), 800);
    }

    // Draw the graph with optional highlighted nodes
    function drawGraph(highlighted = []) {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // Draw edges
      ctx.strokeStyle = "#999";
      for (const [from, to] of edges) {
        const fromNode = nodes.find(n =&gt; n.label === from);
        const toNode = nodes.find(n =&gt; n.label === to);
        ctx.beginPath();
        ctx.moveTo(fromNode.x, fromNode.y);
        ctx.lineTo(toNode.x, toNode.y);
        ctx.stroke();
      }

      // Draw nodes
      for (const node of nodes) {
        ctx.beginPath();
        ctx.arc(node.x, node.y, 25, 0, 2 * Math.PI);
        ctx.fillStyle = highlighted.includes(node.label) ? "#27ae60" : "#3498db"; // green when visited
        ctx.fill();
        ctx.stroke();

        ctx.fillStyle = "#fff";
        ctx.font = "16px Arial";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText(node.label, node.x, node.y);
      }
    }

    drawGraph();
  &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</textarea> <iframe id="rvSSN" class="result_iframe" style="border:none;"></iframe>
 <script>{
const textarea = document.getElementById("AYWcl");
const iframe = document.getElementById("rvSSN");
const html = textarea.value;
const iframeHTML = `${html}`;
const doc = iframe.contentDocument || iframe.contentWindow.document;
doc.open();
doc.write(iframeHTML);
doc.close();
setTimeout(() => {
iframe.style.height = '0px';
const contentHeight = Math.max(
  doc.body.scrollHeight,
  doc.documentElement.scrollHeight
);
iframe.style.height = contentHeight + 'px';
}, 50);
}
		</script>
</div><h3 id="javascript-implementation">JavaScript Implementation</h3><p>Here's how you can implement BFS using an adjacency list representation of a graph:</p><div>
 <div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
  <pre><code class="language-js">class Graph {
  constructor() {
    this.adjList = new Map();
  }

  addVertex(vertex) {
    if (!this.adjList.has(vertex)) {
      this.adjList.set(vertex, []);
    }
  }

  addEdge(v1, v2) {
    this.addVertex(v1);
    this.addVertex(v2);
    this.adjList.get(v1).push(v2); // For undirected: also add v2 → v1
  }

  bfs(start) {
    const visited = new Set();
    const queue = [start];
    const result = [];

    visited.add(start);

    while (queue.length &gt; 0) {
      const current = queue.shift();
      result.push(current);

      for (const neighbor of this.adjList.get(current)) {
        if (!visited.has(neighbor)) {
          visited.add(neighbor);
          queue.push(neighbor);
        }
      }
    }

    return result;
  }
}
 
const g = new Graph();
g.addEdge("A", "B");
g.addEdge("A", "C");
g.addEdge("B", "D");
g.addEdge("C", "E");

console.log(g.bfs("A")); // Output: [ 'A', 'B', 'C', 'D', 'E' ]</code></pre>
 </div>
 <div class="snippet-container" id="b5YGy">
  <div class="snippet-header" onclick="toggleSnippetAndRefresh('b5YGy','wQWxr')">
   Try it in editor
  </div>
  <div class="snippet-body"><textarea id="wQWxr">class Graph {
  constructor() {
    this.adjList = new Map();
  }

  addVertex(vertex) {
    if (!this.adjList.has(vertex)) {
      this.adjList.set(vertex, []);
    }
  }

  addEdge(v1, v2) {
    this.addVertex(v1);
    this.addVertex(v2);
    this.adjList.get(v1).push(v2); // For undirected: also add v2 → v1
  }

  bfs(start) {
    const visited = new Set();
    const queue = [start];
    const result = [];

    visited.add(start);

    while (queue.length &gt; 0) {
      const current = queue.shift();
      result.push(current);

      for (const neighbor of this.adjList.get(current)) {
        if (!visited.has(neighbor)) {
          visited.add(neighbor);
          queue.push(neighbor);
        }
      }
    }

    return result;
  }
}
 
const g = new Graph();
g.addEdge("A", "B");
g.addEdge("A", "C");
g.addEdge("B", "D");
g.addEdge("C", "E");

console.log(g.bfs("A")); // Output: [ 'A', 'B', 'C', 'D', 'E' ]</textarea> <br> <button onclick="renderIframeForClientJavascript('wQWxr','Opo3i')">Run</button> <iframe id="Opo3i" class="result_iframe" style="display: none;"></iframe>
   <script>
  {let editor1 = CodeMirror.fromTextArea(document.getElementById("wQWxr"), {
    mode: "javascript",
    lineNumbers:false,
    tabSize: 2
    });
    const mode = localStorage.getItem("mode") || "light";  
    const newTheme = mode === "dark" ? "material" : "default";
    editor1.setOption("theme", newTheme);

   codeMirrorMap.set("wQWxr", editor1);}
  </script>
  </div>
 </div>
</div><h3 id="traversal-order-step-by-step">Traversal Order (Step-by-Step)</h3><p>Given the graph:</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-bash">A
  / \
 B   C
 |    \
 D     E</code></pre>
</div><p>Starting BFS from <code>"A"</code> would visit nodes in the following order:</p><ol>
 <li>Start with <code>A</code>, enqueue it → <code>[A]</code></li>
 <li>Visit <code>A</code>, enqueue <code>B</code>, <code>C</code> → <code>[B, C]</code></li>
 <li>Visit <code>B</code>, enqueue <code>D</code> → <code>[C, D]</code></li>
 <li>Visit <code>C</code>, enqueue <code>E</code> → <code>[D, E]</code></li>
 <li>Visit <code>D</code> → <code>[E]</code></li>
 <li>Visit <code>E</code> → <code>[]</code></li>
</ol><p>Result: <code>["A", "B", "C", "D", "E"]</code></p><h3 id="time-and-space-complexity">Time and Space Complexity</h3><ul>
 <li><strong>Time Complexity</strong>: O(V + E) Each node and edge is visited at most once.</li>
 <li><strong>Space Complexity</strong>: O(V) To store the queue and visited set.</li>
</ul><h3 id="real-world-use-cases">Real-World Use Cases</h3><ul>
 <li><p><strong>Shortest Path in Unweighted Graphs</strong>: BFS guarantees the shortest path (by edge count) from a source to all reachable nodes.</p></li>
 <li><p><strong>Social Network Analysis</strong>: Discover degrees of separation between people (e.g., "friend of a friend").</p></li>
 <li><p><strong>Peer-to-Peer Networking (e.g., BitTorrent)</strong>: Find closest peers efficiently.</p></li>
 <li><p><strong>Web Crawling</strong>: Explore all reachable links from a seed URL level-by-level.</p></li>
 <li><p><strong>GPS/Mapping (when edge weights are uniform)</strong>: Find the fastest path when all roads have equal weight.</p></li>
</ul><h3 id="bfs-vs-dfs-quick-note">BFS vs DFS (Quick Note)</h3><p>While <strong>DFS</strong> dives deep before backtracking, <strong>BFS</strong> expands outward layer by layer. This makes BFS better for <strong>finding the shortest path</strong>, while DFS can be more efficient for searching deeply nested structures or for <strong>cycle detection</strong>.</p><h3 id="summary">Summary</h3><p>Breadth-First Search is a cornerstone algorithm in graph theory and practical computing. Its use of a queue enables level-order traversal, which is especially powerful for solving <strong>shortest path problems in unweighted graphs</strong>. Whether you're building a web crawler, analyzing networks, or implementing a multiplayer game, mastering BFS in JavaScript gives you a solid foundation for solving real-world problems efficiently.</p><div class = "chapter-navi-section">
<a href="#top" class="nav-button prev">↑</a>
<a href='javascript-algorithms.htm#graphs-traversals' class="nav-button toc-link">Index</a>
<a href="#bottom" class="nav-button next">↓</a>
</div>
<h2 id='depth-first-search-dfs'>14.2 Depth-First Search (DFS)</h2><p><strong>Depth-First Search (DFS)</strong> is a graph traversal technique that explores as deeply as possible along a branch before backtracking. Unlike <strong>Breadth-First Search (BFS)</strong>, which explores neighbors level by level, DFS dives into one path and only reverses course when it hits a dead end. This nature of DFS makes it ideal for tasks that require full path exploration, such as <strong>cycle detection</strong>, <strong>topological sorting</strong>, and <strong>solving puzzles or mazes</strong>.</p><h3 id="how-dfs-works">How DFS Works</h3><p>DFS can be implemented in two ways:</p><ul>
 <li><strong>Recursively</strong>, using the call stack to manage traversal depth.</li>
 <li><strong>Iteratively</strong>, using an explicit <strong>stack</strong> to simulate recursion.</li>
</ul><p>DFS uses a "visited" set or map to avoid revisiting nodes and getting stuck in cycles.</p><div class="snippet-container" id="<!DOCTYPE html>
<html lang=&quot;en&quot;>
<head>
  <meta charset=&quot;UTF-8&quot;>
  <title>DFS Graph Visualization</title>
  <style>
    body { font-family: sans-serif; text-align: center; padding: 20px; }
    canvas { border: 1px solid #ccc; background: #f9f9f9; }
    button { font-size: 16px; padding: 8px 12px; margin: 10px; }
  </style>
</head>
<body>
  <h2>Depth-First Search (DFS) Visualization</h2>
  <button onclick=&quot;runDFS()&quot;>Run DFS</button>
  <canvas id=&quot;canvas&quot; width=&quot;600&quot; height=&quot;600&quot;></canvas>

  <script>
    const canvas = document.getElementById(&quot;canvas&quot;);
    const ctx = canvas.getContext(&quot;2d&quot;);

    const nodes = [
      { label: 'A', x: 150, y: 100 },
      { label: 'B', x: 300, y: 100 },
      { label: 'C', x: 450, y: 100 },
      { label: 'D', x: 150, y: 250 },
      { label: 'E', x: 300, y: 250 },
      { label: 'F', x: 450, y: 250 },
      { label: 'G', x: 300, y: 400 }
    ];

    const edges = [
      ['A', 'B'], ['A', 'D'], ['B', 'C'], ['B', 'E'],
      ['C', 'F'], ['D', 'E'], ['E', 'F'], ['E', 'G']
    ];

    const adjList = {};
    for (const node of nodes) {
      adjList[node.label] = [];
    }
    for (const [from, to] of edges) {
      adjList[from].push(to);
      adjList[to].push(from); // undirected graph
    }

    const visited = new Set();
    let dfsOrder = [];

    function runDFS() {
      visited.clear();
      dfsOrder = [];
      dfs('A');
      animateDFS(0);
    }

    function dfs(nodeLabel) {
      visited.add(nodeLabel);
      dfsOrder.push(nodeLabel);
      for (const neighbor of adjList[nodeLabel]) {
        if (!visited.has(neighbor)) {
          dfs(neighbor);
        }
      }
    }

    function animateDFS(index) {
      if (index >= dfsOrder.length) return;
      drawGraph(dfsOrder.slice(0, index + 1));
      setTimeout(() => animateDFS(index + 1), 800);
    }

    function drawGraph(highlighted = []) {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // Draw edges
      ctx.strokeStyle = &quot;#999&quot;;
      for (const [from, to] of edges) {
        const fromNode = nodes.find(n => n.label === from);
        const toNode = nodes.find(n => n.label === to);
        ctx.beginPath();
        ctx.moveTo(fromNode.x, fromNode.y);
        ctx.lineTo(toNode.x, toNode.y);
        ctx.stroke();
      }

      // Draw nodes
      for (const node of nodes) {
        ctx.beginPath();
        ctx.arc(node.x, node.y, 25, 0, 2 * Math.PI);
        ctx.fillStyle = highlighted.includes(node.label) ? &quot;#e74c3c&quot; : &quot;#3498db&quot;;
        ctx.fill();
        ctx.stroke();

        ctx.fillStyle = &quot;#fff&quot;;
        ctx.font = &quot;16px Arial&quot;;
        ctx.textAlign = &quot;center&quot;;
        ctx.textBaseline = &quot;middle&quot;;
        ctx.fillText(node.label, node.x, node.y);
      }
    }

    drawGraph();
  </script>
</body>
</html>ID"><textarea id="d3JxR" style="display: none;">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
  &lt;meta charset="UTF-8"&gt;
  &lt;title&gt;DFS Graph Visualization&lt;/title&gt;
  &lt;style&gt;
    body { font-family: sans-serif; text-align: center; padding: 20px; }
    canvas { border: 1px solid #ccc; background: #f9f9f9; }
    button { font-size: 16px; padding: 8px 12px; margin: 10px; }
  &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;h2&gt;Depth-First Search (DFS) Visualization&lt;/h2&gt;
  &lt;button onclick="runDFS()"&gt;Run DFS&lt;/button&gt;
  &lt;canvas id="canvas" width="600" height="600"&gt;&lt;/canvas&gt;

  &lt;script&gt;
    const canvas = document.getElementById("canvas");
    const ctx = canvas.getContext("2d");

    const nodes = [
      { label: 'A', x: 150, y: 100 },
      { label: 'B', x: 300, y: 100 },
      { label: 'C', x: 450, y: 100 },
      { label: 'D', x: 150, y: 250 },
      { label: 'E', x: 300, y: 250 },
      { label: 'F', x: 450, y: 250 },
      { label: 'G', x: 300, y: 400 }
    ];

    const edges = [
      ['A', 'B'], ['A', 'D'], ['B', 'C'], ['B', 'E'],
      ['C', 'F'], ['D', 'E'], ['E', 'F'], ['E', 'G']
    ];

    const adjList = {};
    for (const node of nodes) {
      adjList[node.label] = [];
    }
    for (const [from, to] of edges) {
      adjList[from].push(to);
      adjList[to].push(from); // undirected graph
    }

    const visited = new Set();
    let dfsOrder = [];

    function runDFS() {
      visited.clear();
      dfsOrder = [];
      dfs('A');
      animateDFS(0);
    }

    function dfs(nodeLabel) {
      visited.add(nodeLabel);
      dfsOrder.push(nodeLabel);
      for (const neighbor of adjList[nodeLabel]) {
        if (!visited.has(neighbor)) {
          dfs(neighbor);
        }
      }
    }

    function animateDFS(index) {
      if (index &gt;= dfsOrder.length) return;
      drawGraph(dfsOrder.slice(0, index + 1));
      setTimeout(() =&gt; animateDFS(index + 1), 800);
    }

    function drawGraph(highlighted = []) {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // Draw edges
      ctx.strokeStyle = "#999";
      for (const [from, to] of edges) {
        const fromNode = nodes.find(n =&gt; n.label === from);
        const toNode = nodes.find(n =&gt; n.label === to);
        ctx.beginPath();
        ctx.moveTo(fromNode.x, fromNode.y);
        ctx.lineTo(toNode.x, toNode.y);
        ctx.stroke();
      }

      // Draw nodes
      for (const node of nodes) {
        ctx.beginPath();
        ctx.arc(node.x, node.y, 25, 0, 2 * Math.PI);
        ctx.fillStyle = highlighted.includes(node.label) ? "#e74c3c" : "#3498db";
        ctx.fill();
        ctx.stroke();

        ctx.fillStyle = "#fff";
        ctx.font = "16px Arial";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText(node.label, node.x, node.y);
      }
    }

    drawGraph();
  &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</textarea> <iframe id="zAhPU" class="result_iframe" style="border:none;"></iframe>
 <script>{
const textarea = document.getElementById("d3JxR");
const iframe = document.getElementById("zAhPU");
const html = textarea.value;
const iframeHTML = `${html}`;
const doc = iframe.contentDocument || iframe.contentWindow.document;
doc.open();
doc.write(iframeHTML);
doc.close();
setTimeout(() => {
iframe.style.height = '0px';
const contentHeight = Math.max(
  doc.body.scrollHeight,
  doc.documentElement.scrollHeight
);
iframe.style.height = contentHeight + 'px';
}, 50);
}
		</script>
</div><h3 id="recursive-dfs-implementation-javascript">Recursive DFS Implementation (JavaScript)</h3><div>
 <div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
  <pre><code class="language-js">class Graph {
  constructor() {
    this.adjList = new Map();
  }

  addVertex(vertex) {
    if (!this.adjList.has(vertex)) {
      this.adjList.set(vertex, []);
    }
  }

  addEdge(v1, v2) {
    this.addVertex(v1);
    this.addVertex(v2);
    this.adjList.get(v1).push(v2);
    // For undirected: also this.adjList.get(v2).push(v1);
  }

  dfsRecursive(start) {
    const visited = new Set();
    const result = [];

    const dfs = (vertex) =&gt; {
      if (!vertex || visited.has(vertex)) return;
      visited.add(vertex);
      result.push(vertex);

      for (const neighbor of this.adjList.get(vertex)) {
        dfs(neighbor);
      }
    };

    dfs(start);
    return result;
  }
}
 
const g = new Graph();
g.addEdge("A", "B");
g.addEdge("A", "C");
g.addEdge("B", "D");
g.addEdge("C", "E");

console.log(g.dfsRecursive("A")); // Output: [ 'A', 'B', 'D', 'C', 'E' ]</code></pre>
 </div>
 <div class="snippet-container" id="z5odt">
  <div class="snippet-header" onclick="toggleSnippetAndRefresh('z5odt','aWKCo')">
   Try it in editor
  </div>
  <div class="snippet-body"><textarea id="aWKCo">class Graph {
  constructor() {
    this.adjList = new Map();
  }

  addVertex(vertex) {
    if (!this.adjList.has(vertex)) {
      this.adjList.set(vertex, []);
    }
  }

  addEdge(v1, v2) {
    this.addVertex(v1);
    this.addVertex(v2);
    this.adjList.get(v1).push(v2);
    // For undirected: also this.adjList.get(v2).push(v1);
  }

  dfsRecursive(start) {
    const visited = new Set();
    const result = [];

    const dfs = (vertex) =&gt; {
      if (!vertex || visited.has(vertex)) return;
      visited.add(vertex);
      result.push(vertex);

      for (const neighbor of this.adjList.get(vertex)) {
        dfs(neighbor);
      }
    };

    dfs(start);
    return result;
  }
}
 
const g = new Graph();
g.addEdge("A", "B");
g.addEdge("A", "C");
g.addEdge("B", "D");
g.addEdge("C", "E");

console.log(g.dfsRecursive("A")); // Output: [ 'A', 'B', 'D', 'C', 'E' ]</textarea> <br> <button onclick="renderIframeForClientJavascript('aWKCo','FXNlC')">Run</button> <iframe id="FXNlC" class="result_iframe" style="display: none;"></iframe>
   <script>
  {let editor1 = CodeMirror.fromTextArea(document.getElementById("aWKCo"), {
    mode: "javascript",
    lineNumbers:false,
    tabSize: 2
    });
    const mode = localStorage.getItem("mode") || "light";  
    const newTheme = mode === "dark" ? "material" : "default";
    editor1.setOption("theme", newTheme);

   codeMirrorMap.set("aWKCo", editor1);}
  </script>
  </div>
 </div>
</div><h3 id="iterative-dfs-using-a-stack">Iterative DFS Using a Stack</h3><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-js">dfsIterative(start) {
  const visited = new Set();
  const result = [];
  const stack = [start];

  while (stack.length &gt; 0) {
    const current = stack.pop();

    if (!visited.has(current)) {
      visited.add(current);
      result.push(current);

      // Add neighbors in reverse to maintain order
      for (const neighbor of [...this.adjList.get(current)].reverse()) {
        stack.push(neighbor);
      }
    }
  }

  return result;
}</code></pre>
</div><p>This version manually manages the stack. It's functionally similar to the recursive approach but avoids recursion depth limits (especially in large graphs).</p><h3 id="dfs-traversal-example">DFS Traversal Example</h3><p>Graph:</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-bash">A
  / \
 B   C
 |    \
 D     E</code></pre>
</div><p>DFS from <code>A</code> might visit: <code>A → B → D → C → E</code></p><p>Note: The exact traversal order may vary based on how neighbors are added.</p><h3 id="applications-of-dfs">Applications of DFS</h3><h4 id="cycle-detection">Cycle Detection</h4><p>In directed or undirected graphs, DFS can detect back edges, which indicate cycles. If a node is encountered again before the recursion unwinds, a cycle is present.</p><h4 id="maze-solving-puzzle-traversal">Maze Solving / Puzzle Traversal</h4><p>DFS can explore all possible paths through a structure like a maze or puzzle board. It naturally follows a path to the end before trying alternatives.</p><h4 id="topological-sorting">Topological Sorting</h4><p>In Directed Acyclic Graphs (DAGs), DFS is used to order tasks where some must come before others. For example, course scheduling or build systems.</p><h4 id="connected-components">Connected Components</h4><p>By running DFS from unvisited nodes, we can find all separate components in an undirected graph, useful in clustering or segmentation problems.</p><h3 id="time-and-space-complexity">Time and Space Complexity</h3><ul>
 <li><p><strong>Time Complexity</strong>: O(V + E) Each node and edge is visited once.</p></li>
 <li><p><strong>Space Complexity</strong>:</p>
  <ul>
   <li>Recursive: O(V) call stack (worst case)</li>
   <li>Iterative: O(V) stack + visited set</li>
  </ul></li>
</ul><h3 id="summary">Summary</h3><p><strong>Depth-First Search</strong> is a flexible and powerful traversal strategy that excels when you need to explore paths fully, backtrack, or analyze graph structures. Both <strong>recursive and iterative</strong> implementations are easy to express in JavaScript and have wide-ranging applications, from solving puzzles to analyzing dependencies in systems. Understanding DFS equips you to handle complex graph problems with depth-oriented logic and elegant solutions.</p><div class = "chapter-navi-section">
<a href="#top" class="nav-button prev">↑</a>
<a href='javascript-algorithms.htm#graphs-traversals' class="nav-button toc-link">Index</a>
<a href="#bottom" class="nav-button next">↓</a>
</div>
<h2 id='applications-pathfinding-web-crawling'>14.3 Applications (Pathfinding, Web Crawling)</h2><p>Both <strong>Breadth-First Search (BFS)</strong> and <strong>Depth-First Search (DFS)</strong> are foundational algorithms for traversing graphs. While their mechanisms differ—BFS explores <strong>level by level</strong>, and DFS explores <strong>deep before wide</strong>—they each shine in different real-world tasks. This section explores their applications in two major areas: <strong>pathfinding</strong> and <strong>web crawling</strong>.</p><h3 id="pathfinding-in-maps-and-mazes">Pathfinding in Maps and Mazes</h3><h4 id="use-case-finding-the-shortest-route-in-a-grid-or-maze">Use Case: Finding the shortest route in a grid or maze.</h4><p><strong>BFS</strong> is ideal for this because it explores all nodes at a given distance before moving deeper. In an <strong>unweighted grid</strong>, the first time BFS reaches a target cell guarantees the shortest path (by number of steps).</p><h4 id="example-shortest-path-in-a-grid-bfs">Example: Shortest Path in a Grid (BFS)</h4><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-js">function bfsShortestPath(grid, start, end) {
  const rows = grid.length;
  const cols = grid[0].length;
  const directions = [[0,1],[1,0],[0,-1],[-1,0]];
  const visited = Array.from({ length: rows }, () =&gt; Array(cols).fill(false));
  const queue = [[...start, 0]]; // [row, col, steps]

  while (queue.length &gt; 0) {
    const [r, c, steps] = queue.shift();
    if (r === end[0] &amp;&amp; c === end[1]) return steps;
    if (visited[r][c]) continue;
    visited[r][c] = true;

    for (const [dr, dc] of directions) {
      const nr = r + dr, nc = c + dc;
      if (nr &gt;= 0 &amp;&amp; nc &gt;= 0 &amp;&amp; nr &lt; rows &amp;&amp; nc &lt; cols &amp;&amp; grid[nr][nc] === 0) {
        queue.push([nr, nc, steps + 1]);
      }
    }
  }

  return -1; // No path
}</code></pre>
</div><p>Here, the grid is a 2D array where <code>0</code> is a walkable cell and <code>1</code> is a wall. BFS ensures the shortest route is found.</p><h3 id="web-crawling-and-site-traversal">Web Crawling and Site Traversal</h3><h4 id="use-case-visiting-all-linked-pages-from-a-starting-url">Use Case: Visiting all linked pages from a starting URL.</h4><p>Web pages form a graph—nodes are pages, and edges are hyperlinks. <strong>DFS</strong> is often used in basic crawlers for <strong>deep exploration</strong>, while <strong>BFS</strong> can be used when limiting the crawl to a particular depth or breadth.</p><h4 id="example-simulated-web-crawler-dfs">Example: Simulated Web Crawler (DFS)</h4><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-js">function crawl(url, graph, visited = new Set()) {
  if (visited.has(url)) return;
  console.log("Crawling:", url);
  visited.add(url);

  for (const link of graph[url] || []) {
    crawl(link, graph, visited);
  }
}

// Simulated web
const web = {
  "home": ["about", "contact"],
  "about": ["team", "home"],
  "team": [],
  "contact": ["home"]
};

crawl("home", web);</code></pre>
</div><p>This recursively visits all linked pages starting from <code>"home"</code>, preventing cycles using a <code>Set</code>.</p><h3 id="choosing-bfs-vs-dfs">Choosing BFS vs DFS</h3><table>
 <thead>
  <tr>
   <th>Task</th>
   <th>Best Fit</th>
   <th>Reason</th>
  </tr>
 </thead>
 <tbody>
  <tr>
   <td>Shortest path (unweighted)</td>
   <td><strong>BFS</strong></td>
   <td>Guarantees the shortest number of steps</td>
  </tr>
  <tr>
   <td>Maze solving (any path)</td>
   <td><strong>DFS</strong></td>
   <td>Finds any path, potentially faster with pruning</td>
  </tr>
  <tr>
   <td>Web crawling</td>
   <td><strong>DFS</strong>/<strong>BFS</strong></td>
   <td>DFS for depth, BFS for breadth or max-depth limits</td>
  </tr>
  <tr>
   <td>Connected components</td>
   <td><strong>DFS</strong></td>
   <td>Efficient for grouping related nodes</td>
  </tr>
 </tbody>
</table><h3 id="performance-trade-offs">Performance &amp; Trade-offs</h3><ul>
 <li><strong>BFS</strong> uses more memory since it stores all neighbors at the current depth.</li>
 <li><strong>DFS</strong> is lighter in memory but may go deep unnecessarily if not guided.</li>
 <li>For huge or infinite graphs (like the web), adding depth limits or priority rules is essential.</li>
</ul><h3 id="summary">Summary</h3><p>BFS and DFS both power a wide range of real-world applications. Use <strong>BFS</strong> when you care about <strong>minimal steps</strong> or <strong>shortest paths</strong> (like in maps and routing), and use <strong>DFS</strong> when you need <strong>complete exploration</strong> or are working with <strong>structured, tree-like data</strong> (like site maps or puzzle paths). With flexible JavaScript implementations and clear trade-offs, these algorithms are powerful tools in your problem-solving toolkit.</p><div class = "chapter-navi-section">
<a href="javascript-algorithms-graph-representations.htm" class="nav-button prev">←</a>
<a href='javascript-algorithms.htm#graphs-traversals' class="nav-button toc-link">Index</a>
<a href="javascript-algorithms-graph-shortest-paths.htm" class="nav-button next">→</a>
</div>
<section class="download-section">
  <div class="book-cover" style="background-color: #f9f6f1;border: 1px solid #ccc;"> 
    <div class="book-cover-title" style="font-size: 18px;color: #333;top: 20px;">JavaScript Algorithms</div>
    <div class="book-cover-author">readbytes</div>
    <div class="book-cover-bottom-stripe" style="background-color: #333;"></div>
    <img class="book-cover-icon" style="width: 80px;height: 80px;top: 70px;" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFoAAABaCAYAAAA4qEECAAAErElEQVR4Xu2dPWgUQRiGo6BB8I+AlV3w9gzptLBWsLQ89O7ARrDXSivTCTaCnWhn7pQTxOoInpjCeEQQLC2CjVqoVSwMFpp1Jtzo7Luzs/Nd7uZ29r4HPpDsu7vPvIl7+SGTmRmGYRiGYZjCEzVacdnn9NX7+3DdXkGhMg+u3Su6SNztzsZvevH/efED8zrJbM+6EGJ2K5Hv9w9gRpHnXMyik2VsYVaHWJx7tt/bTOQ3urOYUch3QJ5z0YtOCeuQiqNlvybyto/ktbVDcG2jc5GLNgoriMW5Z/svPyfy693DmFHE71ePwrUznQta9ISeyViyKBIziri/Mpe8tt25kEXjMR1ScbQsPC5W5jCjMJT8DTM6MuO6vrHjIkIszj2LL3y2ktOPiy+Y0VE5l/V5IU+EVBwtm/wUzva4SL/wOZUsJ2993rCJEIujZJMl2174Up/C5T8u9LGtzyu6SNkH1+6VhUargkJlHVy7f5aW9qJUqeZy5zguufToBeAxZoRw0Z7goj3BRXuCi/YEF+0BvWQue0xgwfrMiy+aMM8QEUW+w2IHb8fC/+C5jCOGMhOPiqi+vG47zjiABVbr7XOYUWC2Um+fxwwDiKJeYXGYMYHniNnGDDPAUJZTyYph30nTg+G7f5VLj89gzBW8lu2xMzWIIt5iMZgZBrzmqK4bJFhENOLnatRsfcR7YKb0YAELF5+cwsyowHudrLcvYKZ0iIV+wIVjZhzgPaMR/+8pFIbFeilZUWm2Vyd5/5GxWOvsx4VkTbXROovn+wJdMqfevoHnFoKUaMbgeZMAnbIGzysEKGmZiX4DKKo/um5wMg6eWwhsgtVm62cRFoEOJg/xtltZxwqBTV4inuEHcZHztc4RzI0LvLeY15iRBF+0wrDgsX6qZXpUYEanNEVLROY3ZfHDgvdwuU+pipYs1h7OpUqI4z2YGxa8dqXefooZE6UrWoGFiMn8nRIXoubyTbymeLPzO7C0RUuiRvuXoRwyeI1hrlPqoiUnap1jWNLilU7mr0sgeK746rOFGRdKX7QCC4tyHiXi+DU8BzMUpqZoiSzXpTzMZOUoTFXROxh+xKV/gYPHqvVlp88q8pi+ogdgoabBc3bD1BYtEdfcxnLHeK/pLVoiHxvJktsPMDMKpr5oX3DRnuCiPcFFe4KL9gQX7Qku2hNctCe4aE94K1puD6mXNsmpOv74KUTnxEdmEQb9TOA5kx70M6KfcO/u8/j2nWffxb+XskZm9MHjw2YjgrTKygnFeUaF5cSEjZ4c9kJyz/Z7mxTpEJ0T0nhMhyRBy+5sTuXioAjR2UmaKEHJ/tsBLM9BJ0TnXGmiBCWb2GbN5oCE6GyVJkq4Z3FXxo3ubJaDiRCdM6VJErSscTtik0MWITobpYkS7lncKVfblREdbITonJImSVCyKAz7i1KkQ3ROSJMkaNnc7Ygp0iE6Z0pjTockjC8iBmEJRTpEZ6M0ZnRIwrhTrmU7Yop0iM4paTyusyvhnO2IKdIhOqdeWLLYlbDtL0oM/jaKi4MiRGcnaZIwPt8c/zZKnoNOiM4J6SIM+pnAcyY96GekYJtvf0I/EyE6MwzDMAzDjI+/5MPGam/zucIAAAAASUVORK5CYII="/>
  </div>
  <div class="download-info">
    <h2 id='bottom'>Download This Ebook</h2>
    <p class="format-label">Available formats:</p>
    <div class="download-buttons">
      <a href="javascript-algorithms.pdf" class="download-button">📄 PDF</a>
      <a href="javascript-algorithms.epub" class="download-button">📘 EPUB</a>
    </div>
  </div>
</section><div class='related-books'>
<h2>Java Introduction Books</h2>
<div class='related-book-list'>
<a href="javascript-algorithms.htm">
<div class="book-cover" style="background-color: #f9f6f1;border: 1px solid #ccc;"> 
    <div class="book-cover-title" style="font-size: 18px;color: #333;top: 20px;">JavaScript Algorithms</div>
    <div class="book-cover-author">readbytes</div>
    <div class="book-cover-bottom-stripe" style="background-color: #333;"></div>
    <img class="book-cover-icon" style="width: 80px;height: 80px;top: 70px;" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFoAAABaCAYAAAA4qEECAAAErElEQVR4Xu2dPWgUQRiGo6BB8I+AlV3w9gzptLBWsLQ89O7ARrDXSivTCTaCnWhn7pQTxOoInpjCeEQQLC2CjVqoVSwMFpp1Jtzo7Luzs/Nd7uZ29r4HPpDsu7vPvIl7+SGTmRmGYRiGYZjCEzVacdnn9NX7+3DdXkGhMg+u3Su6SNztzsZvevH/efED8zrJbM+6EGJ2K5Hv9w9gRpHnXMyik2VsYVaHWJx7tt/bTOQ3urOYUch3QJ5z0YtOCeuQiqNlvybyto/ktbVDcG2jc5GLNgoriMW5Z/svPyfy693DmFHE71ePwrUznQta9ISeyViyKBIziri/Mpe8tt25kEXjMR1ScbQsPC5W5jCjMJT8DTM6MuO6vrHjIkIszj2LL3y2ktOPiy+Y0VE5l/V5IU+EVBwtm/wUzva4SL/wOZUsJ2993rCJEIujZJMl2174Up/C5T8u9LGtzyu6SNkH1+6VhUargkJlHVy7f5aW9qJUqeZy5zguufToBeAxZoRw0Z7goj3BRXuCi/YEF+0BvWQue0xgwfrMiy+aMM8QEUW+w2IHb8fC/+C5jCOGMhOPiqi+vG47zjiABVbr7XOYUWC2Um+fxwwDiKJeYXGYMYHniNnGDDPAUJZTyYph30nTg+G7f5VLj89gzBW8lu2xMzWIIt5iMZgZBrzmqK4bJFhENOLnatRsfcR7YKb0YAELF5+cwsyowHudrLcvYKZ0iIV+wIVjZhzgPaMR/+8pFIbFeilZUWm2Vyd5/5GxWOvsx4VkTbXROovn+wJdMqfevoHnFoKUaMbgeZMAnbIGzysEKGmZiX4DKKo/um5wMg6eWwhsgtVm62cRFoEOJg/xtltZxwqBTV4inuEHcZHztc4RzI0LvLeY15iRBF+0wrDgsX6qZXpUYEanNEVLROY3ZfHDgvdwuU+pipYs1h7OpUqI4z2YGxa8dqXefooZE6UrWoGFiMn8nRIXoubyTbymeLPzO7C0RUuiRvuXoRwyeI1hrlPqoiUnap1jWNLilU7mr0sgeK746rOFGRdKX7QCC4tyHiXi+DU8BzMUpqZoiSzXpTzMZOUoTFXROxh+xKV/gYPHqvVlp88q8pi+ogdgoabBc3bD1BYtEdfcxnLHeK/pLVoiHxvJktsPMDMKpr5oX3DRnuCiPcFFe4KL9gQX7Qku2hNctCe4aE94K1puD6mXNsmpOv74KUTnxEdmEQb9TOA5kx70M6KfcO/u8/j2nWffxb+XskZm9MHjw2YjgrTKygnFeUaF5cSEjZ4c9kJyz/Z7mxTpEJ0T0nhMhyRBy+5sTuXioAjR2UmaKEHJ/tsBLM9BJ0TnXGmiBCWb2GbN5oCE6GyVJkq4Z3FXxo3ubJaDiRCdM6VJErSscTtik0MWITobpYkS7lncKVfblREdbITonJImSVCyKAz7i1KkQ3ROSJMkaNnc7Ygp0iE6Z0pjTockjC8iBmEJRTpEZ6M0ZnRIwrhTrmU7Yop0iM4paTyusyvhnO2IKdIhOqdeWLLYlbDtL0oM/jaKi4MiRGcnaZIwPt8c/zZKnoNOiM4J6SIM+pnAcyY96GekYJtvf0I/EyE6MwzDMAzDjI+/5MPGam/zucIAAAAASUVORK5CYII="/>
  </div>
</a>



<a href='java.htm'><div class='book-cover' style='background-color: #f9f6f1;color: #111111;border: 1px solid #ccc;display: flex;justify-content: center;align-items: center;text-align: center;'>More Java Books</div></a>
</div>
</div>
  </div>
  <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/prism.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
  
  <script>
    function copyCode(button) {
      const code = button.nextElementSibling.innerText;
      navigator.clipboard.writeText(code).then(() => {
        button.textContent = 'Copied!';
        setTimeout(() => { button.textContent = 'Copy'; }, 1500);
      });
    }
  </script>  
<div id="floatingLog" aria-live="polite" role="alert"></div>
<footer class="page-footer">
    <nav>
      <a href="https://readbytes.github.io">Home</a> | 
      Email:<script language="JavaScript" type="text/javascript">
var part1 = 'yinpeng';var part6 = '263';var part2 = Math.pow(2,6);var part3 = String.fromCharCode(part2);var part4 = 'hotmail dot com';var part5 = part1 + String.fromCharCode(part2) + part4;document.write(part1 + part6 + part3 + part4);
</script>
    </nav>
  <p>© 2025 — All rights reserved.</p>    
  </footer>

</body>
</html>