<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>JavaScript Algorithms Backtracking and Recursion</title>
<link rel='shortcut icon' href='https://java2s.com/style/favicon.ico'>
<link href="https://fonts.googleapis.com/css2?family=Merriweather&display=swap" rel="stylesheet" />
<link href="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet" />

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/codemirror.min.css" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/theme/material.css"> <!-- Dark theme -->
<script src="https://cdn.jsdelivr.net/npm/typescript@5/lib/typescript.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/codemirror.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/mode/htmlmixed/htmlmixed.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/mode/xml/xml.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/mode/css/css.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/mode/javascript/javascript.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/mode/javascript/typescript.min.js"></script>
<style>
    #floatingLog {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(20, 20, 20, 0.95);
      color: white;
      font-family: monospace;
      font-size: 14px;
      padding: 16px 20px;
      border-radius: 8px;
      box-shadow: 0 4px 16px rgba(0, 0, 0, 0.4);
      max-width: 80%;
      max-height: 200px;
      overflow-y: auto;
      display: none;
      z-index: 9999;
      pointer-events: none;
      white-space: pre-wrap;
      text-align: center;
    }
</style>
<script>
  const codeMirrorMap = new Map();
  const iframeMap = new Map();
  
 

  let dismissTimer;
  function showFloatingLog(message) {
	const floatingLog = document.getElementById('floatingLog');

    if (floatingLog.style.display !== 'block') {
      floatingLog.textContent = '';
      floatingLog.style.display = 'block'; 
    }

    floatingLog.textContent += message + '\n';
    floatingLog.scrollTop = floatingLog.scrollHeight; 
    clearTimeout(dismissTimer);
    dismissTimer = setTimeout(() => {
      floatingLog.style.display = 'none';
      floatingLog.textContent = '';
    }, 2000);
  }
  window.addEventListener('message', (event) => {
	    if (!iframeMap.has(event.source)) return;

	    if (event.data?.type === 'console-log') {
	      showFloatingLog(event.data.message);
	    }
  });  
  function renderIframe(button,textarea_id, iframe_id) {
      const html = codeMirrorMap.get(textarea_id).getValue();
      const iframe = document.getElementById(iframe_id);
  
      const oldIframe = iframe;
      const newIframe = document.createElement('iframe');
      newIframe.className ="result_iframe";
      
      newIframe.id = iframe_id;
      oldIframe.replaceWith(newIframe);
 

      // Track the iframe in the map
      iframeMap.set(newIframe.contentWindow, button);

      const overrideScript = `
        <script>
          (function() {
            const originalLog = console.log;
            console.log = function(...args) {
              originalLog.apply(console, args);
              window.parent.postMessage({
                type: 'console-log',
                message: args.map(a => {
                  try { return JSON.stringify(a); }
                  catch { return String(a); }
                }).join(' ')
              }, '*');
            };
          })();
        <\/script>
      `;

      const iframeHTML = `
        <!DOCTYPE html>
        <html>
        <body>
          ${overrideScript}
          ${html}
        </body>
        </html>
      `;
 
      const doc = newIframe.contentDocument || newIframe.contentWindow.document;
      doc.open();
      doc.write(iframeHTML);
      doc.close();

      
  }
  function renderIframeForClientTypescript(textarea_id, iframe_id) {
      let code = codeMirrorMap.get(textarea_id).getValue();
      code = ts.transpile(code);
      const iframe = document.getElementById(iframe_id);
      const doc = iframe.contentDocument || iframe.contentWindow.document;

const html = `
  <!DOCTYPE html>
  <html>
    <head>
      <title>Output</title>
      <style>
        body { font-family: monospace; padding: 1em; background: #f4f4f4; color: #222; }
        pre { white-space: pre-wrap; word-break: break-word; }
        .error { color: red; }
      </style>
    </head>
    <body>
      <pre id="log"></pre>
      <script>
        (function(){
          const logEl = document.getElementById('log');
          const origLog = console.log;
          const origError = console.error;

          console.log = (...args) => {
            logEl.textContent += args.join(' ') + '\\n';
            origLog.apply(console, args);
          };
          console.table = (...args) => {
            logEl.textContent += args.join(' ') + '\\n';
            origLog.apply(console, args);
          };

          console.error = (...args) => {
            logEl.innerHTML +='<span class="error">' + args.join(' ') + '</span>';
            origError.apply(console, args);
          };
          window.addEventListener("error", function (event) {
              console.error("Caught by event listener:", event.message);
          });    
          try {             
              ${code};
          } catch (err) {
            console.error(err.stack || err.message);
          }
        })();
      <\/script>
    </body>
  </html>
`;

      iframe.style.display = "block";
      iframe.srcdoc = html;  
  }

    function renderIframeForClientJavascript(textarea_id, iframe_id) {
        const code = codeMirrorMap.get(textarea_id).getValue();
        const iframe = document.getElementById(iframe_id);
        const doc = iframe.contentDocument || iframe.contentWindow.document;

  const html = `
    <!DOCTYPE html>
    <html>
      <head>
        <title>Output</title>
        <style>
          body { font-family: monospace; padding: 1em; background: #1e1e1e; color: #eee; }
          pre { white-space: pre-wrap; word-break: break-word; }
          .error { color: red; }
        </style>
      </head>
      <body>
        <pre id="log"></pre>
        <script>
          (function(){
            const logEl = document.getElementById('log');
            const origLog = console.log;
            const origError = console.error;

            console.log = (...args) => {
              logEl.textContent += args.join(' ') + '\\n';
              origLog.apply(console, args);
            };
            console.table = (...args) => {
              logEl.textContent += args.join(' ') + '\\n';
              origLog.apply(console, args);
            };

            console.error = (...args) => {
              logEl.innerHTML +='<span class="error">' + args.join(' ') + '</span>';
              origError.apply(console, args);
            };
            window.addEventListener("error", function (event) {
                console.error("Caught by event listener:", event.message);
            });    
            try {
             ${code}; 
            } catch (err) {
              console.error(err.stack || err.message);
            }
          })();
        <\/script>
      </body>
    </html>
  `;
        iframe.style.display = "block";
        iframe.srcdoc = html;  
    }
    function toggleSnippetAndRefresh(id, textarea_id) {
      const box = document.getElementById(id);
      box.classList.toggle("open");
      codeMirrorMap.get(textarea_id).refresh();
    }

  </script>
  <script>
  const mode = localStorage.getItem('mode') || 'light';
  document.documentElement.classList.add(`${mode}-mode`);
  </script>   
<style> 
html {
  scroll-behavior: smooth;
}

body {
  font-family: 'Merriweather', serif;
  margin: 0;
  padding: 2rem 1rem;
  font-size: 15px;
  line-height: 1.5;
  transition: background-color 0.3s, color 0.3s;
}

.container {
  max-width: 700px;
  margin: 0 auto;
  padding: 1rem 2rem;
  box-shadow: 0 0 15px rgba(0,0,0,0.1);
}

h1, h2, h3 {
  font-weight: 600;
  margin-top: 2.5rem;
  margin-bottom: 1rem;
  line-height: 1.2;
}

h1 { font-size: 1.8rem; }
h2 { font-size: 1.4rem; }
h3 { font-size: 1.2rem; }

table {
  width: 100%;
  border-collapse: collapse;
  font-family: sans-serif;
  font-size: 1em;
  margin: 1em 0;
}

th, td {
  padding: 0.6em 1em;
  text-align: left;
  border: 1px solid;
}

tr:nth-child(even) {
  background-color: inherit;
}

tr:hover {
  background-color: inherit;
}

a {
  text-decoration: none;
  transition: color 0.2s;
}

a:hover {
  text-decoration: underline;
}

code {
  color: #d35400;
}

.book-title-chapter {
  font-family: 'Merriweather', serif;
  font-size: 2rem;
  font-weight: bold;
  text-align: center;
  margin-bottom: 2rem;
  border-bottom: 2px solid;
  padding-bottom: 0.5rem;
}

.book-subtitle-chapter {
  text-align: center;
  font-size: 1rem;
  margin-top: -1rem;
  margin-bottom: 2rem;
}

.related-books {
  margin-top: 40px;
}

.related-book-list {
  display: flex;
  flex-wrap: wrap;
  gap: 20px;
}

    .book-cover {
      width: 130px;
      height: 180px;
      font-family: Arial, sans-serif;
      position: relative;
      overflow: hidden;      
      line-height: normal;
      box-shadow: 2px 2px 4px rgba(0,0,0,0.1);
    }
    .book-cover-bottom-stripe {
      position: absolute;
      bottom: 0;
      left: 0;
      height: 5px;
      width: 100%;
    }
    .book-cover-title {
      position: absolute;
      width: 100%;
      text-align: center;
      font-weight: bold;
    }
     
    .book-cover-icon {
      position: absolute;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      align-items: center;
      justify-content: center; 
    }

    .book-cover-author {
      position: absolute;
      bottom: 10px;
      width: 100%;
      text-align: center;
      font-size: 8px;
      color: #333;
    }

.page-footer {
  margin-top: 4rem;
  padding: 1rem 0;
  text-align: center;
  font-size: 0.85rem;
  border-top: 1px solid;
}

.chapter-navi-section {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding-bottom: 10px;
}

.nav-link {
  color: inherit;
  text-decoration: none;
  opacity: 0.5;
  transition: opacity 0.3s ease, text-decoration 0.3s ease;
}

.nav-link:hover {
  opacity: 0.9;
  text-decoration: underline;
}

.prev { text-align: left; }
.toc-link { text-align: center; }
.next { text-align: right; }

.download-section {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 2rem;
  padding: 2rem 1rem;
  max-width: 600px;
  margin: 3rem auto;
  border-radius: 12px;
  box-shadow: 0 4px 10px rgba(0,0,0,0.05);
}

.download-info h2 {
  margin: 0 0 0.5rem;
  font-size: 1.2rem;
}

.format-label {
  margin: 0 0 0.5rem;
  font-size: 0.95rem;
}

.download-buttons {
  display: flex;
  gap: 1rem;
}

.download-button {
  background-color: #4A90E2;
  color: white;
  padding: 0.5em 1.2em;
  border-radius: 25px;
  font-size: 0.95rem;
  text-decoration: none;
  transition: background-color 0.3s ease;
}

.download-button:hover {
  background-color: #357ABD;
}

.code-block {
  position: relative;
  margin-bottom: 1em;
}

.copy-button {
  background: transparent;
  color: white;
  position: absolute;
  top: 8px;
  right: 8px;
  border: none;
  padding: 4px 8px;
  font-size: 12px;
  border-radius: 4px;
  cursor: pointer;
  z-index: 1;
}

.copy-button:hover {
  background-color: #0056b3;
}

.snippet-container {
  overflow: hidden;
}

.snippet-header {
  padding: 0.75rem 1rem;
  cursor: pointer;
  font-size: 1rem;
    background-color: #eeeeee;
    color:  #111111; 
    border-radius: 8px;
    cursor: pointer;
    box-shadow: 0 4px 6px rgba(0,0,0,0.1);  
}

.snippet-body {
  display: none;
  font-family: monospace;
}

.snippet-container.open .snippet-body {
  display: block;
}

.CodeMirror {
  border: 2px solid #ccc;
  border-radius: 4px;
  resize: vertical;
}

/* === Light Mode === */
html.light-mode {
  background-color: #f8f7f5;
  color: #333;
}

html.light-mode .container {
  background: white;
}

html.light-mode .book-title-chapter {
  color: #2c3e50;
  border-color: #ccc;
}
html.light-mode .book-subtitle-chapter{
  color: #888;
}

html.light-mode .page-footer,
html.light-mode .series-name,
html.light-mode .book-subtitle,
html.light-mode .format-label {
  color: #888;
}

html.light-mode .related-books h2 {
  color: #333;
  border-bottom: 2px solid #eee;
}

html.light-mode .book-title {
  color: #fff;
}

html.light-mode .book-cover {
  border: 1px solid #ccc;
}

html.light-mode th {
  background-color: #f2f2f2;
}

html.light-mode tr:nth-child(even) {
  background-color: #fafafa;
}

html.light-mode tr:hover {
  background-color: #e6f7ff;
}

html.light-mode a,
html.light-mode .page-footer a {
  color: #000;
}

/* === Dark Mode === */
html.dark-mode {
  background-color: #181818;
  color: #e0e0e0;
}

html.dark-mode .container {
  background: #222;
}

html.dark-mode .book-title-chapter {
  color: #ddd;
  border-color: #444;
}

html.dark-mode .snippet-header {
    background-color: #333;
    color:  #ddd; 
}


html.dark-mode .book-subtitle-chapter,
html.dark-mode .page-footer,
html.dark-mode .series-name,
html.dark-mode .book-subtitle,
html.dark-mode .book-footer,
html.dark-mode .format-label {
  color: #aaa;
}

html.dark-mode .related-books h2 {
  color: #ddd;
  border-bottom: 2px solid #333;
}

html.dark-mode .book-title {
  color: #fff;
}

html.dark-mode .book-cover {
  border: 1px solid #555;
}

html.dark-mode th {
  background-color: #333;
  color: #fff;
}

html.dark-mode td {
  border-color: #444;
}

html.dark-mode tr:nth-child(even) {
  background-color: #2a2a2a;
}

html.dark-mode tr:hover {
  background-color: #2c3e50;
}

html.dark-mode a,
html.dark-mode .page-footer a {
  color: #eee;
}

    .dialog-backdrop {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: rgba(0,0,0,0.5);
      display: none;
      justify-content: center;
      align-items: center;
      z-index: 10;
    }

    .dialog {
      background: white;
      padding: 20px;
      width: 90vw;
      height: 80vh;
      border-radius: 8px;
      box-shadow: 0 0 20px rgba(0,0,0,0.3);
      display: flex;
      flex-direction: column;
    }
    .dialog-content {
      display: flex;
      flex: 1;
      gap: 20px;
      margin-top: 10px;
    }
    .dialog h2 {
      margin-top: 0;
    }

    .textarea_dialog {
      width: 50%;
      height: 100%;
      resize: none;
      font-family: monospace;
      font-size: 14px;
      padding: 10px;
      box-sizing: border-box;
      border: 1px solid #ccc;
    }

    .iframe_dialog {
      width: 50%;
      height: 100%;
      border: 1px solid #ccc;
    }
    .controls_dialog {
      display: flex;
      justify-content: space-between;
      margin-top: 10px;
    }    
    button { padding: 0.5em 1em; background: green; color: white; border: none; cursor: pointer; }
    button:hover { background: #1e7e34; }
    .result_iframe { width:99%; height:200px; margin-top: 1em;  resize: both;border:1px solid #ccc;}        
</style>
</head>
<body> 
  <div class="container">
    <div class = "chapter-navi-section">
<a href="javascript-algorithms-greedy-algorithms.htm" class="nav-button prev">←</a>
<a href='javascript-algorithms.htm#backtracking-and-recursion' class="nav-button toc-link">Index</a>
<a href="javascript-algorithms-real-world-applications.htm" class="nav-button next">→</a>
</div>

    <h1 class="book-title-chapter" id = 'top'>Backtracking and Recursion</h1>
    <h3 class="book-subtitle-chapter">JavaScript Algorithms</h3>   
    <!-- <h1 class ="chapter-title"></h1> -->
    <h2 id='combinatorial-problems'>20.1 Combinatorial Problems</h2><p>Combinatorial problems are a rich and challenging class of problems where the goal is to explore <strong>all possible configurations</strong> of a given set — such as all subsets, all permutations, or all ways to arrange objects under certain constraints. These problems often involve generating combinations, selecting elements in different orders, or arranging pieces to meet specific goals.</p><p>Such problems are inherently <strong>exponential in nature</strong>. For example, the number of subsets of a set with <code>n</code> elements is <code>2^n</code>, and the number of permutations is <code>n!</code>. This makes brute-force approaches inefficient unless guided by smart techniques that reduce redundant computation.</p><p>One powerful method for solving combinatorial problems is <strong>backtracking</strong> — a form of controlled recursion that builds solutions step-by-step and <strong>abandons paths</strong> that can’t possibly lead to a valid solution.</p><h3 id="what-is-backtracking">What Is Backtracking?</h3><p>Backtracking is a <strong>recursive algorithmic paradigm</strong> used for problems where we build candidates for solutions incrementally, and discard a candidate ("backtrack") as soon as we determine it cannot possibly be part of the final solution.</p><p>Backtracking can be seen as a <strong>depth-first search</strong> through a decision tree:</p><ul>
 <li>At each level, make a choice from available options.</li>
 <li>Recursively explore that path.</li>
 <li>If the path is invalid or complete, <strong>undo</strong> the choice and try the next.</li>
</ul><p>This technique significantly reduces the number of recursive calls in problems with constraints or invalid states.</p><h3 id="example-1-generating-all-subsets">Example 1: Generating All Subsets</h3><p>Let’s start with a classic problem: generating all subsets (also called the power set) of a given array.</p><div>
 <div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
  <pre><code class="language-js">function generateSubsets(nums) {
  const result = [];

  function backtrack(start, path) {
    result.push([...path]); // Add current subset to result

    for (let i = start; i &lt; nums.length; i++) {
      path.push(nums[i]);             // Choose
      backtrack(i + 1, path);         // Explore
      path.pop();                     // Un-choose (backtrack)
    }
  }

  backtrack(0, []);
  return result;
}

// Example
console.log(generateSubsets([1, 2, 3]));</code></pre>
 </div>
 <div class="snippet-container" id="HPtzD">
  <div class="snippet-header" onclick="toggleSnippetAndRefresh('HPtzD','H6ZJs')">
   Try it in editor
  </div>
  <div class="snippet-body"><textarea id="H6ZJs">function generateSubsets(nums) {
  const result = [];

  function backtrack(start, path) {
    result.push([...path]); // Add current subset to result

    for (let i = start; i &lt; nums.length; i++) {
      path.push(nums[i]);             // Choose
      backtrack(i + 1, path);         // Explore
      path.pop();                     // Un-choose (backtrack)
    }
  }

  backtrack(0, []);
  return result;
}

// Example
console.log(generateSubsets([1, 2, 3]));</textarea> <br> <button onclick="renderIframeForClientJavascript('H6ZJs','PDSaR')">Run</button> <iframe id="PDSaR" class="result_iframe" style="display: none;"></iframe>
   <script>
  {let editor1 = CodeMirror.fromTextArea(document.getElementById("H6ZJs"), {
    mode: "javascript",
    lineNumbers:false,
    tabSize: 2
    });
    const mode = localStorage.getItem("mode") || "light";  
    const newTheme = mode === "dark" ? "material" : "default";
    editor1.setOption("theme", newTheme);

   codeMirrorMap.set("H6ZJs", editor1);}
  </script>
  </div>
 </div>
</div><p><strong>Output:</strong></p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-bash">[
  [], [1], [1, 2], [1, 2, 3],
  [1, 3], [2], [2, 3], [3]
]</code></pre>
</div><p><strong>How it works:</strong></p><ul>
 <li>At each step, you choose whether to include the current number.</li>
 <li>You recurse forward, and at each level, explore the remaining elements.</li>
 <li>Backtracking allows the algorithm to discard each choice and explore other branches.</li>
</ul><h3 id="example-2-generating-all-combinations-k-length">Example 2: Generating All Combinations (k-length)</h3><p>Let’s say we want all combinations of size <code>k</code> from a given array.</p><div>
 <div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
  <pre><code class="language-js">function combine(nums, k) {
  const result = [];

  function backtrack(start, path) {
    if (path.length === k) {
      result.push([...path]);
      return;
    }

    for (let i = start; i &lt; nums.length; i++) {
      path.push(nums[i]);
      backtrack(i + 1, path);
      path.pop();
    }
  }

  backtrack(0, []);
  return result;
}

// Example
console.log(combine([1, 2, 3, 4], 2));</code></pre>
 </div>
 <div class="snippet-container" id="ULniR">
  <div class="snippet-header" onclick="toggleSnippetAndRefresh('ULniR','RqgII')">
   Try it in editor
  </div>
  <div class="snippet-body"><textarea id="RqgII">function combine(nums, k) {
  const result = [];

  function backtrack(start, path) {
    if (path.length === k) {
      result.push([...path]);
      return;
    }

    for (let i = start; i &lt; nums.length; i++) {
      path.push(nums[i]);
      backtrack(i + 1, path);
      path.pop();
    }
  }

  backtrack(0, []);
  return result;
}

// Example
console.log(combine([1, 2, 3, 4], 2));</textarea> <br> <button onclick="renderIframeForClientJavascript('RqgII','C7kC1')">Run</button> <iframe id="C7kC1" class="result_iframe" style="display: none;"></iframe>
   <script>
  {let editor1 = CodeMirror.fromTextArea(document.getElementById("RqgII"), {
    mode: "javascript",
    lineNumbers:false,
    tabSize: 2
    });
    const mode = localStorage.getItem("mode") || "light";  
    const newTheme = mode === "dark" ? "material" : "default";
    editor1.setOption("theme", newTheme);

   codeMirrorMap.set("RqgII", editor1);}
  </script>
  </div>
 </div>
</div><p><strong>Output:</strong></p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-bash">[
  [1, 2], [1, 3], [1, 4],
  [2, 3], [2, 4], [3, 4]
]</code></pre>
</div><p>This is very similar to subset generation, but with an added <strong>size constraint</strong>. The recursive tree is pruned whenever the current combination reaches the desired length.</p><h3 id="backtracking-efficiency-and-complexity">Backtracking Efficiency and Complexity</h3><p>Although backtracking is more efficient than brute-force enumeration, its time complexity is still <strong>exponential</strong> in most cases:</p><ul>
 <li>Subsets of <code>n</code> elements: O(2^n)</li>
 <li>Combinations of <code>n</code> elements of length <code>k</code>: O(n choose k)</li>
 <li>Permutations of <code>n</code> elements: O(n!)</li>
</ul><p>Backtracking improves performance <strong>by pruning</strong> — skipping paths that don't meet the criteria early — but it cannot reduce the fundamental explosion of possibilities when exhaustive search is required.</p><h3 id="real-world-use-cases">Real-World Use Cases</h3><p>Combinatorial and backtracking problems are everywhere:</p><ul>
 <li><strong>Password generation</strong> or brute-force guessing</li>
 <li><strong>Subset sum and knapsack</strong>-type decision problems</li>
 <li><strong>Game solving</strong>: Sudoku, crossword fill-ins, chess move trees</li>
 <li><strong>Search engines</strong>: Generating keyword permutations</li>
 <li><strong>Bioinformatics</strong>: DNA sequence alignment</li>
</ul><p>Backtracking is especially useful when the solution space is large, but only a small portion of it is valid or interesting.</p><h3 id="summary">Summary</h3><p>Combinatorial problems require exploring all combinations, permutations, or subsets of a dataset. These problems grow exponentially with input size, but backtracking provides a structured and often more efficient way to explore valid configurations. In JavaScript, recursive functions using arrays and call stacks make backtracking intuitive and powerful. While not a silver bullet, backtracking is a key tool for solving problems that demand a complete search under constraints.</p><div class = "chapter-navi-section">
<a href="#top" class="nav-button prev">↑</a>
<a href='javascript-algorithms.htm#backtracking-and-recursion' class="nav-button toc-link">Index</a>
<a href="#bottom" class="nav-button next">↓</a>
</div>
<h2 id='subsets-permutations-and-n-queens'>20.2 Subsets, Permutations, and N-Queens</h2><p>Backtracking shines in problems that involve <strong>exploring all possible arrangements</strong> under a set of constraints. This section dives deeper into three foundational problems that illustrate how backtracking operates in practice: generating subsets, generating permutations, and solving the N-Queens puzzle.</p><p>Each of these problems involves recursive decision-making, state tracking, and pruning of invalid paths. Understanding how to structure these recursive calls and manage state cleanly is key to mastering backtracking in JavaScript.</p><h3 id="generating-all-subsets">Generating All Subsets</h3><p>The <strong>subset problem</strong> asks us to generate all possible combinations of elements in an array. This is a basic backtracking problem with no constraints.</p><h4 id="javascript-example">JavaScript Example:</h4><div>
 <div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
  <pre><code class="language-js">function subsets(nums) {
  const result = [];

  function backtrack(start, path) {
    result.push([...path]); // Add current combination

    for (let i = start; i &lt; nums.length; i++) {
      path.push(nums[i]);         // Choose
      backtrack(i + 1, path);     // Explore
      path.pop();                 // Undo
    }
  }

  backtrack(0, []);
  return result;
}

// Example
console.log(subsets([1, 2, 3]));</code></pre>
 </div>
 <div class="snippet-container" id="KXLGB">
  <div class="snippet-header" onclick="toggleSnippetAndRefresh('KXLGB','qA7xj')">
   Try it in editor
  </div>
  <div class="snippet-body"><textarea id="qA7xj">function subsets(nums) {
  const result = [];

  function backtrack(start, path) {
    result.push([...path]); // Add current combination

    for (let i = start; i &lt; nums.length; i++) {
      path.push(nums[i]);         // Choose
      backtrack(i + 1, path);     // Explore
      path.pop();                 // Undo
    }
  }

  backtrack(0, []);
  return result;
}

// Example
console.log(subsets([1, 2, 3]));</textarea> <br> <button onclick="renderIframeForClientJavascript('qA7xj','DTPMp')">Run</button> <iframe id="DTPMp" class="result_iframe" style="display: none;"></iframe>
   <script>
  {let editor1 = CodeMirror.fromTextArea(document.getElementById("qA7xj"), {
    mode: "javascript",
    lineNumbers:false,
    tabSize: 2
    });
    const mode = localStorage.getItem("mode") || "light";  
    const newTheme = mode === "dark" ? "material" : "default";
    editor1.setOption("theme", newTheme);

   codeMirrorMap.set("qA7xj", editor1);}
  </script>
  </div>
 </div>
</div><p><strong>State Management Tips:</strong></p><ul>
 <li><code>start</code> prevents revisiting earlier elements.</li>
 <li><code>path</code> is a dynamic list representing the current subset.</li>
 <li>Always <code>pop()</code> after recursion to restore the previous state.</li>
</ul><p><strong>Complexity:</strong> O(2^n) — Each element can either be included or excluded.</p><h3 id="generating-all-permutations">Generating All Permutations</h3><p>Permutations differ from subsets in that <strong>order matters</strong>, and we use <strong>each element exactly once</strong>.</p><h4 id="javascript-example">JavaScript Example:</h4><div>
 <div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
  <pre><code class="language-js">function permutations(nums) {
  const result = [];

  function backtrack(path, used) {
    if (path.length === nums.length) {
      result.push([...path]);
      return;
    }

    for (let i = 0; i &lt; nums.length; i++) {
      if (used[i]) continue;

      used[i] = true;
      path.push(nums[i]);
      backtrack(path, used);
      path.pop();
      used[i] = false;
    }
  }

  backtrack([], Array(nums.length).fill(false));
  return result;
}

// Example
console.log(permutations([1, 2, 3]));</code></pre>
 </div>
 <div class="snippet-container" id="FHPxL">
  <div class="snippet-header" onclick="toggleSnippetAndRefresh('FHPxL','RCbMF')">
   Try it in editor
  </div>
  <div class="snippet-body"><textarea id="RCbMF">function permutations(nums) {
  const result = [];

  function backtrack(path, used) {
    if (path.length === nums.length) {
      result.push([...path]);
      return;
    }

    for (let i = 0; i &lt; nums.length; i++) {
      if (used[i]) continue;

      used[i] = true;
      path.push(nums[i]);
      backtrack(path, used);
      path.pop();
      used[i] = false;
    }
  }

  backtrack([], Array(nums.length).fill(false));
  return result;
}

// Example
console.log(permutations([1, 2, 3]));</textarea> <br> <button onclick="renderIframeForClientJavascript('RCbMF','1fYpS')">Run</button> <iframe id="1fYpS" class="result_iframe" style="display: none;"></iframe>
   <script>
  {let editor1 = CodeMirror.fromTextArea(document.getElementById("RCbMF"), {
    mode: "javascript",
    lineNumbers:false,
    tabSize: 2
    });
    const mode = localStorage.getItem("mode") || "light";  
    const newTheme = mode === "dark" ? "material" : "default";
    editor1.setOption("theme", newTheme);

   codeMirrorMap.set("RCbMF", editor1);}
  </script>
  </div>
 </div>
</div><p><strong>State Management Tips:</strong></p><ul>
 <li>Use a <code>used[]</code> array to track which elements have been included.</li>
 <li>Restore state after each recursive call by resetting <code>used[i]</code> and popping from <code>path</code>.</li>
</ul><p><strong>Pruning Strategies:</strong></p><ul>
 <li>For arrays with duplicates, skip repeated elements with additional checks to avoid duplicate permutations.</li>
</ul><p><strong>Complexity:</strong> O(n!) — The number of permutations of <code>n</code> distinct elements.</p><h3 id="the-n-queens-problem">The N-Queens Problem</h3><p>The <strong>N-Queens</strong> puzzle asks: Place <code>n</code> queens on an <code>n×n</code> chessboard so that no two queens threaten each other. That means:</p><ul>
 <li>No two queens in the same row, column, or diagonal.</li>
</ul><p>This is a <strong>constraint satisfaction problem</strong> that’s perfect for backtracking.</p><h4 id="javascript-example-solving-and-printing-solutions">JavaScript Example (solving and printing solutions):</h4><div>
 <div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
  <pre><code class="language-js">function solveNQueens(n) {
  const results = [];
  const board = Array(n).fill().map(() =&gt; Array(n).fill('.'));

  const cols = new Set();
  const diag1 = new Set(); // row - col
  const diag2 = new Set(); // row + col

  function backtrack(row) {
    if (row === n) {
      results.push(board.map(r =&gt; r.join('')));
      return;
    }

    for (let col = 0; col &lt; n; col++) {
      if (cols.has(col) || diag1.has(row - col) || diag2.has(row + col)) continue;

      board[row][col] = 'Q';
      cols.add(col);
      diag1.add(row - col);
      diag2.add(row + col);

      backtrack(row + 1);

      board[row][col] = '.';
      cols.delete(col);
      diag1.delete(row - col);
      diag2.delete(row + col);
    }
  }

  backtrack(0);
  return results;
}

// Example
console.log(solveNQueens(4));</code></pre>
 </div>
 <div class="snippet-container" id="c0IIy">
  <div class="snippet-header" onclick="toggleSnippetAndRefresh('c0IIy','FvKW2')">
   Try it in editor
  </div>
  <div class="snippet-body"><textarea id="FvKW2">function solveNQueens(n) {
  const results = [];
  const board = Array(n).fill().map(() =&gt; Array(n).fill('.'));

  const cols = new Set();
  const diag1 = new Set(); // row - col
  const diag2 = new Set(); // row + col

  function backtrack(row) {
    if (row === n) {
      results.push(board.map(r =&gt; r.join('')));
      return;
    }

    for (let col = 0; col &lt; n; col++) {
      if (cols.has(col) || diag1.has(row - col) || diag2.has(row + col)) continue;

      board[row][col] = 'Q';
      cols.add(col);
      diag1.add(row - col);
      diag2.add(row + col);

      backtrack(row + 1);

      board[row][col] = '.';
      cols.delete(col);
      diag1.delete(row - col);
      diag2.delete(row + col);
    }
  }

  backtrack(0);
  return results;
}

// Example
console.log(solveNQueens(4));</textarea> <br> <button onclick="renderIframeForClientJavascript('FvKW2','2kNM7')">Run</button> <iframe id="2kNM7" class="result_iframe" style="display: none;"></iframe>
   <script>
  {let editor1 = CodeMirror.fromTextArea(document.getElementById("FvKW2"), {
    mode: "javascript",
    lineNumbers:false,
    tabSize: 2
    });
    const mode = localStorage.getItem("mode") || "light";  
    const newTheme = mode === "dark" ? "material" : "default";
    editor1.setOption("theme", newTheme);

   codeMirrorMap.set("FvKW2", editor1);}
  </script>
  </div>
 </div>
</div><p><strong>Output (formatted):</strong></p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-bash">[
  [".Q..", "...Q", "Q...", "..Q."],
  ["..Q.", "Q...", "...Q", ".Q.."]
]</code></pre>
</div><p><strong>State Management:</strong></p><ul>
 <li><p>Use sets to track:</p>
  <ul>
   <li>Columns where queens are placed.</li>
   <li>Diagonals: <code>row - col</code> (↘) and <code>row + col</code> (↙).</li>
  </ul></li>
 <li><p>Clean up sets after each recursive call to undo state changes.</p></li>
</ul><p><strong>Visualization Tip:</strong> Print the board at each recursive step to trace queen placement and backtracking:</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-js">console.log(board.map(row =&gt; row.join('')).join('\n') + '\n');</code></pre>
</div><p><strong>Complexity:</strong> Exponential, but pruned significantly using sets to skip unsafe positions.</p><h3 id="backtracking-pattern-and-debugging-tips">Backtracking Pattern and Debugging Tips</h3><p>Common structure of backtracking:</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-js">function backtrack(state) {
  if (solution found) return;
  for (choices) {
    if (valid) {
      make choice;
      backtrack(updated state);
      undo choice;
    }
  }
}</code></pre>
</div><p><strong>Debugging Tips:</strong></p><ul>
 <li>Add <code>console.log()</code> at each level to visualize recursion.</li>
 <li>Track the call depth or current path to understand state changes.</li>
 <li>Use indentation based on recursion depth for easier tracing.</li>
</ul><h3 id="relevance-to-constraint-satisfaction">Relevance to Constraint Satisfaction</h3><p>Backtracking is a foundational approach in <strong>constraint satisfaction problems (CSPs)</strong>, which require finding valid configurations that satisfy multiple conditions — such as:</p><ul>
 <li>Sudoku solvers</li>
 <li>Word search puzzles</li>
 <li>Resource assignment with restrictions (e.g., course scheduling)</li>
</ul><p>Each problem defines:</p><ul>
 <li><strong>Variables</strong> (e.g., board cells, positions)</li>
 <li><strong>Domains</strong> (e.g., valid values or moves)</li>
 <li><strong>Constraints</strong> (e.g., no duplicates, no conflicts)</li>
</ul><p>Backtracking efficiently navigates the solution space while pruning invalid paths early — making it ideal for complex CSPs.</p><h3 id="summary">Summary</h3><p>Subsets, permutations, and N-Queens are classic examples that demonstrate the power and flexibility of backtracking. With careful state management, pruning, and recursive logic, you can efficiently explore vast search spaces. As problems grow in complexity, mastering this pattern will help you tackle everything from algorithm puzzles to real-world constraint-driven systems in JavaScript.</p><div class = "chapter-navi-section">
<a href="#top" class="nav-button prev">↑</a>
<a href='javascript-algorithms.htm#backtracking-and-recursion' class="nav-button toc-link">Index</a>
<a href="#bottom" class="nav-button next">↓</a>
</div>
<h2 id='solving-puzzles-recursively'>20.3 Solving Puzzles Recursively</h2><p>Recursive algorithms, especially when combined with <strong>backtracking</strong>, provide a natural and powerful approach to solving complex puzzles. Many logic-based challenges—such as <strong>Sudoku</strong>, <strong>crossword filling</strong>, and <strong>maze navigation</strong>—can be modeled as <strong>state exploration problems</strong>. The goal is to recursively try possible moves, prune invalid paths, and backtrack when a dead end is reached.</p><p>This section explores how to use recursion to solve simplified versions of these puzzles in JavaScript, along with best practices for managing state, recursion depth, and performance.</p><h3 id="recursive-exploration-and-base-cases">Recursive Exploration and Base Cases</h3><p>At the heart of solving any puzzle recursively is the idea of <strong>recursive state exploration</strong>:</p><ol>
 <li><strong>Recursive calls</strong> explore possible choices from the current state.</li>
 <li>A <strong>base case</strong> defines when a solution has been reached (e.g., the puzzle is completely and correctly filled).</li>
 <li>Invalid or impossible states are <strong>pruned early</strong> to avoid unnecessary computation.</li>
 <li>Once all options are exhausted, the algorithm <strong>backtracks</strong> to try other possibilities.</li>
</ol><h3 id="example-1-maze-solving">Example 1: Maze Solving</h3><p>Let’s start with a basic puzzle: finding a path through a maze. Represent the maze as a 2D grid with <code>0</code>s (open paths) and <code>1</code>s (walls).</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-js">function solveMaze(maze, x = 0, y = 0, path = []) {
  const n = maze.length;
  const m = maze[0].length;

  if (x &lt; 0 || y &lt; 0 || x &gt;= n || y &gt;= m || maze[x][y] !== 0) return false;

  path.push([x, y]);

  if (x === n - 1 &amp;&amp; y === m - 1) return true; // Reached the goal

  maze[x][y] = 2; // Mark visited

  const dirs = [[0, 1], [1, 0], [0, -1], [-1, 0]];
  for (const [dx, dy] of dirs) {
    if (solveMaze(maze, x + dx, y + dy, path)) return true;
  }

  path.pop(); // Backtrack
  return false;
}

// Example usage
const maze = [
  [0, 1, 0, 0],
  [0, 0, 0, 1],
  [1, 1, 0, 1],
  [0, 0, 0, 0]
];

const path = [];
if (solveMaze(maze, 0, 0, path)) {
  console.log("Path found:", path);
} else {
  console.log("No path found.");
}</code></pre>
</div><p><strong>Key Points:</strong></p><ul>
 <li>Avoid revisiting by marking cells as visited (<code>2</code>).</li>
 <li>Backtrack by removing the last step from the path.</li>
 <li>Base case: reach the goal cell (bottom-right corner).</li>
</ul><h3 id="example-2-sudoku-solver-simplified-44">Example 2: Sudoku Solver (Simplified 44)</h3><p>Solving a full 9×9 Sudoku is possible with backtracking, but for clarity, here’s a simpler 4×4 version using digits <code>1–4</code>.</p><div>
 <div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
  <pre><code class="language-js">function isValid(board, row, col, num) {
  for (let i = 0; i &lt; 4; i++) {
    if (board[row][i] === num || board[i][col] === num) return false;
  }

  const boxRow = Math.floor(row / 2) * 2;
  const boxCol = Math.floor(col / 2) * 2;

  for (let i = 0; i &lt; 2; i++) {
    for (let j = 0; j &lt; 2; j++) {
      if (board[boxRow + i][boxCol + j] === num) return false;
    }
  }

  return true;
}

function solveSudoku(board) {
  for (let row = 0; row &lt; 4; row++) {
    for (let col = 0; col &lt; 4; col++) {
      if (board[row][col] === 0) {
        for (let num = 1; num &lt;= 4; num++) {
          if (isValid(board, row, col, num)) {
            board[row][col] = num;
            if (solveSudoku(board)) return true;
            board[row][col] = 0; // Backtrack
          }
        }
        return false; // No valid number found
      }
    }
  }
  return true; // Board is filled correctly
}

// Example board (0 = empty)
const board = [
  [1, 0, 0, 0],
  [0, 0, 2, 1],
  [0, 1, 0, 0],
  [0, 0, 0, 2]
];

if (solveSudoku(board)) {
  console.log("Solved board:");
  console.table(board);
} else {
  console.log("No solution exists.");
}</code></pre>
 </div>
 <div class="snippet-container" id="xi7TA">
  <div class="snippet-header" onclick="toggleSnippetAndRefresh('xi7TA','FvpQf')">
   Try it in editor
  </div>
  <div class="snippet-body"><textarea id="FvpQf">function isValid(board, row, col, num) {
  for (let i = 0; i &lt; 4; i++) {
    if (board[row][i] === num || board[i][col] === num) return false;
  }

  const boxRow = Math.floor(row / 2) * 2;
  const boxCol = Math.floor(col / 2) * 2;

  for (let i = 0; i &lt; 2; i++) {
    for (let j = 0; j &lt; 2; j++) {
      if (board[boxRow + i][boxCol + j] === num) return false;
    }
  }

  return true;
}

function solveSudoku(board) {
  for (let row = 0; row &lt; 4; row++) {
    for (let col = 0; col &lt; 4; col++) {
      if (board[row][col] === 0) {
        for (let num = 1; num &lt;= 4; num++) {
          if (isValid(board, row, col, num)) {
            board[row][col] = num;
            if (solveSudoku(board)) return true;
            board[row][col] = 0; // Backtrack
          }
        }
        return false; // No valid number found
      }
    }
  }
  return true; // Board is filled correctly
}

// Example board (0 = empty)
const board = [
  [1, 0, 0, 0],
  [0, 0, 2, 1],
  [0, 1, 0, 0],
  [0, 0, 0, 2]
];

if (solveSudoku(board)) {
  console.log("Solved board:");
  console.table(board);
} else {
  console.log("No solution exists.");
}</textarea> <br> <button onclick="renderIframeForClientJavascript('FvpQf','Mh79N')">Run</button> <iframe id="Mh79N" class="result_iframe" style="display: none;"></iframe>
   <script>
  {let editor1 = CodeMirror.fromTextArea(document.getElementById("FvpQf"), {
    mode: "javascript",
    lineNumbers:false,
    tabSize: 2
    });
    const mode = localStorage.getItem("mode") || "light";  
    const newTheme = mode === "dark" ? "material" : "default";
    editor1.setOption("theme", newTheme);

   codeMirrorMap.set("FvpQf", editor1);}
  </script>
  </div>
 </div>
</div><p><strong>State and Pruning:</strong></p><ul>
 <li>Check constraints before placing a number.</li>
 <li>Backtrack when no valid number can be placed.</li>
 <li>Each recursive call modifies the board in-place.</li>
</ul><h3 id="managing-recursion-depth-and-performance">Managing Recursion Depth and Performance</h3><p>Recursive puzzle solvers can run deep, especially in more complex puzzles like:</p><ul>
 <li>Full-size Sudoku (up to depth 81)</li>
 <li>Crossword or word-placement problems</li>
 <li>Chessboard problems like N-Queens (depth <code>n</code>)</li>
</ul><p><strong>Performance Tips:</strong></p><ul>
 <li><strong>Limit state copies</strong>: Modify state in place and restore it after backtracking.</li>
 <li><strong>Use memoization</strong> if subproblems repeat (e.g., in word puzzles).</li>
 <li><strong>Track visited states</strong> using sets or maps when necessary.</li>
 <li><strong>Tail recursion optimization</strong> isn't available in all JS engines, so avoid very deep recursion unless necessary.</li>
</ul><p>If recursion depth becomes a concern (e.g., &gt;1000), iterative solutions using a stack may be safer in JavaScript.</p><h3 id="real-world-relevance">Real-World Relevance</h3><p>Recursive puzzle solving patterns map directly to real-world problems such as:</p><ul>
 <li><strong>AI planning</strong> (pathfinding, decision trees)</li>
 <li><strong>Constraint satisfaction</strong> (scheduling, layout, assignment)</li>
 <li><strong>Interactive games</strong> (solvers for crosswords, puzzles, logic challenges)</li>
 <li><strong>Validation engines</strong> (form field logic, legal rule applications)</li>
</ul><p>Any problem where you need to <strong>search through options</strong> under <strong>rules and constraints</strong> can likely benefit from backtracking and recursive logic.</p><h3 id="summary">Summary</h3><p>Recursion and backtracking offer a flexible, elegant way to solve constraint-based puzzles like mazes, Sudoku, and word grids. These approaches explore the full space of valid moves and prune dead ends efficiently. With careful management of state, recursion depth, and validity checks, you can solve even complex puzzles effectively in JavaScript. These strategies aren’t just academic — they form the backbone of many real-world problem solvers, games, and AI systems.</p><div class = "chapter-navi-section">
<a href="javascript-algorithms-greedy-algorithms.htm" class="nav-button prev">←</a>
<a href='javascript-algorithms.htm#backtracking-and-recursion' class="nav-button toc-link">Index</a>
<a href="javascript-algorithms-real-world-applications.htm" class="nav-button next">→</a>
</div>
<section class="download-section">
  <div class="book-cover" style="background-color: #f9f6f1;border: 1px solid #ccc;"> 
    <div class="book-cover-title" style="font-size: 18px;color: #333;top: 20px;">JavaScript Algorithms</div>
    <div class="book-cover-author">readbytes</div>
    <div class="book-cover-bottom-stripe" style="background-color: #333;"></div>
    <img class="book-cover-icon" style="width: 80px;height: 80px;top: 70px;" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFoAAABaCAYAAAA4qEECAAAErElEQVR4Xu2dPWgUQRiGo6BB8I+AlV3w9gzptLBWsLQ89O7ARrDXSivTCTaCnWhn7pQTxOoInpjCeEQQLC2CjVqoVSwMFpp1Jtzo7Luzs/Nd7uZ29r4HPpDsu7vPvIl7+SGTmRmGYRiGYZjCEzVacdnn9NX7+3DdXkGhMg+u3Su6SNztzsZvevH/efED8zrJbM+6EGJ2K5Hv9w9gRpHnXMyik2VsYVaHWJx7tt/bTOQ3urOYUch3QJ5z0YtOCeuQiqNlvybyto/ktbVDcG2jc5GLNgoriMW5Z/svPyfy693DmFHE71ePwrUznQta9ISeyViyKBIziri/Mpe8tt25kEXjMR1ScbQsPC5W5jCjMJT8DTM6MuO6vrHjIkIszj2LL3y2ktOPiy+Y0VE5l/V5IU+EVBwtm/wUzva4SL/wOZUsJ2993rCJEIujZJMl2174Up/C5T8u9LGtzyu6SNkH1+6VhUargkJlHVy7f5aW9qJUqeZy5zguufToBeAxZoRw0Z7goj3BRXuCi/YEF+0BvWQue0xgwfrMiy+aMM8QEUW+w2IHb8fC/+C5jCOGMhOPiqi+vG47zjiABVbr7XOYUWC2Um+fxwwDiKJeYXGYMYHniNnGDDPAUJZTyYph30nTg+G7f5VLj89gzBW8lu2xMzWIIt5iMZgZBrzmqK4bJFhENOLnatRsfcR7YKb0YAELF5+cwsyowHudrLcvYKZ0iIV+wIVjZhzgPaMR/+8pFIbFeilZUWm2Vyd5/5GxWOvsx4VkTbXROovn+wJdMqfevoHnFoKUaMbgeZMAnbIGzysEKGmZiX4DKKo/um5wMg6eWwhsgtVm62cRFoEOJg/xtltZxwqBTV4inuEHcZHztc4RzI0LvLeY15iRBF+0wrDgsX6qZXpUYEanNEVLROY3ZfHDgvdwuU+pipYs1h7OpUqI4z2YGxa8dqXefooZE6UrWoGFiMn8nRIXoubyTbymeLPzO7C0RUuiRvuXoRwyeI1hrlPqoiUnap1jWNLilU7mr0sgeK746rOFGRdKX7QCC4tyHiXi+DU8BzMUpqZoiSzXpTzMZOUoTFXROxh+xKV/gYPHqvVlp88q8pi+ogdgoabBc3bD1BYtEdfcxnLHeK/pLVoiHxvJktsPMDMKpr5oX3DRnuCiPcFFe4KL9gQX7Qku2hNctCe4aE94K1puD6mXNsmpOv74KUTnxEdmEQb9TOA5kx70M6KfcO/u8/j2nWffxb+XskZm9MHjw2YjgrTKygnFeUaF5cSEjZ4c9kJyz/Z7mxTpEJ0T0nhMhyRBy+5sTuXioAjR2UmaKEHJ/tsBLM9BJ0TnXGmiBCWb2GbN5oCE6GyVJkq4Z3FXxo3ubJaDiRCdM6VJErSscTtik0MWITobpYkS7lncKVfblREdbITonJImSVCyKAz7i1KkQ3ROSJMkaNnc7Ygp0iE6Z0pjTockjC8iBmEJRTpEZ6M0ZnRIwrhTrmU7Yop0iM4paTyusyvhnO2IKdIhOqdeWLLYlbDtL0oM/jaKi4MiRGcnaZIwPt8c/zZKnoNOiM4J6SIM+pnAcyY96GekYJtvf0I/EyE6MwzDMAzDjI+/5MPGam/zucIAAAAASUVORK5CYII="/>
  </div>
  <div class="download-info">
    <h2 id='bottom'>Download This Ebook</h2>
    <p class="format-label">Available formats:</p>
    <div class="download-buttons">
      <a href="javascript-algorithms.pdf" class="download-button">📄 PDF</a>
      <a href="javascript-algorithms.epub" class="download-button">📘 EPUB</a>
    </div>
  </div>
</section><div class='related-books'>
<h2>Java Introduction Books</h2>
<div class='related-book-list'>
<a href="javascript-algorithms.htm">
<div class="book-cover" style="background-color: #f9f6f1;border: 1px solid #ccc;"> 
    <div class="book-cover-title" style="font-size: 18px;color: #333;top: 20px;">JavaScript Algorithms</div>
    <div class="book-cover-author">readbytes</div>
    <div class="book-cover-bottom-stripe" style="background-color: #333;"></div>
    <img class="book-cover-icon" style="width: 80px;height: 80px;top: 70px;" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFoAAABaCAYAAAA4qEECAAAErElEQVR4Xu2dPWgUQRiGo6BB8I+AlV3w9gzptLBWsLQ89O7ARrDXSivTCTaCnWhn7pQTxOoInpjCeEQQLC2CjVqoVSwMFpp1Jtzo7Luzs/Nd7uZ29r4HPpDsu7vPvIl7+SGTmRmGYRiGYZjCEzVacdnn9NX7+3DdXkGhMg+u3Su6SNztzsZvevH/efED8zrJbM+6EGJ2K5Hv9w9gRpHnXMyik2VsYVaHWJx7tt/bTOQ3urOYUch3QJ5z0YtOCeuQiqNlvybyto/ktbVDcG2jc5GLNgoriMW5Z/svPyfy693DmFHE71ePwrUznQta9ISeyViyKBIziri/Mpe8tt25kEXjMR1ScbQsPC5W5jCjMJT8DTM6MuO6vrHjIkIszj2LL3y2ktOPiy+Y0VE5l/V5IU+EVBwtm/wUzva4SL/wOZUsJ2993rCJEIujZJMl2174Up/C5T8u9LGtzyu6SNkH1+6VhUargkJlHVy7f5aW9qJUqeZy5zguufToBeAxZoRw0Z7goj3BRXuCi/YEF+0BvWQue0xgwfrMiy+aMM8QEUW+w2IHb8fC/+C5jCOGMhOPiqi+vG47zjiABVbr7XOYUWC2Um+fxwwDiKJeYXGYMYHniNnGDDPAUJZTyYph30nTg+G7f5VLj89gzBW8lu2xMzWIIt5iMZgZBrzmqK4bJFhENOLnatRsfcR7YKb0YAELF5+cwsyowHudrLcvYKZ0iIV+wIVjZhzgPaMR/+8pFIbFeilZUWm2Vyd5/5GxWOvsx4VkTbXROovn+wJdMqfevoHnFoKUaMbgeZMAnbIGzysEKGmZiX4DKKo/um5wMg6eWwhsgtVm62cRFoEOJg/xtltZxwqBTV4inuEHcZHztc4RzI0LvLeY15iRBF+0wrDgsX6qZXpUYEanNEVLROY3ZfHDgvdwuU+pipYs1h7OpUqI4z2YGxa8dqXefooZE6UrWoGFiMn8nRIXoubyTbymeLPzO7C0RUuiRvuXoRwyeI1hrlPqoiUnap1jWNLilU7mr0sgeK746rOFGRdKX7QCC4tyHiXi+DU8BzMUpqZoiSzXpTzMZOUoTFXROxh+xKV/gYPHqvVlp88q8pi+ogdgoabBc3bD1BYtEdfcxnLHeK/pLVoiHxvJktsPMDMKpr5oX3DRnuCiPcFFe4KL9gQX7Qku2hNctCe4aE94K1puD6mXNsmpOv74KUTnxEdmEQb9TOA5kx70M6KfcO/u8/j2nWffxb+XskZm9MHjw2YjgrTKygnFeUaF5cSEjZ4c9kJyz/Z7mxTpEJ0T0nhMhyRBy+5sTuXioAjR2UmaKEHJ/tsBLM9BJ0TnXGmiBCWb2GbN5oCE6GyVJkq4Z3FXxo3ubJaDiRCdM6VJErSscTtik0MWITobpYkS7lncKVfblREdbITonJImSVCyKAz7i1KkQ3ROSJMkaNnc7Ygp0iE6Z0pjTockjC8iBmEJRTpEZ6M0ZnRIwrhTrmU7Yop0iM4paTyusyvhnO2IKdIhOqdeWLLYlbDtL0oM/jaKi4MiRGcnaZIwPt8c/zZKnoNOiM4J6SIM+pnAcyY96GekYJtvf0I/EyE6MwzDMAzDjI+/5MPGam/zucIAAAAASUVORK5CYII="/>
  </div>
</a>



<a href='java.htm'><div class='book-cover' style='background-color: #f9f6f1;color: #111111;border: 1px solid #ccc;display: flex;justify-content: center;align-items: center;text-align: center;'>More Java Books</div></a>
</div>
</div>
  </div>
  <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/prism.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
  
  <script>
    function copyCode(button) {
      const code = button.nextElementSibling.innerText;
      navigator.clipboard.writeText(code).then(() => {
        button.textContent = 'Copied!';
        setTimeout(() => { button.textContent = 'Copy'; }, 1500);
      });
    }
  </script>  
<div id="floatingLog" aria-live="polite" role="alert"></div>
<footer class="page-footer">
    <nav>
      <a href="https://readbytes.github.io">Home</a> | 
      Email:<script language="JavaScript" type="text/javascript">
var part1 = 'yinpeng';var part6 = '263';var part2 = Math.pow(2,6);var part3 = String.fromCharCode(part2);var part4 = 'hotmail dot com';var part5 = part1 + String.fromCharCode(part2) + part4;document.write(part1 + part6 + part3 + part4);
</script>
    </nav>
  <p>© 2025 — All rights reserved.</p>    
  </footer>

</body>
</html>