<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>C++ for Beginners Advanced Memory Management</title>
<link rel='shortcut icon' href='https://readbytes.github.io/images/favicon.ico'>
<link href="https://fonts.googleapis.com/css2?family=Merriweather&display=swap" rel="stylesheet" />
<link href="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet" />
<script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/prism.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/codemirror.min.css" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/codemirror.min.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/theme/dracula.min.css"><style>
html {scroll-behavior: smooth;}  
body {font-family: 'Merriweather', serif;;margin: 0;padding: 2rem 1rem;font-size: 15px;line-height: 1.5;transition: background-color 0.3s, color 0.3s;}
.container {max-width: 750px;margin: 0 auto;padding: 1rem 2rem;}
.light-mode {background-color: #f8f7f5;color: #333;} 
.dark-mode {background-color: #121212;color: #e0e0e0;}
a { text-decoration: none;transition: color 0.2s;}
a:hover {text-decoration: underline;}
.light-mode a {color: #555;}
.dark-mode a {color: #aaa;}
</style><style>
.related-book-list {display: flex;flex-wrap: wrap;gap: 20px;}
.related-books {margin-top: 40px;}
.related-books h2 {font-size: 22px;margin-bottom: 20px;border-bottom: 2px solid #eee;padding-bottom: 8px;}
.light-mode .related-books h2 {color: #333;border-color: #eee;}
.dark-mode .related-books h2 {color: #ddd;border-color: #333;}
</style><style>
.book-cover {width: 130px;height: 180px;font-family: Arial, sans-serif;position: relative;overflow: hidden;box-shadow: 2px 2px 4px rgba(0,0,0,0.1);}
.book-cover-bottom-stripe {position: absolute;bottom: 0;left: 0;height: 5px;width: 100%;}
.book-cover-title {position: absolute;width: 100%;text-align: center;font-weight: bold;}
.book-cover-icon {position: absolute;left: 50%;transform: translateX(-50%);display: flex;align-items: center;justify-content: center;}
.book-cover-author {position: absolute;bottom: 10px;width: 100%;text-align: center;font-size: 8px;color: #333;}
</style><style>
.book-title-toc {font-size: 32px;font-weight: bold; }
.book-subtitle-toc {font-size: 18px;margin-top: 8px;font-style: italic;}
.book-header {text-align: center;margin-bottom: 40px;}

.toc-container {border-radius: 10px;padding: 30px;margin-bottom: 40px;box-shadow: 0 8px 20px rgba(0,0,0,0.05);}
h1 {font-size: 24px;text-align: center;margin-bottom: 30px;letter-spacing: 1px;padding-bottom: 10px;}
.toc-list,.toc-section-list {list-style: none;padding: 0;margin: 0;}
.toc-section-list {padding-left: 18px;margin-top: 6px;margin-bottom: 20px; }
.toc-chapter {padding: 20px 0;}
.chapter-title,.toc-section {display: flex;justify-content: space-between;padding-top: 4px;}
.chapter-title {font-size: 17px;font-weight: bold;}
.chapter-page,.section-page {font-style: italic;}
 
 
.light-mode .book-title-toc,.light-mode .chapter-title,.light-mode .book-name {color: #222;}
.light-mode .book-subtitle-toc,.light-mode .book-sub,.light-mode .chapter-page,.light-mode .section-page {color: #666;}
.light-mode .toc-container { background: #fff;border: 1px solid #ddd;}
.light-mode h1 {border-bottom: 2px solid #eee;color: #222;}
.light-mode .toc-section {  color: #444;}

.light-mode .book-cover { border: 1px solid #ccc;box-shadow: 0 6px 12px rgba(0, 0, 0, 0.15);}
.light-mode .book-title,.light-mode .series-name {color: #fff;}
.light-mode .book-subtitle,.light-mode .book-footer {color: #aaa;}

.dark-mode .book-title-toc,.dark-mode .chapter-title,.dark-mode .book-name {color: #f5f5f5;}
.dark-mode .book-subtitle-toc,.dark-mode .book-sub,.dark-mode .chapter-page,.dark-mode .section-page {color: #aaa;}
.dark-mode .toc-container {background: #1e1e1e;border: 1px solid #444;}

.dark-mode h1 {border-bottom: 2px solid #333;color: #eee;}
.dark-mode .toc-section {color: #bbb;}

.dark-mode .related-books h2 {color: #ddd;border-bottom: 2px solid #333;}
.dark-mode .book-title,.dark-mode .series-name {color: #fff;}
.dark-mode .book-subtitle,.dark-mode .book-footer {color: #bbb;}
.dark-mode .toc-section {color: #ddd;}

@media (max-width: 600px) {
  .chapter-title,
  .toc-section {
    flex-direction: column;
    align-items: flex-start;
  }

  .chapter-page,
  .section-page {
    margin-top: 4px;
  }
}

</style><style>
.light-mode .container {box-shadow: 0 0 15px rgba(0,0,0,0.1);}
.dark-mode .container {box-shadow: 0 0 15px rgba(255, 255, 255, 0.05);}

h1, h2, h3 {font-weight: 600;margin-top: 2.5rem;margin-bottom: 1rem;line-height: 1.2;}
h1 { font-size: 1.8rem; }
h2 { font-size: 1.4rem; }
h3 { font-size: 1.2rem; }

table {width: 100%;border-collapse: collapse;font-family: sans-serif;font-size: 1em;margin: 1em 0;}
th, td {padding: 0.6em 1em;text-align: left;border: 1px solid;}
tr:nth-child(even) {  background-color: inherit;}
tr:hover { background-color: inherit;}

code {color: #d35400;}

.chapter-navi-section {display: flex;justify-content: space-between;align-items: center;padding-bottom: 10px;padding-top: 10px;}
.nav-link {color: inherit;text-decoration: none;opacity: 0.5;transition: opacity 0.3s ease, text-decoration 0.3s ease;}
.nav-link:hover {opacity: 0.9;text-decoration: underline;}
.prev { text-align: left; }
.toc-link { text-align: center; }
.next { text-align: right; }

.download-section {display: flex;align-items: center;justify-content: center;gap: 2rem;padding: 2rem 1rem;max-width: 600px;margin: 3rem auto;border-radius: 12px;box-shadow: 0 4px 10px rgba(0,0,0,0.05);}
.download-info h2 {margin: 0 0 0.5rem;font-size: 1.2rem;}
.format-label {margin: 0 0 0.5rem;font-size: 0.95rem;}
.download-buttons {display: flex;gap: 1rem;}
.download-button {background-color: #4A90E2;color: white;padding: 0.5em 1.2em;border-radius: 25px;font-size: 0.95rem;text-decoration: none;transition: background-color 0.3s ease;}
.download-button:hover {background-color: #357ABD;}

.code-block {position: relative;margin-bottom: 1em;}
.copy-button {background: transparent;color: white;position: absolute;top: 8px;right: 8px;border: none;padding: 4px 8px;font-size: 12px;border-radius: 4px;cursor: pointer;z-index: 1;}
.copy-button:hover {background-color: #0056b3;}

.snippet-container {overflow: hidden;}
.snippet-header {padding: 0.75rem 1rem;cursor: pointer;font-size: 1rem;background-color: #eeeeee;color:  #111111; border-radius: 8px;cursor: pointer;box-shadow: 0 4px 6px rgba(0,0,0,0.1); }
.snippet-body {display: none;font-family: monospace;}
.snippet-container.open .snippet-body {display: block;}

.CodeMirror {border: 2px solid #ccc;border-radius: 4px;resize: vertical;}

.light-mode .format-label {color: #888;}
.light-mode th {background-color: #f2f2f2;}
.light-mode tr:nth-child(even) {background-color: #fafafa;}
.light-mode tr:hover {background-color: #e6f7ff;}

.dark-mode .snippet-header {background-color: #333;color:  #ddd; }
.dark-mode .format-label {color: #aaa;}
.dark-mode th {background-color: #333;color: #fff;}
.dark-mode td {border-color: #444;}
.dark-mode tr:nth-child(even) {background-color: #2a2a2a;}
.dark-mode tr:hover {background-color: #2c3e50;}


.button-group-run-edit {display: flex;width: 100%;gap: 1rem;}
.button-run-edit {flex: 1;padding: 1rem;font-size: 1rem;font-weight: 600;border: none;border-radius: 8px;cursor: pointer;transition: background 0.3s, color 0.3s;}

.light-mode .button-run-edit {background-color: #f0f0f0;color: #222;box-shadow: 0 0 10px rgba(0, 0, 0, 0.05);}
.light-mode .button-run-edit:hover {background-color: #e0e0e0;}

.dark-mode .button-run-edit {background-color: #2a2a2a;color: #f5f5f5;box-shadow: 0 0 10px rgba(255, 255, 255, 0.05);}
.dark-mode .button-run-edit:hover {background-color: #3a3a3a;}

button { padding: 0.5em 1em; background: green; color: white; border: none; cursor: pointer; }
button:hover { background: #1e7e34; }
.result_iframe { width:99%; margin-top: 1em;  resize: both;background-color: #515b63;border:1px solid #ccc;}   

.dialog-backdrop {position: fixed;top: 0;left: 0;width: 100vw;height: 100vh;background: rgba(0,0,0,0.5);display: none;justify-content: center;align-items: center;z-index: 10;}
.dialog {background: #90979e;padding: 20px;width: 90vw;height: 80vh;border-radius: 8px;box-shadow: 0 0 20px rgba(0,0,0,0.3);display: flex;flex-direction: column;}
.dialog-content {display: flex;gap: 20px;margin-top: 10px;height: calc(100% - 40px);}
.editor-container, .preview-container {flex: 1;height: 100%;max-height: 100%;overflow: hidden; }
.result_iframe_dialog {width: 100%;height: 100%;resize: both;border:1px solid #ccc;overflow: auto; }   
.CodeMirror {width: 100% !important;height: 100% !important;}
</style>
</head>
<body>
<script>const mode = localStorage.getItem('mode') || 'light';document.documentElement.classList.add(`${mode}-mode`);</script>  
<div class="container"><div class = "chapter-navi-section">
<a href="cplusplus-for-beginners-file-input-and-output.htm" class="nav-button prev">←</a>
<a href='cplusplus-for-beginners.htm#advanced-memory-management' class="nav-button toc-link">Index</a>
<a href="cplusplus-for-beginners-multithreading-and-concurrency-basics.htm" class="nav-button next">→</a>
</div>
<div class='book-header'><h1 class='book-title-toc' id = 'top'>Advanced Memory Management</h1><h3 class='book-subtitle-toc'>C++ for Beginners</h3></div><h2 id='smart-pointers-unique-ptr-shared-ptr-weak-ptr'>16.1 Smart Pointers (<code>unique_ptr</code>, <code>shared_ptr</code>, <code>weak_ptr</code>)</h2><p>Managing dynamic memory manually with raw pointers in C++ can be error-prone. Common problems such as memory leaks, dangling pointers, or double deletions often arise when <code>new</code> and <code>delete</code> calls are not carefully balanced. To address these issues, <strong>smart pointers</strong> were introduced in C++ to provide safer, automatic memory management. They encapsulate raw pointers and control the lifetime of dynamically allocated objects, reducing the risk of bugs and making code easier to maintain.</p><p>In this section, we explore the three primary smart pointer types provided by the C++ Standard Library: <code>unique_ptr</code>, <code>shared_ptr</code>, and <code>weak_ptr</code>. Each serves a specific purpose for managing ownership and object lifetimes.</p><h3 id="why-use-smart-pointers">Why Use Smart Pointers?</h3><p>Before diving into each type, let's briefly outline why smart pointers are important:</p><ul>
 <li><strong>Automatic deletion:</strong> They automatically delete the managed object when it is no longer needed.</li>
 <li><strong>Exception safety:</strong> They prevent resource leaks even if exceptions occur.</li>
 <li><strong>Clear ownership semantics:</strong> They express who “owns” an object, making code easier to understand.</li>
 <li><strong>Avoid dangling pointers:</strong> They reduce the risk of pointers referring to deleted objects.</li>
</ul><h3 id="unique-ptr-exclusive-ownership"><code>unique_ptr</code>: Exclusive Ownership</h3><p><code>std::unique_ptr</code> represents <em>exclusive ownership</em> of a dynamically allocated object. At any time, only one <code>unique_ptr</code> can own the object. When the <code>unique_ptr</code> goes out of scope or is reset, it automatically deletes the owned object.</p><h3 id="creating-and-using-unique-ptr">Creating and Using <code>unique_ptr</code></h3><div class="code-block">
 <button class="copy-button" onclick="copyCode(this)">📋</button>
 <pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;memory&gt;

int main() {
    std::unique_ptr&lt;int&gt; ptr1(new int(42)); // owns an int with value 42

    std::cout &lt;&lt; "Value: " &lt;&lt; *ptr1 &lt;&lt; '\n'; // Access via dereference

    // Transferring ownership using std::move
    std::unique_ptr&lt;int&gt; ptr2 = std::move(ptr1);
    if (!ptr1) {
        std::cout &lt;&lt; "ptr1 is now null after move\n";
    }
    std::cout &lt;&lt; "ptr2 owns: " &lt;&lt; *ptr2 &lt;&lt; '\n';

    // Automatic deletion when ptr2 goes out of scope
    return 0;
}</code></pre>
</div><h3 id="important-points-about-unique-ptr">Important points about <code>unique_ptr</code>:</h3><ul>
 <li><strong>No copy allowed:</strong> Copying is disallowed to enforce exclusive ownership. You must use <code>std::move()</code> to transfer ownership.</li>
 <li><strong>Automatic deletion:</strong> When the last <code>unique_ptr</code> owning the object is destroyed or reset, it deletes the object.</li>
 <li><strong>Custom deleters:</strong> You can provide a custom deleter if needed (e.g., to delete arrays or close files).</li>
</ul><div class="code-block">
 <button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-cpp">std::unique_ptr&lt;int[]&gt; arr(new int[10]); // managing dynamic array</code></pre>
</div><h3 id="pitfalls-to-avoid">Pitfalls to avoid</h3><ul>
 <li>Don’t manually delete the managed object.</li>
 <li>Avoid creating multiple <code>unique_ptr</code>s managing the same raw pointer; it leads to double deletion.</li>
 <li>Always use <code>std::move</code> to transfer ownership, not copy.</li>
</ul><h3 id="shared-ptr-shared-ownership-with-reference-counting"><code>shared_ptr</code>: Shared Ownership with Reference Counting</h3><p>Sometimes, multiple parts of a program need to share ownership of an object. <code>std::shared_ptr</code> allows multiple pointers to <em>share ownership</em> of the same resource. The object is destroyed only when the <em>last</em> <code>shared_ptr</code> owning it is destroyed or reset.</p><h3 id="creating-and-using-shared-ptr">Creating and Using <code>shared_ptr</code></h3><div class="code-block">
 <button class="copy-button" onclick="copyCode(this)">📋</button>
 <pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;memory&gt;

int main() {
    std::shared_ptr&lt;int&gt; sp1 = std::make_shared&lt;int&gt;(100);
    std::cout &lt;&lt; "Value: " &lt;&lt; *sp1 &lt;&lt; '\n';
    std::cout &lt;&lt; "Use count: " &lt;&lt; sp1.use_count() &lt;&lt; '\n'; // 1

    {
        std::shared_ptr&lt;int&gt; sp2 = sp1; // shared ownership
        std::cout &lt;&lt; "Use count after copy: " &lt;&lt; sp1.use_count() &lt;&lt; '\n'; // 2
        std::cout &lt;&lt; "sp2 points to: " &lt;&lt; *sp2 &lt;&lt; '\n';
    } // sp2 goes out of scope here

    std::cout &lt;&lt; "Use count after sp2 destroyed: " &lt;&lt; sp1.use_count() &lt;&lt; '\n'; // 1

    return 0;
}</code></pre>
</div><h3 id="key-features-of-shared-ptr">Key features of <code>shared_ptr</code>:</h3><ul>
 <li>Maintains an internal <em>reference count</em> to track how many <code>shared_ptr</code>s own the object.</li>
 <li>When the last <code>shared_ptr</code> is destroyed or reset, the managed object is deleted.</li>
 <li>You can query the number of owners with <code>use_count()</code>.</li>
 <li>You can safely copy <code>shared_ptr</code>s, increasing the reference count.</li>
</ul><h3 id="potential-issues">Potential issues</h3><ul>
 <li><strong>Circular references:</strong> If two <code>shared_ptr</code>s reference each other, the reference count never reaches zero, causing a memory leak. This is where <code>weak_ptr</code> helps (explained next).</li>
 <li>Slightly more overhead than <code>unique_ptr</code> due to reference counting.</li>
</ul><h3 id="weak-ptr-breaking-cyclic-dependencies"><code>weak_ptr</code>: Breaking Cyclic Dependencies</h3><p><code>std::weak_ptr</code> is a companion to <code>shared_ptr</code>. It holds a <em>non-owning</em> ("weak") reference to an object managed by <code>shared_ptr</code>. It does <strong>not</strong> increase the reference count and thus does not affect the lifetime of the object.</p><h3 id="why-weak-ptr">Why <code>weak_ptr</code>?</h3><p>When two or more objects hold <code>shared_ptr</code>s to each other, they form a <strong>reference cycle</strong>, preventing their memory from ever being freed. Using <code>weak_ptr</code> breaks this cycle by providing a way to reference an object without extending its lifetime.</p><h3 id="using-weak-ptr">Using <code>weak_ptr</code></h3><div class="code-block">
 <button class="copy-button" onclick="copyCode(this)">📋</button>
 <pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;memory&gt;

struct Node {
    std::shared_ptr&lt;Node&gt; next;
    std::weak_ptr&lt;Node&gt; prev; // weak_ptr to break cycle
    int value;

    Node(int v) : value(v) {}
};

int main() {
    auto first = std::make_shared&lt;Node&gt;(1);
    auto second = std::make_shared&lt;Node&gt;(2);

    first-&gt;next = second;
    second-&gt;prev = first; // weak_ptr doesn't increase ref count

    std::cout &lt;&lt; "First use count: " &lt;&lt; first.use_count() &lt;&lt; '\n';  // 1
    std::cout &lt;&lt; "Second use count: " &lt;&lt; second.use_count() &lt;&lt; '\n'; // 1

    // Access prev node safely
    if (auto prevPtr = second-&gt;prev.lock()) {
        std::cout &lt;&lt; "Second's prev value: " &lt;&lt; prevPtr-&gt;value &lt;&lt; '\n';
    }

    return 0;
}</code></pre>
</div><h3 id="important-aspects-of-weak-ptr">Important aspects of <code>weak_ptr</code>:</h3><ul>
 <li>You <strong>cannot directly dereference</strong> a <code>weak_ptr</code>. Instead, call <code>lock()</code> which returns a <code>shared_ptr</code> if the object is still alive.</li>
 <li>If the object has been deleted, <code>lock()</code> returns an empty <code>shared_ptr</code>.</li>
 <li>Useful for caching, observer patterns, or any situation where you want to observe an object without preventing its deletion.</li>
</ul><h3 id="summary-of-smart-pointer-usage">Summary of Smart Pointer Usage</h3><table>
 <thead>
  <tr>
   <th>Smart Pointer</th>
   <th>Ownership Type</th>
   <th>Copyable?</th>
   <th>Use Case</th>
  </tr>
 </thead>
 <tbody>
  <tr>
   <td><code>unique_ptr</code></td>
   <td>Exclusive</td>
   <td>No (move only)</td>
   <td>When single ownership is needed</td>
  </tr>
  <tr>
   <td><code>shared_ptr</code></td>
   <td>Shared (reference counting)</td>
   <td>Yes</td>
   <td>When multiple owners share the object</td>
  </tr>
  <tr>
   <td><code>weak_ptr</code></td>
   <td>Non-owning observer</td>
   <td>Yes</td>
   <td>To avoid circular references or observe object</td>
  </tr>
 </tbody>
</table><h3 id="additional-tips-and-best-practices">Additional Tips and Best Practices</h3><ul>
 <li><p>Prefer <code>std::make_unique&lt;T&gt;()</code> and <code>std::make_shared&lt;T&gt;()</code> to create smart pointers. They are safer and more efficient.</p>
  <div class="code-block">
   <button class="copy-button" onclick="copyCode(this)">▯</button>
   <pre><code class="language-cpp">auto up = std::make_unique&lt;int&gt;(10);
auto sp = std::make_shared&lt;int&gt;(20);</code></pre>
  </div></li>
 <li><p>Avoid using raw <code>new</code> and <code>delete</code> directly; smart pointers handle memory safely.</p></li>
 <li><p>Avoid mixing raw pointers and smart pointers for the same resource.</p></li>
 <li><p>Remember that <code>unique_ptr</code> is lighter and faster but less flexible than <code>shared_ptr</code>.</p></li>
 <li><p>Always use <code>weak_ptr</code> to break reference cycles when designing complex object graphs.</p></li>
</ul><h3 id="conclusion">Conclusion</h3><p>Smart pointers are a fundamental part of modern C++ programming, providing powerful tools to manage dynamic memory safely and efficiently. <code>unique_ptr</code> guarantees exclusive ownership and zero-overhead automatic cleanup, <code>shared_ptr</code> enables shared ownership with automatic reference counting, and <code>weak_ptr</code> prevents cyclic dependencies and dangling references.</p><p>By incorporating smart pointers into your programs, you reduce the chances of memory leaks and dangling pointers, making your code more robust, readable, and maintainable.</p><div class = "chapter-navi-section">
<a href="#top" class="nav-button prev">↑</a>
<a href='cplusplus-for-beginners.htm#advanced-memory-management' class="nav-button toc-link">Index</a>
<a href="#bottom" class="nav-button next">↓</a>
</div>
<h2 id='move-semantics-and-rvalue-references'>16.2 Move Semantics and Rvalue References</h2><p>In traditional C++, copying objects—especially those managing dynamic resources like memory or file handles—can be expensive. Copy constructors and copy assignment operators duplicate the underlying data, which can be slow and resource-intensive, particularly for large objects or containers.</p><p><strong>Move semantics</strong>, introduced in C++11, provide a way to transfer resources from one object to another <strong>without copying</strong>, optimizing performance. This powerful feature uses <strong>rvalue references</strong> and enables the compiler and programmer to "move" resources rather than duplicate them.</p><p>In this section, we will explore the concepts behind move semantics, explain rvalue references and their distinction from lvalues, and show how to implement move constructors and move assignment operators. We will also discuss how <code>std::move</code> helps explicitly indicate moves and examine the practical benefits through examples.</p><h3 id="understanding-lvalues-and-rvalues">Understanding Lvalues and Rvalues</h3><p>To understand move semantics, it is crucial to know the difference between <strong>lvalues</strong> and <strong>rvalues</strong>:</p><ul>
 <li><p><strong>Lvalue (locator value):</strong> An expression that refers to a specific memory location and has an identifiable address. Variables you can take the address of are lvalues. For example:</p>
  <div class="code-block">
   <button class="copy-button" onclick="copyCode(this)">▯</button>
   <pre><code class="language-cpp">int x = 5;     // x is an lvalue
int* p = &amp;x;   // legal: taking address of x</code></pre>
  </div></li>
 <li><p><strong>Rvalue (read value):</strong> A temporary object or value that does not have a persistent memory address. Examples include literals, temporary objects returned from functions, or expressions like <code>x + y</code>. For example:</p>
  <div class="code-block">
   <button class="copy-button" onclick="copyCode(this)">▯</button>
   <pre><code class="language-cpp">int y = 10;
int z = x + y;  // x + y is an rvalue</code></pre>
  </div></li>
</ul><p>Before C++11, you could only bind lvalues to references (e.g., <code>int&amp; ref = x;</code>). Rvalues could not bind to non-const references, limiting optimization opportunities.</p><h3 id="rvalue-references">Rvalue References (<code>&amp;&amp;</code>)</h3><p>C++11 introduced <strong>rvalue references</strong>, declared with <code>&amp;&amp;</code>, allowing functions and constructors to accept rvalues explicitly.</p><div class="code-block">
 <button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-cpp">int&amp;&amp; rref = 10;  // binds to temporary (rvalue)</code></pre>
</div><p>This enables functions to differentiate between lvalues and rvalues, so they can:</p><ul>
 <li>Copy resources when passed an lvalue (to keep the original intact).</li>
 <li>Move resources (i.e., steal ownership) when passed an rvalue, avoiding expensive copies.</li>
</ul><p>Rvalue references are the foundation of move semantics.</p><h3 id="what-is-move-semantics">What Is Move Semantics?</h3><p>Move semantics allow the <strong>resources owned by a temporary object (rvalue)</strong> to be transferred ("moved") to another object rather than copied. After the move, the source object is typically left in a valid but unspecified (often "empty") state.</p><p>This transfer avoids the costly operations involved in copying large resources like dynamically allocated arrays, file handles, or sockets.</p><h3 id="using-std-move">Using <code>std::move</code></h3><p>The function <code>std::move</code> is a utility that <strong>casts its argument to an rvalue reference</strong>, enabling move semantics for objects that are otherwise lvalues.</p><div class="code-block">
 <button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-cpp">#include &lt;utility&gt;  // for std::move

std::string s1 = "Hello";
std::string s2 = std::move(s1);  // Move s1's content to s2</code></pre>
</div><p>After this, <code>s1</code> is in a valid but unspecified state (often empty), and <code>s2</code> now owns the original string content.</p><h3 id="move-constructor-and-move-assignment-operator">Move Constructor and Move Assignment Operator</h3><p>Classes that manage resources can define:</p><ul>
 <li>A <strong>move constructor</strong>: constructs an object by taking ownership of the resources from an rvalue.</li>
 <li>A <strong>move assignment operator</strong>: transfers resources from an rvalue to an existing object.</li>
</ul><p>These are similar in purpose to copy constructor and copy assignment but optimized for moving resources.</p><h3 id="move-constructor-syntax">Move Constructor Syntax</h3><div class="code-block">
 <button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-cpp">ClassName(ClassName&amp;&amp; other) noexcept;</code></pre>
</div><ul>
 <li>Takes an rvalue reference to another object.</li>
 <li>Transfers ownership of resources.</li>
 <li>Leaves <code>other</code> in a safe-to-destruct state.</li>
</ul><h3 id="move-assignment-operator-syntax">Move Assignment Operator Syntax</h3><div class="code-block">
 <button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-cpp">ClassName&amp; operator=(ClassName&amp;&amp; other) noexcept;</code></pre>
</div><ul>
 <li>Transfers ownership from <code>other</code> to the current object.</li>
 <li>Properly frees any existing resources before the move.</li>
 <li>Leaves <code>other</code> in a valid state.</li>
</ul><h3 id="example-move-semantics-in-a-simple-string-wrapper">Example: Move Semantics in a Simple String Wrapper</h3><p>Let’s illustrate move semantics with a simplified string wrapper class:</p><div class="code-block">
 <button class="copy-button" onclick="copyCode(this)">📋</button>
 <pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;cstring&gt;

class MyString {
private:
    char* data;
public:
    // Constructor
    MyString(const char* s) {
        if (s) {
            data = new char[strlen(s) + 1];
            strcpy(data, s);
        } else {
            data = nullptr;
        }
    }

    // Destructor
    ~MyString() {
        delete[] data;
    }

    // Copy Constructor
    MyString(const MyString&amp; other) {
        std::cout &lt;&lt; "Copy constructor called\n";
        if (other.data) {
            data = new char[strlen(other.data) + 1];
            strcpy(data, other.data);
        } else {
            data = nullptr;
        }
    }

    // Move Constructor
    MyString(MyString&amp;&amp; other) noexcept {
        std::cout &lt;&lt; "Move constructor called\n";
        data = other.data;    // Steal resource
        other.data = nullptr; // Leave other in safe state
    }

    // Copy Assignment
    MyString&amp; operator=(const MyString&amp; other) {
        std::cout &lt;&lt; "Copy assignment called\n";
        if (this != &amp;other) {
            delete[] data;
            if (other.data) {
                data = new char[strlen(other.data) + 1];
                strcpy(data, other.data);
            } else {
                data = nullptr;
            }
        }
        return *this;
    }

    // Move Assignment
    MyString&amp; operator=(MyString&amp;&amp; other) noexcept {
        std::cout &lt;&lt; "Move assignment called\n";
        if (this != &amp;other) {
            delete[] data;
            data = other.data;    // Steal resource
            other.data = nullptr; // Safe state for other
        }
        return *this;
    }

    void print() const {
        if (data) std::cout &lt;&lt; data &lt;&lt; '\n';
        else std::cout &lt;&lt; "(null)\n";
    }
};

int main() {
    MyString s1("Hello");
    MyString s2 = std::move(s1);  // Calls move constructor

    s2.print();
    s1.print(); // Should be null

    MyString s3("World");
    s3 = std::move(s2);  // Calls move assignment

    s3.print();
    s2.print(); // Should be null

    return 0;
}</code></pre>
</div><h3 id="output">Output</h3><div class="code-block">
 <button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-bash">Move constructor called
Hello
(null)
Move assignment called
Hello
(null)</code></pre>
</div><h3 id="explanation">Explanation:</h3><ul>
 <li>Move constructor steals the internal pointer instead of allocating and copying.</li>
 <li>After the move, the source (<code>s1</code> or <code>s2</code>) is left with <code>nullptr</code> to prevent double deletion.</li>
 <li>Move assignment frees any current resource before stealing the new one.</li>
</ul><h3 id="performance-benefits">Performance Benefits</h3><p>Move semantics significantly improve performance by:</p><ul>
 <li>Eliminating deep copies of large resources.</li>
 <li>Enabling efficient transfer of ownership in STL containers like <code>std::vector</code>, <code>std::string</code>, <code>std::unique_ptr</code>.</li>
 <li>Reducing unnecessary memory allocations and deallocations.</li>
</ul><p>For example, when a vector resizes, it moves elements to the new storage using move constructors if available, making resizing faster than copying.</p><h3 id="using-move-semantics-with-stl-containers">Using Move Semantics with STL Containers</h3><p>The Standard Library containers support move semantics. Consider this example with a vector of strings:</p><div class="code-block">
 <button class="copy-button" onclick="copyCode(this)">📋</button>
 <pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;

int main() {
    std::vector&lt;std::string&gt; v;
    v.push_back("One");
    v.push_back("Two");

    std::string s = "Three";
    v.push_back(std::move(s));  // Moves 's' into vector

    std::cout &lt;&lt; "Vector contents:\n";
    for (const auto&amp; str : v) {
        std::cout &lt;&lt; str &lt;&lt; '\n';
    }
    std::cout &lt;&lt; "Original string after move: " &lt;&lt; s &lt;&lt; '\n'; // Usually empty

    return 0;
}</code></pre>
</div><h3 id="summary-and-best-practices">Summary and Best Practices</h3><ul>
 <li>Implement move constructors and move assignment operators for classes managing resources.</li>
 <li>Use <code>std::move</code> to enable moves for lvalues when appropriate.</li>
 <li>Mark move operations <code>noexcept</code> if possible to enable optimizations.</li>
 <li>Prefer <code>std::make_unique</code> and <code>std::make_shared</code> to create smart pointers efficiently using move semantics.</li>
 <li>Understand that after moving, the source object is left in a valid but unspecified state.</li>
 <li>Use move semantics to optimize performance, especially for large objects or containers.</li>
</ul><h3 id="conclusion">Conclusion</h3><p>Move semantics and rvalue references provide powerful tools for efficient resource management in C++. By enabling the transfer of resources instead of expensive copies, move semantics improve performance and express intent clearly. With practice, move semantics become an essential technique for writing modern, optimized C++ code.</p><p>In the next section, we will explore <strong>RAII (Resource Acquisition Is Initialization)</strong>—a core idiom for managing resources safely and effectively in C++.</p><div class = "chapter-navi-section">
<a href="#top" class="nav-button prev">↑</a>
<a href='cplusplus-for-beginners.htm#advanced-memory-management' class="nav-button toc-link">Index</a>
<a href="#bottom" class="nav-button next">↓</a>
</div>
<h2 id='raii-resource-acquisition-is-initialization'>16.3 RAII (Resource Acquisition Is Initialization)</h2><p>In C++, managing resources such as memory, file handles, or locks can be tricky. Forgetting to release these resources leads to issues like memory leaks, resource exhaustion, or deadlocks. To solve these problems in a clean, robust way, C++ programmers rely on a fundamental idiom called <strong>RAII</strong>, which stands for <strong>Resource Acquisition Is Initialization</strong>.</p><p>RAII ties the lifetime of a resource directly to the lifetime of an object, ensuring that resources are acquired and released in a controlled, exception-safe manner.</p><h3 id="what-is-raii">What Is RAII?</h3><p>RAII is a design pattern where <strong>resource management is bound to the lifespan of an object</strong>. When an object is created (initialized), it acquires the resource. When the object goes out of scope or is destroyed, its destructor automatically releases the resource.</p><p>This automatic acquisition and release help eliminate many common bugs related to manual resource management, such as:</p><ul>
 <li>Memory leaks (forgetting to <code>delete</code> allocated memory)</li>
 <li>File handles left open</li>
 <li>Mutexes never unlocked</li>
</ul><p>In other words, resource management becomes predictable and safe, even in the presence of exceptions.</p><h3 id="how-raii-works">How RAII Works</h3><p>The core idea is simple:</p><ul>
 <li><strong>Constructor acquires the resource</strong> (e.g., opens a file, allocates memory, locks a mutex).</li>
 <li><strong>Destructor releases the resource</strong> (e.g., closes the file, frees memory, unlocks the mutex).</li>
</ul><p>Because destructors run automatically when an object goes out of scope (stack unwinding), resources are always properly cleaned up, even if an exception is thrown.</p><h3 id="raii-example-managing-a-file-handle">RAII Example: Managing a File Handle</h3><p>Consider managing a file with manual <code>fopen</code> and <code>fclose</code> calls:</p><div class="code-block">
 <button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-cpp">#include &lt;cstdio&gt;

void writeToFile(const char* filename) {
    FILE* file = fopen(filename, "w");
    if (!file) {
        throw std::runtime_error("Failed to open file");
    }

    fprintf(file, "Hello RAII!\n");

    // Must remember to close file manually
    fclose(file);
}</code></pre>
</div><p>If an exception is thrown before <code>fclose</code> is called, the file remains open, potentially causing resource leaks.</p><p>Using RAII, we wrap the file in a class that handles opening and closing automatically:</p><div class="code-block">
 <button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-cpp">#include &lt;cstdio&gt;
#include &lt;stdexcept&gt;

class FileRAII {
private:
    FILE* file;
public:
    FileRAII(const char* filename, const char* mode) {
        file = fopen(filename, mode);
        if (!file) {
            throw std::runtime_error("Failed to open file");
        }
    }

    ~FileRAII() {
        if (file) {
            fclose(file);
        }
    }

    FILE* get() const { return file; }

    // Disable copying to avoid double fclose
    FileRAII(const FileRAII&amp;) = delete;
    FileRAII&amp; operator=(const FileRAII&amp;) = delete;
};

void writeToFile(const char* filename) {
    FileRAII file(filename, "w");
    fprintf(file.get(), "Hello RAII!\n");

    // No explicit fclose needed; handled automatically
}</code></pre>
</div><p>Now, regardless of how the function exits (normal return or exception), the file is closed properly.</p><h3 id="raii-with-mutex-locks">RAII with Mutex Locks</h3><p>RAII is especially important for managing <strong>locks</strong> in concurrent programming to prevent deadlocks.</p><p>Manually locking and unlocking a mutex can be error-prone:</p><div class="code-block">
 <button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-cpp">#include &lt;mutex&gt;

std::mutex mtx;

void doWork() {
    mtx.lock();
    // ... critical section ...
    mtx.unlock();
}</code></pre>
</div><p>If an exception occurs inside the critical section, <code>mtx.unlock()</code> may never be called, causing deadlocks.</p><p>Using RAII, the Standard Library provides <code>std::lock_guard</code> to manage mutexes:</p><div class="code-block">
 <button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-cpp">#include &lt;mutex&gt;

std::mutex mtx;

void doWork() {
    std::lock_guard&lt;std::mutex&gt; lock(mtx);  // locks on construction
    // ... critical section ...

    // automatically unlocks when 'lock' goes out of scope
}</code></pre>
</div><p><code>std::lock_guard</code> locks the mutex in its constructor and unlocks it in its destructor, guaranteeing the mutex is always released.</p><h3 id="raii-and-smart-pointers">RAII and Smart Pointers</h3><p>Smart pointers, such as <code>std::unique_ptr</code> and <code>std::shared_ptr</code>, are classic RAII examples that manage dynamic memory:</p><div class="code-block">
 <button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-cpp">#include &lt;memory&gt;

void example() {
    std::unique_ptr&lt;int&gt; ptr(new int(42));  // acquires memory

    // use ptr like a normal pointer
    std::cout &lt;&lt; *ptr &lt;&lt; std::endl;

    // no explicit delete needed; memory freed when ptr is destroyed
}</code></pre>
</div><p>When the smart pointer goes out of scope, it automatically deletes the memory it manages, preventing leaks and dangling pointers.</p><h3 id="benefits-of-raii">Benefits of RAII</h3><ul>
 <li><strong>Exception Safety:</strong> Resources are released even when exceptions occur, preventing leaks.</li>
 <li><strong>Simplified Code:</strong> No need for explicit resource release calls scattered throughout code.</li>
 <li><strong>Improved Maintainability:</strong> The resource management logic is localized within RAII classes.</li>
 <li><strong>Predictable Lifetime:</strong> The resource lifetime exactly matches the object lifetime.</li>
</ul><h3 id="guidelines-for-implementing-raii">Guidelines for Implementing RAII</h3><ul>
 <li>Encapsulate resource acquisition in constructors.</li>
 <li>Encapsulate resource release in destructors.</li>
 <li>Disable copying if copying a resource doesn’t make sense or implement deep copies.</li>
 <li>Prefer using existing RAII wrappers (like smart pointers, lock guards) instead of reinventing the wheel.</li>
 <li>Make RAII classes small and focused, managing a single resource.</li>
</ul><h3 id="summary">Summary</h3><p>RAII is a cornerstone idiom in C++ programming that leverages constructors and destructors to manage resources automatically. It ties resource lifetime to object lifetime, ensuring resources like memory, file handles, and locks are safely acquired and released.</p><p>By embracing RAII, your code becomes safer, cleaner, and easier to maintain — especially when dealing with exceptions or complex control flows.</p><div class = "chapter-navi-section">
<a href="#top" class="nav-button prev">↑</a>
<a href='cplusplus-for-beginners.htm#advanced-memory-management' class="nav-button toc-link">Index</a>
<a href="#bottom" class="nav-button next">↓</a>
</div>
<h2 id='memory-leaks-and-tools-for-detection'>16.4 Memory Leaks and Tools for Detection</h2><p>Memory leaks are a common and critical problem in C++ programming, especially in applications that manage dynamic memory manually. They occur when a program allocates memory on the heap but fails to release it, causing the application’s memory usage to grow unnecessarily over time. This can lead to degraded performance, system instability, or even crashes due to exhausted memory.</p><h3 id="common-causes-of-memory-leaks-in-c">Common Causes of Memory Leaks in C</h3><p>Manual Memory Management Mistakes</p><p>In C++, dynamic memory is often allocated using <code>new</code> and deallocated with <code>delete</code>. Forgetting to call <code>delete</code> after a <code>new</code> allocation causes memory leaks:</p><div class="code-block">
 <button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-cpp">void leakExample() {
    int* ptr = new int(42);
    // Forgot to delete ptr
}</code></pre>
</div><h3 id="lost-pointers">Lost Pointers</h3><p>Another common cause is losing the pointer to allocated memory before freeing it:</p><div class="code-block">
 <button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-cpp">void leakExample() {
    int* ptr = new int[10];
    ptr = nullptr;  // lost the reference to allocated memory
    // No delete[] called, memory leaked
}</code></pre>
</div><h3 id="cyclic-references-in-smart-pointers">Cyclic References in Smart Pointers</h3><p>Even with smart pointers, memory leaks can occur if there are <strong>cyclic references</strong>, especially with <code>std::shared_ptr</code>. For example, two objects holding shared pointers to each other prevent both from being destroyed.</p><h3 id="impact-of-memory-leaks">Impact of Memory Leaks</h3><ul>
 <li><strong>Increased Memory Usage:</strong> Applications consume more RAM over time.</li>
 <li><strong>Performance Degradation:</strong> More memory usage can slow down systems.</li>
 <li><strong>Crashes:</strong> Out-of-memory conditions can cause program failure.</li>
 <li><strong>Hard-to-Debug Issues:</strong> Leaks may not manifest immediately, making them challenging to identify.</li>
</ul><h3 id="tools-and-techniques-for-detecting-memory-leaks">Tools and Techniques for Detecting Memory Leaks</h3><p>C++ developers use specialized tools to detect and analyze memory leaks. These tools monitor your program's memory allocations and deallocations, helping you identify leaks and their locations.</p><h3 id="valgrind-linux-macos">Valgrind (Linux/macOS)</h3><p>Valgrind is a popular open-source tool for detecting memory leaks and errors:</p><ul>
 <li><strong>How it works:</strong> Runs your program in a virtual environment, tracking memory operations.</li>
 <li><strong>Usage:</strong> Run your executable with <code>valgrind ./your_program</code>.</li>
 <li><strong>Output:</strong> Provides detailed reports of leaked blocks, including allocation stack traces.</li>
</ul><p><strong>Example Valgrind command:</strong></p><div class="code-block">
 <button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-bash">valgrind --leak-check=full ./your_program</code></pre>
</div><p>Valgrind will list all leaks and indicate where memory was allocated but never freed.</p><h3 id="addresssanitizer-asan">AddressSanitizer (ASan)</h3><p>AddressSanitizer is a fast memory error detector integrated with compilers like GCC and Clang:</p><ul>
 <li><strong>How it works:</strong> Adds instrumentation during compilation to check memory operations at runtime.</li>
 <li><strong>Usage:</strong> Compile with <code>-fsanitize=address -g</code> flags.</li>
 <li><strong>Output:</strong> Detects leaks, buffer overflows, use-after-free, and more.</li>
</ul><p><strong>Example compile command:</strong></p><div class="code-block">
 <button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-bash">g++ -fsanitize=address -g main.cpp -o main
./main</code></pre>
</div><p>ASan outputs detailed diagnostics with line numbers and stack traces.</p><h3 id="ide-integrated-profilers-and-debuggers">IDE-Integrated Profilers and Debuggers</h3><p>Many IDEs like Visual Studio, CLion, and Xcode provide built-in tools or plugins for memory profiling:</p><ul>
 <li><strong>Visual Studio:</strong> Offers a Diagnostic Tools window with memory usage reports.</li>
 <li><strong>CLion:</strong> Supports Valgrind integration and its own profiler.</li>
 <li><strong>Xcode:</strong> Instruments tool can track leaks and allocations.</li>
</ul><p>These tools offer GUI interfaces for easier analysis.</p><h3 id="best-practices-for-writing-leak-free-code">Best Practices for Writing Leak-Free Code</h3><h4 id="prefer-raii-and-smart-pointers">Prefer RAII and Smart Pointers</h4><p>Use RAII techniques and smart pointers (<code>std::unique_ptr</code>, <code>std::shared_ptr</code>) to automate memory management and avoid manual <code>new</code>/<code>delete</code> mistakes.</p><h4 id="avoid-raw-new-and-delete-in-high-level-code">Avoid Raw <code>new</code> and <code>delete</code> in High-Level Code</h4><p>Minimize direct use of <code>new</code> and <code>delete</code>. If manual management is necessary, encapsulate allocations within classes that follow RAII principles.</p><h4 id="watch-out-for-cyclic-references">Watch Out for Cyclic References</h4><p>Use <code>std::weak_ptr</code> to break cycles in shared ownership scenarios:</p><div class="code-block">
 <button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-cpp">struct Node {
    std::shared_ptr&lt;Node&gt; next;
    std::weak_ptr&lt;Node&gt; prev;  // prevents cyclic references
};</code></pre>
</div><h4 id="always-match-new-with-delete">Always Match <code>new[]</code> with <code>delete[]</code></h4><p>When allocating arrays, use <code>new[]</code> and pair it with <code>delete[]</code> to avoid undefined behavior and leaks.</p><h4 id="initialize-pointers-and-reset-them-after-deletion">Initialize Pointers and Reset Them After Deletion</h4><p>Set pointers to <code>nullptr</code> after deleting to avoid dangling pointers and accidental reuse.</p><h3 id="interpreting-tool-output">Interpreting Tool Output</h3><h4 id="valgrind-example-output">Valgrind Example Output</h4><div class="code-block">
 <button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-bash">==1234== 40 bytes in 1 blocks are definitely lost in loss record 1 of 2
==1234==    at 0x4C2BBAF: operator new(unsigned long) (vg_replace_malloc.c:334)
==1234==    by 0x4006F4: leakExample() (example.cpp:5)
==1234==    by 0x400720: main (example.cpp:12)</code></pre>
</div><ul>
 <li>Shows the number of bytes leaked.</li>
 <li>Shows the allocation site (file and line number).</li>
 <li>Use this info to locate and fix the leak.</li>
</ul><h3 id="addresssanitizer-output">AddressSanitizer Output</h3><div class="code-block">
 <button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-bash">=================================================================
==5678==ERROR: LeakSanitizer: detected memory leaks

Direct leak of 40 byte(s) in 1 object(s) allocated at:
    #0 0x4b9d70 in operator new(unsigned long)
    #1 0x4011a4 in leakExample() example.cpp:5
    #2 0x401240 in main example.cpp:12</code></pre>
</div><p>Similar info to Valgrind, with clear stack traces for debugging.</p><h3 id="summary">Summary</h3><p>Memory leaks remain a serious issue in C++ development, but modern tools and best practices significantly reduce their risk. By:</p><ul>
 <li>Understanding common leak causes,</li>
 <li>Using smart pointers and RAII,</li>
 <li>Employing powerful detection tools like Valgrind and AddressSanitizer,</li>
 <li>Carefully interpreting diagnostic reports,</li>
</ul><p>you can write efficient, leak-free C++ applications that maintain stability and performance over time.</p><div class = "chapter-navi-section">
<a href="cplusplus-for-beginners-file-input-and-output.htm" class="nav-button prev">←</a>
<a href='cplusplus-for-beginners.htm#advanced-memory-management' class="nav-button toc-link">Index</a>
<a href="cplusplus-for-beginners-multithreading-and-concurrency-basics.htm" class="nav-button next">→</a>
</div>
<section class="download-section">
  <div class="book-cover" style="background-color: #f9f6f1;border: 1px solid #ccc;"> 
    <div class="book-cover-title" style="font-size: 18px;color: #333;top: 20px;">C++ for Beginners</div>
    <div class="book-cover-author">readbytes</div>
    <div class="book-cover-bottom-stripe" style="background-color: #333;"></div>
    <img class="book-cover-icon" style="width: 90px;height: 90px;top: 70px;" src="data:image/png;base64,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"/>
  </div>
  <div class="download-info">
    <h2 id='bottom'>Download This Ebook</h2>
    <p class="format-label">Available formats:</p>
    <div class="download-buttons">
      <a href="cplusplus-for-beginners.pdf" class="download-button">📄 PDF</a>
      <a href="cplusplus-for-beginners.epub" class="download-button">📘 EPUB</a>
    </div>
  </div>
</section><div class='related-books'>
<h2>C++ Introduction Books</h2>
<div class='related-book-list'>
<a href="cplusplus-for-beginners.htm">
<div class="book-cover" style="background-color: #f9f6f1;border: 1px solid #ccc;"> 
    <div class="book-cover-title" style="font-size: 18px;color: #333;top: 20px;">C++ for Beginners</div>
    <div class="book-cover-author">readbytes</div>
    <div class="book-cover-bottom-stripe" style="background-color: #333;"></div>
    <img class="book-cover-icon" style="width: 90px;height: 90px;top: 70px;" src="data:image/png;base64,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"/>
  </div>
</a>


<a href="cplusplus-syntax.htm">
<div class="book-cover" style="background-color: #f9f6f1;border: 1px solid #ccc;"> 
    <div class="book-cover-title" style="font-size: 20px;color: #333;top: 20px;">C++ Syntax</div>
    <div class="book-cover-author">readbytes</div>
    <div class="book-cover-bottom-stripe" style="background-color: #333;"></div>
    <img class="book-cover-icon" style="width: 90px;height: 90px;top: 70px;" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFoAAABaCAYAAAA4qEECAAAFZ0lEQVR4Xu2dy4scVRSH8ye0iYtkERcmzgjT2OYBuhNREMVXBh/TgsYQx5ULDYTgVl3EFyg6uFJBV76IEXdKXAVBJCgISSTRGRmZiZlADBo6M5kp+3ZbnXt/p7q6btWtc++pqQPfpu/p7vP7UnSqi+m6GzbkrMbYO50u0Tqjgx5Kqe4brSa8+XplFf0UroQ3GbDltqNRs70Y3Tw5G22//2SXU0Fyy5MXc6GyqYyYWwd9WdfGbW9uxRe9vvlBtOvZKLrpwTOiUDO7QjlALxu3zWxFf5mq++RF/YU27/40au39lwSQAspygXICwhfRY2rhv5Z6URxcEuoAQUkuQV/oM7HwSN45vUoGlwaKKQOrI1t9zuhPaD19mQwtEZRSFrq71M/sqh3JMSikTHSH6LdXeoN6Ag4rlV3Ta0RG2aTKjhfU/6Q4rGRQAgf62QhKHnzjk3wKlwRK4EI7qq99g4wf3NR8nwwqmfE9s0QAF8olOarjB1QDDisZDM+NIbqhXYXDQaWDwbnRPj46xtkGDiodDM6N7nYgWl2hwkEl09r7DwnOzZbbr131G4iemFokw0oGQ/ug2XVKRI9PzpJhJYOhfdB66m8qevsDp8iwksHQPqi8aAzsi1o0E7VoJioteuzh30lgX1RaNIb1SS2aiVo0E5UVPTH1Fwnrk8qKxqC+qUUzUYtmwovoL49dioYV9uZhx/4VEjRmWM2fp70uYRc9qrA/DxhSZ1RhvyuCEL1wfiU6PXulB/bnAUPqnJnv8+cSTtEv7HeFd9G4XpyzJGQaWLjuisqJxoCjeOVjc572y7THBayim4+cNUKdONkhPUXBgKO495AxUrTvVdrjAq+ij//k/i9UMeAo7jlojFSLzsLE4/ZfuyspuvXYb0Yo16IxXBZQ9DOv0x4XsIqeOjRvhPri20ukpwgYLgt3HTBGir75kfa4gFU01h373f5ZA4bLChauu4BNdPtF82hWhT1FuHVfh4TLCtbR47SnKKWKTqu5hWXSXwQMZsOBGZzOLOzPA7voNz66QPpcgMHy8Py7OG2/sC8P7KLjurK8RvqLgMFsmDmC05mF/XkoVbTOjinz1E4V9uSl6I+AsF6YoT1FYROtwLpzeo705AFD2YKF6y5gFf3oQfPM48h3w8+jD3+4ZIDrOnGYtz7vgyHTuBvOo7/+nva4gFW0zTdDLFyPGdN+BBQXhkyDfDN8jfa4gFW0zbWOH365bIDrMXqYE7/2wZBpoOhKXOuwEZ0VDGTLuhD98+kO6bEFA9lyXxWvRyuwcN0GdccFDGTLe1+Z87Rfoj0uEC0aw+QBC9dd4V10XMsraz2wPw0Mk4WVq33WcID/C/tdwS766uqwiP3C/jQwTBZGFfa7gl204rnDC5hvUNg7DAySlWH1yTHa6xIvol2AQUKnFs2ESNHjk3MkSOiIFI0hJFCLZqIWzYQ40c0nLpAQEhAnGgNIoRbNRC2aCVGid6b8CCh0RInG4SVRi2YiUXSIN68ae8juR0ChkSg6xNux4eDSSLwdW4g3GMTBpZF4g0EFBvUNDi4N3a0SHeRNYCfaS2RwaWii+1s/xQ+oRQzsCxxaIoOjGe8fHdKNunFoaWzSdh/SRQd363kcXBrax4a5eVm8EMJmCmn33pDA5t2f0aMZRStUM4bnBAeXhu4SPfdKb/C54Q0OLomRklWFsoUTDi8F3d11N759A/o1quF5UzIcXgq6sy7n0GtiwZN6L4RCygIDSAB9oc/UwiOba+NIDBEy+tmF1ZGMhZ/ZijK3Qh3f8wcJEyJOt0LVC19UR12harbPOdncFzfWDQGVTb8KlwT6KlyNertqHffbVSdVo96A3ar+A5kzbYSE7G+UAAAAAElFTkSuQmCC"/>
  </div>
</a>


<a href="cplusplus-stl.htm">
<div class="book-cover" style="background-color: #f9f6f1;border: 1px solid #ccc;"> 
    <div class="book-cover-title" style="font-size: 20px;color: #333;top: 20px;">C++ STL</div>
    <div class="book-cover-author">readbytes</div>
    <div class="book-cover-bottom-stripe" style="background-color: #333;"></div>
    <img class="book-cover-icon" style="width: 90px;height: 90px;top: 70px;" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFoAAABaCAYAAAA4qEECAAADK0lEQVR4Xu2cvWsTcRjHo+DkIKiTjiJugqTJ0cG/QcRZ/wJXQTd3ByeHDiLJnS84dHMVBHUSRQUH90pNfmfb6CKi8fqSaj93ae4lzzV3+X7gS9vkeZ7f7/lwEDq0jYYQQgghxFzQ9t0wbTzf3WO/SAllpg3niAlQYJa0uu4W54kxeA96ZykwU4JwnTPFGGLyMqd3nTNFAnFx2cOZIiee//UK5TLsEQWg3D1ZHpxgvShATLCeajsoWKKNaAfuDyVvZuGhu8paURBK1lNtBAVLtBEULNFGULBEG0HBlRfNRUrMqwW/f473GZFQvxXWVQbPD5e4zEGlcXt4eHQvvrdbU2W4zEGn5Yd3+NoovHul4DKzHN69UnCZWQ7vXim8IHzJhWY1vLtIQSRujSInhTNEBppL345R6LiwV+SAUpPCHpETimVYLwpAuRJtBOVKtBHNR4OTFCzRRlCwRBtBwRJtBAVLtBEULNFGeN3wPiVvp/+OtVmJ5qzvmdl1z1kzV8Ql53+q0/6az765gBLyConqN9i/X9hfeyiAYX0S7cCtsi9NOKf2UADDesL6LOGsWsPlx+V8d/Vo3t5x4bzyGA4P8TK1TuBeU0FpxC5T83D/0uBF6h7uXxq8SN3D/Utj80OHl6ltgvAX9y+V2IUm53eUQZQvUT4nvJ8x/e/R14+RiBeeHz4bZfPn6PW3bT908Z7s4d6Vgwsxix13mj15iGb94Ows4bxKwWUY1heF89OGcyoHFypjOZ4zKV7gVjijUjSfrJ/hUqOwdtrwvH2yzN7KkbDUTsKfrLWgufTmSPzsf2F9ZeFitVtwVqBgiTaCgiXaCAqWaCMoWKKNoGCJNoKCJdoICpZoIyhYoo2gYIk2goIl2ggKlmgjKFiijaBgiTaCgiXagLbfu0jBW+m6NdaKAsQEj9Jxl1krChATvBPWiQJ4fviJgiV6yiw+3ThOuRI9ZbzA3aRYSZ4iFx73T1FqUtg3l1DKbrr9960gvBt9f207/Rst332I1U0Iz5tbKGaa4VlzTSQk8X84Fw3PEY3p/70KTxA7UFTeeB13ibPFf1BY1nCeEEIIIYQowl8t5mhjJHw+fQAAAABJRU5ErkJggg=="/>
  </div>
</a>



<a href='cplusplus.htm'><div class='book-cover' style='background-color: #f9f6f1;color: #111111;border: 1px solid #ccc;display: flex;justify-content: center;align-items: center;text-align: center;'>More C++ Books</div></a>
</div>
</div><script>
function copyCode(button) {const code = button.nextElementSibling.innerText;navigator.clipboard.writeText(code).then(() => {button.textContent = 'Copied!';setTimeout(() => { button.textContent = 'Copy'; }, 1500);});}
</script></div>
<style>
.site-footer {margin-top: 60px;padding: 20px 0;border-top: 1px solid #eee;text-align: center;font-size: 14px;}
.site-footer a {text-decoration: none;}
.light-mode .site-footer {color: #777;border-color: #eee;}
.dark-mode .site-footer {color: #888;border-color: #333;}
.light-mode .site-footer a {color: #555;}
.dark-mode .site-footer a {color: #aaa;}
.site-footer a:hover {text-decoration: underline;}    
</style>
<footer class="site-footer">
<nav><a href="https://readbytes.github.io">Home</a> |Email:<script type="text/javascript">
var part1 = 'yinpeng';var part6 = '263';var part2 = Math.pow(2,6);var part3 = String.fromCharCode(part2);var part4 = 'hotmail dot com';var part5 = part1 + String.fromCharCode(part2) + part4;document.write(part1 + part6 + part3 + part4);
</script>
| <a id="mode-toggle" href="#">Toggle Dark Mode</a>
</nav><p>© 2025 — All rights reserved.</p></footer>
<script>
const toggleButton = document.getElementById('mode-toggle');
const body = document.body;
const savedMode = localStorage.getItem('mode') || 'light';
body.classList.add(savedMode + '-mode');
toggleButton.addEventListener('click', () => {
      const isDark = body.classList.contains('dark-mode');
      body.classList.toggle('dark-mode', !isDark);
      body.classList.toggle('light-mode', isDark);
      localStorage.setItem('mode', isDark ? 'light' : 'dark');
});
function copyCode(button) {const code = button.nextElementSibling.innerText;navigator.clipboard.writeText(code).then(() => {button.textContent = 'Copied!';setTimeout(() => { button.textContent = 'Copy'; }, 1500);});}
</script>
</body>
</html>