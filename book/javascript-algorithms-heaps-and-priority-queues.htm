<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>JavaScript Algorithms Heaps and Priority Queues</title>
<link rel='shortcut icon' href='https://java2s.com/style/favicon.ico'>
<link href="https://fonts.googleapis.com/css2?family=Merriweather&display=swap" rel="stylesheet" />
<link href="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet" />

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/codemirror.min.css" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/theme/material.css"> <!-- Dark theme -->
<script src="https://cdn.jsdelivr.net/npm/typescript@5/lib/typescript.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/codemirror.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/mode/htmlmixed/htmlmixed.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/mode/xml/xml.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/mode/css/css.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/mode/javascript/javascript.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/mode/javascript/typescript.min.js"></script>
<style>
    #floatingLog {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(20, 20, 20, 0.95);
      color: white;
      font-family: monospace;
      font-size: 14px;
      padding: 16px 20px;
      border-radius: 8px;
      box-shadow: 0 4px 16px rgba(0, 0, 0, 0.4);
      max-width: 80%;
      max-height: 200px;
      overflow-y: auto;
      display: none;
      z-index: 9999;
      pointer-events: none;
      white-space: pre-wrap;
      text-align: center;
    }
</style>
<script>
  const codeMirrorMap = new Map();
  const iframeMap = new Map();
  
 

  let dismissTimer;
  function showFloatingLog(message) {
	const floatingLog = document.getElementById('floatingLog');

    if (floatingLog.style.display !== 'block') {
      floatingLog.textContent = '';
      floatingLog.style.display = 'block'; 
    }

    floatingLog.textContent += message + '\n';
    floatingLog.scrollTop = floatingLog.scrollHeight; 
    clearTimeout(dismissTimer);
    dismissTimer = setTimeout(() => {
      floatingLog.style.display = 'none';
      floatingLog.textContent = '';
    }, 2000);
  }
  window.addEventListener('message', (event) => {
	    if (!iframeMap.has(event.source)) return;

	    if (event.data?.type === 'console-log') {
	      showFloatingLog(event.data.message);
	    }
  });  
  function renderIframe(button,textarea_id, iframe_id) {
      const html = codeMirrorMap.get(textarea_id).getValue();
      const iframe = document.getElementById(iframe_id);
  
      const oldIframe = iframe;
      const newIframe = document.createElement('iframe');
      newIframe.className ="result_iframe";
      
      newIframe.id = iframe_id;
      oldIframe.replaceWith(newIframe);
 

      // Track the iframe in the map
      iframeMap.set(newIframe.contentWindow, button);

      const overrideScript = `
        <script>
          (function() {
            const originalLog = console.log;
            console.log = function(...args) {
              originalLog.apply(console, args);
              window.parent.postMessage({
                type: 'console-log',
                message: args.map(a => {
                  try { return JSON.stringify(a); }
                  catch { return String(a); }
                }).join(' ')
              }, '*');
            };
          })();
        <\/script>
      `;

      const iframeHTML = `
        <!DOCTYPE html>
        <html>
        <body>
          ${overrideScript}
          ${html}
        </body>
        </html>
      `;
 
      const doc = newIframe.contentDocument || newIframe.contentWindow.document;
      doc.open();
      doc.write(iframeHTML);
      doc.close();

      
  }
  function renderIframeForClientTypescript(textarea_id, iframe_id) {
      let code = codeMirrorMap.get(textarea_id).getValue();
      code = ts.transpile(code);
      const iframe = document.getElementById(iframe_id);
      const doc = iframe.contentDocument || iframe.contentWindow.document;

const html = `
  <!DOCTYPE html>
  <html>
    <head>
      <title>Output</title>
      <style>
        body { font-family: monospace; padding: 1em; background: #f4f4f4; color: #222; }
        pre { white-space: pre-wrap; word-break: break-word; }
        .error { color: red; }
      </style>
    </head>
    <body>
      <pre id="log"></pre>
      <script>
        (function(){
          const logEl = document.getElementById('log');
          const origLog = console.log;
          const origError = console.error;

          console.log = (...args) => {
            logEl.textContent += args.join(' ') + '\\n';
            origLog.apply(console, args);
          };
          console.table = (...args) => {
            logEl.textContent += args.join(' ') + '\\n';
            origLog.apply(console, args);
          };

          console.error = (...args) => {
            logEl.innerHTML +='<span class="error">' + args.join(' ') + '</span>';
            origError.apply(console, args);
          };
          window.addEventListener("error", function (event) {
              console.error("Caught by event listener:", event.message);
          });    
          try {             
              ${code};
          } catch (err) {
            console.error(err.stack || err.message);
          }
        })();
      <\/script>
    </body>
  </html>
`;

      iframe.style.display = "block";
      iframe.srcdoc = html;  
  }

    function renderIframeForClientJavascript(textarea_id, iframe_id) {
        const code = codeMirrorMap.get(textarea_id).getValue();
        const iframe = document.getElementById(iframe_id);
        const doc = iframe.contentDocument || iframe.contentWindow.document;

  const html = `
    <!DOCTYPE html>
    <html>
      <head>
        <title>Output</title>
        <style>
          body { font-family: monospace; padding: 1em; background: #1e1e1e; color: #eee; }
          pre { white-space: pre-wrap; word-break: break-word; }
          .error { color: red; }
        </style>
      </head>
      <body>
        <pre id="log"></pre>
        <script>
          (function(){
            const logEl = document.getElementById('log');
            const origLog = console.log;
            const origError = console.error;

            console.log = (...args) => {
              logEl.textContent += args.join(' ') + '\\n';
              origLog.apply(console, args);
            };
            console.table = (...args) => {
              logEl.textContent += args.join(' ') + '\\n';
              origLog.apply(console, args);
            };

            console.error = (...args) => {
              logEl.innerHTML +='<span class="error">' + args.join(' ') + '</span>';
              origError.apply(console, args);
            };
            window.addEventListener("error", function (event) {
                console.error("Caught by event listener:", event.message);
            });    
            try {
             ${code}; 
            } catch (err) {
              console.error(err.stack || err.message);
            }
          })();
        <\/script>
      </body>
    </html>
  `;
        iframe.style.display = "block";
        iframe.srcdoc = html;  
    }
    function toggleSnippetAndRefresh(id, textarea_id) {
      const box = document.getElementById(id);
      box.classList.toggle("open");
      codeMirrorMap.get(textarea_id).refresh();
    }

  </script>
  <script>
  const mode = localStorage.getItem('mode') || 'light';
  document.documentElement.classList.add(`${mode}-mode`);
  </script>   
<style> 
html {
  scroll-behavior: smooth;
}

body {
  font-family: 'Merriweather', serif;
  margin: 0;
  padding: 2rem 1rem;
  font-size: 15px;
  line-height: 1.5;
  transition: background-color 0.3s, color 0.3s;
}

.container {
  max-width: 700px;
  margin: 0 auto;
  padding: 1rem 2rem;
  box-shadow: 0 0 15px rgba(0,0,0,0.1);
}

h1, h2, h3 {
  font-weight: 600;
  margin-top: 2.5rem;
  margin-bottom: 1rem;
  line-height: 1.2;
}

h1 { font-size: 1.8rem; }
h2 { font-size: 1.4rem; }
h3 { font-size: 1.2rem; }

table {
  width: 100%;
  border-collapse: collapse;
  font-family: sans-serif;
  font-size: 1em;
  margin: 1em 0;
}

th, td {
  padding: 0.6em 1em;
  text-align: left;
  border: 1px solid;
}

tr:nth-child(even) {
  background-color: inherit;
}

tr:hover {
  background-color: inherit;
}

a {
  text-decoration: none;
  transition: color 0.2s;
}

a:hover {
  text-decoration: underline;
}

code {
  color: #d35400;
}

.book-title-chapter {
  font-family: 'Merriweather', serif;
  font-size: 2rem;
  font-weight: bold;
  text-align: center;
  margin-bottom: 2rem;
  border-bottom: 2px solid;
  padding-bottom: 0.5rem;
}

.book-subtitle-chapter {
  text-align: center;
  font-size: 1rem;
  margin-top: -1rem;
  margin-bottom: 2rem;
}

.related-books {
  margin-top: 40px;
}

.related-book-list {
  display: flex;
  flex-wrap: wrap;
  gap: 20px;
}

    .book-cover {
      width: 130px;
      height: 180px;
      font-family: Arial, sans-serif;
      position: relative;
      overflow: hidden;      
      line-height: normal;
      box-shadow: 2px 2px 4px rgba(0,0,0,0.1);
    }
    .book-cover-bottom-stripe {
      position: absolute;
      bottom: 0;
      left: 0;
      height: 5px;
      width: 100%;
    }
    .book-cover-title {
      position: absolute;
      width: 100%;
      text-align: center;
      font-weight: bold;
    }
     
    .book-cover-icon {
      position: absolute;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      align-items: center;
      justify-content: center; 
    }

    .book-cover-author {
      position: absolute;
      bottom: 10px;
      width: 100%;
      text-align: center;
      font-size: 8px;
      color: #333;
    }

.page-footer {
  margin-top: 4rem;
  padding: 1rem 0;
  text-align: center;
  font-size: 0.85rem;
  border-top: 1px solid;
}

.chapter-navi-section {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding-bottom: 10px;
}

.nav-link {
  color: inherit;
  text-decoration: none;
  opacity: 0.5;
  transition: opacity 0.3s ease, text-decoration 0.3s ease;
}

.nav-link:hover {
  opacity: 0.9;
  text-decoration: underline;
}

.prev { text-align: left; }
.toc-link { text-align: center; }
.next { text-align: right; }

.download-section {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 2rem;
  padding: 2rem 1rem;
  max-width: 600px;
  margin: 3rem auto;
  border-radius: 12px;
  box-shadow: 0 4px 10px rgba(0,0,0,0.05);
}

.download-info h2 {
  margin: 0 0 0.5rem;
  font-size: 1.2rem;
}

.format-label {
  margin: 0 0 0.5rem;
  font-size: 0.95rem;
}

.download-buttons {
  display: flex;
  gap: 1rem;
}

.download-button {
  background-color: #4A90E2;
  color: white;
  padding: 0.5em 1.2em;
  border-radius: 25px;
  font-size: 0.95rem;
  text-decoration: none;
  transition: background-color 0.3s ease;
}

.download-button:hover {
  background-color: #357ABD;
}

.code-block {
  position: relative;
  margin-bottom: 1em;
}

.copy-button {
  background: transparent;
  color: white;
  position: absolute;
  top: 8px;
  right: 8px;
  border: none;
  padding: 4px 8px;
  font-size: 12px;
  border-radius: 4px;
  cursor: pointer;
  z-index: 1;
}

.copy-button:hover {
  background-color: #0056b3;
}

.snippet-container {
  overflow: hidden;
}

.snippet-header {
  padding: 0.75rem 1rem;
  cursor: pointer;
  font-size: 1rem;
    background-color: #eeeeee;
    color:  #111111; 
    border-radius: 8px;
    cursor: pointer;
    box-shadow: 0 4px 6px rgba(0,0,0,0.1);  
}

.snippet-body {
  display: none;
  font-family: monospace;
}

.snippet-container.open .snippet-body {
  display: block;
}

.CodeMirror {
  border: 2px solid #ccc;
  border-radius: 4px;
  resize: vertical;
}

/* === Light Mode === */
html.light-mode {
  background-color: #f8f7f5;
  color: #333;
}

html.light-mode .container {
  background: white;
}

html.light-mode .book-title-chapter {
  color: #2c3e50;
  border-color: #ccc;
}
html.light-mode .book-subtitle-chapter{
  color: #888;
}

html.light-mode .page-footer,
html.light-mode .series-name,
html.light-mode .book-subtitle,
html.light-mode .format-label {
  color: #888;
}

html.light-mode .related-books h2 {
  color: #333;
  border-bottom: 2px solid #eee;
}

html.light-mode .book-title {
  color: #fff;
}

html.light-mode .book-cover {
  border: 1px solid #ccc;
}

html.light-mode th {
  background-color: #f2f2f2;
}

html.light-mode tr:nth-child(even) {
  background-color: #fafafa;
}

html.light-mode tr:hover {
  background-color: #e6f7ff;
}

html.light-mode a,
html.light-mode .page-footer a {
  color: #000;
}

/* === Dark Mode === */
html.dark-mode {
  background-color: #181818;
  color: #e0e0e0;
}

html.dark-mode .container {
  background: #222;
}

html.dark-mode .book-title-chapter {
  color: #ddd;
  border-color: #444;
}

html.dark-mode .snippet-header {
    background-color: #333;
    color:  #ddd; 
}


html.dark-mode .book-subtitle-chapter,
html.dark-mode .page-footer,
html.dark-mode .series-name,
html.dark-mode .book-subtitle,
html.dark-mode .book-footer,
html.dark-mode .format-label {
  color: #aaa;
}

html.dark-mode .related-books h2 {
  color: #ddd;
  border-bottom: 2px solid #333;
}

html.dark-mode .book-title {
  color: #fff;
}

html.dark-mode .book-cover {
  border: 1px solid #555;
}

html.dark-mode th {
  background-color: #333;
  color: #fff;
}

html.dark-mode td {
  border-color: #444;
}

html.dark-mode tr:nth-child(even) {
  background-color: #2a2a2a;
}

html.dark-mode tr:hover {
  background-color: #2c3e50;
}

html.dark-mode a,
html.dark-mode .page-footer a {
  color: #eee;
}

    .dialog-backdrop {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: rgba(0,0,0,0.5);
      display: none;
      justify-content: center;
      align-items: center;
      z-index: 10;
    }

    .dialog {
      background: white;
      padding: 20px;
      width: 90vw;
      height: 80vh;
      border-radius: 8px;
      box-shadow: 0 0 20px rgba(0,0,0,0.3);
      display: flex;
      flex-direction: column;
    }
    .dialog-content {
      display: flex;
      flex: 1;
      gap: 20px;
      margin-top: 10px;
    }
    .dialog h2 {
      margin-top: 0;
    }

    .textarea_dialog {
      width: 50%;
      height: 100%;
      resize: none;
      font-family: monospace;
      font-size: 14px;
      padding: 10px;
      box-sizing: border-box;
      border: 1px solid #ccc;
    }

    .iframe_dialog {
      width: 50%;
      height: 100%;
      border: 1px solid #ccc;
    }
    .controls_dialog {
      display: flex;
      justify-content: space-between;
      margin-top: 10px;
    }    
    button { padding: 0.5em 1em; background: green; color: white; border: none; cursor: pointer; }
    button:hover { background: #1e7e34; }
    .result_iframe { width:99%; height:200px; margin-top: 1em;  resize: both;border:1px solid #ccc;}        
</style>
</head>
<body> 
  <div class="container">
    <div class = "chapter-navi-section">
<a href="javascript-algorithms-trees-and-binary-search-trees.htm" class="nav-button prev">←</a>
<a href='javascript-algorithms.htm#heaps-and-priority-queues' class="nav-button toc-link">Index</a>
<a href="javascript-algorithms-balanced-search-trees.htm" class="nav-button next">→</a>
</div>

    <h1 class="book-title-chapter" id = 'top'>Heaps and Priority Queues</h1>
    <h3 class="book-subtitle-chapter">JavaScript Algorithms</h3>   
    <!-- <h1 class ="chapter-title"></h1> -->
    <h2 id='min-heap-max-heap'>11.1 Min-Heap, Max-Heap</h2><p>A <strong>heap</strong> is a specialized tree-based data structure that satisfies two important properties:</p><ul>
 <li>It is a <strong>complete binary tree</strong>, meaning all levels are fully filled except possibly the last, which is filled from left to right.</li>
 <li>It maintains the <strong>heap order property</strong>, which differs depending on whether it is a min-heap or max-heap.</li>
</ul><p>Heaps are widely used in algorithms requiring <strong>priority access</strong> to elements, such as priority queues and heap sort.</p><div class="snippet-container" id="<!DOCTYPE html>
<html lang=&quot;en&quot;>
<head>
  <meta charset=&quot;UTF-8&quot;>
  <title>Heap Visualizer</title>
  <style>
    body {
      font-family: Arial;
      text-align: center;
      padding: 20px;
    }
    canvas {
      border: 1px solid #ccc;
      background: #f8f8f8;
      margin-top: 10px;
    }
    input, button, select {
      margin: 5px;
      padding: 6px 10px;
      font-size: 16px;
    }
    #output {
      margin-top: 15px;
      font-size: 18px;
    }
  </style>
</head>
<body>

<h2>Heap Visualizer (Min/Max Toggle + Step-by-Step)</h2>

<input type=&quot;number&quot; id=&quot;valueInput&quot; placeholder=&quot;Enter number&quot;>
<button onclick=&quot;prepareInsert()&quot;>Insert</button>
<button onclick=&quot;prepareDelete()&quot;>Delete Root</button>
<select id=&quot;heapType&quot; onchange=&quot;setHeapType()&quot;>
  <option value=&quot;max&quot;>Max-Heap</option>
  <option value=&quot;min&quot;>Min-Heap</option>
</select>
<button onclick=&quot;stepForward()&quot;>Next</button>
<button onclick=&quot;stepBackward()&quot;>Back</button>

<canvas id=&quot;canvas&quot; width=&quot;1000&quot; height=&quot;500&quot;></canvas>
<div id=&quot;output&quot;></div>

<script>
const canvas = document.getElementById(&quot;canvas&quot;);
const ctx = canvas.getContext(&quot;2d&quot;);

let heap = [];
let heapType = &quot;max&quot;;
let animations = [];
let currentStep = 0;

function compare(a, b) {
  return heapType === &quot;min&quot; ? a < b : a > b;
}

function setHeapType() {
  heapType = document.getElementById(&quot;heapType&quot;).value;
}

function prepareInsert() {
  const value = parseInt(document.getElementById(&quot;valueInput&quot;).value);
  if (isNaN(value)) return;
  const steps = [];
  heap.push(value);
  let idx = heap.length - 1;
  steps.push({ type: 'insert', index: idx, value });
  while (idx > 0) {
    const parent = Math.floor((idx - 1) / 2);
    steps.push({ type: 'compare', i: idx, j: parent });
    if (compare(heap[idx], heap[parent])) {
      steps.push({ type: 'swap', i: idx, j: parent });
      [heap[idx], heap[parent]] = [heap[parent], heap[idx]];
      idx = parent;
    } else break;
  }
  steps.push({ type: 'done' });
  animations = steps;
  currentStep = 0;
  drawHeap();
}

function prepareDelete() {
  if (heap.length === 0) return;
  const steps = [];
  const last = heap.pop();
  if (heap.length === 0) {
    drawHeap();
    return;
  }
  heap[0] = last;
  let idx = 0;
  steps.push({ type: 'replaceRoot', value: last });
  while (true) {
    const left = 2 * idx + 1;
    const right = 2 * idx + 2;
    let target = idx;
    if (left < heap.length &amp;&amp; compare(heap[left], heap[target])) target = left;
    if (right < heap.length &amp;&amp; compare(heap[right], heap[target])) target = right;
    if (target !== idx) {
      steps.push({ type: 'swap', i: idx, j: target });
      [heap[idx], heap[target]] = [heap[target], heap[idx]];
      idx = target;
    } else break;
  }
  steps.push({ type: 'done' });
  animations = steps;
  currentStep = 0;
  drawHeap();
}

function stepForward() {
  if (currentStep >= animations.length) return;
  const step = animations[currentStep];
  if (step.type === 'swap') {
    [heap[step.i], heap[step.j]] = [heap[step.j], heap[step.i]];
  }
  currentStep++;
  drawHeap(step);
}

function stepBackward() {
  if (currentStep <= 0) return;
  currentStep--;
  const step = animations[currentStep];
  if (step.type === 'swap') {
    [heap[step.i], heap[step.j]] = [heap[step.j], heap[step.i]];
  }
  drawHeap(step);
}

function layoutHeap() {
  const positions = [];
  const levelHeight = 70;
  for (let i = 0; i < heap.length; i++) {
    const level = Math.floor(Math.log2(i + 1));
    const indexInLevel = i - (2 ** level - 1);
    const nodes = 2 ** level;
    const spacing = canvas.width / (nodes + 1);
    const x = spacing * (indexInLevel + 1);
    const y = 50 + level * levelHeight;
    positions.push({ x, y });
  }
  return positions;
}

function drawHeap(highlight = null) {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  const pos = layoutHeap();

  // Lines
  for (let i = 1; i < heap.length; i++) {
    const parent = Math.floor((i - 1) / 2);
    ctx.beginPath();
    ctx.moveTo(pos[i].x, pos[i].y);
    ctx.lineTo(pos[parent].x, pos[parent].y);
    ctx.strokeStyle = &quot;#aaa&quot;;
    ctx.stroke();
  }

  // Nodes
  for (let i = 0; i < heap.length; i++) {
    ctx.beginPath();
    ctx.arc(pos[i].x, pos[i].y, 20, 0, 2 * Math.PI);
    ctx.fillStyle = (highlight &amp;&amp; (highlight.i === i || highlight.j === i)) ? &quot;#f39c12&quot; : &quot;#3498db&quot;;
    ctx.fill();
    ctx.strokeStyle = &quot;#000&quot;;
    ctx.stroke();
    ctx.fillStyle = &quot;#fff&quot;;
    ctx.font = &quot;16px Arial&quot;;
    ctx.textAlign = &quot;center&quot;;
    ctx.textBaseline = &quot;middle&quot;;
    ctx.fillText(heap[i], pos[i].x, pos[i].y);
  }
  document.getElementById(&quot;output&quot;).textContent = `Heap Array: [${heap.join(', ')}]`;
}

</script>

</body>
</html>ID"><textarea id="nMe9g" style="display: none;">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
  &lt;meta charset="UTF-8"&gt;
  &lt;title&gt;Heap Visualizer&lt;/title&gt;
  &lt;style&gt;
    body {
      font-family: Arial;
      text-align: center;
      padding: 20px;
    }
    canvas {
      border: 1px solid #ccc;
      background: #f8f8f8;
      margin-top: 10px;
    }
    input, button, select {
      margin: 5px;
      padding: 6px 10px;
      font-size: 16px;
    }
    #output {
      margin-top: 15px;
      font-size: 18px;
    }
  &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;h2&gt;Heap Visualizer (Min/Max Toggle + Step-by-Step)&lt;/h2&gt;

&lt;input type="number" id="valueInput" placeholder="Enter number"&gt;
&lt;button onclick="prepareInsert()"&gt;Insert&lt;/button&gt;
&lt;button onclick="prepareDelete()"&gt;Delete Root&lt;/button&gt;
&lt;select id="heapType" onchange="setHeapType()"&gt;
  &lt;option value="max"&gt;Max-Heap&lt;/option&gt;
  &lt;option value="min"&gt;Min-Heap&lt;/option&gt;
&lt;/select&gt;
&lt;button onclick="stepForward()"&gt;Next&lt;/button&gt;
&lt;button onclick="stepBackward()"&gt;Back&lt;/button&gt;

&lt;canvas id="canvas" width="1000" height="500"&gt;&lt;/canvas&gt;
&lt;div id="output"&gt;&lt;/div&gt;

&lt;script&gt;
const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");

let heap = [];
let heapType = "max";
let animations = [];
let currentStep = 0;

function compare(a, b) {
  return heapType === "min" ? a &lt; b : a &gt; b;
}

function setHeapType() {
  heapType = document.getElementById("heapType").value;
}

function prepareInsert() {
  const value = parseInt(document.getElementById("valueInput").value);
  if (isNaN(value)) return;
  const steps = [];
  heap.push(value);
  let idx = heap.length - 1;
  steps.push({ type: 'insert', index: idx, value });
  while (idx &gt; 0) {
    const parent = Math.floor((idx - 1) / 2);
    steps.push({ type: 'compare', i: idx, j: parent });
    if (compare(heap[idx], heap[parent])) {
      steps.push({ type: 'swap', i: idx, j: parent });
      [heap[idx], heap[parent]] = [heap[parent], heap[idx]];
      idx = parent;
    } else break;
  }
  steps.push({ type: 'done' });
  animations = steps;
  currentStep = 0;
  drawHeap();
}

function prepareDelete() {
  if (heap.length === 0) return;
  const steps = [];
  const last = heap.pop();
  if (heap.length === 0) {
    drawHeap();
    return;
  }
  heap[0] = last;
  let idx = 0;
  steps.push({ type: 'replaceRoot', value: last });
  while (true) {
    const left = 2 * idx + 1;
    const right = 2 * idx + 2;
    let target = idx;
    if (left &lt; heap.length &amp;&amp; compare(heap[left], heap[target])) target = left;
    if (right &lt; heap.length &amp;&amp; compare(heap[right], heap[target])) target = right;
    if (target !== idx) {
      steps.push({ type: 'swap', i: idx, j: target });
      [heap[idx], heap[target]] = [heap[target], heap[idx]];
      idx = target;
    } else break;
  }
  steps.push({ type: 'done' });
  animations = steps;
  currentStep = 0;
  drawHeap();
}

function stepForward() {
  if (currentStep &gt;= animations.length) return;
  const step = animations[currentStep];
  if (step.type === 'swap') {
    [heap[step.i], heap[step.j]] = [heap[step.j], heap[step.i]];
  }
  currentStep++;
  drawHeap(step);
}

function stepBackward() {
  if (currentStep &lt;= 0) return;
  currentStep--;
  const step = animations[currentStep];
  if (step.type === 'swap') {
    [heap[step.i], heap[step.j]] = [heap[step.j], heap[step.i]];
  }
  drawHeap(step);
}

function layoutHeap() {
  const positions = [];
  const levelHeight = 70;
  for (let i = 0; i &lt; heap.length; i++) {
    const level = Math.floor(Math.log2(i + 1));
    const indexInLevel = i - (2 ** level - 1);
    const nodes = 2 ** level;
    const spacing = canvas.width / (nodes + 1);
    const x = spacing * (indexInLevel + 1);
    const y = 50 + level * levelHeight;
    positions.push({ x, y });
  }
  return positions;
}

function drawHeap(highlight = null) {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  const pos = layoutHeap();

  // Lines
  for (let i = 1; i &lt; heap.length; i++) {
    const parent = Math.floor((i - 1) / 2);
    ctx.beginPath();
    ctx.moveTo(pos[i].x, pos[i].y);
    ctx.lineTo(pos[parent].x, pos[parent].y);
    ctx.strokeStyle = "#aaa";
    ctx.stroke();
  }

  // Nodes
  for (let i = 0; i &lt; heap.length; i++) {
    ctx.beginPath();
    ctx.arc(pos[i].x, pos[i].y, 20, 0, 2 * Math.PI);
    ctx.fillStyle = (highlight &amp;&amp; (highlight.i === i || highlight.j === i)) ? "#f39c12" : "#3498db";
    ctx.fill();
    ctx.strokeStyle = "#000";
    ctx.stroke();
    ctx.fillStyle = "#fff";
    ctx.font = "16px Arial";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillText(heap[i], pos[i].x, pos[i].y);
  }
  document.getElementById("output").textContent = `Heap Array: [${heap.join(', ')}]`;
}

&lt;/script&gt;

&lt;/body&gt;
&lt;/html&gt;</textarea> <iframe id="0hvDI" class="result_iframe" style="border:none;"></iframe>
 <script>{
const textarea = document.getElementById("nMe9g");
const iframe = document.getElementById("0hvDI");
const html = textarea.value;
const iframeHTML = `${html}`;
const doc = iframe.contentDocument || iframe.contentWindow.document;
doc.open();
doc.write(iframeHTML);
doc.close();
setTimeout(() => {
iframe.style.height = '0px';
const contentHeight = Math.max(
  doc.body.scrollHeight,
  doc.documentElement.scrollHeight
);
iframe.style.height = contentHeight + 'px';
}, 50);
}
		</script>
</div><h3 id="complete-binary-tree-structure">Complete Binary Tree Structure</h3><p>A <strong>complete binary tree</strong> ensures the tree is balanced and dense. This property allows heaps to be efficiently implemented using arrays, where:</p><ul>
 <li><p>The root is at index 0.</p></li>
 <li><p>For a node at index <code>i</code>:</p>
  <ul>
   <li>Left child is at <code>2i + 1</code></li>
   <li>Right child is at <code>2i + 2</code></li>
   <li>Parent is at <code>Math.floor((i - 1) / 2)</code></li>
  </ul></li>
</ul><h3 id="min-heap-vs-max-heap">Min-Heap vs Max-Heap</h3><ul>
 <li><p><strong>Min-Heap</strong>: The value of each node is <strong>less than or equal to</strong> its children. The smallest element is always at the root.</p> <p>Use case: Efficiently retrieving the minimum element, like scheduling tasks with the earliest deadline.</p></li>
 <li><p><strong>Max-Heap</strong>: The value of each node is <strong>greater than or equal to</strong> its children. The largest element is always at the root.</p> <p>Use case: Implementing priority queues where the highest priority element is needed quickly.</p></li>
</ul><h3 id="heap-property-heap-invariant">Heap Property (Heap Invariant)</h3><p>The heap property is essential for priority access:</p><ul>
 <li>In a <strong>min-heap</strong>, every parent node is smaller than or equal to its children.</li>
 <li>In a <strong>max-heap</strong>, every parent node is greater than or equal to its children.</li>
</ul><p>This property guarantees that accessing the root gives the <strong>minimum</strong> or <strong>maximum</strong> element in constant time, <code>O(1)</code>.</p><h3 id="core-heap-operations">Core Heap Operations</h3><p>The two fundamental operations for heaps are:</p><ul>
 <li><strong>Insertion</strong>: Add a new element to the bottom of the tree (end of the array), then "bubble it up" to restore heap order.</li>
 <li><strong>Extraction (removeMin or removeMax)</strong>: Remove the root element and replace it with the last element, then "bubble it down" (heapify) to restore heap order.</li>
</ul><h3 id="javascript-min-heap-example">JavaScript Min-Heap Example</h3><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-js">class MinHeap {
  constructor() {
    this.heap = [];
  }

  getParentIndex(i) {
    return Math.floor((i - 1) / 2);
  }

  getLeftChildIndex(i) {
    return 2 * i + 1;
  }

  getRightChildIndex(i) {
    return 2 * i + 2;
  }

  swap(i, j) {
    [this.heap[i], this.heap[j]] = [this.heap[j], this.heap[i]];
  }

  insert(value) {
    this.heap.push(value);
    this.bubbleUp();
  }

  bubbleUp() {
    let index = this.heap.length - 1;
    while (
      index &gt; 0 &amp;&amp;
      this.heap[index] &lt; this.heap[this.getParentIndex(index)]
    ) {
      this.swap(index, this.getParentIndex(index));
      index = this.getParentIndex(index);
    }
  }

  extractMin() {
    if (this.heap.length === 0) return null;
    if (this.heap.length === 1) return this.heap.pop();

    const min = this.heap[0];
    this.heap[0] = this.heap.pop();
    this.bubbleDown();
    return min;
  }

  bubbleDown() {
    let index = 0;
    const length = this.heap.length;

    while (true) {
      const left = this.getLeftChildIndex(index);
      const right = this.getRightChildIndex(index);
      let smallest = index;

      if (left &lt; length &amp;&amp; this.heap[left] &lt; this.heap[smallest]) {
        smallest = left;
      }
      if (right &lt; length &amp;&amp; this.heap[right] &lt; this.heap[smallest]) {
        smallest = right;
      }
      if (smallest === index) break;

      this.swap(index, smallest);
      index = smallest;
    }
  }
}</code></pre>
</div><h3 id="visualizing-min-heap-operations">Visualizing Min-Heap Operations</h3><p>Suppose we insert the values <code>[10, 15, 20, 17, 25]</code> step-by-step:</p><ol>
 <li>Insert 10 → Heap: <code>[10]</code></li>
 <li>Insert 15 → Heap: <code>[10, 15]</code> (no swaps)</li>
 <li>Insert 20 → Heap: <code>[10, 15, 20]</code> (no swaps)</li>
 <li>Insert 17 → Heap: <code>[10, 15, 20, 17]</code> (no swaps)</li>
 <li>Insert 25 → Heap: <code>[10, 15, 20, 17, 25]</code> (no swaps)</li>
</ol><p>Now extract the minimum:</p><ul>
 <li>Remove root (10), replace with last (25) → <code>[25, 15, 20, 17]</code></li>
 <li>Bubble down swaps 25 with 15 → <code>[15, 25, 20, 17]</code></li>
 <li>Bubble down swaps 25 with 17 → <code>[15, 17, 20, 25]</code></li>
</ul><h3 id="why-use-heaps">Why Use Heaps?</h3><ul>
 <li><strong>Fast access to min or max</strong>: Root is always the min (min-heap) or max (max-heap).</li>
 <li><strong>Efficient insertions and deletions</strong>: Both operations take <code>O(log n)</code> due to tree height.</li>
 <li><strong>Applications</strong>: Priority queues, scheduling, graph algorithms (Dijkstra’s shortest path), and heap sort.</li>
</ul><h3 id="summary">Summary</h3><p>Heaps are complete binary trees that maintain a heap order—either min-heap or max-heap—enabling efficient priority access. Implementing heaps with arrays leverages their completeness for easy parent-child index calculations. The core operations of insertion and extraction rely on bubbling elements up or down to maintain the heap invariant. Understanding heaps lays the groundwork for efficient priority queue implementations and sorting algorithms like heap sort.</p><div class = "chapter-navi-section">
<a href="#top" class="nav-button prev">↑</a>
<a href='javascript-algorithms.htm#heaps-and-priority-queues' class="nav-button toc-link">Index</a>
<a href="#bottom" class="nav-button next">↓</a>
</div>
<h2 id='heap-sort'>11.2 Heap Sort</h2><p><strong>Heap sort</strong> is an efficient, comparison-based sorting algorithm that uses a <strong>binary heap</strong> to organize and sort elements. It’s particularly useful when <strong>in-place sorting</strong> is required and <strong>consistent time complexity</strong> is desired across best, average, and worst cases.</p><p>Heap sort works in <strong>two phases</strong>:</p><ol>
 <li><strong>Build a max-heap</strong> (or min-heap) from the input array.</li>
 <li><strong>Repeatedly extract</strong> the root (maximum or minimum), swap it to the end, and re-heapify the remaining portion.</li>
</ol><h3 id="phase-1-build-the-heap">Phase 1: Build the Heap</h3><p>A <strong>max-heap</strong> ensures the largest value is at the root. This is ideal when sorting in ascending order—by repeatedly removing the max, we can construct the sorted array from end to start.</p><p>We start heapifying from the last non-leaf node and move upwards, ensuring each subtree satisfies the heap property.</p><h3 id="phase-2-extract-elements-and-heapify">Phase 2: Extract Elements and Heapify</h3><p>Once the heap is built:</p><ul>
 <li>Swap the root with the last item in the heap.</li>
 <li>Reduce the heap size by 1.</li>
 <li>Re-heapify the root to restore heap order.</li>
</ul><p>Repeat until the heap is empty.</p><div class="snippet-container" id="<!DOCTYPE html>
<html lang=&quot;en&quot;>
<head>
  <meta charset=&quot;UTF-8&quot;>
  <title>Heap Sort Visualization</title>
  <style>
    body {
      font-family: Arial;
      text-align: center;
      padding: 20px;
    }
    canvas {
      border: 1px solid #ccc;
      background: #f8f8f8;
      margin-top: 10px;
      width:100%;
      height:400px;
    }
    input, button {
      font-size: 16px;
      margin: 5px;
      padding: 5px 10px;
    }
    #arrays {
      display: flex;
      justify-content: space-around;
      font-size: 18px;
      margin-top: 10px;
    }
    #arrays div {
      width: 30%;
    }
  </style>
</head>
<body>
<h2>Heap Sort Visualization</h2>
<input type=&quot;text&quot; id=&quot;arrayInput&quot; placeholder=&quot;e.g. 5,3,8,1,6&quot;>
<button onclick=&quot;startHeapSort()&quot;>Start Sort</button>
<canvas id=&quot;canvas&quot; height=&quot;400&quot;></canvas>
<div id=&quot;arrays&quot;>
  <div><strong>Original Array:</strong><br><span id=&quot;original&quot;></span></div>
  <div><strong>Heap:</strong><br><span id=&quot;heap&quot;></span></div>
  <div><strong>Sorted Result:</strong><br><span id=&quot;sorted&quot;></span></div>
</div>
<script>
const canvas = document.getElementById(&quot;canvas&quot;);
const ctx = canvas.getContext(&quot;2d&quot;);
let original = [];
let heap = [];
let sorted = [];
let steps = [];
let stepIndex = 0;

function startHeapSort() {
  const input = document.getElementById(&quot;arrayInput&quot;).value;
  original = input.split(',').map(x => parseInt(x.trim())).filter(x => !isNaN(x));
  heap = [...original];
  sorted = [];
  buildHeap(heap);
  steps = createSortSteps([...heap]);
  stepIndex = 0;
  draw();
  runSteps();
}

function buildHeap(arr) {
  for (let i = Math.floor(arr.length / 2) - 1; i >= 0; i--) {
    heapify(arr, i, arr.length);
  }
}

function heapify(arr, i, n) {
  let largest = i;
  const l = 2 * i + 1;
  const r = 2 * i + 2;
  if (l < n &amp;&amp; arr[l] > arr[largest]) largest = l;
  if (r < n &amp;&amp; arr[r] > arr[largest]) largest = r;
  if (largest !== i) {
    [arr[i], arr[largest]] = [arr[largest], arr[i]];
    heapify(arr, largest, n);
  }
}

function createSortSteps(arr) {
  const steps = [];
  for (let i = arr.length - 1; i >= 0; i--) {
    steps.push({ type: 'swap', i: 0, j: i });
    [arr[0], arr[i]] = [arr[i], arr[0]];
    steps.push({ type: 'heapify', stop: i });
    heapify(arr, 0, i);
    steps.push({ type: 'recordSorted', val: arr[i] });
  }
  return steps;
}

function runSteps() {
  if (stepIndex >= steps.length) return;
  const step = steps[stepIndex];
  if (step.type === 'swap') {
    [heap[step.i], heap[step.j]] = [heap[step.j], heap[step.i]];
  } else if (step.type === 'heapify') {
    // Redraw after heapify
  } else if (step.type === 'recordSorted') {
    sorted.unshift(step.val);
  }
  draw();
  stepIndex++;
  setTimeout(runSteps, 700);
}

function layoutHeap(arr) {
  const positions = [];
  const levelHeight = 70;
  for (let i = 0; i < arr.length; i++) {
    const level = Math.floor(Math.log2(i + 1));
    const indexInLevel = i - (2 ** level - 1);
    const nodes = 2 ** level;
    const spacing = canvas.width / (nodes + 1);
    const x = spacing * (indexInLevel + 1);
    const y = 50 + level * levelHeight;
    positions.push({ x, y });
  }
  return positions;
}

function draw() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  const pos = layoutHeap(heap);
  for (let i = 1; i < heap.length; i++) {
    const parent = Math.floor((i - 1) / 2);
    if (parent >= 0 &amp;&amp; pos[i] &amp;&amp; pos[parent]) {
      ctx.beginPath();
      ctx.moveTo(pos[i].x, pos[i].y);
      ctx.lineTo(pos[parent].x, pos[parent].y);
      ctx.strokeStyle = &quot;#aaa&quot;;
      ctx.stroke();
    }
  }
  for (let i = 0; i < heap.length; i++) {
    ctx.beginPath();
    ctx.arc(pos[i].x, pos[i].y, 20, 0, Math.PI * 2);
    ctx.fillStyle = &quot;#3498db&quot;;
    ctx.fill();
    ctx.stroke();
    ctx.fillStyle = &quot;#fff&quot;;
    ctx.font = &quot;16px Arial&quot;;
    ctx.textAlign = &quot;center&quot;;
    ctx.textBaseline = &quot;middle&quot;;
    ctx.fillText(heap[i], pos[i].x, pos[i].y);
  }
  document.getElementById(&quot;original&quot;).textContent = original.join(&quot;, &quot;);
  document.getElementById(&quot;heap&quot;).textContent = heap.join(&quot;, &quot;);
  document.getElementById(&quot;sorted&quot;).textContent = sorted.join(&quot;, &quot;);
}
</script>
</body>
</html>ID"><textarea id="zHR9W" style="display: none;">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
  &lt;meta charset="UTF-8"&gt;
  &lt;title&gt;Heap Sort Visualization&lt;/title&gt;
  &lt;style&gt;
    body {
      font-family: Arial;
      text-align: center;
      padding: 20px;
    }
    canvas {
      border: 1px solid #ccc;
      background: #f8f8f8;
      margin-top: 10px;
      width:100%;
      height:400px;
    }
    input, button {
      font-size: 16px;
      margin: 5px;
      padding: 5px 10px;
    }
    #arrays {
      display: flex;
      justify-content: space-around;
      font-size: 18px;
      margin-top: 10px;
    }
    #arrays div {
      width: 30%;
    }
  &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;h2&gt;Heap Sort Visualization&lt;/h2&gt;
&lt;input type="text" id="arrayInput" placeholder="e.g. 5,3,8,1,6"&gt;
&lt;button onclick="startHeapSort()"&gt;Start Sort&lt;/button&gt;
&lt;canvas id="canvas" height="400"&gt;&lt;/canvas&gt;
&lt;div id="arrays"&gt;
  &lt;div&gt;&lt;strong&gt;Original Array:&lt;/strong&gt;&lt;br&gt;&lt;span id="original"&gt;&lt;/span&gt;&lt;/div&gt;
  &lt;div&gt;&lt;strong&gt;Heap:&lt;/strong&gt;&lt;br&gt;&lt;span id="heap"&gt;&lt;/span&gt;&lt;/div&gt;
  &lt;div&gt;&lt;strong&gt;Sorted Result:&lt;/strong&gt;&lt;br&gt;&lt;span id="sorted"&gt;&lt;/span&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;script&gt;
const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");
let original = [];
let heap = [];
let sorted = [];
let steps = [];
let stepIndex = 0;

function startHeapSort() {
  const input = document.getElementById("arrayInput").value;
  original = input.split(',').map(x =&gt; parseInt(x.trim())).filter(x =&gt; !isNaN(x));
  heap = [...original];
  sorted = [];
  buildHeap(heap);
  steps = createSortSteps([...heap]);
  stepIndex = 0;
  draw();
  runSteps();
}

function buildHeap(arr) {
  for (let i = Math.floor(arr.length / 2) - 1; i &gt;= 0; i--) {
    heapify(arr, i, arr.length);
  }
}

function heapify(arr, i, n) {
  let largest = i;
  const l = 2 * i + 1;
  const r = 2 * i + 2;
  if (l &lt; n &amp;&amp; arr[l] &gt; arr[largest]) largest = l;
  if (r &lt; n &amp;&amp; arr[r] &gt; arr[largest]) largest = r;
  if (largest !== i) {
    [arr[i], arr[largest]] = [arr[largest], arr[i]];
    heapify(arr, largest, n);
  }
}

function createSortSteps(arr) {
  const steps = [];
  for (let i = arr.length - 1; i &gt;= 0; i--) {
    steps.push({ type: 'swap', i: 0, j: i });
    [arr[0], arr[i]] = [arr[i], arr[0]];
    steps.push({ type: 'heapify', stop: i });
    heapify(arr, 0, i);
    steps.push({ type: 'recordSorted', val: arr[i] });
  }
  return steps;
}

function runSteps() {
  if (stepIndex &gt;= steps.length) return;
  const step = steps[stepIndex];
  if (step.type === 'swap') {
    [heap[step.i], heap[step.j]] = [heap[step.j], heap[step.i]];
  } else if (step.type === 'heapify') {
    // Redraw after heapify
  } else if (step.type === 'recordSorted') {
    sorted.unshift(step.val);
  }
  draw();
  stepIndex++;
  setTimeout(runSteps, 700);
}

function layoutHeap(arr) {
  const positions = [];
  const levelHeight = 70;
  for (let i = 0; i &lt; arr.length; i++) {
    const level = Math.floor(Math.log2(i + 1));
    const indexInLevel = i - (2 ** level - 1);
    const nodes = 2 ** level;
    const spacing = canvas.width / (nodes + 1);
    const x = spacing * (indexInLevel + 1);
    const y = 50 + level * levelHeight;
    positions.push({ x, y });
  }
  return positions;
}

function draw() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  const pos = layoutHeap(heap);
  for (let i = 1; i &lt; heap.length; i++) {
    const parent = Math.floor((i - 1) / 2);
    if (parent &gt;= 0 &amp;&amp; pos[i] &amp;&amp; pos[parent]) {
      ctx.beginPath();
      ctx.moveTo(pos[i].x, pos[i].y);
      ctx.lineTo(pos[parent].x, pos[parent].y);
      ctx.strokeStyle = "#aaa";
      ctx.stroke();
    }
  }
  for (let i = 0; i &lt; heap.length; i++) {
    ctx.beginPath();
    ctx.arc(pos[i].x, pos[i].y, 20, 0, Math.PI * 2);
    ctx.fillStyle = "#3498db";
    ctx.fill();
    ctx.stroke();
    ctx.fillStyle = "#fff";
    ctx.font = "16px Arial";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillText(heap[i], pos[i].x, pos[i].y);
  }
  document.getElementById("original").textContent = original.join(", ");
  document.getElementById("heap").textContent = heap.join(", ");
  document.getElementById("sorted").textContent = sorted.join(", ");
}
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</textarea> <iframe id="N1RIH" class="result_iframe" style="border:none;"></iframe>
 <script>{
const textarea = document.getElementById("zHR9W");
const iframe = document.getElementById("N1RIH");
const html = textarea.value;
const iframeHTML = `${html}`;
const doc = iframe.contentDocument || iframe.contentWindow.document;
doc.open();
doc.write(iframeHTML);
doc.close();
setTimeout(() => {
iframe.style.height = '0px';
const contentHeight = Math.max(
  doc.body.scrollHeight,
  doc.documentElement.scrollHeight
);
iframe.style.height = contentHeight + 'px';
}, 50);
}
		</script>
</div><h3 id="why-it-works">Why It Works</h3><p>By always moving the <strong>largest remaining value</strong> to the end of the array, heap sort gradually builds a sorted section at the array’s tail, <strong>in-place</strong>, without using additional memory.</p><h3 id="javascript-implementation">JavaScript Implementation</h3><div>
 <div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
  <pre><code class="language-js">function heapSort(arr) {
  const n = arr.length;

  // Build max heap
  for (let i = Math.floor(n / 2) - 1; i &gt;= 0; i--) {
    heapify(arr, n, i);
  }

  // Extract elements from heap one by one
  for (let i = n - 1; i &gt; 0; i--) {
    // Move current root to end
    [arr[0], arr[i]] = [arr[i], arr[0]];

    // Heapify the reduced heap
    heapify(arr, i, 0);
  }

  return arr;
}

// Heapify a subtree rooted at index i
function heapify(arr, heapSize, i) {
  let largest = i;
  const left = 2 * i + 1;
  const right = 2 * i + 2;

  // If left child is larger
  if (left &lt; heapSize &amp;&amp; arr[left] &gt; arr[largest]) {
    largest = left;
  }

  // If right child is larger
  if (right &lt; heapSize &amp;&amp; arr[right] &gt; arr[largest]) {
    largest = right;
  }

  // If root is not largest, swap and continue
  if (largest !== i) {
    [arr[i], arr[largest]] = [arr[largest], arr[i]];
    heapify(arr, heapSize, largest);
  }
}
let a= [4, 10, 3, 5, 1];
heapSort(a); 
console.log(a);
// Output: [1, 3, 4, 5, 10]</code></pre>
 </div>
 <div class="snippet-container" id="Y9ujV">
  <div class="snippet-header" onclick="toggleSnippetAndRefresh('Y9ujV','CloqH')">
   Try it in editor
  </div>
  <div class="snippet-body"><textarea id="CloqH">function heapSort(arr) {
  const n = arr.length;

  // Build max heap
  for (let i = Math.floor(n / 2) - 1; i &gt;= 0; i--) {
    heapify(arr, n, i);
  }

  // Extract elements from heap one by one
  for (let i = n - 1; i &gt; 0; i--) {
    // Move current root to end
    [arr[0], arr[i]] = [arr[i], arr[0]];

    // Heapify the reduced heap
    heapify(arr, i, 0);
  }

  return arr;
}

// Heapify a subtree rooted at index i
function heapify(arr, heapSize, i) {
  let largest = i;
  const left = 2 * i + 1;
  const right = 2 * i + 2;

  // If left child is larger
  if (left &lt; heapSize &amp;&amp; arr[left] &gt; arr[largest]) {
    largest = left;
  }

  // If right child is larger
  if (right &lt; heapSize &amp;&amp; arr[right] &gt; arr[largest]) {
    largest = right;
  }

  // If root is not largest, swap and continue
  if (largest !== i) {
    [arr[i], arr[largest]] = [arr[largest], arr[i]];
    heapify(arr, heapSize, largest);
  }
}
let a= [4, 10, 3, 5, 1];
heapSort(a); 
console.log(a);
// Output: [1, 3, 4, 5, 10]</textarea> <br> <button onclick="renderIframeForClientJavascript('CloqH','aXg1p')">Run</button> <iframe id="aXg1p" class="result_iframe" style="display: none;"></iframe>
   <script>
  {let editor1 = CodeMirror.fromTextArea(document.getElementById("CloqH"), {
    mode: "javascript",
    lineNumbers:false,
    tabSize: 2
    });
    const mode = localStorage.getItem("mode") || "light";  
    const newTheme = mode === "dark" ? "material" : "default";
    editor1.setOption("theme", newTheme);

   codeMirrorMap.set("CloqH", editor1);}
  </script>
  </div>
 </div>
</div><p><strong>Step-by-step visualization</strong>:</p><ol>
 <li><p><strong>Build max-heap</strong> from <code>[4, 10, 3, 5, 1]</code> → <code>[10, 5, 3, 4, 1]</code></p></li>
 <li><p><strong>Extract max (10)</strong>, move to end → <code>[1, 5, 3, 4, 10]</code> Heapify → <code>[5, 4, 3, 1, 10]</code></p></li>
 <li><p><strong>Extract max (5)</strong>, move to end → <code>[1, 4, 3, 5, 10]</code> Heapify → <code>[4, 1, 3, 5, 10]</code></p></li>
 <li><p><strong>Continue</strong> until fully sorted → <code>[1, 3, 4, 5, 10]</code></p></li>
</ol><h3 id="time-and-space-complexity">Time and Space Complexity</h3><table>
 <thead>
  <tr>
   <th>Operation</th>
   <th>Complexity</th>
  </tr>
 </thead>
 <tbody>
  <tr>
   <td>Build heap</td>
   <td>O(n)</td>
  </tr>
  <tr>
   <td>Heapify (per op)</td>
   <td>O(log n)</td>
  </tr>
  <tr>
   <td>Total sort</td>
   <td><strong>O(n log n)</strong></td>
  </tr>
 </tbody>
</table><ul>
 <li><strong>Space</strong>: O(1) (in-place)</li>
 <li><strong>Stable</strong>: ❌ No (relative order of equal elements is not preserved)</li>
</ul><h3 id="pros-and-cons">Pros and Cons</h3><p><strong>Advantages:</strong></p><ul>
 <li>Consistent O(n log n) performance</li>
 <li>No additional memory required (in-place)</li>
 <li>Good choice for large arrays when stability isn’t required</li>
</ul><p><strong>Disadvantages:</strong></p><ul>
 <li>Not stable</li>
 <li>More data movement than merge sort</li>
 <li>Generally slower than quicksort for small arrays due to larger constant factors</li>
</ul><h3 id="visual-aid-max-heap-tree-for-4-10-3-5-1">Visual Aid: Max-Heap Tree for <code>[4, 10, 3, 5, 1]</code></h3><p>Initial array:</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-bash">10
       /  \
     5     3
    / \
   4   1</code></pre>
</div><p>After extracting root <code>10</code> and heapifying:</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-bash">5
       / \
     4     3
    /
   1</code></pre>
</div><p>Sorted portion builds from right to left in the array.</p><h3 id="tip-reversing-for-descending-order">Tip: Reversing for Descending Order</h3><p>To sort in <strong>descending order</strong>, build a <strong>min-heap</strong> instead and extract the smallest repeatedly.</p><h3 id="summary">Summary</h3><p><strong>Heap sort</strong> is a powerful and predictable sorting algorithm based on the heap data structure. By building a max-heap and extracting elements in-place, it provides consistent <code>O(n log n)</code> performance. Though not stable, its memory efficiency and structured nature make it valuable in scenarios where space and predictability matter more than speed or stability.</p><div class = "chapter-navi-section">
<a href="#top" class="nav-button prev">↑</a>
<a href='javascript-algorithms.htm#heaps-and-priority-queues' class="nav-button toc-link">Index</a>
<a href="#bottom" class="nav-button next">↓</a>
</div>
<h2 id='implementing-a-priority-queue'>11.3 Implementing a Priority Queue</h2><p>A <strong>priority queue</strong> is an abstract data structure similar to a regular queue, but with one major difference: <strong>each element has a priority</strong>, and elements are dequeued based on <strong>priority order</strong>, not arrival order.</p><p>Unlike a standard queue (FIFO), where the first item in is the first out, a <strong>priority queue dequeues the item with the highest priority</strong> (or lowest, depending on the implementation).</p><h3 id="common-use-cases">Common Use Cases</h3><p>Priority queues are widely used in:</p><ul>
 <li><strong>Task scheduling</strong> (e.g., OS process management)</li>
 <li><strong>Event-driven systems</strong> (e.g., simulations)</li>
 <li><strong>Shortest path algorithms</strong>, like Dijkstra’s</li>
 <li><strong>Job queues</strong> in backend systems</li>
 <li><strong>Autocomplete systems</strong>, based on frequency scores</li>
</ul><h3 id="how-heaps-make-this-efficient">How Heaps Make This Efficient</h3><p>A <strong>binary heap</strong> is the ideal structure for implementing a priority queue because:</p><ul>
 <li>Insertion: O(log n)</li>
 <li>Removal of the highest-priority element (usually the root): O(log n)</li>
 <li>Accessing the highest priority element (peek): O(1)</li>
</ul><p>We use a <strong>min-heap</strong> to extract the element with the <strong>lowest numerical priority value</strong> (e.g., priority 1 is higher than 3). You could flip the comparison to make it a max-priority queue instead.</p><h3 id="javascript-implementation">JavaScript Implementation</h3><p>Let’s implement a <strong>min-priority queue</strong>, where lower numbers mean higher priority.</p><div>
 <div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
  <pre><code class="language-js">class PriorityQueue {
  constructor() {
    this.heap = [];
  }

  // Helper functions to navigate the heap
  getParent(i) {
    return Math.floor((i - 1) / 2);
  }

  getLeft(i) {
    return 2 * i + 1;
  }

  getRight(i) {
    return 2 * i + 2;
  }

  swap(i, j) {
    [this.heap[i], this.heap[j]] = [this.heap[j], this.heap[i]];
  }

  // Insert an element with a priority
  enqueue(value, priority) {
    const node = { value, priority };
    this.heap.push(node);
    this.bubbleUp();
  }

  // Move new node up to maintain heap order
  bubbleUp() {
    let index = this.heap.length - 1;
    while (
      index &gt; 0 &amp;&amp;
      this.heap[index].priority &lt; this.heap[this.getParent(index)].priority
    ) {
      this.swap(index, this.getParent(index));
      index = this.getParent(index);
    }
  }

  // Remove and return the highest priority item
  dequeue() {
    if (this.heap.length === 0) return null;
    if (this.heap.length === 1) return this.heap.pop();

    const root = this.heap[0];
    this.heap[0] = this.heap.pop();
    this.bubbleDown();
    return root;
  }

  // Re-heapify the root
  bubbleDown() {
    let index = 0;
    const length = this.heap.length;

    while (true) {
      const left = this.getLeft(index);
      const right = this.getRight(index);
      let smallest = index;

      if (
        left &lt; length &amp;&amp;
        this.heap[left].priority &lt; this.heap[smallest].priority
      ) {
        smallest = left;
      }
      if (
        right &lt; length &amp;&amp;
        this.heap[right].priority &lt; this.heap[smallest].priority
      ) {
        smallest = right;
      }
      if (smallest === index) break;

      this.swap(index, smallest);
      index = smallest;
    }
  }

  // Peek at the highest-priority item without removing it
  peek() {
    return this.heap.length &gt; 0 ? this.heap[0] : null;
  }

  isEmpty() {
    return this.heap.length === 0;
  }
}

const pq = new PriorityQueue();

pq.enqueue("Low priority task", 5);
pq.enqueue("Urgent bug fix", 1);
pq.enqueue("Feature development", 3);

console.log(JSON.stringify(pq.peek(),null,2)); 
// { value: 'Urgent bug fix', priority: 1 }

console.log(JSON.stringify(pq.dequeue(),null,2)); 
// { value: 'Urgent bug fix', priority: 1 }

console.log(JSON.stringify(pq.dequeue(),null,2)); 
// { value: 'Feature development', priority: 3 }</code></pre>
 </div>
 <div class="snippet-container" id="4SeNg">
  <div class="snippet-header" onclick="toggleSnippetAndRefresh('4SeNg','XaPED')">
   Try it in editor
  </div>
  <div class="snippet-body"><textarea id="XaPED">class PriorityQueue {
  constructor() {
    this.heap = [];
  }

  // Helper functions to navigate the heap
  getParent(i) {
    return Math.floor((i - 1) / 2);
  }

  getLeft(i) {
    return 2 * i + 1;
  }

  getRight(i) {
    return 2 * i + 2;
  }

  swap(i, j) {
    [this.heap[i], this.heap[j]] = [this.heap[j], this.heap[i]];
  }

  // Insert an element with a priority
  enqueue(value, priority) {
    const node = { value, priority };
    this.heap.push(node);
    this.bubbleUp();
  }

  // Move new node up to maintain heap order
  bubbleUp() {
    let index = this.heap.length - 1;
    while (
      index &gt; 0 &amp;&amp;
      this.heap[index].priority &lt; this.heap[this.getParent(index)].priority
    ) {
      this.swap(index, this.getParent(index));
      index = this.getParent(index);
    }
  }

  // Remove and return the highest priority item
  dequeue() {
    if (this.heap.length === 0) return null;
    if (this.heap.length === 1) return this.heap.pop();

    const root = this.heap[0];
    this.heap[0] = this.heap.pop();
    this.bubbleDown();
    return root;
  }

  // Re-heapify the root
  bubbleDown() {
    let index = 0;
    const length = this.heap.length;

    while (true) {
      const left = this.getLeft(index);
      const right = this.getRight(index);
      let smallest = index;

      if (
        left &lt; length &amp;&amp;
        this.heap[left].priority &lt; this.heap[smallest].priority
      ) {
        smallest = left;
      }
      if (
        right &lt; length &amp;&amp;
        this.heap[right].priority &lt; this.heap[smallest].priority
      ) {
        smallest = right;
      }
      if (smallest === index) break;

      this.swap(index, smallest);
      index = smallest;
    }
  }

  // Peek at the highest-priority item without removing it
  peek() {
    return this.heap.length &gt; 0 ? this.heap[0] : null;
  }

  isEmpty() {
    return this.heap.length === 0;
  }
}

const pq = new PriorityQueue();

pq.enqueue("Low priority task", 5);
pq.enqueue("Urgent bug fix", 1);
pq.enqueue("Feature development", 3);

console.log(JSON.stringify(pq.peek(),null,2)); 
// { value: 'Urgent bug fix', priority: 1 }

console.log(JSON.stringify(pq.dequeue(),null,2)); 
// { value: 'Urgent bug fix', priority: 1 }

console.log(JSON.stringify(pq.dequeue(),null,2)); 
// { value: 'Feature development', priority: 3 }</textarea> <br> <button onclick="renderIframeForClientJavascript('XaPED','zEhfk')">Run</button> <iframe id="zEhfk" class="result_iframe" style="display: none;"></iframe>
   <script>
  {let editor1 = CodeMirror.fromTextArea(document.getElementById("XaPED"), {
    mode: "javascript",
    lineNumbers:false,
    tabSize: 2
    });
    const mode = localStorage.getItem("mode") || "light";  
    const newTheme = mode === "dark" ? "material" : "default";
    editor1.setOption("theme", newTheme);

   codeMirrorMap.set("XaPED", editor1);}
  </script>
  </div>
 </div>
</div><p>Each task is executed in order of <strong>ascending priority value</strong>, not insertion order.</p><h3 id="time-complexity-summary">Time Complexity Summary</h3><table>
 <thead>
  <tr>
   <th>Operation</th>
   <th>Time Complexity</th>
  </tr>
 </thead>
 <tbody>
  <tr>
   <td><code>enqueue</code></td>
   <td>O(log n)</td>
  </tr>
  <tr>
   <td><code>dequeue</code></td>
   <td>O(log n)</td>
  </tr>
  <tr>
   <td><code>peek</code></td>
   <td>O(1)</td>
  </tr>
 </tbody>
</table><p>These performance guarantees come from the underlying heap structure.</p><h3 id="summary">Summary</h3><p>Priority queues are crucial in many algorithmic and real-time systems where urgency dictates order. A <strong>binary heap</strong> makes them efficient by enabling quick access to the highest-priority item and maintaining order with minimal overhead. By implementing a priority queue from scratch in JavaScript, you not only gain insight into data structures but also prepare for scenarios involving efficient task handling, scheduling, and graph algorithms.</p><div class = "chapter-navi-section">
<a href="javascript-algorithms-trees-and-binary-search-trees.htm" class="nav-button prev">←</a>
<a href='javascript-algorithms.htm#heaps-and-priority-queues' class="nav-button toc-link">Index</a>
<a href="javascript-algorithms-balanced-search-trees.htm" class="nav-button next">→</a>
</div>
<section class="download-section">
  <div class="book-cover" style="background-color: #f9f6f1;border: 1px solid #ccc;"> 
    <div class="book-cover-title" style="font-size: 18px;color: #333;top: 20px;">JavaScript Algorithms</div>
    <div class="book-cover-author">readbytes</div>
    <div class="book-cover-bottom-stripe" style="background-color: #333;"></div>
    <img class="book-cover-icon" style="width: 80px;height: 80px;top: 70px;" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFoAAABaCAYAAAA4qEECAAAErElEQVR4Xu2dPWgUQRiGo6BB8I+AlV3w9gzptLBWsLQ89O7ARrDXSivTCTaCnWhn7pQTxOoInpjCeEQQLC2CjVqoVSwMFpp1Jtzo7Luzs/Nd7uZ29r4HPpDsu7vPvIl7+SGTmRmGYRiGYZjCEzVacdnn9NX7+3DdXkGhMg+u3Su6SNztzsZvevH/efED8zrJbM+6EGJ2K5Hv9w9gRpHnXMyik2VsYVaHWJx7tt/bTOQ3urOYUch3QJ5z0YtOCeuQiqNlvybyto/ktbVDcG2jc5GLNgoriMW5Z/svPyfy693DmFHE71ePwrUznQta9ISeyViyKBIziri/Mpe8tt25kEXjMR1ScbQsPC5W5jCjMJT8DTM6MuO6vrHjIkIszj2LL3y2ktOPiy+Y0VE5l/V5IU+EVBwtm/wUzva4SL/wOZUsJ2993rCJEIujZJMl2174Up/C5T8u9LGtzyu6SNkH1+6VhUargkJlHVy7f5aW9qJUqeZy5zguufToBeAxZoRw0Z7goj3BRXuCi/YEF+0BvWQue0xgwfrMiy+aMM8QEUW+w2IHb8fC/+C5jCOGMhOPiqi+vG47zjiABVbr7XOYUWC2Um+fxwwDiKJeYXGYMYHniNnGDDPAUJZTyYph30nTg+G7f5VLj89gzBW8lu2xMzWIIt5iMZgZBrzmqK4bJFhENOLnatRsfcR7YKb0YAELF5+cwsyowHudrLcvYKZ0iIV+wIVjZhzgPaMR/+8pFIbFeilZUWm2Vyd5/5GxWOvsx4VkTbXROovn+wJdMqfevoHnFoKUaMbgeZMAnbIGzysEKGmZiX4DKKo/um5wMg6eWwhsgtVm62cRFoEOJg/xtltZxwqBTV4inuEHcZHztc4RzI0LvLeY15iRBF+0wrDgsX6qZXpUYEanNEVLROY3ZfHDgvdwuU+pipYs1h7OpUqI4z2YGxa8dqXefooZE6UrWoGFiMn8nRIXoubyTbymeLPzO7C0RUuiRvuXoRwyeI1hrlPqoiUnap1jWNLilU7mr0sgeK746rOFGRdKX7QCC4tyHiXi+DU8BzMUpqZoiSzXpTzMZOUoTFXROxh+xKV/gYPHqvVlp88q8pi+ogdgoabBc3bD1BYtEdfcxnLHeK/pLVoiHxvJktsPMDMKpr5oX3DRnuCiPcFFe4KL9gQX7Qku2hNctCe4aE94K1puD6mXNsmpOv74KUTnxEdmEQb9TOA5kx70M6KfcO/u8/j2nWffxb+XskZm9MHjw2YjgrTKygnFeUaF5cSEjZ4c9kJyz/Z7mxTpEJ0T0nhMhyRBy+5sTuXioAjR2UmaKEHJ/tsBLM9BJ0TnXGmiBCWb2GbN5oCE6GyVJkq4Z3FXxo3ubJaDiRCdM6VJErSscTtik0MWITobpYkS7lncKVfblREdbITonJImSVCyKAz7i1KkQ3ROSJMkaNnc7Ygp0iE6Z0pjTockjC8iBmEJRTpEZ6M0ZnRIwrhTrmU7Yop0iM4paTyusyvhnO2IKdIhOqdeWLLYlbDtL0oM/jaKi4MiRGcnaZIwPt8c/zZKnoNOiM4J6SIM+pnAcyY96GekYJtvf0I/EyE6MwzDMAzDjI+/5MPGam/zucIAAAAASUVORK5CYII="/>
  </div>
  <div class="download-info">
    <h2 id='bottom'>Download This Ebook</h2>
    <p class="format-label">Available formats:</p>
    <div class="download-buttons">
      <a href="javascript-algorithms.pdf" class="download-button">📄 PDF</a>
      <a href="javascript-algorithms.epub" class="download-button">📘 EPUB</a>
    </div>
  </div>
</section><div class='related-books'>
<h2>Java Introduction Books</h2>
<div class='related-book-list'>
<a href="javascript-algorithms.htm">
<div class="book-cover" style="background-color: #f9f6f1;border: 1px solid #ccc;"> 
    <div class="book-cover-title" style="font-size: 18px;color: #333;top: 20px;">JavaScript Algorithms</div>
    <div class="book-cover-author">readbytes</div>
    <div class="book-cover-bottom-stripe" style="background-color: #333;"></div>
    <img class="book-cover-icon" style="width: 80px;height: 80px;top: 70px;" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFoAAABaCAYAAAA4qEECAAAErElEQVR4Xu2dPWgUQRiGo6BB8I+AlV3w9gzptLBWsLQ89O7ARrDXSivTCTaCnWhn7pQTxOoInpjCeEQQLC2CjVqoVSwMFpp1Jtzo7Luzs/Nd7uZ29r4HPpDsu7vPvIl7+SGTmRmGYRiGYZjCEzVacdnn9NX7+3DdXkGhMg+u3Su6SNztzsZvevH/efED8zrJbM+6EGJ2K5Hv9w9gRpHnXMyik2VsYVaHWJx7tt/bTOQ3urOYUch3QJ5z0YtOCeuQiqNlvybyto/ktbVDcG2jc5GLNgoriMW5Z/svPyfy693DmFHE71ePwrUznQta9ISeyViyKBIziri/Mpe8tt25kEXjMR1ScbQsPC5W5jCjMJT8DTM6MuO6vrHjIkIszj2LL3y2ktOPiy+Y0VE5l/V5IU+EVBwtm/wUzva4SL/wOZUsJ2993rCJEIujZJMl2174Up/C5T8u9LGtzyu6SNkH1+6VhUargkJlHVy7f5aW9qJUqeZy5zguufToBeAxZoRw0Z7goj3BRXuCi/YEF+0BvWQue0xgwfrMiy+aMM8QEUW+w2IHb8fC/+C5jCOGMhOPiqi+vG47zjiABVbr7XOYUWC2Um+fxwwDiKJeYXGYMYHniNnGDDPAUJZTyYph30nTg+G7f5VLj89gzBW8lu2xMzWIIt5iMZgZBrzmqK4bJFhENOLnatRsfcR7YKb0YAELF5+cwsyowHudrLcvYKZ0iIV+wIVjZhzgPaMR/+8pFIbFeilZUWm2Vyd5/5GxWOvsx4VkTbXROovn+wJdMqfevoHnFoKUaMbgeZMAnbIGzysEKGmZiX4DKKo/um5wMg6eWwhsgtVm62cRFoEOJg/xtltZxwqBTV4inuEHcZHztc4RzI0LvLeY15iRBF+0wrDgsX6qZXpUYEanNEVLROY3ZfHDgvdwuU+pipYs1h7OpUqI4z2YGxa8dqXefooZE6UrWoGFiMn8nRIXoubyTbymeLPzO7C0RUuiRvuXoRwyeI1hrlPqoiUnap1jWNLilU7mr0sgeK746rOFGRdKX7QCC4tyHiXi+DU8BzMUpqZoiSzXpTzMZOUoTFXROxh+xKV/gYPHqvVlp88q8pi+ogdgoabBc3bD1BYtEdfcxnLHeK/pLVoiHxvJktsPMDMKpr5oX3DRnuCiPcFFe4KL9gQX7Qku2hNctCe4aE94K1puD6mXNsmpOv74KUTnxEdmEQb9TOA5kx70M6KfcO/u8/j2nWffxb+XskZm9MHjw2YjgrTKygnFeUaF5cSEjZ4c9kJyz/Z7mxTpEJ0T0nhMhyRBy+5sTuXioAjR2UmaKEHJ/tsBLM9BJ0TnXGmiBCWb2GbN5oCE6GyVJkq4Z3FXxo3ubJaDiRCdM6VJErSscTtik0MWITobpYkS7lncKVfblREdbITonJImSVCyKAz7i1KkQ3ROSJMkaNnc7Ygp0iE6Z0pjTockjC8iBmEJRTpEZ6M0ZnRIwrhTrmU7Yop0iM4paTyusyvhnO2IKdIhOqdeWLLYlbDtL0oM/jaKi4MiRGcnaZIwPt8c/zZKnoNOiM4J6SIM+pnAcyY96GekYJtvf0I/EyE6MwzDMAzDjI+/5MPGam/zucIAAAAASUVORK5CYII="/>
  </div>
</a>



<a href='java.htm'><div class='book-cover' style='background-color: #f9f6f1;color: #111111;border: 1px solid #ccc;display: flex;justify-content: center;align-items: center;text-align: center;'>More Java Books</div></a>
</div>
</div>
  </div>
  <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/prism.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
  
  <script>
    function copyCode(button) {
      const code = button.nextElementSibling.innerText;
      navigator.clipboard.writeText(code).then(() => {
        button.textContent = 'Copied!';
        setTimeout(() => { button.textContent = 'Copy'; }, 1500);
      });
    }
  </script>  
<div id="floatingLog" aria-live="polite" role="alert"></div>
<footer class="page-footer">
    <nav>
      <a href="https://readbytes.github.io">Home</a> | 
      Email:<script language="JavaScript" type="text/javascript">
var part1 = 'yinpeng';var part6 = '263';var part2 = Math.pow(2,6);var part3 = String.fromCharCode(part2);var part4 = 'hotmail dot com';var part5 = part1 + String.fromCharCode(part2) + part4;document.write(part1 + part6 + part3 + part4);
</script>
    </nav>
  <p>© 2025 — All rights reserved.</p>    
  </footer>

</body>
</html>