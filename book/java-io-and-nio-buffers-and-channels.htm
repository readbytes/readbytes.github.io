<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Java IO and NIO Buffers and Channels</title>
<link rel='shortcut icon' href='https://java2s.com/style/favicon.ico'>
<link href="https://fonts.googleapis.com/css2?family=Merriweather&display=swap" rel="stylesheet" />
<link href="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet" />


  <script>
  const mode = localStorage.getItem('mode') || 'light';
  document.documentElement.classList.add(`${mode}-mode`);
  </script>   
<style> 
html {
  scroll-behavior: smooth;
}

body {
  font-family: 'Merriweather', serif;
  margin: 0;
  padding: 2rem 1rem;
  font-size: 15px;
  line-height: 1.5;
  transition: background-color 0.3s, color 0.3s;
}

.container {
  max-width: 700px;
  margin: 0 auto;
  padding: 1rem 2rem;
  box-shadow: 0 0 15px rgba(0,0,0,0.1);
}

h1, h2, h3 {
  font-weight: 600;
  margin-top: 2.5rem;
  margin-bottom: 1rem;
  line-height: 1.2;
}

h1 { font-size: 1.8rem; }
h2 { font-size: 1.4rem; }
h3 { font-size: 1.2rem; }

table {
  width: 100%;
  border-collapse: collapse;
  font-family: sans-serif;
  font-size: 1em;
  margin: 1em 0;
}

th, td {
  padding: 0.6em 1em;
  text-align: left;
  border: 1px solid;
}

tr:nth-child(even) {
  background-color: inherit;
}

tr:hover {
  background-color: inherit;
}

a {
  text-decoration: none;
  transition: color 0.2s;
}

a:hover {
  text-decoration: underline;
}

code {
  color: #d35400;
}

.book-title-chapter {
  font-family: 'Merriweather', serif;
  font-size: 2rem;
  font-weight: bold;
  text-align: center;
  margin-bottom: 2rem;
  border-bottom: 2px solid;
  padding-bottom: 0.5rem;
}

.book-subtitle-chapter {
  text-align: center;
  font-size: 1rem;
  margin-top: -1rem;
  margin-bottom: 2rem;
}

.related-books {
  margin-top: 40px;
}

.related-book-list {
  display: flex;
  flex-wrap: wrap;
  gap: 20px;
}

    .book-cover {
      width: 130px;
      height: 180px;
      font-family: Arial, sans-serif;
      position: relative;
      overflow: hidden;      
      line-height: normal;
      box-shadow: 2px 2px 4px rgba(0,0,0,0.1);
    }
    .book-cover-bottom-stripe {
      position: absolute;
      bottom: 0;
      left: 0;
      height: 5px;
      width: 100%;
    }
    .book-cover-title {
      position: absolute;
      width: 100%;
      text-align: center;
      font-weight: bold;
    }
     
    .book-cover-icon {
      position: absolute;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      align-items: center;
      justify-content: center; 
    }

    .book-cover-author {
      position: absolute;
      bottom: 10px;
      width: 100%;
      text-align: center;
      font-size: 8px;
      color: #333;
    }

.page-footer {
  margin-top: 4rem;
  padding: 1rem 0;
  text-align: center;
  font-size: 0.85rem;
  border-top: 1px solid;
}

.chapter-navi-section {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding-bottom: 10px;
}

.nav-link {
  color: inherit;
  text-decoration: none;
  opacity: 0.5;
  transition: opacity 0.3s ease, text-decoration 0.3s ease;
}

.nav-link:hover {
  opacity: 0.9;
  text-decoration: underline;
}

.prev { text-align: left; }
.toc-link { text-align: center; }
.next { text-align: right; }

.download-section {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 2rem;
  padding: 2rem 1rem;
  max-width: 600px;
  margin: 3rem auto;
  border-radius: 12px;
  box-shadow: 0 4px 10px rgba(0,0,0,0.05);
}

.download-info h2 {
  margin: 0 0 0.5rem;
  font-size: 1.2rem;
}

.format-label {
  margin: 0 0 0.5rem;
  font-size: 0.95rem;
}

.download-buttons {
  display: flex;
  gap: 1rem;
}

.download-button {
  background-color: #4A90E2;
  color: white;
  padding: 0.5em 1.2em;
  border-radius: 25px;
  font-size: 0.95rem;
  text-decoration: none;
  transition: background-color 0.3s ease;
}

.download-button:hover {
  background-color: #357ABD;
}

.code-block {
  position: relative;
  margin-bottom: 1em;
}

.copy-button {
  background: transparent;
  color: white;
  position: absolute;
  top: 8px;
  right: 8px;
  border: none;
  padding: 4px 8px;
  font-size: 12px;
  border-radius: 4px;
  cursor: pointer;
  z-index: 1;
}

.copy-button:hover {
  background-color: #0056b3;
}

.snippet-container {
  overflow: hidden;
}

.snippet-header {
  padding: 0.75rem 1rem;
  cursor: pointer;
  font-size: 1rem;
    background-color: #eeeeee;
    color:  #111111; 
    border-radius: 8px;
    cursor: pointer;
    box-shadow: 0 4px 6px rgba(0,0,0,0.1);  
}

.snippet-body {
  display: none;
  font-family: monospace;
}

.snippet-container.open .snippet-body {
  display: block;
}

.CodeMirror {
  border: 2px solid #ccc;
  border-radius: 4px;
  resize: vertical;
}

/* === Light Mode === */
html.light-mode {
  background-color: #f8f7f5;
  color: #333;
}

html.light-mode .container {
  background: white;
}

html.light-mode .book-title-chapter {
  color: #2c3e50;
  border-color: #ccc;
}
html.light-mode .book-subtitle-chapter{
  color: #888;
}

html.light-mode .page-footer,
html.light-mode .series-name,
html.light-mode .book-subtitle,
html.light-mode .format-label {
  color: #888;
}

html.light-mode .related-books h2 {
  color: #333;
  border-bottom: 2px solid #eee;
}

html.light-mode .book-title {
  color: #fff;
}

html.light-mode .book-cover {
  border: 1px solid #ccc;
}

html.light-mode th {
  background-color: #f2f2f2;
}

html.light-mode tr:nth-child(even) {
  background-color: #fafafa;
}

html.light-mode tr:hover {
  background-color: #e6f7ff;
}

html.light-mode a,
html.light-mode .page-footer a {
  color: #000;
}

/* === Dark Mode === */
html.dark-mode {
  background-color: #181818;
  color: #e0e0e0;
}

html.dark-mode .container {
  background: #222;
}

html.dark-mode .book-title-chapter {
  color: #ddd;
  border-color: #444;
}

html.dark-mode .snippet-header {
    background-color: #333;
    color:  #ddd; 
}


html.dark-mode .book-subtitle-chapter,
html.dark-mode .page-footer,
html.dark-mode .series-name,
html.dark-mode .book-subtitle,
html.dark-mode .book-footer,
html.dark-mode .format-label {
  color: #aaa;
}

html.dark-mode .related-books h2 {
  color: #ddd;
  border-bottom: 2px solid #333;
}

html.dark-mode .book-title {
  color: #fff;
}

html.dark-mode .book-cover {
  border: 1px solid #555;
}

html.dark-mode th {
  background-color: #333;
  color: #fff;
}

html.dark-mode td {
  border-color: #444;
}

html.dark-mode tr:nth-child(even) {
  background-color: #2a2a2a;
}

html.dark-mode tr:hover {
  background-color: #2c3e50;
}

html.dark-mode a,
html.dark-mode .page-footer a {
  color: #eee;
}

    .dialog-backdrop {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: rgba(0,0,0,0.5);
      display: none;
      justify-content: center;
      align-items: center;
      z-index: 10;
    }

    .dialog {
      background: white;
      padding: 20px;
      width: 90vw;
      height: 80vh;
      border-radius: 8px;
      box-shadow: 0 0 20px rgba(0,0,0,0.3);
      display: flex;
      flex-direction: column;
    }
    .dialog-content {
      display: flex;
      flex: 1;
      gap: 20px;
      margin-top: 10px;
    }
    .dialog h2 {
      margin-top: 0;
    }

    .textarea_dialog {
      width: 50%;
      height: 100%;
      resize: none;
      font-family: monospace;
      font-size: 14px;
      padding: 10px;
      box-sizing: border-box;
      border: 1px solid #ccc;
    }

    .iframe_dialog {
      width: 50%;
      height: 100%;
      border: 1px solid #ccc;
    }
    .controls_dialog {
      display: flex;
      justify-content: space-between;
      margin-top: 10px;
    }    
    button { padding: 0.5em 1em; background: green; color: white; border: none; cursor: pointer; }
    button:hover { background: #1e7e34; }
    .result_iframe { width:99%; height:200px; margin-top: 1em;  resize: both;border:1px solid #ccc;}        
</style>
</head>
<body> 
  <div class="container">
    <div class = "chapter-navi-section">
<a href="java-io-and-nio-introduction-to-java-nio-new-io.htm" class="nav-button prev">←</a>
<a href='java-io-and-nio.htm#buffers-and-channels' class="nav-button toc-link">Index</a>
<a href="java-io-and-nio-selectors-and-non-blocking-io.htm" class="nav-button next">→</a>
</div>

    <h1 class="book-title-chapter" id = 'top'>Buffers and Channels</h1>
    <h3 class="book-subtitle-chapter">Java IO and NIO</h3>   
    <!-- <h1 class ="chapter-title"></h1> -->
    <h2 id='bytebuffer-and-other-buffer-types'>6.1 ByteBuffer and Other Buffer Types</h2><p>In Java NIO, the concept of <strong>buffers</strong> is central to handling data during IO operations. Unlike the traditional stream-based IO model, where data flows sequentially byte-by-byte or character-by-character, NIO uses buffers as fixed-size containers to hold data explicitly. Understanding buffers, especially <code>ByteBuffer</code> and its siblings, is essential for efficient and controlled data processing in Java NIO.</p><h3 id="what-are-buffers-in-java-nio">What Are Buffers in Java NIO?</h3><p>A <strong>Buffer</strong> is a block of memory used for reading and writing data. It acts as an intermediary storage area between the application and the IO channel. Buffers provide a structured way to handle data with explicit control over the read/write process.</p><p>Buffers come with a fixed <strong>capacity</strong>, and they maintain two important pointers:</p><ul>
 <li><strong>Position:</strong> The index of the next element to be read or written.</li>
 <li><strong>Limit:</strong> The boundary that marks the end of the readable or writable data.</li>
</ul><p>Additionally, buffers have a <strong>mark</strong> feature to save and reset positions during complex operations.</p><h3 id="the-role-of-buffers">The Role of Buffers</h3><p>Buffers serve as the workspace for data moving between Java programs and IO devices (files, sockets, etc.). The workflow usually involves:</p><ul>
 <li>Reading data <strong>from a channel into a buffer</strong>.</li>
 <li>Processing or manipulating data inside the buffer.</li>
 <li>Writing data <strong>from the buffer back to a channel</strong>.</li>
</ul><p>This explicit buffering model allows for more efficient IO by reducing the overhead of system calls and enabling batch processing of data.</p><h3 id="the-bytebuffer-class">The ByteBuffer Class</h3><p>Among all buffer types, <strong><code>ByteBuffer</code></strong> is the most fundamental and widely used. It stores data as raw bytes (<code>byte</code> values). Because virtually all data — text, images, multimedia — can be represented as bytes, <code>ByteBuffer</code> acts as the base for many IO operations.</p><h3 id="internal-structure-of-bytebuffer">Internal Structure of ByteBuffer</h3><p><code>ByteBuffer</code> extends the abstract <code>Buffer</code> class and provides several key methods for manipulating data.</p><ul>
 <li><p><strong>Allocation:</strong></p> <p>You create a <code>ByteBuffer</code> by allocating a fixed amount of space.</p>
  <div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
   <pre><code class="language-Java">ByteBuffer buffer = ByteBuffer.allocate(1024);  // 1 KB buffer</code></pre>
  </div></li>
 <li><p><strong>Position, Limit, Capacity:</strong></p>
  <ul>
   <li><code>capacity()</code> returns the buffer’s total size (e.g., 1024 bytes).</li>
   <li><code>position()</code> shows the current index for reading/writing.</li>
   <li><code>limit()</code> marks the end of data for read/write operations.</li>
  </ul></li>
 <li><p><strong>Writing to the Buffer:</strong></p> <p>You write data using <code>put()</code> methods, which write bytes and advance the position.</p>
  <div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
   <pre><code class="language-Java">buffer.put((byte)65);          // Writes ASCII 'A'
buffer.put(new byte[] {1, 2}); // Writes multiple bytes</code></pre>
  </div></li>
 <li><p><strong>Flipping the Buffer:</strong></p> <p>Before reading data back, you call <code>flip()</code> to prepare the buffer:</p>
  <div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
   <pre><code class="language-Java">buffer.flip();</code></pre>
  </div> <p>This sets the limit to the current position and resets position to zero, so you can read from the start up to the written data.</p></li>
 <li><p><strong>Reading from the Buffer:</strong></p> <p>You read data using <code>get()</code> methods:</p>
  <div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
   <pre><code class="language-Java">byte b = buffer.get();       // Reads one byte
byte[] data = new byte[buffer.remaining()];
buffer.get(data);            // Reads multiple bytes</code></pre>
  </div></li>
 <li><p><strong>Clearing and Compacting:</strong></p> <p>After reading or when you want to reuse the buffer, you use:</p>
  <ul>
   <li><code>clear()</code>: Resets position and limit to capacity for writing new data.</li>
   <li><code>compact()</code>: Moves unread data to the beginning and prepares for writing more data.</li>
  </ul></li>
</ul><h3 id="example-basic-bytebuffer-usage">Example: Basic ByteBuffer Usage</h3><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-java">import java.nio.ByteBuffer;

public class ByteBufferExample {
    public static void main(String[] args) {
        // Allocate a ByteBuffer with capacity 10 bytes
        ByteBuffer buffer = ByteBuffer.allocate(10);

        // Write bytes into the buffer
        buffer.put((byte) 'H');
        buffer.put((byte) 'i');

        // Prepare the buffer for reading
        buffer.flip();

        // Read bytes from the buffer and print as characters
        while (buffer.hasRemaining()) {
            System.out.print((char) buffer.get());
        }
        // Output: Hi
    }
}</code></pre>
</div><h3 id="other-buffer-types-in-java-nio">Other Buffer Types in Java NIO</h3><p>Java NIO provides specialized buffers for different primitive data types, each subclassing the abstract <code>Buffer</code> class:</p><table>
 <thead>
  <tr>
   <th>Buffer Type</th>
   <th>Stores Data of Type</th>
   <th>Common Use Case</th>
  </tr>
 </thead>
 <tbody>
  <tr>
   <td><code>CharBuffer</code></td>
   <td><code>char</code> (16-bit Unicode)</td>
   <td>Handling character data, text processing</td>
  </tr>
  <tr>
   <td><code>ShortBuffer</code></td>
   <td><code>short</code></td>
   <td>Working with 16-bit integers</td>
  </tr>
  <tr>
   <td><code>IntBuffer</code></td>
   <td><code>int</code></td>
   <td>Working with 32-bit integers</td>
  </tr>
  <tr>
   <td><code>LongBuffer</code></td>
   <td><code>long</code></td>
   <td>Handling 64-bit integers</td>
  </tr>
  <tr>
   <td><code>FloatBuffer</code></td>
   <td><code>float</code></td>
   <td>Working with floating-point numbers</td>
  </tr>
  <tr>
   <td><code>DoubleBuffer</code></td>
   <td><code>double</code></td>
   <td>Handling double-precision floating-point numbers</td>
  </tr>
 </tbody>
</table><h3 id="why-use-different-buffer-types">Why Use Different Buffer Types?</h3><p>Using typed buffers allows you to:</p><ul>
 <li>Work directly with higher-level data types without manually converting them to bytes.</li>
 <li>Simplify code when working with structured binary data formats.</li>
 <li>Benefit from type-specific <code>get()</code> and <code>put()</code> methods.</li>
</ul><p>For example, an <code>IntBuffer</code> lets you read/write integers rather than manually packing and unpacking bytes.</p><h3 id="example-using-an-intbuffer">Example: Using an IntBuffer</h3><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-java">import java.nio.IntBuffer;

public class IntBufferExample {
    public static void main(String[] args) {
        // Allocate an IntBuffer with capacity for 5 integers
        IntBuffer intBuffer = IntBuffer.allocate(5);

        // Put some integers into the buffer
        intBuffer.put(10);
        intBuffer.put(20);
        intBuffer.put(30);

        // Prepare buffer for reading
        intBuffer.flip();

        // Read integers from the buffer
        while (intBuffer.hasRemaining()) {
            System.out.println(intBuffer.get());
        }
        // Output:
        // 10
        // 20
        // 30
    }
}</code></pre>
</div><h3 id="buffer-lifecycle-recap">Buffer Lifecycle Recap</h3><ol>
 <li><strong>Allocate</strong> the buffer with a fixed size.</li>
 <li><strong>Write data</strong> using <code>put()</code> methods.</li>
 <li><strong>Flip</strong> the buffer to switch from writing to reading mode.</li>
 <li><strong>Read data</strong> using <code>get()</code> methods.</li>
 <li>Optionally, <strong>compact</strong> or <strong>clear</strong> the buffer for reuse.</li>
</ol><h3 id="summary">Summary</h3><ul>
 <li><strong>Buffers</strong> are core to Java NIO’s approach to data handling, offering explicit control over memory and data transfer.</li>
 <li><code>ByteBuffer</code> is the fundamental buffer storing raw bytes and is used extensively in IO operations.</li>
 <li>Other buffer types (<code>CharBuffer</code>, <code>IntBuffer</code>, <code>DoubleBuffer</code>, etc.) allow direct handling of primitive data types, simplifying code and improving clarity.</li>
 <li>Understanding buffer states (position, limit, capacity) and lifecycle methods (<code>flip()</code>, <code>clear()</code>, <code>compact()</code>) is crucial for correct usage.</li>
 <li>Using buffers improves IO efficiency by allowing batch operations and better control over data flow.</li>
</ul><div class = "chapter-navi-section">
<a href="#top" class="nav-button prev">↑</a>
<a href='java-io-and-nio.htm#buffers-and-channels' class="nav-button toc-link">Index</a>
<a href="#bottom" class="nav-button next">↓</a>
</div>
<h2 id='buffer-operations-read-write-flip-clear-compact'>6.2 Buffer Operations: Read, Write, Flip, Clear, Compact</h2><p>Buffers are fundamental to Java NIO’s data handling, acting as containers that hold data for reading from or writing to IO channels. To use buffers effectively, you must understand the key operations that control their internal state: the <strong>position</strong>, <strong>limit</strong>, and <strong>capacity</strong>. These operations govern where data is written or read, how much data can be accessed, and how the buffer can be reused efficiently.</p><p>This section explains the most important buffer operations: <code>put()</code> (write), <code>get()</code> (read), <code>flip()</code>, <code>clear()</code>, and <code>compact()</code>, detailing their effects and showing common usage patterns.</p><h3 id="buffer-anatomy-recap">Buffer Anatomy Recap</h3><p>Before diving into operations, remember these core properties of a buffer:</p><ul>
 <li><strong>Capacity:</strong> The fixed size of the buffer; the maximum number of elements it can hold.</li>
 <li><strong>Position:</strong> The index of the next element to read or write.</li>
 <li><strong>Limit:</strong> The index marking the end of readable or writable data.</li>
</ul><p>At any moment, the buffer’s state determines how much data can be read or written.</p><h3 id="writing-to-buffers-put">Writing to Buffers: <code>put()</code></h3><p>The <code>put()</code> method writes data into the buffer at the current position and advances the position by the number of elements written.</p><ul>
 <li>You can write single elements or arrays of data.</li>
 <li>Writing is only allowed up to the buffer’s capacity (or limit, depending on state).</li>
 <li>Attempting to write beyond the limit throws a <code>BufferOverflowException</code>.</li>
</ul><p><strong>Example:</strong></p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-Java">ByteBuffer buffer = ByteBuffer.allocate(10);
buffer.put((byte)10);
buffer.put((byte)20);

System.out.println("Position after writing: " + buffer.position());  // Outputs 2</code></pre>
</div><p>At this point, the buffer's position is 2 (two bytes written), limit is 10 (capacity).</p><h3 id="preparing-to-read-flip">Preparing to Read: <code>flip()</code></h3><p>After writing data, you call <code>flip()</code> to switch the buffer from <strong>write mode</strong> to <strong>read mode</strong>. What <code>flip()</code> does:</p><ul>
 <li>Sets the limit to the current position (marks the end of valid data).</li>
 <li>Resets the position to zero (start reading from the beginning).</li>
</ul><p>This prepares the buffer to be read from the data just written.</p><p><strong>Example:</strong></p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-Java">buffer.flip();
System.out.println("Position after flip: " + buffer.position());  // 0
System.out.println("Limit after flip: " + buffer.limit());        // 2</code></pre>
</div><p>Now, the buffer is ready to read 2 bytes from position 0 up to limit 2.</p><h3 id="reading-from-buffers-get">Reading from Buffers: <code>get()</code></h3><p>The <code>get()</code> method reads data from the current position and advances it.</p><ul>
 <li>Reading continues until position reaches limit.</li>
 <li>Reading beyond limit throws a <code>BufferUnderflowException</code>.</li>
</ul><p><strong>Example:</strong></p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-Java">byte first = buffer.get();
byte second = buffer.get();
System.out.println("Bytes read: " + first + ", " + second);
System.out.println("Position after reading: " + buffer.position()); // 2</code></pre>
</div><h3 id="clearing-the-buffer-clear">Clearing the Buffer: <code>clear()</code></h3><p>After you finish reading and want to write new data, call <code>clear()</code>.</p><ul>
 <li>Resets position to 0.</li>
 <li>Sets limit to capacity.</li>
 <li>The buffer is ready for writing again.</li>
 <li><strong>Note:</strong> It does NOT erase data, but marks the entire buffer as writable.</li>
</ul><p><strong>Example:</strong></p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-Java">buffer.clear();
System.out.println("Position after clear: " + buffer.position());  // 0
System.out.println("Limit after clear: " + buffer.limit());        // 10</code></pre>
</div><h3 id="compacting-the-buffer-compact">Compacting the Buffer: <code>compact()</code></h3><p><code>compact()</code> is used when you have read some data from the buffer but still have unread data that you want to keep before writing more.</p><p>What <code>compact()</code> does:</p><ul>
 <li>Copies unread data from current position to the beginning of the buffer.</li>
 <li>Sets position to just after the copied data.</li>
 <li>Sets limit to capacity, so you can write more data after the unread portion.</li>
</ul><p>This avoids overwriting unread data while allowing new data to be appended.</p><p><strong>Example:</strong></p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-Java">// Suppose buffer has limit=10, position=4 after reading some bytes
buffer.compact();
System.out.println("Position after compact: " + buffer.position());
// Now position is set after unread data, ready for writing more</code></pre>
</div><h3 id="step-by-step-example-using-buffer-operations-in-a-typical-read-write-cycle">Step-by-Step Example: Using Buffer Operations in a Typical Read/Write Cycle</h3><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-java">import java.nio.ByteBuffer;

public class Test {

    public static void main(String[] argv) throws Exception {
        ByteBuffer buffer = ByteBuffer.allocate(8);

        // Step 1: Write data into buffer
        buffer.put((byte) 1);
        buffer.put((byte) 2);
        buffer.put((byte) 3);
        System.out.println("After writing, position: " + buffer.position()); // 3

        // Step 2: Prepare buffer for reading
        buffer.flip();
        System.out.println("After flip, position: " + buffer.position() + ", limit: " + buffer.limit()); // 0, 3

        // Step 3: Read one byte
        byte b = buffer.get();
        System.out.println("Read byte: " + b);
        System.out.println("Position after read: " + buffer.position()); // 1

        // Step 4: Compact the buffer (keep unread bytes)
        buffer.compact();
        System.out.println("After compact, position: " + buffer.position() + ", limit: " + buffer.limit()); // 2, 8

        // Step 5: Write more data after compacting
        buffer.put((byte) 4);
        buffer.put((byte) 5);
        System.out.println("After writing more, position: " + buffer.position()); // 4

        // Step 6: Prepare to read all available data again
        buffer.flip();
        while (buffer.hasRemaining()) {
            System.out.println("Reading: " + buffer.get());
        }
    }
}</code></pre>
</div><p><strong>Output breakdown:</strong></p><ul>
 <li>After initial write, position is 3 (bytes 1,2,3).</li>
 <li><code>flip()</code> sets position to 0 and limit to 3 for reading.</li>
 <li>One byte read advances position to 1.</li>
 <li><code>compact()</code> shifts unread bytes (2,3) to front and sets position to 2 for writing more.</li>
 <li>New bytes (4,5) added; position moves to 4.</li>
 <li>Another <code>flip()</code> prepares buffer for reading all 4 bytes.</li>
 <li>Reads output: 2, 3, 4, 5.</li>
</ul><h3 id="summary-of-buffer-operations">Summary of Buffer Operations</h3><table>
 <thead>
  <tr>
   <th>Operation</th>
   <th>Position (pos)</th>
   <th>Limit (lim)</th>
   <th>Capacity (cap)</th>
   <th>Purpose</th>
  </tr>
 </thead>
 <tbody>
  <tr>
   <td><code>put()</code></td>
   <td>Advances by number written</td>
   <td>Unchanged</td>
   <td>Unchanged</td>
   <td>Write data into buffer at current position</td>
  </tr>
  <tr>
   <td><code>flip()</code></td>
   <td>Set to 0</td>
   <td>Set to current position</td>
   <td>Unchanged</td>
   <td>Prepare buffer for reading data just written</td>
  </tr>
  <tr>
   <td><code>get()</code></td>
   <td>Advances by number read</td>
   <td>Unchanged</td>
   <td>Unchanged</td>
   <td>Read data from buffer at current position</td>
  </tr>
  <tr>
   <td><code>clear()</code></td>
   <td>Set to 0</td>
   <td>Set to capacity</td>
   <td>Unchanged</td>
   <td>Prepare buffer for writing new data (discard old markers)</td>
  </tr>
  <tr>
   <td><code>compact()</code></td>
   <td>Set to unread data length</td>
   <td>Set to capacity</td>
   <td>Unchanged</td>
   <td>Keep unread data, move to front, prepare for writing more</td>
  </tr>
 </tbody>
</table><h3 id="why-these-operations-matter">Why These Operations Matter</h3><ul>
 <li><strong><code>flip()</code></strong> is essential to switch modes between writing and reading.</li>
 <li><strong><code>clear()</code></strong> resets the buffer for reuse without erasing data physically.</li>
 <li><strong><code>compact()</code></strong> is useful for partial reads where you want to keep leftover data and still write new data without losing anything.</li>
 <li>Using these operations correctly avoids common bugs like reading unwritten data or overwriting unread bytes.</li>
</ul><h3 id="conclusion">Conclusion</h3><p>Mastering buffer operations like <code>put()</code>, <code>get()</code>, <code>flip()</code>, <code>clear()</code>, and <code>compact()</code> is crucial for efficient data management in Java NIO. These operations give fine-grained control over buffer state, enabling you to handle complex IO workflows and maximize performance.</p><p>With practice, these methods become intuitive and enable building scalable, non-blocking IO applications that efficiently manage data flow.</p><div class = "chapter-navi-section">
<a href="#top" class="nav-button prev">↑</a>
<a href='java-io-and-nio.htm#buffers-and-channels' class="nav-button toc-link">Index</a>
<a href="#bottom" class="nav-button next">↓</a>
</div>
<h2 id='filechannel-for-file-operations'>6.3 FileChannel for File Operations</h2><p>Java NIO (New IO) introduced several new abstractions for more efficient and flexible input/output operations. One of the core classes for file handling in NIO is <strong><code>FileChannel</code></strong>. It provides an efficient way to read from, write to, and manipulate files at a low level, improving upon the traditional Java IO classes like <code>FileInputStream</code> and <code>FileOutputStream</code>.</p><h3 id="what-is-filechannel">What is FileChannel?</h3><p><code>FileChannel</code> is a part of the <code>java.nio.channels</code> package and represents a connection to a file that supports reading, writing, mapping, and manipulating file content. Unlike stream-based IO, which processes data sequentially, <code>FileChannel</code> allows random access to file content and can read/write data at specific positions.</p><h3 id="advantages-of-filechannel-over-traditional-io">Advantages of FileChannel over Traditional IO</h3><ol>
 <li><p><strong>Random Access:</strong> Unlike traditional <code>FileInputStream</code> or <code>FileOutputStream</code>, which only allow sequential reading or writing, <code>FileChannel</code> supports random access, enabling you to read/write at any position in the file without having to process all preceding bytes.</p></li>
 <li><p><strong>Efficient Bulk Data Transfer:</strong> <code>FileChannel</code> can transfer data directly between channels using <code>transferTo()</code> and <code>transferFrom()</code>, which can leverage lower-level OS optimizations and reduce overhead.</p></li>
 <li><p><strong>Memory Mapping:</strong> You can map files directly into memory with <code>FileChannel.map()</code>, allowing you to treat file content as a part of memory — improving performance for large files.</p></li>
 <li><p><strong>Non-blocking and Asynchronous IO Compatibility:</strong> As part of NIO, <code>FileChannel</code> fits well into non-blocking IO paradigms and works smoothly with buffers and selectors.</p></li>
 <li><p><strong>Explicit Buffer Management:</strong> Instead of relying on streams, <code>FileChannel</code> requires buffers for reading and writing, offering more precise control over data flow.</p></li>
</ol><h3 id="creating-a-filechannel">Creating a FileChannel</h3><p>You obtain a <code>FileChannel</code> instance from file streams or from the <code>java.nio.file.Files</code> utility:</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-Java">// From FileInputStream or FileOutputStream
FileInputStream fis = new FileInputStream("example.txt");
FileChannel channel = fis.getChannel();

// Or from RandomAccessFile for read-write mode
RandomAccessFile raf = new RandomAccessFile("example.txt", "rw");
FileChannel rafChannel = raf.getChannel();

// Or using Files.newByteChannel (Java 7+)
Path path = Paths.get("example.txt");
FileChannel fileChannel = FileChannel.open(path, StandardOpenOption.READ, StandardOpenOption.WRITE);</code></pre>
</div><h3 id="key-filechannel-methods">Key FileChannel Methods</h3><ul>
 <li><p><strong><code>int read(ByteBuffer dst)</code></strong>: Reads bytes from the channel into the buffer starting at the current file position. Advances the position by the number of bytes read.</p></li>
 <li><p><strong><code>int write(ByteBuffer src)</code></strong>: Writes bytes from the buffer into the channel starting at the current file position. Advances the position by the number of bytes written.</p></li>
 <li><p><strong><code>long position()</code> / <code>position(long newPosition)</code></strong>: Gets or sets the file position for the next read or write.</p></li>
 <li><p><strong><code>long size()</code></strong>: Returns the current size of the file.</p></li>
 <li><p><strong><code>FileLock lock(long position, long size, boolean shared)</code></strong>: Locks a region of the file for exclusive or shared access.</p></li>
 <li><p><strong><code>long transferTo(long position, long count, WritableByteChannel target)</code></strong>: Transfers bytes directly from this channel to another writable channel.</p></li>
 <li><p><strong><code>long transferFrom(ReadableByteChannel src, long position, long count)</code></strong>: Transfers bytes from a readable channel into this file channel.</p></li>
 <li><p><strong><code>MappedByteBuffer map(FileChannel.MapMode mode, long position, long size)</code></strong>: Maps a region of the file into memory.</p></li>
</ul><h3 id="reading-a-file-using-filechannel">Reading a File Using FileChannel</h3><p>Reading data from a file using <code>FileChannel</code> requires a <code>ByteBuffer</code> to hold the data read:</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-java">import java.io.FileInputStream;
import java.nio.ByteBuffer;
import java.nio.channels.FileChannel;

public class FileChannelReadExample {
    public static void main(String[] args) {
        try (FileInputStream fis = new FileInputStream("example.txt");
             FileChannel fileChannel = fis.getChannel()) {

            ByteBuffer buffer = ByteBuffer.allocate(1024); // 1 KB buffer

            int bytesRead = fileChannel.read(buffer);
            while (bytesRead != -1) {
                buffer.flip();  // Prepare buffer for reading

                while (buffer.hasRemaining()) {
                    System.out.print((char) buffer.get());  // Print characters read
                }

                buffer.clear(); // Prepare buffer for writing
                bytesRead = fileChannel.read(buffer);
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}</code></pre>
</div><p><strong>Explanation:</strong></p><ul>
 <li>We allocate a buffer of size 1024 bytes.</li>
 <li>We read data into the buffer until EOF (<code>read()</code> returns -1).</li>
 <li>Before reading data from the buffer, we call <code>flip()</code> to switch from writing mode to reading mode.</li>
 <li>After processing, <code>clear()</code> resets the buffer to receive more data.</li>
</ul><h3 id="writing-to-a-file-using-filechannel">Writing to a File Using FileChannel</h3><p>Similarly, writing requires a buffer filled with data to be written:</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-java">import java.io.FileOutputStream;
import java.nio.ByteBuffer;
import java.nio.channels.FileChannel;

public class FileChannelWriteExample {
    public static void main(String[] args) {
        String data = "Hello, FileChannel!";

        try (FileOutputStream fos = new FileOutputStream("output.txt");
             FileChannel fileChannel = fos.getChannel()) {

            ByteBuffer buffer = ByteBuffer.allocate(1024);
            buffer.put(data.getBytes());

            buffer.flip(); // Prepare buffer for writing to channel

            while (buffer.hasRemaining()) {
                fileChannel.write(buffer);
            }

            System.out.println("Data written to file successfully.");
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}</code></pre>
</div><p><strong>Explanation:</strong></p><ul>
 <li>We put the byte representation of a string into the buffer.</li>
 <li><code>flip()</code> switches buffer from write mode to read mode.</li>
 <li>We write the buffer contents to the channel in a loop until all bytes are written.</li>
</ul><h3 id="random-access-with-filechannel">Random Access with FileChannel</h3><p>Because <code>FileChannel</code> supports setting the file position, you can read or write data at arbitrary locations:</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-java">import java.io.RandomAccessFile;
import java.nio.ByteBuffer;
import java.nio.channels.FileChannel;

public class Test {

    public static void main(String[] argv) throws Exception {
        RandomAccessFile raf = new RandomAccessFile("data.bin", "rw");
        FileChannel channel = raf.getChannel();

        ByteBuffer buffer = ByteBuffer.allocate(4);
        buffer.putInt(12345);
        buffer.flip();

        // Write at position 10
        channel.position(10);
        channel.write(buffer);

        // Read back the integer at position 10
        buffer.clear();
        channel.position(10);
        channel.read(buffer);
        buffer.flip();

        System.out.println("Read integer: " + buffer.getInt());

        channel.close();
        raf.close();
    }
}</code></pre>
</div><h3 id="summary">Summary</h3><ul>
 <li><code>FileChannel</code> is a powerful NIO class for file operations supporting efficient, random access to file data.</li>
 <li>It offers advantages over traditional IO, such as bulk transfers, memory mapping, and position-based access.</li>
 <li>Operations revolve around <code>ByteBuffer</code>s to read and write data.</li>
 <li>Key methods include <code>read()</code>, <code>write()</code>, <code>position()</code>, and <code>map()</code>.</li>
 <li>Using <code>FileChannel</code> with buffers enables high-performance and flexible file IO suited for modern Java applications.</li>
</ul><div class = "chapter-navi-section">
<a href="#top" class="nav-button prev">↑</a>
<a href='java-io-and-nio.htm#buffers-and-channels' class="nav-button toc-link">Index</a>
<a href="#bottom" class="nav-button next">↓</a>
</div>
<h2 id='socketchannel-and-datagramchannel'>6.4 SocketChannel and DatagramChannel</h2><p>Java NIO provides powerful networking capabilities through channels designed for scalable, efficient IO operations. Two primary channel classes for network communication are:</p><ul>
 <li><strong><code>SocketChannel</code></strong> — for TCP-based stream communication.</li>
 <li><strong><code>DatagramChannel</code></strong> — for UDP-based datagram communication.</li>
</ul><p>These classes support <strong>non-blocking IO</strong>, allowing Java applications to handle many simultaneous network connections with minimal threads and overhead.</p><h3 id="socketchannel-tcp-communication-in-java-nio">SocketChannel: TCP Communication in Java NIO</h3><p><strong>Role and Characteristics:</strong></p><p><code>SocketChannel</code> is a selectable channel for stream-oriented TCP connections. It allows you to open a TCP socket connection to a remote server, read from and write to the connection, and optionally configure non-blocking behavior.</p><p>TCP (Transmission Control Protocol) provides a reliable, ordered, and error-checked delivery of a stream of bytes between applications.</p><p><strong>Key Features:</strong></p><ul>
 <li>Supports <strong>connection-oriented</strong> communication.</li>
 <li>Can operate in <strong>blocking</strong> or <strong>non-blocking</strong> modes.</li>
 <li>Integrates with NIO’s <strong>Selector</strong> for multiplexed IO.</li>
 <li>Reads and writes use <code>ByteBuffer</code>s.</li>
 <li>Allows random access to the stream position only in blocking mode (non-blocking reads/writes are always sequential).</li>
</ul><h3 id="basic-usage-of-socketchannel">Basic Usage of SocketChannel</h3><ol>
 <li><strong>Opening and Connecting:</strong></li>
</ol><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-java">import java.net.InetSocketAddress;
import java.nio.ByteBuffer;
import java.nio.channels.SocketChannel;

public class SocketChannelExample {
    public static void main(String[] args) {
        try {
            // Open a SocketChannel
            SocketChannel socketChannel = SocketChannel.open();

            // Configure non-blocking mode
            socketChannel.configureBlocking(false);

            // Connect to server at localhost:5000
            socketChannel.connect(new InetSocketAddress("localhost", 5000));

            // Wait or check for connection completion (non-blocking)
            while (!socketChannel.finishConnect()) {
                System.out.println("Connecting...");
                // Do something else or sleep briefly
            }

            // Prepare data to send
            String message = "Hello, Server!";
            ByteBuffer buffer = ByteBuffer.wrap(message.getBytes());

            // Write data to server
            while (buffer.hasRemaining()) {
                socketChannel.write(buffer);
            }

            // Read response
            buffer.clear();
            int bytesRead = socketChannel.read(buffer);
            if (bytesRead &gt; 0) {
                buffer.flip();
                byte[] received = new byte[buffer.remaining()];
                buffer.get(received);
                System.out.println("Received: " + new String(received));
            }

            socketChannel.close();

        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}</code></pre>
</div><p><strong>Explanation:</strong></p><ul>
 <li>We open a <code>SocketChannel</code> and configure it to non-blocking mode.</li>
 <li>The connection attempt is initiated but may not complete immediately; <code>finishConnect()</code> confirms when connected.</li>
 <li>Data is written and read using <code>ByteBuffer</code>s.</li>
 <li>Non-blocking mode allows the application to perform other tasks while waiting for the connection or IO readiness.</li>
</ul><h3 id="datagramchannel-udp-communication-in-java-nio">DatagramChannel: UDP Communication in Java NIO</h3><p><strong>Role and Characteristics:</strong></p><p><code>DatagramChannel</code> provides a selectable channel for sending and receiving UDP packets.</p><p>UDP (User Datagram Protocol) is connectionless and message-oriented, meaning it sends discrete packets without establishing a dedicated connection, with no guarantee of delivery or order.</p><p><strong>Key Features:</strong></p><ul>
 <li>Supports <strong>connectionless</strong> communication.</li>
 <li>Can send and receive <strong>datagrams</strong> (packets).</li>
 <li>Works in blocking or non-blocking modes.</li>
 <li>Uses <code>ByteBuffer</code> for packet data.</li>
 <li>Supports multicast via the <code>join()</code> method.</li>
</ul><h3 id="basic-usage-of-datagramchannel">Basic Usage of DatagramChannel</h3><ol>
 <li><strong>Opening, Sending, and Receiving Packets:</strong></li>
</ol><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-java">import java.net.InetSocketAddress;
import java.nio.ByteBuffer;
import java.nio.channels.DatagramChannel;

public class DatagramChannelExample {
    public static void main(String[] args) {
        try {
            // Open DatagramChannel and bind to a local port
            DatagramChannel datagramChannel = DatagramChannel.open();
            datagramChannel.bind(new InetSocketAddress(9999));

            // Configure non-blocking mode
            datagramChannel.configureBlocking(false);

            // Prepare a message to send
            String message = "Hello UDP!";
            ByteBuffer sendBuffer = ByteBuffer.wrap(message.getBytes());

            // Send the packet to a remote address
            InetSocketAddress remoteAddress = new InetSocketAddress("localhost", 8888);
            datagramChannel.send(sendBuffer, remoteAddress);

            // Prepare buffer for receiving
            ByteBuffer receiveBuffer = ByteBuffer.allocate(1024);

            // Receive packets (non-blocking, returns null if none)
            InetSocketAddress senderAddress = (InetSocketAddress) datagramChannel.receive(receiveBuffer);

            if (senderAddress != null) {
                receiveBuffer.flip();
                byte[] data = new byte[receiveBuffer.remaining()];
                receiveBuffer.get(data);
                System.out.println("Received from " + senderAddress + ": " + new String(data));
            } else {
                System.out.println("No packet received");
            }

            datagramChannel.close();

        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}</code></pre>
</div><p><strong>Explanation:</strong></p><ul>
 <li>We open and bind the <code>DatagramChannel</code> to a local port to receive packets.</li>
 <li>The channel is set to non-blocking mode.</li>
 <li>We send a UDP packet using <code>send()</code>.</li>
 <li>We attempt to receive a packet using <code>receive()</code>, which returns immediately in non-blocking mode.</li>
 <li>Received data is read from the <code>ByteBuffer</code>.</li>
</ul><h3 id="non-blocking-io-and-selectors">Non-Blocking IO and Selectors</h3><p>Both <code>SocketChannel</code> and <code>DatagramChannel</code> can be used with Java NIO’s <strong>Selector</strong> class to handle multiple network connections or datagram sockets efficiently using a single thread.</p><p>Non-blocking IO avoids the thread-per-connection model, greatly improving scalability for servers or clients managing many simultaneous connections.</p><p><strong>Example Selector usage highlights:</strong></p><ul>
 <li>Register channels with the selector for interested events (OP_READ, OP_WRITE, OP_CONNECT).</li>
 <li>The selector blocks until one or more registered channels are ready for IO.</li>
 <li>The application processes ready channels, reading or writing as appropriate.</li>
</ul><h3 id="summary">Summary</h3><table>
 <thead>
  <tr>
   <th>Feature</th>
   <th>SocketChannel</th>
   <th>DatagramChannel</th>
  </tr>
 </thead>
 <tbody>
  <tr>
   <td>Protocol</td>
   <td>TCP (stream, connection-oriented)</td>
   <td>UDP (datagram, connectionless)</td>
  </tr>
  <tr>
   <td>Communication model</td>
   <td>Reliable, ordered byte streams</td>
   <td>Unreliable, discrete packets</td>
  </tr>
  <tr>
   <td>Blocking/non-blocking</td>
   <td>Supports both</td>
   <td>Supports both</td>
  </tr>
  <tr>
   <td>Usage scenario</td>
   <td>Web servers, chat clients, file transfer</td>
   <td>DNS, real-time data, multicast</td>
  </tr>
  <tr>
   <td>Key methods</td>
   <td><code>connect()</code>, <code>read()</code>, <code>write()</code>, <code>finishConnect()</code></td>
   <td><code>send()</code>, <code>receive()</code></td>
  </tr>
 </tbody>
</table><h3 id="conclusion">Conclusion</h3><p><code>SocketChannel</code> and <code>DatagramChannel</code> are powerful tools in Java NIO for building scalable network applications. Their support for non-blocking IO and integration with selectors enables efficient multiplexed IO operations. <code>SocketChannel</code> is ideal for reliable TCP stream communication, while <code>DatagramChannel</code> suits fast, connectionless UDP messaging.</p><p>Mastering these classes equips Java developers to build high-performance servers, clients, and real-time networked applications that can handle thousands of connections efficiently.</p><div class = "chapter-navi-section">
<a href="#top" class="nav-button prev">↑</a>
<a href='java-io-and-nio.htm#buffers-and-channels' class="nav-button toc-link">Index</a>
<a href="#bottom" class="nav-button next">↓</a>
</div>
<h2 id='memory-mapped-files'>6.5 Memory-Mapped Files</h2><p>When dealing with large files or performance-critical applications, traditional read/write operations may become bottlenecks. Java NIO offers an advanced feature called <strong>memory-mapped files</strong> that can significantly improve IO efficiency by leveraging the operating system's virtual memory subsystem. This section explains what memory mapping is, how it works in Java, and how to use <code>MappedByteBuffer</code> to perform fast file operations.</p><h3 id="what-is-memory-mapping">What is Memory Mapping?</h3><p>Memory mapping a file means associating a portion of a file directly with a region of memory. Instead of explicitly reading or writing bytes via system calls, the file’s contents are mapped into the process’s address space. This allows a program to access file contents just like normal memory arrays.</p><p><strong>How it works:</strong></p><ul>
 <li>The operating system loads the requested file region into RAM on demand.</li>
 <li>Reads and writes to the memory region are automatically synchronized with the file on disk.</li>
 <li>The OS handles paging in/out of data, caching, and flushing changes back to disk.</li>
 <li>Access to the file content becomes very fast and efficient, often faster than traditional IO streams.</li>
</ul><h3 id="advantages-of-memory-mapped-files">Advantages of Memory-Mapped Files</h3><ol>
 <li><p><strong>High Performance:</strong> Because file content is accessed via memory pointers, reading and writing can avoid many copies and system calls.</p></li>
 <li><p><strong>Random Access Efficiency:</strong> You can read or write any part of the file instantly by simply accessing the memory region at an offset.</p></li>
 <li><p><strong>Reduced Buffering Overhead:</strong> Eliminates the need for manual buffering since the OS handles paging.</p></li>
 <li><p><strong>Simplified Code:</strong> Treat file data as a simple array, simplifying complex IO logic.</p></li>
 <li><p><strong>Large File Handling:</strong> Suitable for working with files larger than the available heap space, since the OS pages data transparently.</p></li>
</ol><h3 id="mappedbytebuffer-the-java-api">MappedByteBuffer: The Java API</h3><p>In Java NIO, the <code>FileChannel</code> class provides a <code>map()</code> method that returns a <code>MappedByteBuffer</code>. This buffer represents the memory-mapped region of the file.</p><p><strong>Signature:</strong></p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-Java">MappedByteBuffer map(FileChannel.MapMode mode, long position, long size) throws IOException;</code></pre>
</div><ul>
 <li><p><strong><code>mode</code></strong>: Specifies access type — read-only, read-write, or private (copy-on-write).</p>
  <ul>
   <li><code>MapMode.READ_ONLY</code>: Read-only mapping.</li>
   <li><code>MapMode.READ_WRITE</code>: Read-write mapping.</li>
   <li><code>MapMode.PRIVATE</code>: Changes are private to the process (not written back).</li>
  </ul></li>
 <li><p><strong><code>position</code></strong>: The starting byte offset in the file.</p></li>
 <li><p><strong><code>size</code></strong>: The number of bytes to map.</p></li>
</ul><p>Once mapped, you can read/write the buffer like any other NIO buffer. Changes to a <code>READ_WRITE</code> buffer are written back to the file, either immediately or when the buffer is flushed.</p><h3 id="example-mapping-a-file-and-reading-data">Example: Mapping a File and Reading Data</h3><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-java">import java.io.RandomAccessFile;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;

public class MemoryMappedFileRead {
    public static void main(String[] args) {
        try (RandomAccessFile file = new RandomAccessFile("largefile.txt", "r");
             FileChannel channel = file.getChannel()) {

            // Map the first 1024 bytes of the file into memory (read-only)
            MappedByteBuffer buffer = channel.map(FileChannel.MapMode.READ_ONLY, 0, 1024);

            // Read bytes from the buffer
            for (int i = 0; i &lt; 1024; i++) {
                byte b = buffer.get(i);
                System.out.print((char) b);
            }

        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}</code></pre>
</div><p><strong>Explanation:</strong></p><ul>
 <li>Opens a file in read-only mode.</li>
 <li>Maps the first 1024 bytes into memory.</li>
 <li>Reads bytes directly from the mapped buffer as if reading an array.</li>
 <li>No explicit <code>read()</code> calls; the OS manages loading pages on demand.</li>
</ul><h3 id="example-modifying-a-file-using-memory-mapping">Example: Modifying a File Using Memory Mapping</h3><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-java">import java.io.RandomAccessFile;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;

public class MemoryMappedFileWrite {
    public static void main(String[] args) {
        try (RandomAccessFile file = new RandomAccessFile("data.bin", "rw");
             FileChannel channel = file.getChannel()) {

            // Map the first 128 bytes of the file into memory (read-write)
            MappedByteBuffer buffer = channel.map(FileChannel.MapMode.READ_WRITE, 0, 128);

            // Write some bytes into the buffer at specific positions
            buffer.put(0, (byte) 10);
            buffer.put(1, (byte) 20);
            buffer.put(2, (byte) 30);

            // Sequential write example
            buffer.position(3);
            buffer.put((byte) 40);
            buffer.put((byte) 50);

            // Force changes to be written to disk (optional, as OS flushes eventually)
            buffer.force();

            System.out.println("Data written successfully.");

        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}</code></pre>
</div><p><strong>Explanation:</strong></p><ul>
 <li>Opens the file in read-write mode.</li>
 <li>Maps 128 bytes starting at the beginning of the file.</li>
 <li>Writes data at specific offsets within the mapped region.</li>
 <li>Calls <code>force()</code> to flush changes to disk immediately (optional).</li>
</ul><h3 id="best-practices-and-considerations">Best Practices and Considerations</h3><ul>
 <li><p><strong>Size Matters:</strong> The size parameter controls how much of the file is mapped. Mapping very large files in one go may cause <code>OutOfMemoryError</code> on 32-bit JVMs. Consider mapping in chunks.</p></li>
 <li><p><strong>OS-Dependent Behavior:</strong> Memory mapping relies heavily on the OS's virtual memory system. Performance and behavior may vary across platforms.</p></li>
 <li><p><strong>Resource Management:</strong> Unlike streams, <code>MappedByteBuffer</code>s are managed by the OS, and explicit unmapping is not directly exposed in Java. This can cause the file to remain locked until the buffer is garbage collected, which can affect file deletion on some systems.</p></li>
 <li><p><strong>Concurrency:</strong> Multiple threads can safely read from a <code>MappedByteBuffer</code>. Writing should be carefully synchronized.</p></li>
 <li><p><strong>File Size Changes:</strong> If the file size changes on disk after mapping, behavior is undefined. Ideally, map the file once when size is stable.</p></li>
</ul><h3 id="when-to-use-memory-mapped-files">When to Use Memory-Mapped Files</h3><ul>
 <li>Reading or writing very large files where performance matters.</li>
 <li>Random access patterns requiring low latency.</li>
 <li>Applications like databases, multimedia processing, or large-scale file transformations.</li>
 <li>Avoiding overhead of frequent system calls in traditional IO.</li>
</ul><h3 id="summary">Summary</h3><ul>
 <li><strong>Memory mapping</strong> maps a file’s content directly into memory, allowing fast and flexible IO.</li>
 <li>Java NIO’s <code>FileChannel.map()</code> returns a <code>MappedByteBuffer</code> to access mapped file regions.</li>
 <li>It improves performance by minimizing system calls, enabling random access, and leveraging OS virtual memory.</li>
 <li>Use <code>MappedByteBuffer</code> for efficient reading and writing of files, especially large or performance-critical ones.</li>
 <li>Remember platform-specific behavior and resource management considerations.</li>
</ul><div class = "chapter-navi-section">
<a href="java-io-and-nio-introduction-to-java-nio-new-io.htm" class="nav-button prev">←</a>
<a href='java-io-and-nio.htm#buffers-and-channels' class="nav-button toc-link">Index</a>
<a href="java-io-and-nio-selectors-and-non-blocking-io.htm" class="nav-button next">→</a>
</div>
<section class="download-section">
  <div class="book-cover" style="background-color: #f9f6f1;border: 1px solid #ccc;"> 
    <div class="book-cover-title" style="font-size: 18px;color: #333;top: 20px;">Java IO and NIO</div>
    <div class="book-cover-author">readbytes</div>
    <div class="book-cover-bottom-stripe" style="background-color: #333;"></div>
    <img class="book-cover-icon" style="width: 80px;height: 90px;top: 60px;" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFoAAABaCAYAAAA4qEECAAADAElEQVR4Xu2Zu6oTURSGjze0UfANtLAUzgOI4DOItc+VKk1uJ12aadNa21vbCpYK4wQmcPiYzL5k7eXM2f8HP0JYa/3ZX2PEmxshxAPi7u6uLRH2VA3lWId9VdK27WOKsQ47q6RpmucUYx12VolEOyHRToyJ5mwI7ufeeZBItBMS7YREOyHRTki0ExLthEQ7IdFOSLQTEu2ERDsxJtoq7KwSiXZCop04Ho9PKcY67KwWirEO+6qGcqzCHhGBJDoh0U5ItAP7/f6bRDtAyV3+ckYYQNHr9fo1Z8SVtG37iKI5Mzv4IKuwJwXeuvbef4ePsQ77YuGdLp85MysGHmQa9sXAG7l3JgUfZB32heh+0t3yRvfZD87NDj7KOuwLwf2cG5OEj7IO+8bg7imr1eoV55Lh0VC4bwE7cru4n3Jns9l85d7YPmdCSV8oADtyu7gfe4fzMbucCyV9oQDsyO3i/tid7i+395xjuHMfzoaSvlAAduR2cf/+ne7PT/x8JL94mwzsjCZ5wTN8XAjuTynT/nKJcH9KmfaXS4T7U8q0v1wi3J9Skr8cH3cJ7l3I98Ph8HLg86SuM9zPvRMDO0JJXwjQ/Wx6yx3kI3cGZqK6CPdz78TAjlDSF0ZYLpcvOH9O0zQX/xnL2ZiuIbifeycGdoSSvjACZ2N2TnA+do9wP/dODOwIhfvZ8HCfn5wbYmDPNOybLXxYn9+cu8TArmnYN1v4sNTHcdc67JslfFTOw7hvHfbNEj6q+3n3gTMheMM67JsdfNA1j+Idq7BnlvBR2+32DWfElazX63cUzRlhACVLdCEk2QmJdmC3232RaAcoucsfzogAAxJNwp6qoRzrsK9aKMY6i8XiGTurhGKsc/ofGHZWCcVYR6J7KMY6Et1DMedwLgT3JRpQjEQXgmIkuhAUI9GFoBiJLgTFSHQhKEaiC0ExEl0IipHoQlCMRBeCYiS6EBQj0YWgGOtIdA/FWEeieyjGOhLdQzHW2e/3T9hZJRRjHfZVDeVYhT1CiDnzD27IzgFe/xOvAAAAAElFTkSuQmCC"/>
  </div>
  <div class="download-info">
    <h2 id='bottom'>Download This Ebook</h2>
    <p class="format-label">Available formats:</p>
    <div class="download-buttons">
      <a href="java-io-and-nio.pdf" class="download-button">📄 PDF</a>
      <a href="java-io-and-nio.epub" class="download-button">📘 EPUB</a>
    </div>
  </div>
</section><div class='related-books'>
<h2>Java In-Depth Books</h2>
<div class='related-book-list'>
<a href="java-io-and-nio.htm">
<div class="book-cover" style="background-color: #f9f6f1;border: 1px solid #ccc;"> 
    <div class="book-cover-title" style="font-size: 18px;color: #333;top: 20px;">Java IO and NIO</div>
    <div class="book-cover-author">readbytes</div>
    <div class="book-cover-bottom-stripe" style="background-color: #333;"></div>
    <img class="book-cover-icon" style="width: 80px;height: 90px;top: 60px;" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFoAAABaCAYAAAA4qEECAAADAElEQVR4Xu2Zu6oTURSGjze0UfANtLAUzgOI4DOItc+VKk1uJ12aadNa21vbCpYK4wQmcPiYzL5k7eXM2f8HP0JYa/3ZX2PEmxshxAPi7u6uLRH2VA3lWId9VdK27WOKsQ47q6RpmucUYx12VolEOyHRToyJ5mwI7ufeeZBItBMS7YREOyHRTki0ExLthEQ7IdFOSLQTEu2ERDsxJtoq7KwSiXZCop04Ho9PKcY67KwWirEO+6qGcqzCHhGBJDoh0U5ItAP7/f6bRDtAyV3+ckYYQNHr9fo1Z8SVtG37iKI5Mzv4IKuwJwXeuvbef4ePsQ77YuGdLp85MysGHmQa9sXAG7l3JgUfZB32heh+0t3yRvfZD87NDj7KOuwLwf2cG5OEj7IO+8bg7imr1eoV55Lh0VC4bwE7cru4n3Jns9l85d7YPmdCSV8oADtyu7gfe4fzMbucCyV9oQDsyO3i/tid7i+395xjuHMfzoaSvlAAduR2cf/+ne7PT/x8JL94mwzsjCZ5wTN8XAjuTynT/nKJcH9KmfaXS4T7U8q0v1wi3J9Skr8cH3cJ7l3I98Ph8HLg86SuM9zPvRMDO0JJXwjQ/Wx6yx3kI3cGZqK6CPdz78TAjlDSF0ZYLpcvOH9O0zQX/xnL2ZiuIbifeycGdoSSvjACZ2N2TnA+do9wP/dODOwIhfvZ8HCfn5wbYmDPNOybLXxYn9+cu8TArmnYN1v4sNTHcdc67JslfFTOw7hvHfbNEj6q+3n3gTMheMM67JsdfNA1j+Idq7BnlvBR2+32DWfElazX63cUzRlhACVLdCEk2QmJdmC3232RaAcoucsfzogAAxJNwp6qoRzrsK9aKMY6i8XiGTurhGKsc/ofGHZWCcVYR6J7KMY6Et1DMedwLgT3JRpQjEQXgmIkuhAUI9GFoBiJLgTFSHQhKEaiC0ExEl0IipHoQlCMRBeCYiS6EBQj0YWgGOtIdA/FWEeieyjGOhLdQzHW2e/3T9hZJRRjHfZVDeVYhT1CiDnzD27IzgFe/xOvAAAAAElFTkSuQmCC"/>
  </div>
</a>


<a href="java-collections.htm">
<div class="book-cover" style="background-color: #f9f6f1;border: 1px solid #ccc;"> 
    <div class="book-cover-title" style="font-size: 18px;color: #333;top: 20px;">Java Collections</div>
    <div class="book-cover-author">readbytes</div>
    <div class="book-cover-bottom-stripe" style="background-color: #333;"></div>
    <img class="book-cover-icon" style="width: 80px;height: 90px;top: 60px;" src='data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFoAAABaCAYAAAA4qEECAAADAElEQVR4Xu2dQYrUUBRFIw50JI7FrYgrcAPOXYPORHci7sah4EAQFyA6dNKosZK2Ee8/dOclP7/+i/fAmaR+Xr17KehJV2oYjDHGGGM6YRxzmgZdPKvdMt4vl03vLU15ZsYnsORB7Apd7mh2gS51VM/K+LVc6LA+0/QNKZax9RnvlG+C/tI7+6PYuYLV0MHoc72rX8ZvsP9Gq6BDyWzo/jXcjA4sfKN39E+RoYaf9F2CFAPFjGiG3b0Y5r9111LcJGZEM7QW0UNqRjTDWXwQXCojmoEk9MxmHwWGZ0QzkMT4ujy31b/D4UU8uITp/J4uRDOQxPiyPFfDy+HwQnFoCdPZFi5AM5BE/0VP51r5brgRzUASexU9/piG60VxEdO5lt6AZiCJ3Yoep+Fw8Z8DS5gHNfLncCOagSSWFE2M38tzanFBXcS9k/OwBi5AM5DE2qIn9JxaXFAXM33S5oE7+nFYhGYgiRxFX7FH4V+GEJqBJHIV3QGagSRcdBDNQBIuOohmIAkXHUQzkISLDqIZSMJFB9EMJOGig2gGknDRQTQDSbjoIJqBJHIUfffkPLCC74dNaAaSyFH0PKyiL4bVaAaS6L/oedAOrkQzkISLDqIZSMJFB9EMJNF/0bdPzsMquxLNQBL9Fz3x4eQ8sJIb0AwkkaPoK56efLvSV0MVNANJ5Cq6AzQDSbjoIJqBJFx0EM1AEi46iGYgCRcdRDOQhIsOohlIwkUH0Qwk4aKDaAaScNFBNANJuOggmoEkXHQQzUASLjqIZiAJFx1EM5CEiw6iGUjCRQfRDCSxtuh2X63oDM1AEkuKXmtxQc2IZiCJ3Yqu9vW3ztAMJLFX0ZfD4YXiUDI0A0m46CCagSTyfOm+EzQDSeiZzT4ODM+IZjiLD4NLZUQztBbRQ2pGNMPu1nh4lR/H9sfP+i5BioFgNnT/Gm5GB6Ib/im8Nf0+MtMPgb3Wquhwqw1Vwg/qbkix0EHtAl3qaHaDfx6kIf7Bm8YUyyY1Dbp4Fo0xxhhj/kd+A/PkOH57kF8HAAAAAElFTkSuQmCC'/>
  </div>
</a>


<a href="java-regex.htm">
<div class="book-cover" style="background-color: #f9f6f1;border: 1px solid #ccc;"> 
    <div class="book-cover-title" style="font-size: 18px;color: #333;top: 20px;">Java Regex</div>
    <div class="book-cover-author">readbytes</div>
    <div class="book-cover-bottom-stripe" style="background-color: #333;"></div>
    <img class="book-cover-icon" style="width: 80px;height: 90px;top: 60px;" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFoAAABaCAYAAAA4qEECAAAFo0lEQVR4Xu2d3WscVRiH+y/YXuuFkov6H9je2huvlAQvFalCEW8qiFRFQcGrmoJ4U5TSLWglFqRIlJqCH6XWalM/0lrT1O1ukt3sV5qPTZrP3XHfLTM983vPztc5s+zZPQ88N5l3Z9inwzA70Dl79iQks29oM7N3yBkoW98ZO6RC62ANdvDBtYF9lJEcxHNi+CWnOvmXs5rN9aX03eg74vcWxV6xObX3iUdxp2P7DzqDztiTB1lsaoX9InF631BJ3NH408N4vIFn/NCwL/aZVjPsGAj+a1mCwV7YUwqeyZZoxDqz8ZpsiYfY7mzQNdtGVkdsiH3b2Mj6CIztbrB3F+qMHxqRh84Iv/gsehDO6oe/IN0/ju0/gPOWhNAPO3ZW27M5HXyhTwtP4Sx68S4f9NRPuJbgnEURsa0Xmp5QWfQyMfLwqZ8XunrtT5yzKEKPWFnoem4O5xKxsVbS5vbmMu7eKOr5OUnovHro1ep0KppKPT+vP/TGWpkF0qWp2NBdwobuEjY0MnXbcb4cd5xCGbco0XOhb8wuOhdnGp4//7fl254ah9/urAZ6KrQYGL01V0sndLPJw8pUxJjQ5OXsBh5KjVZjFjRIBXoqdKWcZXHRK/kGHi45GDJMBXoqNFku3WVx0V9nNcTGiK7nLgRvT0jPhSZLacfGeK7Xb4bPJaQnQz+InWNx0USXEQzn+vsUTvKZfgxNFhfyLC4a68x+7QMejrwieVqJM+QX3+BUZHo6NDlfnGNx0auzdPsQAQxHXprEKT7jqkDPhyZni/MsLhopNoY7kcEJPuN6bBQnY2FEaDJXLLC4aGhsjIfgdtdX3sHJ2BgTmswVwmMHXrMxoBgb/+76snpkwqjQZKnusLhox7uRryd4yDA1YVxoYmG1yeKi0jP7nzs8ZJAaMTI0UVhJEPvN4zxmJzVjbGhidik8tu8ygjE7mQJGha7XZvBQTnYxPHb7zF6o8qAyU8KY0Gv37uJhPGZq4bEXpnI8KpoiRoTe3lzBQzCmq51j59aabSu/3OBxSU23cEH0fOgHT+ej8W+Fx3Yju9YuXO16ZCKV0DvVSWfrzlnm+tyP/pCVW2xGNAlibIzsunT+p65GJroamhRD4zbVyC7TFR4XXf7qIn4sVVIJ3bj9meNce0OqGLM5+Rbb7jMhePmQWXzqWWf15Of40dRIJfTmwmV2hiY1LhhUJkV2Xfn4FO4iFXo+NBkVDCpTjOzFPvEp7ko7RoQmw8CgMjGw6PJourGNCU12AoPKXHpvlMVFl4+fxF1rw6jQJIJBZbpgWJnLH34i7F0fxoamnzEYVKZI6ZkXWViZS+9+5PucDowNjUFlIlt/3GRRO7n4+vv4cSWMDI1BZcpYP/89Cxpk7cgx3EVijAuNQWV2AkOSbZpN9nfX6uHkP5xE+i50EBgRwe1e7BeO4mhs+ip0GBjw/nc/4AibCZqNQ9+EjgLGI50G/yzOeLMK9EXoqBQPPMfixYm9cek3HIuM8aHjgvFcmzs7OMpm2v8oCTE6dBJ2q/dYPC/29rZvFrcPZGgVdss1FtCLvX6/PVN5/lW2beBC62C3VGURw2z/D66EGBdaJ7vFMosZpAoDHZqIGluVgQ/dJuAnuI7IhA0NVEaOtOMuHrVP74zEhu4SNnSXkIdWfHnVbr3AAunSVOjkZaF1vI4NA+nQZKSvY7MvGNSP9AWDpEUvYlv7EtgU8UK7Sz/Z0Ongnc34/mi7apA+xNWHxND21fOa8S4buHiZu4GWJbKo8W2nxRTE0PasVkdsiZ3b2NjqhEYmaNkhGzs5Yrszjzz+GPb1QQtq2djxEZu17pvL2FWK70M2dijYC3sGgmc2LUtk8SPeXcQ6kxFcdo+kG/FBR+tSqCK4U1F6QlW7/rezms33pfTdxKdwMrGXMhm7XLWo/uWqZdgF2OPxPxXwJpKIkhiiAAAAAElFTkSuQmCC"/>
  </div>
</a>


<a href="java-functional-programming.htm">
<div class="book-cover" style="background-color: #f9f6f1;border: 1px solid #ccc;"> 
    <div class="book-cover-title" style="font-size: 18px;color: #333;top: 20px;">Java Functional Programming</div>
    <div class="book-cover-author">readbytes</div>
    <div class="book-cover-bottom-stripe" style="background-color: #333;"></div>
    <img class="book-cover-icon" style="width: 80px;height: 80px;top: 80px;" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFoAAABaCAYAAAA4qEECAAADzUlEQVR4Xu2bO4sUURCFlxVBzfwLJkb+A1MxEgMRDBQDRTBRwchARk00MRFBAwNBzEQwMBfEBz7wbWIkiIGJoInio9wZdmZ7T1V3V91bPVhaH3xJ973n3jk2vdO968JCkiRJkiRRIYphWOgI/zB/uyHBDxHFUODmIxkK3HwkQ4Gbj2QY6BDffCTDgBuPZhhw49EMA248miGgW3zj0QwBbjqiIcBNRzQEuOlohoA+8Y1HMgy4cauJEizO5EZMS0RoUSjPYKIEi7OaKMHirCZKsDiTi5iWiNAmoTyDiRIszmqiBIsz+QXTklZYeQYTJXSUl2cxUYLFWU2UYHEmb2Na0gorz2CihJ7w8iwmSrA4q4kSLM7kYUxLWmHlGUyU0C9ensVECRZnNQS4abPPMNEOy7S4BdN00L5GxmU8q4cuNXL24tll2KYrLIXW8yyLJdAJnkP3cFQ/9FzIGeEgHOBgCZhh1Qod5xkzH+PoduiVMH/qqDkQT3q4trGAEpZh1AId4/OZb3EWh14K89DRdDCecNIKzjdp+IelHcL8Nj/g7BU6r2R0+3gCHvRyN26tHdoszDdoAef2KpQt3pN7ZAc81YLzrFrAuSrfNOY/Es4rZAdcfbCywS7YPIvfMa0buiBkaFz6ATn+POy4xmvjhfGgsxpwjsUSigsr8el0UTzh7c9Vn5FBe4Q5BkuZXKFCnqsPmwviyQHsAsdarWF8tWGem/dxMRwwkG3gOJMvMM1O7S8aRJtX8hQ2aCDbwHEWvXAte3pPlmCDBxKhK3yMRU9cbiOKp0k+aQg3+K7pTdUPyHeYVgELL9At7/zqLA9KH0YmNh5qqqHPwgJWLzby8JxBb1y+Wxve+vXCwguc5Lzmxy164lLy1IL32SJ0Qwi3+k04ZtSLqttFm3dxlUJY8Lzdijsqo+QtnFqPK5u2CcFz1APT++RSPe7ZLHSO1qL6zYiXmu/WXdAaIXRO1lD8mnSpsOKHmpu4CyMscB5W/m8rlqex8TBS+lBTDQYObS2Y16vwxFfydbAaDBzaWmgXz2y14/46fg3Kxre5E2cXwoKH8geuXIb4hzNo11u4ZVRX9kmcVQELH0hP6BTPnym9T26h8559Gkc7wBYZQG/oLF+D/WZEgfht5AyOcoLeC4s5OwR0oLHGVTyrh643cvbjWWewGFc/4mr/MXRQKMjJBMCCvEwAWsdL8jARwJKqvYMrJDNYWRUmHWBZNSY9YGGlJj1gYUWew9REhBVnNFFCX3l5FhMDWJ7WpAAssc+kAiyzzcQJLHbibxyVJEmSJMk/xB+4wdarC+OVAQAAAABJRU5ErkJggg=="/>
  </div>
</a>


<a href="java-streams.htm">
<div class="book-cover" style="background-color: #f9f6f1;border: 1px solid #ccc;"> 
    <div class="book-cover-title" style="font-size: 18px;color: #333;top: 20px;">Java Streams</div>
    <div class="book-cover-author">readbytes</div>
    <div class="book-cover-bottom-stripe" style="background-color: #333;"></div>
    <img class="book-cover-icon" style="width: 80px;height: 80px;top: 60px;" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFoAAABaCAYAAAA4qEECAAACbklEQVR4Xu3cP4oUQRiG8S8xEzESDI1MPIRHEQQPYTK9iCyewMxrGIiCoaFnWFkMTIwUxD894KI8VbNdVdNfzdR87w+eRKa2ul+WVZM1G8+3ud+d+mhBvbZ0DO/uWEAcoVfhcIBehcQRvAvt1dz7gjjaVfxcrhcmxTiwvkudcGAN7YQDa2gnHFhDO+HAGtoJB24ZmmdzhcdBWobh2VzhcZCWYXg2V3gcpGUYns0VHgdpGYZnc4XHQVqG4dlc4XGQlmF4Nld4HKRlGJ7NFR4HaRmGZ3MN48Hcu7lLS19ihI7SPUsfdPSOCh/ulDoKfKhT7KC2P3P5QKfawfBBTr2D4ENEqDs+QJS64uWR6ubc0ssj1Q0vjlYXvLS1X3Mv5x7NPTyi+Jy5uuClNY2Az5zL3RtLLy1pJHz2XO544VLbHw+j4TvkcscLlxoR3yGXO154XaPie+Ry9djSC69rVHyPXK62/xTjhbu6+HtmRHyXXK6iDH1wGroTDd2Jhu5EQ3eioTvR0J1o6E40tAMOt1YCHGitBDjQWglwoLUS4EBrJcCB1kqAA62VwFOnREREROSIPbP7/CNZ28Y+2KT/hPjbjnyVOPl/ZA3tZLLzZGiN7YAD/+smPyqt0nH1Xe2Cw7LndpdHpBZH3ZXs4YndSAbdleyBYy4ljTjkUtKAI5a0sS/8MrKEI5YmFTZ2mQxYmlTgeDVt7DO/nOzC8WqTApPdSoarTQpM9ikZrjYpMNmPZLjapMDZ/JcZh6tNCkx2OxmuNinE4WraDPnbZw5ksp/JgKVJJQ5YmjTgiEvJHib7mgyaS1Yy2dtk3DP7zo9F9wfJyGVFhM8g5gAAAABJRU5ErkJggg=="/>
  </div>
</a>



<a href='java.htm'><div class='book-cover' style='background-color: #f9f6f1;color: #111111;border: 1px solid #ccc;display: flex;justify-content: center;align-items: center;text-align: center;'>More Java Books</div></a>
</div>
</div>
  </div>
  <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/prism.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
  
  <script>
    function copyCode(button) {
      const code = button.nextElementSibling.innerText;
      navigator.clipboard.writeText(code).then(() => {
        button.textContent = 'Copied!';
        setTimeout(() => { button.textContent = 'Copy'; }, 1500);
      });
    }
  </script>  
<div id="floatingLog" aria-live="polite" role="alert"></div>
<footer class="page-footer">
    <nav>
      <a href="https://readbytes.github.io">Home</a> | 
      Email:<script language="JavaScript" type="text/javascript">
var part1 = 'yinpeng';var part6 = '263';var part2 = Math.pow(2,6);var part3 = String.fromCharCode(part2);var part4 = 'hotmail dot com';var part5 = part1 + String.fromCharCode(part2) + part4;document.write(part1 + part6 + part3 + part4);
</script>
    </nav>
  <p>© 2025 — All rights reserved.</p>    
  </footer>

</body>
</html>