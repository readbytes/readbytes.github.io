<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>C Pointers Advanced Pointer Concepts</title>
<link rel='shortcut icon' href='https://java2s.com/style/favicon.ico'>
<link href="https://fonts.googleapis.com/css2?family=Merriweather&display=swap" rel="stylesheet" />
<link href="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet" />


  <script>
  const mode = localStorage.getItem('mode') || 'light';
  document.documentElement.classList.add(`${mode}-mode`);
  </script>   
<style> 
html {
  scroll-behavior: smooth;
}

body {
  font-family: 'Merriweather', serif;
  margin: 0;
  padding: 2rem 1rem;
  font-size: 15px;
  line-height: 1.5;
  transition: background-color 0.3s, color 0.3s;
}

.container {
  max-width: 700px;
  margin: 0 auto;
  padding: 1rem 2rem;
  box-shadow: 0 0 15px rgba(0,0,0,0.1);
}

h1, h2, h3 {
  font-weight: 600;
  margin-top: 2.5rem;
  margin-bottom: 1rem;
  line-height: 1.2;
}

h1 { font-size: 1.8rem; }
h2 { font-size: 1.4rem; }
h3 { font-size: 1.2rem; }

table {
  width: 100%;
  border-collapse: collapse;
  font-family: sans-serif;
  font-size: 1em;
  margin: 1em 0;
}

th, td {
  padding: 0.6em 1em;
  text-align: left;
  border: 1px solid;
}

tr:nth-child(even) {
  background-color: inherit;
}

tr:hover {
  background-color: inherit;
}

a {
  text-decoration: none;
  transition: color 0.2s;
}

a:hover {
  text-decoration: underline;
}

code {
  color: #d35400;
}

.book-title-chapter {
  font-family: 'Merriweather', serif;
  font-size: 2rem;
  font-weight: bold;
  text-align: center;
  margin-bottom: 2rem;
  border-bottom: 2px solid;
  padding-bottom: 0.5rem;
}

.book-subtitle-chapter {
  text-align: center;
  font-size: 1rem;
  margin-top: -1rem;
  margin-bottom: 2rem;
}

.related-books {
  margin-top: 40px;
}

.related-book-list {
  display: flex;
  flex-wrap: wrap;
  gap: 20px;
}

    .book-cover {
      width: 130px;
      height: 180px;
      font-family: Arial, sans-serif;
      position: relative;
      overflow: hidden;      
      line-height: normal;
      box-shadow: 2px 2px 4px rgba(0,0,0,0.1);
    }
    .book-cover-bottom-stripe {
      position: absolute;
      bottom: 0;
      left: 0;
      height: 5px;
      width: 100%;
    }
    .book-cover-title {
      position: absolute;
      width: 100%;
      text-align: center;
      font-weight: bold;
    }
     
    .book-cover-icon {
      position: absolute;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      align-items: center;
      justify-content: center; 
    }

    .book-cover-author {
      position: absolute;
      bottom: 10px;
      width: 100%;
      text-align: center;
      font-size: 8px;
      color: #333;
    }

.page-footer {
  margin-top: 4rem;
  padding: 1rem 0;
  text-align: center;
  font-size: 0.85rem;
  border-top: 1px solid;
}

.chapter-navi-section {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding-bottom: 10px;
}

.nav-link {
  color: inherit;
  text-decoration: none;
  opacity: 0.5;
  transition: opacity 0.3s ease, text-decoration 0.3s ease;
}

.nav-link:hover {
  opacity: 0.9;
  text-decoration: underline;
}

.prev { text-align: left; }
.toc-link { text-align: center; }
.next { text-align: right; }

.download-section {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 2rem;
  padding: 2rem 1rem;
  max-width: 600px;
  margin: 3rem auto;
  border-radius: 12px;
  box-shadow: 0 4px 10px rgba(0,0,0,0.05);
}

.download-info h2 {
  margin: 0 0 0.5rem;
  font-size: 1.2rem;
}

.format-label {
  margin: 0 0 0.5rem;
  font-size: 0.95rem;
}

.download-buttons {
  display: flex;
  gap: 1rem;
}

.download-button {
  background-color: #4A90E2;
  color: white;
  padding: 0.5em 1.2em;
  border-radius: 25px;
  font-size: 0.95rem;
  text-decoration: none;
  transition: background-color 0.3s ease;
}

.download-button:hover {
  background-color: #357ABD;
}

.code-block {
  position: relative;
  margin-bottom: 1em;
}

.copy-button {
  background: transparent;
  color: white;
  position: absolute;
  top: 8px;
  right: 8px;
  border: none;
  padding: 4px 8px;
  font-size: 12px;
  border-radius: 4px;
  cursor: pointer;
  z-index: 1;
}

.copy-button:hover {
  background-color: #0056b3;
}

.snippet-container {
  overflow: hidden;
}

.snippet-header {
  padding: 0.75rem 1rem;
  cursor: pointer;
  font-size: 1rem;
    background-color: #eeeeee;
    color:  #111111; 
    border-radius: 8px;
    cursor: pointer;
    box-shadow: 0 4px 6px rgba(0,0,0,0.1);  
}

.snippet-body {
  display: none;
  font-family: monospace;
}

.snippet-container.open .snippet-body {
  display: block;
}

.CodeMirror {
  border: 2px solid #ccc;
  border-radius: 4px;
  resize: vertical;
}

/* === Light Mode === */
html.light-mode {
  background-color: #f8f7f5;
  color: #333;
}

html.light-mode .container {
  background: white;
}

html.light-mode .book-title-chapter {
  color: #2c3e50;
  border-color: #ccc;
}
html.light-mode .book-subtitle-chapter{
  color: #888;
}

html.light-mode .page-footer,
html.light-mode .series-name,
html.light-mode .book-subtitle,
html.light-mode .format-label {
  color: #888;
}

html.light-mode .related-books h2 {
  color: #333;
  border-bottom: 2px solid #eee;
}

html.light-mode .book-title {
  color: #fff;
}

html.light-mode .book-cover {
  border: 1px solid #ccc;
}

html.light-mode th {
  background-color: #f2f2f2;
}

html.light-mode tr:nth-child(even) {
  background-color: #fafafa;
}

html.light-mode tr:hover {
  background-color: #e6f7ff;
}

html.light-mode a,
html.light-mode .page-footer a {
  color: #000;
}

/* === Dark Mode === */
html.dark-mode {
  background-color: #181818;
  color: #e0e0e0;
}

html.dark-mode .container {
  background: #222;
}

html.dark-mode .book-title-chapter {
  color: #ddd;
  border-color: #444;
}

html.dark-mode .snippet-header {
    background-color: #333;
    color:  #ddd; 
}


html.dark-mode .book-subtitle-chapter,
html.dark-mode .page-footer,
html.dark-mode .series-name,
html.dark-mode .book-subtitle,
html.dark-mode .book-footer,
html.dark-mode .format-label {
  color: #aaa;
}

html.dark-mode .related-books h2 {
  color: #ddd;
  border-bottom: 2px solid #333;
}

html.dark-mode .book-title {
  color: #fff;
}

html.dark-mode .book-cover {
  border: 1px solid #555;
}

html.dark-mode th {
  background-color: #333;
  color: #fff;
}

html.dark-mode td {
  border-color: #444;
}

html.dark-mode tr:nth-child(even) {
  background-color: #2a2a2a;
}

html.dark-mode tr:hover {
  background-color: #2c3e50;
}

html.dark-mode a,
html.dark-mode .page-footer a {
  color: #eee;
}

    .dialog-backdrop {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: rgba(0,0,0,0.5);
      display: none;
      justify-content: center;
      align-items: center;
      z-index: 10;
    }

    .dialog {
      background: white;
      padding: 20px;
      width: 90vw;
      height: 80vh;
      border-radius: 8px;
      box-shadow: 0 0 20px rgba(0,0,0,0.3);
      display: flex;
      flex-direction: column;
    }
    .dialog-content {
      display: flex;
      flex: 1;
      gap: 20px;
      margin-top: 10px;
    }
    .dialog h2 {
      margin-top: 0;
    }

    .textarea_dialog {
      width: 50%;
      height: 100%;
      resize: none;
      font-family: monospace;
      font-size: 14px;
      padding: 10px;
      box-sizing: border-box;
      border: 1px solid #ccc;
    }

    .iframe_dialog {
      width: 50%;
      height: 100%;
      border: 1px solid #ccc;
    }
    .controls_dialog {
      display: flex;
      justify-content: space-between;
      margin-top: 10px;
    }    
    button { padding: 0.5em 1em; background: green; color: white; border: none; cursor: pointer; }
    button:hover { background: #1e7e34; }
    .result_iframe { width:99%; height:200px; margin-top: 1em;  resize: both;border:1px solid #ccc;}        
</style>
</head>
<body> 
  <div class="container">
    <div class = "chapter-navi-section">
<a href="c-pointers-arrays-of-pointers-and-pointer-arrays.htm" class="nav-button prev">‚Üê</a>
<a href='c-pointers.htm#advanced-pointer-concepts' class="nav-button toc-link">Index</a>
<a href="c-pointers-pointers-and-data-structures.htm" class="nav-button next">‚Üí</a>
</div>

    <h1 class="book-title-chapter" id = 'top'>Advanced Pointer Concepts</h1>
    <h3 class="book-subtitle-chapter">C Pointers</h3>   
    <!-- <h1 class ="chapter-title"></h1> -->
    <h2 id='const-pointers-vs-pointer-to-const'>10.1 Const Pointers vs Pointer to Const</h2><p>In C, the keywords <code>const</code> and <code>pointer</code> can combine in two distinct ways, leading to different behaviors and usage patterns:</p><ul>
 <li><strong>Const pointer</strong>: The pointer itself is constant ‚Äî it cannot point to a different address after initialization.</li>
 <li><strong>Pointer to const</strong>: The data pointed to is constant ‚Äî you cannot modify the value through the pointer.</li>
</ul><p>Understanding the difference is crucial for writing safe and clear code that respects immutability where needed.</p><h3 id="syntax-and-meaning">Syntax and Meaning</h3><h4 id="pointer-to-const-pointer-to-constant-data">Pointer to Const (Pointer to constant data)</h4><div class="code-block"><button class="copy-button" onclick="copyCode(this)">‚ñØ</button>
 <pre><code class="language-c">const int *ptr;</code></pre>
</div><ul>
 <li><strong>Meaning:</strong> You can change <code>ptr</code> to point to another <code>int</code>, but you <strong>cannot modify</strong> the <code>int</code> value through <code>ptr</code>.</li>
 <li>The data pointed to is read-only via this pointer.</li>
 <li>Also written as:</li>
</ul><div class="code-block"><button class="copy-button" onclick="copyCode(this)">‚ñØ</button>
 <pre><code class="language-c">int const *ptr;  // Equivalent to const int *ptr</code></pre>
</div><h4 id="const-pointer-constant-pointer">Const Pointer (Constant pointer)</h4><div class="code-block"><button class="copy-button" onclick="copyCode(this)">‚ñØ</button>
 <pre><code class="language-c">int * const ptr;</code></pre>
</div><ul>
 <li><strong>Meaning:</strong> <code>ptr</code> must always point to the same location after initialization ‚Äî the pointer itself is immutable.</li>
 <li>You <strong>can modify</strong> the data pointed to via <code>ptr</code>.</li>
 <li>You must initialize it at declaration because you can‚Äôt change the address later.</li>
</ul><h4 id="const-pointer-to-const-data">Const Pointer to Const Data</h4><div class="code-block"><button class="copy-button" onclick="copyCode(this)">‚ñØ</button>
 <pre><code class="language-c">const int * const ptr;</code></pre>
</div><ul>
 <li>Both the pointer and the data it points to are constant.</li>
 <li>You cannot change <code>ptr</code> to point elsewhere, nor can you modify the data through <code>ptr</code>.</li>
</ul><h4 id="visualizing-differences">Visualizing Differences</h4><table>
 <thead>
  <tr>
   <th>Declaration</th>
   <th>Pointer Mutability</th>
   <th>Data Mutability via Pointer</th>
   <th>Use Case Example</th>
  </tr>
 </thead>
 <tbody>
  <tr>
   <td><code>const int *ptr;</code></td>
   <td>Can change</td>
   <td>Cannot change</td>
   <td>Read-only access to data; e.g., safe input params</td>
  </tr>
  <tr>
   <td><code>int * const ptr;</code></td>
   <td>Cannot change</td>
   <td>Can change</td>
   <td>Fixed pointer to a modifiable variable</td>
  </tr>
  <tr>
   <td><code>const int * const ptr;</code></td>
   <td>Cannot change</td>
   <td>Cannot change</td>
   <td>Fixed pointer to read-only data</td>
  </tr>
 </tbody>
</table><h4 id="examples">Examples</h4><p>Pointer to const (data is const):</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">‚ñØ</button>
 <pre><code class="language-c">void printValue(const int *ptr) {
    // *ptr = 10;  // Error: cannot modify value through pointer to const
    printf("Value: %d\n", *ptr);
}

int main() {
    int x = 5;
    const int *ptr = &amp;x;

    printValue(ptr);

    ptr = &amp;x + 1; // Allowed: pointer can change

    // *ptr = 10;  // Error: data is const through ptr

    return 0;
}</code></pre>
</div><h4 id="const-pointer-pointer-is-const">Const pointer (pointer is const):</h4><div class="code-block"><button class="copy-button" onclick="copyCode(this)">‚ñØ</button>
 <pre><code class="language-c">int main() {
    int x = 5;
    int * const ptr = &amp;x;

    *ptr = 10;  // Allowed: can modify data

    // ptr = &amp;y; // Error: cannot change the pointer itself

    printf("x = %d\n", x);
    return 0;
}</code></pre>
</div><h4 id="const-pointer-to-const-data">Const pointer to const data:</h4><div class="code-block"><button class="copy-button" onclick="copyCode(this)">‚ñØ</button>
 <pre><code class="language-c">int main() {
    int x = 5;
    const int * const ptr = &amp;x;

    // *ptr = 10; // Error: cannot modify data
    // ptr = &amp;y;  // Error: cannot change pointer

    printf("x = %d\n", *ptr);
    return 0;
}</code></pre>
</div><h3 id="summary">Summary</h3><ul>
 <li><strong>Pointer to const (<code>const type *ptr</code>)</strong>: Data is read-only through this pointer; pointer can change.</li>
 <li><strong>Const pointer (<code>type * const ptr</code>)</strong>: Pointer address is fixed; data can be changed.</li>
 <li><strong>Const pointer to const data (<code>const type * const ptr</code>)</strong>: Neither pointer nor data can be changed.</li>
</ul><p>Using these qualifiers correctly helps:</p><ul>
 <li>Enforce <strong>immutability</strong> where needed.</li>
 <li>Prevent <strong>accidental modification</strong> of data or pointer.</li>
 <li>Improve <strong>code safety</strong> and <strong>clarity</strong> by documenting intent.</li>
</ul><p>Always choose the qualifier that best fits your data and pointer usage scenario.</p><div class = "chapter-navi-section">
<a href="#top" class="nav-button prev">‚Üë</a>
<a href='c-pointers.htm#advanced-pointer-concepts' class="nav-button toc-link">Index</a>
<a href="#bottom" class="nav-button next">‚Üì</a>
</div>
<h2 id='restrict-keyword-and-pointer-optimization'>10.2 Restrict Keyword and Pointer Optimization</h2><p>In C99 and later standards, the <code>restrict</code> keyword was introduced to help the compiler optimize code that uses pointers. It is a powerful tool that allows the compiler to generate more efficient machine code by making assumptions about pointer aliasing.</p><h3 id="what-is-restrict">What is <code>restrict</code>?</h3><p>The <code>restrict</code> keyword is a <strong>type qualifier</strong> that can be applied to pointers. It tells the compiler:</p><blockquote>
 <p><em>For the lifetime of this pointer, the object it points to will only be accessed through this pointer (or a value directly derived from it).</em></p>
</blockquote><p>In simpler terms, it means <strong>no other pointer will access the same memory location</strong> during the lifetime of this pointer. This promise enables the compiler to optimize memory accesses aggressively.</p><h3 id="why-does-restrict-matter">Why Does <code>restrict</code> Matter?</h3><p>In C, pointers can often alias ‚Äî that is, two or more pointers might refer to the same memory location. This forces the compiler to be conservative in optimizations, such as:</p><ul>
 <li>Avoiding reordering reads and writes.</li>
 <li>Preventing keeping values in registers assuming they are unchanged.</li>
</ul><p>When you declare a pointer with <code>restrict</code>, you tell the compiler that such aliasing <strong>does not occur</strong> for that pointer, allowing more aggressive optimizations like vectorization or reduced memory loads/stores.</p><h3 id="syntax">Syntax</h3><div class="code-block"><button class="copy-button" onclick="copyCode(this)">‚ñØ</button>
 <pre><code class="language-c">void update_array(int *restrict a, int *restrict b, int n);</code></pre>
</div><p>Here, both pointers <code>a</code> and <code>b</code> are declared with <code>restrict</code>, which means:</p><ul>
 <li>The memory blocks <code>a</code> and <code>b</code> point to do <strong>not overlap</strong>.</li>
 <li>Accesses through <code>a</code> do not affect data accessed through <code>b</code>, and vice versa.</li>
</ul><h3 id="example-without-and-with-restrict">Example: Without and With <code>restrict</code></h3><div class="code-block"><button class="copy-button" onclick="copyCode(this)">üìã</button>
 <pre><code class="language-c">#include &lt;stdio.h&gt;

// Without restrict: compiler assumes a and b may overlap
void add_arrays(int *a, int *b, int *result, int n) {
    for (int i = 0; i &lt; n; i++) {
        result[i] = a[i] + b[i];
    }
}

// With restrict: compiler can optimize assuming no overlap
void add_arrays_optimized(int *restrict a, int *restrict b, int *restrict result, int n) {
    for (int i = 0; i &lt; n; i++) {
        result[i] = a[i] + b[i];
    }
}

int main() {
    int x[] = {1, 2, 3};
    int y[] = {4, 5, 6};
    int z[3];

    add_arrays_optimized(x, y, z, 3);

    for (int i = 0; i &lt; 3; i++) {
        printf("%d ", z[i]);
    }

    return 0;
}</code></pre>
</div><h3 id="when-is-restrict-safe-to-use">When is <code>restrict</code> Safe to Use?</h3><p>You must ensure the promise of non-aliasing holds true. Violating it leads to <strong>undefined behavior</strong>.</p><ul>
 <li><p>Only use <code>restrict</code> when you guarantee that the pointers do not overlap.</p></li>
 <li><p>Avoid using <code>restrict</code> on pointers that might alias, e.g., overlapping arrays or multiple references to the same memory.</p></li>
 <li><p>Common use cases include:</p>
  <ul>
   <li>Separate input and output buffers.</li>
   <li>Non-overlapping slices of arrays.</li>
   <li>Functions working on independent data blocks.</li>
  </ul></li>
</ul><h3 id="benefits">Benefits</h3><ul>
 <li><p>Enables the compiler to produce faster code by:</p>
  <ul>
   <li>Reducing unnecessary memory loads/stores.</li>
   <li>Allowing vectorization and parallelization.</li>
  </ul></li>
 <li><p>Particularly useful in performance-critical code like numerical computations, graphics, or signal processing.</p></li>
</ul><h3 id="summary">Summary</h3><table>
 <thead>
  <tr>
   <th>Aspect</th>
   <th>Description</th>
  </tr>
 </thead>
 <tbody>
  <tr>
   <td>What is <code>restrict</code>?</td>
   <td>A pointer qualifier promising no aliasing access</td>
  </tr>
  <tr>
   <td>Purpose</td>
   <td>Help compiler optimize memory access safely</td>
  </tr>
  <tr>
   <td>Usage</td>
   <td>Declare pointers as <code>restrict</code> when non-overlapping</td>
  </tr>
  <tr>
   <td>Risks</td>
   <td>Undefined behavior if aliasing occurs despite <code>restrict</code></td>
  </tr>
  <tr>
   <td>Benefits</td>
   <td>Faster code, better vectorization, fewer memory ops</td>
  </tr>
 </tbody>
</table><p>Using <code>restrict</code> correctly can significantly improve performance in critical code paths by enabling more aggressive compiler optimizations, but it requires careful guarantees about pointer usage and aliasing.</p><div class = "chapter-navi-section">
<a href="#top" class="nav-button prev">‚Üë</a>
<a href='c-pointers.htm#advanced-pointer-concepts' class="nav-button toc-link">Index</a>
<a href="#bottom" class="nav-button next">‚Üì</a>
</div>
<h2 id='volatile-pointers-and-memory-mapped-i-o'>10.3 Volatile Pointers and Memory Mapped I/O</h2><p>When programming close to hardware‚Äîsuch as in embedded systems, device drivers, or real-time applications‚Äîyou often interact directly with hardware registers or shared memory locations. These memory locations can change independently of the program‚Äôs flow, so the compiler must be instructed <strong>not to optimize away reads or writes</strong> to these addresses.</p><p>This is where the <code>volatile</code> qualifier becomes essential.</p><h3 id="what-does-volatile-mean">What Does <code>volatile</code> Mean?</h3><p>The <code>volatile</code> keyword tells the compiler:</p><blockquote>
 <p><em>The value of this variable (or memory location) <strong>can change at any time without any action being taken by the code the compiler finds nearby</strong>.</em></p>
</blockquote><p>Because of this, the compiler <strong>must not cache the value in registers, nor skip reading or writing to it</strong>, even if it appears redundant or unnecessary from a normal program logic point of view.</p><h3 id="volatile-pointers">Volatile Pointers</h3><p>When working with pointers to hardware registers or memory-mapped I/O, you declare them as <strong>pointers to volatile data</strong> to prevent the compiler from optimizing out essential memory operations:</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">‚ñØ</button>
 <pre><code class="language-c">volatile int *ptr_to_register;</code></pre>
</div><ul>
 <li>Here, <code>ptr_to_register</code> points to an <code>int</code> that is <code>volatile</code>.</li>
 <li>Every time you read <code>*ptr_to_register</code>, the compiler will generate a real memory read.</li>
 <li>Every time you write to <code>*ptr_to_register</code>, the compiler will generate a real memory write.</li>
</ul><h3 id="why-is-this-important">Why Is This Important?</h3><h4 id="hardware-registers">Hardware Registers</h4><p>Memory-mapped registers control hardware behavior (e.g., status registers, control flags). Their values can:</p><ul>
 <li>Change spontaneously due to external events (hardware signals).</li>
 <li>Require precise read/write timing for correct operation.</li>
</ul><p>Without <code>volatile</code>, the compiler might:</p><ul>
 <li>Optimize away multiple reads, assuming the value hasn‚Äôt changed.</li>
 <li>Reorder or remove writes, causing incorrect hardware behavior.</li>
</ul><h4 id="shared-memory-in-concurrency">Shared Memory in Concurrency</h4><p>In multi-threaded or interrupt-driven programs, variables modified outside the normal program flow must be declared volatile to ensure visibility of changes.</p><h4 id="example-accessing-a-hardware-register">Example: Accessing a Hardware Register</h4><div class="code-block"><button class="copy-button" onclick="copyCode(this)">‚ñØ</button>
 <pre><code class="language-c">#define STATUS_REG_ADDR 0x40000000

volatile unsigned int *status_reg = (volatile unsigned int *)STATUS_REG_ADDR;

void wait_for_ready() {
    while ((*status_reg &amp; 0x1) == 0) {
        // Wait until hardware sets ready bit
    }
}</code></pre>
</div><ul>
 <li>The <code>status_reg</code> pointer points to a hardware register.</li>
 <li>The compiler <strong>must</strong> reload the value of <code>*status_reg</code> every time the loop condition is checked.</li>
 <li>Without <code>volatile</code>, the compiler might optimize the loop into an infinite one by assuming the value never changes.</li>
</ul><h3 id="summary">Summary</h3><table>
 <thead>
  <tr>
   <th>Aspect</th>
   <th>Explanation</th>
  </tr>
 </thead>
 <tbody>
  <tr>
   <td><code>volatile</code> qualifier</td>
   <td>Prevents compiler from optimizing reads/writes</td>
  </tr>
  <tr>
   <td>Usage with pointers</td>
   <td><code>volatile</code> applies to data pointed to, ensuring real memory access</td>
  </tr>
  <tr>
   <td>Common use cases</td>
   <td>Hardware registers, shared memory, interrupt flags</td>
  </tr>
  <tr>
   <td>Risk without <code>volatile</code></td>
   <td>Incorrect behavior due to skipped or reordered memory access</td>
  </tr>
 </tbody>
</table><p>In embedded and real-time programming, correctly using <strong>volatile pointers</strong> is critical to ensuring your program interacts correctly and reliably with hardware and concurrent processes.</p><div class = "chapter-navi-section">
<a href="#top" class="nav-button prev">‚Üë</a>
<a href='c-pointers.htm#advanced-pointer-concepts' class="nav-button toc-link">Index</a>
<a href="#bottom" class="nav-button next">‚Üì</a>
</div>
<h2 id='examples-using-const-and-volatile-in-embedded-c'>10.4 Examples: Using Const and Volatile in Embedded C</h2><p>In embedded programming, the use of <code>const</code> and <code>volatile</code> qualifiers is crucial for writing safe, reliable, and efficient low-level code. These qualifiers help the compiler generate the correct instructions and prevent subtle bugs related to memory access.</p><p>Below are practical examples illustrating how to use <strong>const pointers</strong> for read-only memory and <strong>volatile pointers</strong> for hardware registers.</p><h3 id="example-1-using-const-for-read-only-memory">Example 1: Using <code>const</code> for Read-Only Memory</h3><p>Embedded devices often store fixed configuration data or lookup tables in <strong>read-only memory</strong> (such as flash). Declaring pointers to this data as <code>const</code> prevents accidental modification and can enable compiler optimizations.</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">‚ñØ</button>
 <pre><code class="language-c">// A lookup table stored in read-only memory
const uint8_t crc_table[16] = {
    0x00, 0x07, 0x0E, 0x09,
    0x1C, 0x1B, 0x12, 0x15,
    0x38, 0x3F, 0x36, 0x31,
    0x24, 0x23, 0x2A, 0x2D
};

void print_crc_table(void) {
    const uint8_t *ptr = crc_table;  // Pointer to const data

    for (int i = 0; i &lt; 16; i++) {
        printf("Entry %d: 0x%02X\n", i, ptr[i]);
        // *ptr = 0xFF;  // Error: cannot modify const data via pointer
    }
}</code></pre>
</div><ul>
 <li>The <code>const uint8_t *ptr</code> ensures the program does not accidentally write to <code>crc_table</code>.</li>
 <li>This guarantees the integrity of critical read-only data and can allow the compiler to place the data in protected memory regions.</li>
</ul><h3 id="example-2-using-volatile-for-hardware-registers">Example 2: Using <code>volatile</code> for Hardware Registers</h3><p>Accessing hardware registers requires <code>volatile</code> pointers to ensure every read and write actually happens at the memory-mapped address, preventing the compiler from optimizing accesses away.</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">‚ñØ</button>
 <pre><code class="language-c">#define GPIO_PORTA_BASE 0x40004000U
#define GPIO_DATA_OFFSET 0x3FC

// Pointer to a hardware register (GPIO data register)
volatile uint32_t *gpio_porta_data = (volatile uint32_t *)(GPIO_PORTA_BASE + GPIO_DATA_OFFSET);

void set_pin_high(int pin) {
    *gpio_porta_data |= (1U &lt;&lt; pin);  // Set the specified pin high
}

void set_pin_low(int pin) {
    *gpio_porta_data &amp;= ~(1U &lt;&lt; pin);  // Set the specified pin low
}

uint32_t read_gpio(void) {
    return *gpio_porta_data;  // Always read actual register value
}</code></pre>
</div><ul>
 <li><p>Declaring <code>gpio_porta_data</code> as <code>volatile</code> tells the compiler:</p>
  <ul>
   <li><strong>Do not cache</strong> the value in a register.</li>
   <li><strong>Do not optimize away</strong> reads or writes.</li>
  </ul></li>
 <li><p>This ensures that each operation genuinely affects the hardware pins as expected.</p></li>
</ul><h3 id="example-3-combining-const-and-volatile">Example 3: Combining <code>const</code> and <code>volatile</code></h3><p>Sometimes, a hardware register is read-only (e.g., a status register updated by hardware). In such cases, the pointer should be both <code>const</code> (data cannot be modified by software) and <code>volatile</code> (data can change anytime):</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">‚ñØ</button>
 <pre><code class="language-c">#define STATUS_REG_ADDR 0x40005000U

volatile const uint32_t * const status_reg = (volatile const uint32_t *)STATUS_REG_ADDR;

uint32_t read_status(void) {
    return *status_reg;  // Read fresh status every time
}

// Attempting to write through this pointer will cause a compile error:
// *status_reg = 0xFF;  // Error: data is const</code></pre>
</div><ul>
 <li><code>volatile const</code> means the data may change unexpectedly but <strong>cannot be modified by the program</strong>.</li>
 <li>The pointer itself is <code>const</code> so it always points to the same register address.</li>
</ul><h3 id="summary">Summary</h3><table>
 <thead>
  <tr>
   <th>Qualifier Combination</th>
   <th>Use Case</th>
   <th>Effect</th>
  </tr>
 </thead>
 <tbody>
  <tr>
   <td><code>const</code></td>
   <td>Read-only memory (flash, config)</td>
   <td>Prevents modifying read-only data</td>
  </tr>
  <tr>
   <td><code>volatile</code></td>
   <td>Hardware registers</td>
   <td>Ensures all reads/writes occur in memory</td>
  </tr>
  <tr>
   <td><code>volatile const</code></td>
   <td>Read-only hardware status registers</td>
   <td>Prevents writes, guarantees fresh reads</td>
  </tr>
  <tr>
   <td><code>const * const</code></td>
   <td>Fixed pointer to constant data</td>
   <td>Pointer and data both immutable</td>
  </tr>
 </tbody>
</table><p>By using <code>const</code> and <code>volatile</code> appropriately, embedded programmers can write code that is safer, easier to maintain, and behaves correctly when interacting with hardware.</p><p>These qualifiers form the backbone of reliable embedded software, guiding the compiler‚Äôs optimizations while preventing errors that could lead to subtle and hard-to-debug hardware issues.</p><div class = "chapter-navi-section">
<a href="c-pointers-arrays-of-pointers-and-pointer-arrays.htm" class="nav-button prev">‚Üê</a>
<a href='c-pointers.htm#advanced-pointer-concepts' class="nav-button toc-link">Index</a>
<a href="c-pointers-pointers-and-data-structures.htm" class="nav-button next">‚Üí</a>
</div>
<section class="download-section">
  <div class="book-cover" style="background-color: #f9f6f1;border: 1px solid #ccc;"> 
    <div class="book-cover-title" style="font-size: 22px;color: #333;top: 20px;">C Pointers</div>
    <div class="book-cover-author">readbytes</div>
    <div class="book-cover-bottom-stripe" style="background-color: #333;"></div>
    <img class="book-cover-icon" style="width: 90px;height: 90px;top: 70px;" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFoAAABaCAYAAAA4qEECAAAD5ElEQVR4Xu2dwYoUVxhGr7hQn0F8AyH4Cq5cCwFxk2cQ3GXR1TK+QN5AssnWrRsfwWR0LbhJxKXoIhBQK2Olb5/v1tdV0/fHOPwHDtj/PbdudYHOuKpSkiRJkovFUP744qevvuSyZSin1d5TLlvGs85/7re553OzO3DfJXDPRd97bobylxy49HC2tZvylvkem/Je9uz8wHyPTfmzsWeng23toXs+Ch5GHWypgy11sKUOtjQMHkQdbKmDLXWwpQ62NAweRB1sqYMtdbClDrY0DB5EHWypgy11sKUOtjQMHkQdbKmDLXWwpQ62NAweRB1sqYMtdbClDrY0DB5EHWypgy11sKUOtjQMHkQdbKmDLXWwpQ62NAweRB1sqYMtdbClDrY0SZIkSZI18CdpGqMM0hhlkMYogzRGGaQxyiCNUQZpjDJIY5RBGqMM0hhlkMYogzRGGaQxyiCNUQZpjDJIY5RBT5fAPfO+W7xvabe2PUYZ9HQpQ7kjeynh+lzLNbqmPUYZ9NR/iYcH1uevdagnXJ/8pVxZ1PVQBj1d8iUmfi7XZW3ns+pKO7TTc3t0PZRBT5d8ibVNDTvXsxnKr0waTT9l0NMlX2Ji/GvMNTZDeYrP/0hbr9ecp+mpDHp66EscWh/dlgfS1LCv14fypPrz3ar5u5rXvV6rlzLo6Rq4t3WNafZjuSyz1p6zB31J2pr9Xq/VSxn0dAlDuSr7WtfYltfN+fj79dye8UHvf/4dn9nr+b2UQU9rlszpo/LDbFczt8YHTbTXe+ilDHpaU8+35adq/lj2tfY75vZND7p1raF8lDVep6cy6GnNmrVW4xjK8+Y+/6Bbvd5DL2XQ0xqujb8FTGzKfVl/UK5Ve180rWmdWz/oobz5b74p92Z63mM/ZdDTGq4dWndrkyflRrPZzeoHPf6bf+tfeZ3WNXorg57WcO3M29X6zebeuf+UaHfSmO0/6Dl3va71UgY9reGaa1qzOVvtxKb8Jn1L7o9QBmmMMkhjlEEaowzSGGWQxiiDNEYZpDHKII1RBmmMMkhjlEEaowzSGGWQxiiDNEYZpDHKII0xSZIkSZI18CcpdbClDrbUwZY62NIweBB1sKUOttTBljrY0jB4EHWwpQ621MGWOtjSMHgQdbClDrbUwZY62NIweBB1sKUOttTBljrY0jB4EHWwpQ621MGWOtjSMHgQdbClDrbUwZY62NIweBB1sKUOttTBljrY0jB4EHWwpQ621MGWOtjSMKJeSjZe13HMS8m23+NLyUZ44JIbnuCei773aPZfpLjuJYzbI17CeNyLI+tzX3HZsn/uuntOkiRJ/vd8BnnbnC2TD9qmAAAAAElFTkSuQmCC"/>
  </div>
  <div class="download-info">
    <h2 id='bottom'>Download This Ebook</h2>
    <p class="format-label">Available formats:</p>
    <div class="download-buttons">
      <a href="c-pointers.pdf" class="download-button">üìÑ PDF</a>
      <a href="c-pointers.epub" class="download-button">üìò EPUB</a>
    </div>
  </div>
</section><div class='related-books'>
<h2>C Introduction Books</h2>
<div class='related-book-list'>
<a href="c-for-beginners.htm">
<div class="book-cover" style="background-color: #f9f6f1;border: 1px solid #ccc;"> 
    <div class="book-cover-title" style="font-size: 18px;color: #333;top: 20px;">C for Beginners</div>
    <div class="book-cover-author">readbytes</div>
    <div class="book-cover-bottom-stripe" style="background-color: #333;"></div>
    <img class="book-cover-icon" style="width: 90px;height: 90px;top: 70px;" src="data:image/png;base64,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"/>
  </div>
</a>


<a href="c-pointers.htm">
<div class="book-cover" style="background-color: #f9f6f1;border: 1px solid #ccc;"> 
    <div class="book-cover-title" style="font-size: 22px;color: #333;top: 20px;">C Pointers</div>
    <div class="book-cover-author">readbytes</div>
    <div class="book-cover-bottom-stripe" style="background-color: #333;"></div>
    <img class="book-cover-icon" style="width: 90px;height: 90px;top: 70px;" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFoAAABaCAYAAAA4qEECAAAD5ElEQVR4Xu2dwYoUVxhGr7hQn0F8AyH4Cq5cCwFxk2cQ3GXR1TK+QN5AssnWrRsfwWR0LbhJxKXoIhBQK2Olb5/v1tdV0/fHOPwHDtj/PbdudYHOuKpSkiRJkovFUP744qevvuSyZSin1d5TLlvGs85/7re553OzO3DfJXDPRd97bobylxy49HC2tZvylvkem/Je9uz8wHyPTfmzsWeng23toXs+Ch5GHWypgy11sKUOtjQMHkQdbKmDLXWwpQ62NAweRB1sqYMtdbClDrY0DB5EHWypgy11sKUOtjQMHkQdbKmDLXWwpQ62NAweRB1sqYMtdbClDrY0DB5EHWypgy11sKUOtjQMHkQdbKmDLXWwpQ62NAweRB1sqYMtdbClDrY0SZIkSZI18CdpGqMM0hhlkMYogzRGGaQxyiCNUQZpjDJIY5RBGqMM0hhlkMYogzRGGaQxyiCNUQZpjDJIY5RBT5fAPfO+W7xvabe2PUYZ9HQpQ7kjeynh+lzLNbqmPUYZ9NR/iYcH1uevdagnXJ/8pVxZ1PVQBj1d8iUmfi7XZW3ns+pKO7TTc3t0PZRBT5d8ibVNDTvXsxnKr0waTT9l0NMlX2Ji/GvMNTZDeYrP/0hbr9ecp+mpDHp66EscWh/dlgfS1LCv14fypPrz3ar5u5rXvV6rlzLo6Rq4t3WNafZjuSyz1p6zB31J2pr9Xq/VSxn0dAlDuSr7WtfYltfN+fj79dye8UHvf/4dn9nr+b2UQU9rlszpo/LDbFczt8YHTbTXe+ilDHpaU8+35adq/lj2tfY75vZND7p1raF8lDVep6cy6GnNmrVW4xjK8+Y+/6Bbvd5DL2XQ0xqujb8FTGzKfVl/UK5Ve180rWmdWz/oobz5b74p92Z63mM/ZdDTGq4dWndrkyflRrPZzeoHPf6bf+tfeZ3WNXorg57WcO3M29X6zebeuf+UaHfSmO0/6Dl3va71UgY9reGaa1qzOVvtxKb8Jn1L7o9QBmmMMkhjlEEaowzSGGWQxiiDNEYZpDHKII1RBmmMMkhjlEEaowzSGGWQxiiDNEYZpDHKII0xSZIkSZI18CcpdbClDrbUwZY62NIweBB1sKUOttTBljrY0jB4EHWwpQ621MGWOtjSMHgQdbClDrbUwZY62NIweBB1sKUOttTBljrY0jB4EHWwpQ621MGWOtjSMHgQdbClDrbUwZY62NIweBB1sKUOttTBljrY0jB4EHWwpQ621MGWOtjSMKJeSjZe13HMS8m23+NLyUZ44JIbnuCei773aPZfpLjuJYzbI17CeNyLI+tzX3HZsn/uuntOkiRJ/vd8BnnbnC2TD9qmAAAAAElFTkSuQmCC"/>
  </div>
</a>



<a href='c.htm'><div class='book-cover' style='background-color: #f9f6f1;color: #111111;border: 1px solid #ccc;display: flex;justify-content: center;align-items: center;text-align: center;'>More C Books</div></a>
</div>
</div>
  </div>
  <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/prism.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
  
  <script>
    function copyCode(button) {
      const code = button.nextElementSibling.innerText;
      navigator.clipboard.writeText(code).then(() => {
        button.textContent = 'Copied!';
        setTimeout(() => { button.textContent = 'Copy'; }, 1500);
      });
    }
  </script>  
<div id="floatingLog" aria-live="polite" role="alert"></div>
<footer class="page-footer">
    <nav>
      <a href="https://readbytes.github.io">Home</a> | 
      Email:<script language="JavaScript" type="text/javascript">
var part1 = 'yinpeng';var part6 = '263';var part2 = Math.pow(2,6);var part3 = String.fromCharCode(part2);var part4 = 'hotmail dot com';var part5 = part1 + String.fromCharCode(part2) + part4;document.write(part1 + part6 + part3 + part4);
</script>
    </nav>
  <p>¬© 2025 ‚Äî All rights reserved.</p>    
  </footer>

</body>
</html>