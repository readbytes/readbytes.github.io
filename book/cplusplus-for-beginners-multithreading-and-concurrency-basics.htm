<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>C++ for Beginners Multithreading and Concurrency Basics</title>
<link rel='shortcut icon' href='https://java2s.com/style/favicon.ico'>
<link href="https://fonts.googleapis.com/css2?family=Merriweather&display=swap" rel="stylesheet" />
<link href="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet" />


  <script>
  const mode = localStorage.getItem('mode') || 'light';
  document.documentElement.classList.add(`${mode}-mode`);
  </script>   
<style> 
html {
  scroll-behavior: smooth;
}

body {
  font-family: 'Merriweather', serif;
  margin: 0;
  padding: 2rem 1rem;
  font-size: 15px;
  line-height: 1.5;
  transition: background-color 0.3s, color 0.3s;
}

.container {
  max-width: 700px;
  margin: 0 auto;
  padding: 1rem 2rem;
  box-shadow: 0 0 15px rgba(0,0,0,0.1);
}

h1, h2, h3 {
  font-weight: 600;
  margin-top: 2.5rem;
  margin-bottom: 1rem;
  line-height: 1.2;
}

h1 { font-size: 1.8rem; }
h2 { font-size: 1.4rem; }
h3 { font-size: 1.2rem; }

table {
  width: 100%;
  border-collapse: collapse;
  font-family: sans-serif;
  font-size: 1em;
  margin: 1em 0;
}

th, td {
  padding: 0.6em 1em;
  text-align: left;
  border: 1px solid;
}

tr:nth-child(even) {
  background-color: inherit;
}

tr:hover {
  background-color: inherit;
}

a {
  text-decoration: none;
  transition: color 0.2s;
}

a:hover {
  text-decoration: underline;
}

code {
  color: #d35400;
}

.book-title-chapter {
  font-family: 'Merriweather', serif;
  font-size: 2rem;
  font-weight: bold;
  text-align: center;
  margin-bottom: 2rem;
  border-bottom: 2px solid;
  padding-bottom: 0.5rem;
}

.book-subtitle-chapter {
  text-align: center;
  font-size: 1rem;
  margin-top: -1rem;
  margin-bottom: 2rem;
}

.related-books {
  margin-top: 40px;
}

.related-book-list {
  display: flex;
  flex-wrap: wrap;
  gap: 20px;
}

    .book-cover {
      width: 130px;
      height: 180px;
      font-family: Arial, sans-serif;
      position: relative;
      overflow: hidden;      
      line-height: normal;
      box-shadow: 2px 2px 4px rgba(0,0,0,0.1);
    }
    .book-cover-bottom-stripe {
      position: absolute;
      bottom: 0;
      left: 0;
      height: 5px;
      width: 100%;
    }
    .book-cover-title {
      position: absolute;
      width: 100%;
      text-align: center;
      font-weight: bold;
    }
     
    .book-cover-icon {
      position: absolute;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      align-items: center;
      justify-content: center; 
    }

    .book-cover-author {
      position: absolute;
      bottom: 10px;
      width: 100%;
      text-align: center;
      font-size: 8px;
      color: #333;
    }

.page-footer {
  margin-top: 4rem;
  padding: 1rem 0;
  text-align: center;
  font-size: 0.85rem;
  border-top: 1px solid;
}

.chapter-navi-section {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding-bottom: 10px;
}

.nav-link {
  color: inherit;
  text-decoration: none;
  opacity: 0.5;
  transition: opacity 0.3s ease, text-decoration 0.3s ease;
}

.nav-link:hover {
  opacity: 0.9;
  text-decoration: underline;
}

.prev { text-align: left; }
.toc-link { text-align: center; }
.next { text-align: right; }

.download-section {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 2rem;
  padding: 2rem 1rem;
  max-width: 600px;
  margin: 3rem auto;
  border-radius: 12px;
  box-shadow: 0 4px 10px rgba(0,0,0,0.05);
}

.download-info h2 {
  margin: 0 0 0.5rem;
  font-size: 1.2rem;
}

.format-label {
  margin: 0 0 0.5rem;
  font-size: 0.95rem;
}

.download-buttons {
  display: flex;
  gap: 1rem;
}

.download-button {
  background-color: #4A90E2;
  color: white;
  padding: 0.5em 1.2em;
  border-radius: 25px;
  font-size: 0.95rem;
  text-decoration: none;
  transition: background-color 0.3s ease;
}

.download-button:hover {
  background-color: #357ABD;
}

.code-block {
  position: relative;
  margin-bottom: 1em;
}

.copy-button {
  background: transparent;
  color: white;
  position: absolute;
  top: 8px;
  right: 8px;
  border: none;
  padding: 4px 8px;
  font-size: 12px;
  border-radius: 4px;
  cursor: pointer;
  z-index: 1;
}

.copy-button:hover {
  background-color: #0056b3;
}

.snippet-container {
  overflow: hidden;
}

.snippet-header {
  padding: 0.75rem 1rem;
  cursor: pointer;
  font-size: 1rem;
    background-color: #eeeeee;
    color:  #111111; 
    border-radius: 8px;
    cursor: pointer;
    box-shadow: 0 4px 6px rgba(0,0,0,0.1);  
}

.snippet-body {
  display: none;
  font-family: monospace;
}

.snippet-container.open .snippet-body {
  display: block;
}

.CodeMirror {
  border: 2px solid #ccc;
  border-radius: 4px;
  resize: vertical;
}

/* === Light Mode === */
html.light-mode {
  background-color: #f8f7f5;
  color: #333;
}

html.light-mode .container {
  background: white;
}

html.light-mode .book-title-chapter {
  color: #2c3e50;
  border-color: #ccc;
}
html.light-mode .book-subtitle-chapter{
  color: #888;
}

html.light-mode .page-footer,
html.light-mode .series-name,
html.light-mode .book-subtitle,
html.light-mode .format-label {
  color: #888;
}

html.light-mode .related-books h2 {
  color: #333;
  border-bottom: 2px solid #eee;
}

html.light-mode .book-title {
  color: #fff;
}

html.light-mode .book-cover {
  border: 1px solid #ccc;
}

html.light-mode th {
  background-color: #f2f2f2;
}

html.light-mode tr:nth-child(even) {
  background-color: #fafafa;
}

html.light-mode tr:hover {
  background-color: #e6f7ff;
}

html.light-mode a,
html.light-mode .page-footer a {
  color: #000;
}

/* === Dark Mode === */
html.dark-mode {
  background-color: #181818;
  color: #e0e0e0;
}

html.dark-mode .container {
  background: #222;
}

html.dark-mode .book-title-chapter {
  color: #ddd;
  border-color: #444;
}

html.dark-mode .snippet-header {
    background-color: #333;
    color:  #ddd; 
}


html.dark-mode .book-subtitle-chapter,
html.dark-mode .page-footer,
html.dark-mode .series-name,
html.dark-mode .book-subtitle,
html.dark-mode .book-footer,
html.dark-mode .format-label {
  color: #aaa;
}

html.dark-mode .related-books h2 {
  color: #ddd;
  border-bottom: 2px solid #333;
}

html.dark-mode .book-title {
  color: #fff;
}

html.dark-mode .book-cover {
  border: 1px solid #555;
}

html.dark-mode th {
  background-color: #333;
  color: #fff;
}

html.dark-mode td {
  border-color: #444;
}

html.dark-mode tr:nth-child(even) {
  background-color: #2a2a2a;
}

html.dark-mode tr:hover {
  background-color: #2c3e50;
}

html.dark-mode a,
html.dark-mode .page-footer a {
  color: #eee;
}

    .dialog-backdrop {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: rgba(0,0,0,0.5);
      display: none;
      justify-content: center;
      align-items: center;
      z-index: 10;
    }

    .dialog {
      background: white;
      padding: 20px;
      width: 90vw;
      height: 80vh;
      border-radius: 8px;
      box-shadow: 0 0 20px rgba(0,0,0,0.3);
      display: flex;
      flex-direction: column;
    }
    .dialog-content {
      display: flex;
      flex: 1;
      gap: 20px;
      margin-top: 10px;
    }
    .dialog h2 {
      margin-top: 0;
    }

    .textarea_dialog {
      width: 50%;
      height: 100%;
      resize: none;
      font-family: monospace;
      font-size: 14px;
      padding: 10px;
      box-sizing: border-box;
      border: 1px solid #ccc;
    }

    .iframe_dialog {
      width: 50%;
      height: 100%;
      border: 1px solid #ccc;
    }
    .controls_dialog {
      display: flex;
      justify-content: space-between;
      margin-top: 10px;
    }    
    button { padding: 0.5em 1em; background: green; color: white; border: none; cursor: pointer; }
    button:hover { background: #1e7e34; }
    .result_iframe { width:99%; height:200px; margin-top: 1em;  resize: both;border:1px solid #ccc;}        
</style>
</head>
<body> 
  <div class="container">
    <div class = "chapter-navi-section">
<a href="cplusplus-for-beginners-advanced-memory-management.htm" class="nav-button prev">←</a>
<a href='cplusplus-for-beginners.htm#multithreading-and-concurrency-basics' class="nav-button toc-link">Index</a>
<a href="cplusplus-for-beginners-lambda-functions-and-functional-programming-features.htm" class="nav-button next">→</a>
</div>

    <h1 class="book-title-chapter" id = 'top'>Multithreading and Concurrency Basics</h1>
    <h3 class="book-subtitle-chapter">C++ for Beginners</h3>   
    <!-- <h1 class ="chapter-title"></h1> -->
    <h2 id='introduction-to-threads-in-cplusplus'>17.1 Introduction to Threads in C++</h2><p>In modern software development, programs that perform multiple tasks simultaneously are becoming increasingly common. This capability is known as <strong>concurrency</strong>, and one of its fundamental building blocks is the <strong>thread</strong>. In this section, we will introduce the concept of threads, explain how C++ supports multithreading through the C++11 <code>&lt;thread&gt;</code> library, discuss the advantages and challenges of multithreading, and provide simple examples to get you started.</p><h3 id="what-are-threads-and-why-use-them">What Are Threads and Why Use Them?</h3><p>A <strong>thread</strong> is the smallest unit of execution within a program. Traditionally, a program runs as a single thread, executing one instruction after another sequentially. However, by using multiple threads, a program can perform multiple operations at the same time.</p><p>For example, consider a program that needs to:</p><ul>
 <li>Download files from the internet,</li>
 <li>Process user input,</li>
 <li>Write data to disk.</li>
</ul><p>If these operations are performed one after another, the program may be slow or unresponsive. Using multiple threads allows these tasks to run concurrently, improving performance and responsiveness.</p><h3 id="concurrency-vs-parallelism">Concurrency vs. Parallelism</h3><ul>
 <li><strong>Concurrency</strong> means multiple tasks making progress at the same time. This might happen by quickly switching between tasks on a single CPU core (time slicing).</li>
 <li><strong>Parallelism</strong> means multiple tasks actually executing simultaneously, often on multiple CPU cores.</li>
</ul><p>Multithreading enables both concurrency and parallelism depending on the system capabilities.</p><h3 id="introducing-the-c11-thread-library">Introducing the C11 <code>thread</code> Library</h3><p>Before C++11, thread support was platform-specific and inconsistent. The C++11 standard introduced the <code>&lt;thread&gt;</code> library, providing a portable and standardized way to create and manage threads.</p><h3 id="creating-a-thread">Creating a Thread</h3><p>You can create a new thread by constructing an object of the <code>std::thread</code> class and passing it a function or callable to run:</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">📋</button>
 <pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;thread&gt;

void hello() {
    std::cout &lt;&lt; "Hello from thread!\n";
}

int main() {
    std::thread t(hello);  // Start thread executing hello()
    t.join();              // Wait for thread t to finish
    return 0;
}</code></pre>
</div><p>In this example:</p><ul>
 <li>A thread <code>t</code> is launched to execute the function <code>hello()</code>.</li>
 <li><code>t.join()</code> blocks the main thread until <code>t</code> finishes.</li>
</ul><h3 id="thread-lifecycle-basics">Thread Lifecycle Basics</h3><p>A thread typically goes through these stages:</p><ol>
 <li><strong>Created</strong>: The <code>std::thread</code> object is constructed, starting the thread.</li>
 <li><strong>Running</strong>: The thread executes the provided function.</li>
 <li><strong>Joined or Detached</strong>: The thread is either joined or detached to manage its lifetime.</li>
 <li><strong>Finished</strong>: The thread completes execution.</li>
</ol><h3 id="joining-threads">Joining Threads</h3><ul>
 <li>The <strong><code>join()</code></strong> function blocks the calling thread until the target thread completes.</li>
 <li>You must call <code>join()</code> or <code>detach()</code> on every <code>std::thread</code> object before it is destroyed; otherwise, the program will terminate.</li>
</ul><h3 id="detaching-threads">Detaching Threads</h3><ul>
 <li>The <strong><code>detach()</code></strong> function lets the thread run independently (in the background).</li>
 <li>Detached threads continue executing after the main thread ends, but you lose control over them.</li>
</ul><p>Example of detaching a thread:</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-cpp">std::thread t([] {
    std::cout &lt;&lt; "Detached thread running\n";
});
t.detach();</code></pre>
</div><h3 id="advantages-of-multithreading">Advantages of Multithreading</h3><ul>
 <li><strong>Improved Performance:</strong> Utilize multiple CPU cores to run tasks simultaneously.</li>
 <li><strong>Better Responsiveness:</strong> User interfaces remain active while background tasks run.</li>
 <li><strong>Resource Sharing:</strong> Threads within the same process share memory, enabling efficient communication.</li>
 <li><strong>Scalability:</strong> Programs can handle more workload by adding threads.</li>
</ul><h3 id="challenges-and-pitfalls-of-multithreading">Challenges and Pitfalls of Multithreading</h3><p>While multithreading offers many benefits, it also introduces challenges:</p><h3 id="race-conditions">Race Conditions</h3><p>Occurs when two or more threads access shared data simultaneously and at least one thread modifies it, leading to inconsistent or incorrect results.</p><p>Example:</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-cpp">int counter = 0;

void increment() {
    for (int i = 0; i &lt; 1000; ++i) {
        ++counter;  // Not thread-safe
    }
}</code></pre>
</div><p>If multiple threads run <code>increment()</code> concurrently without synchronization, the final value of <code>counter</code> may be incorrect.</p><h3 id="deadlocks">Deadlocks</h3><p>Happens when two or more threads wait indefinitely for each other to release resources.</p><p>Example scenario:</p><ul>
 <li>Thread A holds lock 1 and waits for lock 2.</li>
 <li>Thread B holds lock 2 and waits for lock 1.</li>
</ul><p>Both wait forever, causing a deadlock.</p><h3 id="simple-example-launching-multiple-threads">Simple Example: Launching Multiple Threads</h3><p>Let’s create a program that launches multiple threads to print messages:</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">📋</button>
 <pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;thread&gt;
#include &lt;vector&gt;

void printMessage(int id) {
    std::cout &lt;&lt; "Thread " &lt;&lt; id &lt;&lt; " is running.\n";
}

int main() {
    const int numThreads = 5;
    std::vector&lt;std::thread&gt; threads;

    // Launch threads
    for (int i = 0; i &lt; numThreads; ++i) {
        threads.emplace_back(printMessage, i);
    }

    // Join threads
    for (auto&amp; t : threads) {
        t.join();
    }

    std::cout &lt;&lt; "All threads finished.\n";
    return 0;
}</code></pre>
</div><p>Output (order may vary):</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-bash">Thread 0 is running.
Thread 1 is running.
Thread 2 is running.
Thread 3 is running.
Thread 4 is running.
All threads finished.</code></pre>
</div><h3 id="summary">Summary</h3><ul>
 <li>A <strong>thread</strong> is a single flow of execution within a program.</li>
 <li>C++11 introduced the standardized <code>&lt;thread&gt;</code> library for multithreading.</li>
 <li>Threads allow concurrent and parallel execution, improving performance and responsiveness.</li>
 <li>You create a thread by constructing <code>std::thread</code> with a callable.</li>
 <li>Threads must be either <strong>joined</strong> or <strong>detached</strong> to manage their lifecycle.</li>
 <li>Multithreading introduces challenges like <strong>race conditions</strong> and <strong>deadlocks</strong> that require careful synchronization.</li>
 <li>Starting with simple thread creation and management prepares you for more complex concurrency programming.</li>
</ul><div class = "chapter-navi-section">
<a href="#top" class="nav-button prev">↑</a>
<a href='cplusplus-for-beginners.htm#multithreading-and-concurrency-basics' class="nav-button toc-link">Index</a>
<a href="#bottom" class="nav-button next">↓</a>
</div>
<h2 id='thread-management-and-synchronization'>17.2 Thread Management and Synchronization</h2><p>In the previous section, we introduced the concept of threads in C++ and how to create and launch them using the C++11 <code>&lt;thread&gt;</code> library. As you work with multithreading, managing threads properly and ensuring safe access to shared resources become critical. This section explores thread management operations like joining and detaching threads, explains the importance of synchronization, introduces synchronization primitives such as mutexes and condition variables, and demonstrates examples to illustrate thread-safe programming and coordination between threads.</p><h3 id="thread-management-joining-and-detaching">Thread Management: Joining and Detaching</h3><p>Once a thread is started using <code>std::thread</code>, managing its lifetime correctly is essential to avoid program errors and undefined behavior.</p><h3 id="joining-threads">Joining Threads</h3><p>Calling the <code>join()</code> method on a thread makes the calling thread (usually the main thread) wait until the target thread completes execution. This ensures that resources associated with the thread are cleaned up properly and the program does not exit prematurely.</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-cpp">std::thread t([] {
    std::cout &lt;&lt; "Thread running\n";
});
t.join();  // Wait for t to finish</code></pre>
</div><p>If you forget to join a joinable thread before it goes out of scope, the program will terminate with a runtime error.</p><h3 id="detaching-threads">Detaching Threads</h3><p>The <code>detach()</code> method lets a thread run independently in the background. Once detached, you cannot join the thread anymore or directly check if it has finished.</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-cpp">std::thread t([] {
    std::cout &lt;&lt; "Detached thread running\n";
});
t.detach();</code></pre>
</div><p>Detaching is useful for fire-and-forget tasks, but it requires caution because the thread may continue running even after the main program finishes, which can lead to resource leaks or crashes if not handled properly.</p><h3 id="why-synchronization-is-essential">Why Synchronization Is Essential</h3><p>When multiple threads access <strong>shared resources</strong> such as variables, files, or hardware devices, <strong>race conditions</strong> can occur if their access is not controlled. A race condition happens when the outcome depends on the unpredictable timing of thread execution, leading to inconsistent or incorrect results.</p><p>For example, consider two threads incrementing the same integer:</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-cpp">int counter = 0;

void increment() {
    for (int i = 0; i &lt; 10000; ++i) {
        ++counter;  // Not thread-safe
    }
}</code></pre>
</div><p>If two threads call <code>increment()</code> concurrently without synchronization, some increments may be lost because <code>++counter</code> involves multiple CPU instructions (read-modify-write) that can be interrupted by another thread.</p><p><strong>Synchronization</strong> mechanisms prevent such data races by controlling how threads access shared data, ensuring only one thread modifies or reads data at a time or coordinating their actions.</p><h3 id="mutexes-mutual-exclusion-locks">Mutexes: Mutual Exclusion Locks</h3><p>A <strong>mutex</strong> (short for mutual exclusion) is a synchronization primitive that ensures only one thread can own the mutex and access the protected resource at a time.</p><p>C++ provides <code>std::mutex</code> in the <code>&lt;mutex&gt;</code> header:</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;thread&gt;
#include &lt;mutex&gt;

int counter = 0;
std::mutex mtx;  // Mutex to protect counter

void safe_increment() {
    for (int i = 0; i &lt; 10000; ++i) {
        std::lock_guard&lt;std::mutex&gt; lock(mtx);  // Lock mutex
        ++counter;                              // Critical section
    }
}</code></pre>
</div><p>Here:</p><ul>
 <li><code>std::lock_guard</code> automatically locks the mutex when constructed and releases it when destructed (e.g., at the end of the scope). This ensures exception-safe locking.</li>
 <li>Only one thread can execute the critical section modifying <code>counter</code> at a time.</li>
</ul><h3 id="using-the-mutex-directly">Using the mutex directly:</h3><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-cpp">mtx.lock();
counter++;
mtx.unlock();</code></pre>
</div><p>However, using <code>lock()</code> and <code>unlock()</code> manually is error-prone; you risk deadlocks or unlocking errors, so prefer <code>std::lock_guard</code> or <code>std::unique_lock</code>.</p><h3 id="condition-variables-thread-coordination">Condition Variables: Thread Coordination</h3><p>While mutexes protect shared data, sometimes threads need to <strong>wait</strong> for certain conditions or events before continuing. <strong>Condition variables</strong> provide a way to block a thread until notified by another thread.</p><p>C++ provides <code>std::condition_variable</code> for this purpose:</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">📋</button>
 <pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;thread&gt;
#include &lt;mutex&gt;
#include &lt;condition_variable&gt;

std::mutex mtx;
std::condition_variable cv;
bool ready = false;

void worker() {
    std::unique_lock&lt;std::mutex&gt; lock(mtx);
    cv.wait(lock, []{ return ready; });  // Wait until ready == true
    std::cout &lt;&lt; "Worker thread proceeding after signal\n";
}

int main() {
    std::thread t(worker);

    {
        std::lock_guard&lt;std::mutex&gt; lock(mtx);
        ready = true;   // Set condition
    }
    cv.notify_one();    // Notify worker thread

    t.join();
    return 0;
}</code></pre>
</div><p>How it works:</p><ul>
 <li>The worker thread locks the mutex and waits on the condition variable <code>cv</code>.</li>
 <li>The <code>wait()</code> function releases the mutex and blocks the thread until notified and the condition predicate (<code>ready == true</code>) becomes true.</li>
 <li>The main thread sets <code>ready</code> to true under mutex protection and calls <code>notify_one()</code> to wake the waiting thread.</li>
</ul><h3 id="example-thread-safe-counter-using-mutex">Example: Thread-Safe Counter Using Mutex</h3><p>Here’s a complete example demonstrating multiple threads incrementing a shared counter safely:</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">📋</button>
 <pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;thread&gt;
#include &lt;mutex&gt;
#include &lt;vector&gt;

int counter = 0;
std::mutex mtx;

void increment(int id) {
    for (int i = 0; i &lt; 1000; ++i) {
        std::lock_guard&lt;std::mutex&gt; lock(mtx);
        ++counter;
        // Optionally print:
        // std::cout &lt;&lt; "Thread " &lt;&lt; id &lt;&lt; " incremented counter to " &lt;&lt; counter &lt;&lt; "\n";
    }
}

int main() {
    const int numThreads = 10;
    std::vector&lt;std::thread&gt; threads;

    for (int i = 0; i &lt; numThreads; ++i) {
        threads.emplace_back(increment, i);
    }

    for (auto&amp; t : threads) {
        t.join();
    }

    std::cout &lt;&lt; "Final counter value: " &lt;&lt; counter &lt;&lt; "\n";  // Should be 10000
    return 0;
}</code></pre>
</div><h3 id="summary">Summary</h3><ul>
 <li>Thread management involves <strong>joining</strong> to wait for thread completion or <strong>detaching</strong> for background execution.</li>
 <li>Synchronization is vital to protect shared resources and avoid race conditions.</li>
 <li><strong>Mutexes</strong> (<code>std::mutex</code>) provide mutual exclusion, allowing only one thread to access a critical section.</li>
 <li><strong>Lock guards</strong> like <code>std::lock_guard</code> and <code>std::unique_lock</code> simplify mutex management and prevent errors.</li>
 <li><strong>Condition variables</strong> (<code>std::condition_variable</code>) allow threads to wait for specific conditions and coordinate execution.</li>
 <li>Combining these primitives leads to robust, thread-safe programs.</li>
</ul><p>Mastering thread management and synchronization is the foundation for writing reliable multithreaded C++ programs. In the next section, we will explore <strong>mutexes, locks, and condition variables</strong> in more detail, including common patterns and best practices.</p><div class = "chapter-navi-section">
<a href="#top" class="nav-button prev">↑</a>
<a href='cplusplus-for-beginners.htm#multithreading-and-concurrency-basics' class="nav-button toc-link">Index</a>
<a href="#bottom" class="nav-button next">↓</a>
</div>
<h2 id='mutexes-locks-and-condition-variables'>17.3 Mutexes, Locks, and Condition Variables</h2><p>In multithreaded programming, coordinating access to shared resources is crucial to avoid data races, inconsistencies, and undefined behavior. In the previous section, we introduced basic thread management and synchronization concepts. Now, we dive deeper into three essential synchronization primitives in C++: <strong>mutexes</strong>, <strong>locks</strong>, and <strong>condition variables</strong>.</p><p>These tools help you manage concurrent access to shared data safely and enable threads to communicate with one another by waiting and signaling specific conditions.</p><h3 id="mutexes-ensuring-mutual-exclusion">Mutexes: Ensuring Mutual Exclusion</h3><p>A <strong>mutex</strong> (short for <em>mutual exclusion</em>) is a synchronization primitive that allows only one thread at a time to own the lock and access a protected resource. This prevents race conditions when multiple threads try to read or modify shared data simultaneously.</p><h3 id="using-std-mutex">Using <code>std::mutex</code></h3><p>C++ provides <code>std::mutex</code> in the <code>&lt;mutex&gt;</code> header. Here's how to use it:</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;thread&gt;
#include &lt;mutex&gt;

std::mutex mtx;
int shared_data = 0;

void increment() {
    mtx.lock();         // Acquire the mutex lock
    ++shared_data;      // Critical section: safe to access shared data
    mtx.unlock();       // Release the lock
}</code></pre>
</div><p>However, manually locking and unlocking the mutex is error-prone. Forgetting to unlock or exceptions thrown before unlocking can cause deadlocks.</p><h3 id="locks-managing-mutexes-safely-and-conveniently">Locks: Managing Mutexes Safely and Conveniently</h3><p>To avoid manual management, C++ provides <strong>lock classes</strong> that automatically acquire and release mutex locks, making your code safer and cleaner.</p><h3 id="std-lock-guard"><code>std::lock_guard</code></h3><p><code>std::lock_guard</code> is a lightweight wrapper that locks a mutex when created and unlocks it when destroyed (typically at the end of a scope).</p><p>Example:</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-cpp">void safe_increment() {
    std::lock_guard&lt;std::mutex&gt; lock(mtx);  // Locks mutex on creation
    ++shared_data;                           // Safe critical section
}   // Automatically unlocks when lock goes out of scope</code></pre>
</div><p>Advantages:</p><ul>
 <li>Exception-safe: the lock is released even if an exception is thrown.</li>
 <li>Simple syntax, minimal overhead.</li>
</ul><h3 id="std-unique-lock"><code>std::unique_lock</code></h3><p><code>std::unique_lock</code> is a more flexible lock that allows:</p><ul>
 <li>Locking and unlocking multiple times.</li>
 <li>Deferred locking.</li>
 <li>Moving ownership between locks.</li>
</ul><p>Example:</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-cpp">void flexible_increment() {
    std::unique_lock&lt;std::mutex&gt; lock(mtx, std::defer_lock);  // Do not lock immediately
    // ... do some work ...
    lock.lock();    // Lock when ready
    ++shared_data;
    lock.unlock();  // Unlock manually if needed

    // Later, can lock again
    lock.lock();
    // ... another critical section ...
}</code></pre>
</div><p>Use <code>std::unique_lock</code> when you need more control over locking/unlocking or want to use condition variables (which require <code>std::unique_lock</code>).</p><h3 id="condition-variables-waiting-and-signaling-between-threads">Condition Variables: Waiting and Signaling Between Threads</h3><p>Mutexes protect shared data, but sometimes threads need to <strong>wait for a specific condition</strong> before proceeding. For example, a thread might wait until a buffer has data before processing it, or wait until a flag becomes true.</p><p><strong>Condition variables</strong> provide this capability: they allow threads to <strong>block and wait</strong> until notified by another thread that a condition has changed.</p><h3 id="using-std-condition-variable">Using <code>std::condition_variable</code></h3><p>The condition variable class in C++ is <code>std::condition_variable</code>, defined in <code>&lt;condition_variable&gt;</code>.</p><p>Key methods:</p><ul>
 <li><code>wait(std::unique_lock&lt;std::mutex&gt;&amp; lock)</code>: Blocks the current thread until notified.</li>
 <li><code>notify_one()</code>: Wakes up one waiting thread.</li>
 <li><code>notify_all()</code>: Wakes up all waiting threads.</li>
</ul><h3 id="basic-workflow">Basic Workflow</h3><ul>
 <li>A thread locks a mutex and calls <code>wait()</code> on the condition variable, which atomically unlocks the mutex and suspends the thread.</li>
 <li>Another thread changes the condition and calls <code>notify_one()</code> or <code>notify_all()</code>.</li>
 <li>The waiting thread wakes up, reacquires the mutex, and continues.</li>
</ul><h3 id="example-producer-consumer-problem">Example: Producer-Consumer Problem</h3><p>The producer-consumer problem is a classic example where condition variables shine. One thread produces data and places it in a buffer, and another thread consumes it.</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">📋</button>
 <pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;thread&gt;
#include &lt;mutex&gt;
#include &lt;condition_variable&gt;
#include &lt;queue&gt;

std::queue&lt;int&gt; buffer;
const unsigned int maxBufferSize = 10;

std::mutex mtx;
std::condition_variable cv_producer;
std::condition_variable cv_consumer;

bool finished = false;

void producer() {
    for (int i = 0; i &lt; 20; ++i) {
        std::unique_lock&lt;std::mutex&gt; lock(mtx);
        cv_producer.wait(lock, []{ return buffer.size() &lt; maxBufferSize; });  // Wait if buffer is full

        buffer.push(i);
        std::cout &lt;&lt; "Produced: " &lt;&lt; i &lt;&lt; std::endl;

        lock.unlock();
        cv_consumer.notify_one();  // Notify consumer
    }

    // Notify consumer no more data will be produced
    std::unique_lock&lt;std::mutex&gt; lock(mtx);
    finished = true;
    lock.unlock();
    cv_consumer.notify_all();
}

void consumer() {
    while (true) {
        std::unique_lock&lt;std::mutex&gt; lock(mtx);
        cv_consumer.wait(lock, []{ return !buffer.empty() || finished; });  // Wait if buffer empty

        if (!buffer.empty()) {
            int data = buffer.front();
            buffer.pop();
            std::cout &lt;&lt; "Consumed: " &lt;&lt; data &lt;&lt; std::endl;

            lock.unlock();
            cv_producer.notify_one();  // Notify producer space is available
        } else if (finished) {
            break;  // No more data to consume
        }
    }
}

int main() {
    std::thread p(producer);
    std::thread c(consumer);

    p.join();
    c.join();

    return 0;
}</code></pre>
</div><h3 id="explanation">Explanation</h3><ul>
 <li><strong>Producer</strong> waits if the buffer is full (<code>buffer.size() &gt;= maxBufferSize</code>) before pushing data.</li>
 <li><strong>Consumer</strong> waits if the buffer is empty before popping data.</li>
 <li>Condition variables synchronize the threads so that producers wait for space and consumers wait for data.</li>
 <li><code>finished</code> flag signals the consumer when no more items will be produced.</li>
</ul><h3 id="summary-and-best-practices">Summary and Best Practices</h3><ul>
 <li>Use <strong><code>std::mutex</code></strong> to protect shared resources and avoid race conditions.</li>
 <li>Prefer <strong><code>std::lock_guard</code></strong> for simple, exception-safe locking.</li>
 <li>Use <strong><code>std::unique_lock</code></strong> when you need more control or plan to use condition variables.</li>
 <li><strong>Condition variables</strong> allow threads to wait efficiently for events or state changes, enabling safe thread coordination.</li>
 <li>Always protect shared data and condition checks with mutexes to avoid race conditions.</li>
 <li>Be cautious about <strong>spurious wakeups</strong>: condition variables may wake even if the condition is not true, so always use a predicate in <code>wait()</code> to re-check the condition.</li>
 <li>Avoid deadlocks by locking mutexes in a consistent order and keeping critical sections short.</li>
</ul><h3 id="next-steps">Next Steps</h3><p>Understanding these synchronization primitives sets the stage for writing correct and efficient multithreaded C++ programs. The next section will provide practical <strong>simple parallel programming examples</strong>, applying what we have learned so far to real-world tasks.</p><div class = "chapter-navi-section">
<a href="#top" class="nav-button prev">↑</a>
<a href='cplusplus-for-beginners.htm#multithreading-and-concurrency-basics' class="nav-button toc-link">Index</a>
<a href="#bottom" class="nav-button next">↓</a>
</div>
<h2 id='simple-parallel-programming-examples'>17.4 Simple Parallel Programming Examples</h2><p>Multithreading can significantly improve performance in applications that perform computationally intensive or I/O-bound tasks by running parts of the code concurrently. In this section, we will explore practical examples demonstrating how to use threads in C++ to parallelize simple tasks such as numerical computation and file processing. Along the way, we'll highlight proper synchronization, safe data sharing, and common pitfalls.</p><h3 id="example-1-parallel-summation-of-an-array">Example 1: Parallel Summation of an Array</h3><p>Suppose we want to compute the sum of a large array of integers. We can divide the array into chunks and sum each chunk in a separate thread, then combine the results.</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">📋</button>
 <pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;thread&gt;
#include &lt;numeric&gt; // std::accumulate
#include &lt;mutex&gt;

std::mutex result_mutex;

void partial_sum(const std::vector&lt;int&gt;&amp; data, int start, int end, int&amp; result) {
    int sum = std::accumulate(data.begin() + start, data.begin() + end, 0);
    
    std::lock_guard&lt;std::mutex&gt; lock(result_mutex);
    result += sum; // Safely update shared result
}

int main() {
    const int dataSize = 10000;
    std::vector&lt;int&gt; data(dataSize, 1); // Fill with 1s
    int result = 0;

    int mid = dataSize / 2;
    std::thread t1(partial_sum, std::cref(data), 0, mid, std::ref(result));
    std::thread t2(partial_sum, std::cref(data), mid, dataSize, std::ref(result));

    t1.join();
    t2.join();

    std::cout &lt;&lt; "Total Sum = " &lt;&lt; result &lt;&lt; std::endl;
    return 0;
}</code></pre>
</div><p><strong>Explanation</strong>:</p><ul>
 <li>The array is divided into two halves.</li>
 <li>Each thread computes the sum of a half.</li>
 <li><code>std::mutex</code> ensures that updates to the shared <code>result</code> variable are thread-safe.</li>
</ul><h3 id="example-2-concurrent-file-line-counting">Example 2: Concurrent File Line Counting</h3><p>Let's assume we have multiple files and want to count the number of lines in each concurrently. This is I/O-bound and benefits from multithreading.</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">📋</button>
 <pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;fstream&gt;
#include &lt;thread&gt;
#include &lt;vector&gt;
#include &lt;string&gt;

void count_lines(const std::string&amp; filename) {
    std::ifstream file(filename);
    if (!file) {
        std::cerr &lt;&lt; "Cannot open file: " &lt;&lt; filename &lt;&lt; std::endl;
        return;
    }

    int lines = 0;
    std::string line;
    while (std::getline(file, line)) {
        ++lines;
    }

    std::cout &lt;&lt; filename &lt;&lt; ": " &lt;&lt; lines &lt;&lt; " lines\n";
}

int main() {
    std::vector&lt;std::string&gt; files = {"file1.txt", "file2.txt", "file3.txt"};
    std::vector&lt;std::thread&gt; threads;

    for (const auto&amp; file : files) {
        threads.emplace_back(count_lines, file);
    }

    for (auto&amp; t : threads) {
        t.join();
    }

    return 0;
}</code></pre>
</div><p><strong>Key Takeaways</strong>:</p><ul>
 <li>Each file is processed in its own thread.</li>
 <li>There is no need for synchronization here because threads do not share data.</li>
</ul><h3 id="example-3-thread-safe-logging">Example 3: Thread-Safe Logging</h3><p>When multiple threads log messages to <code>std::cout</code>, outputs can become interleaved and unreadable. Using a mutex ensures clean output.</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">📋</button>
 <pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;thread&gt;
#include &lt;mutex&gt;

std::mutex cout_mutex;

void log_message(int thread_id) {
    for (int i = 0; i &lt; 5; ++i) {
        std::lock_guard&lt;std::mutex&gt; lock(cout_mutex);
        std::cout &lt;&lt; "Thread " &lt;&lt; thread_id &lt;&lt; " - Message " &lt;&lt; i &lt;&lt; std::endl;
    }
}

int main() {
    std::thread t1(log_message, 1);
    std::thread t2(log_message, 2);

    t1.join();
    t2.join();

    return 0;
}</code></pre>
</div><p>This guarantees that each line is printed atomically by one thread, avoiding jumbled output.</p><h3 id="performance-considerations">Performance Considerations</h3><p>While multithreading can enhance performance, it’s not always a free win:</p><ul>
 <li><strong>Thread creation overhead</strong>: Creating too many threads for small tasks can actually slow down the program.</li>
 <li><strong>False sharing</strong>: When threads modify adjacent memory, cache performance may degrade.</li>
 <li><strong>Context switching</strong>: Excessive thread switching can reduce CPU efficiency.</li>
 <li><strong>Load balancing</strong>: Distribute work evenly across threads.</li>
</ul><p>Use <strong>thread pools</strong> or libraries like <strong>OpenMP</strong> or <strong>std::async</strong> for more scalable solutions in larger programs.</p><h3 id="common-pitfalls">Common Pitfalls</h3><ol>
 <li><p><strong>Race Conditions</strong>: Occur when multiple threads access and modify shared data unsafely. Always use synchronization primitives like <code>std::mutex</code>.</p></li>
 <li><p><strong>Deadlocks</strong>: Happen when two or more threads wait for each other’s resources. Avoid nested locking or use <code>std::lock()</code> to lock multiple mutexes safely.</p></li>
 <li><p><strong>Resource leaks</strong>: Forgetting to <code>join()</code> or <code>detach()</code> threads can lead to resource leaks or undefined behavior.</p></li>
 <li><p><strong>Non-determinism</strong>: Thread scheduling is non-deterministic, so bugs may only appear occasionally. Always test thoroughly.</p></li>
</ol><h3 id="conclusion">Conclusion</h3><p>These simple examples illustrate how C++ threads can be used to speed up tasks like computation and file processing. As a beginner, focus on:</p><ul>
 <li>Using threads to divide clearly separable tasks.</li>
 <li>Ensuring shared data is protected with mutexes.</li>
 <li>Keeping code simple and readable.</li>
</ul><p>As you grow more comfortable, you'll explore more advanced concurrency tools and design patterns to write scalable and robust multithreaded applications.</p><p>In the next chapters, we’ll further explore the Standard Library and other advanced C++ programming topics that complement concurrent programming effectively.</p><div class = "chapter-navi-section">
<a href="cplusplus-for-beginners-advanced-memory-management.htm" class="nav-button prev">←</a>
<a href='cplusplus-for-beginners.htm#multithreading-and-concurrency-basics' class="nav-button toc-link">Index</a>
<a href="cplusplus-for-beginners-lambda-functions-and-functional-programming-features.htm" class="nav-button next">→</a>
</div>
<section class="download-section">
  <div class="book-cover" style="background-color: #f9f6f1;border: 1px solid #ccc;"> 
    <div class="book-cover-title" style="font-size: 18px;color: #333;top: 20px;">C++ for Beginners</div>
    <div class="book-cover-author">readbytes</div>
    <div class="book-cover-bottom-stripe" style="background-color: #333;"></div>
    <img class="book-cover-icon" style="width: 90px;height: 90px;top: 70px;" src="data:image/png;base64,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"/>
  </div>
  <div class="download-info">
    <h2 id='bottom'>Download This Ebook</h2>
    <p class="format-label">Available formats:</p>
    <div class="download-buttons">
      <a href="cplusplus-for-beginners.pdf" class="download-button">📄 PDF</a>
      <a href="cplusplus-for-beginners.epub" class="download-button">📘 EPUB</a>
    </div>
  </div>
</section><div class='related-books'>
<h2>C++ Introduction Books</h2>
<div class='related-book-list'>
<a href="cplusplus-for-beginners.htm">
<div class="book-cover" style="background-color: #f9f6f1;border: 1px solid #ccc;"> 
    <div class="book-cover-title" style="font-size: 18px;color: #333;top: 20px;">C++ for Beginners</div>
    <div class="book-cover-author">readbytes</div>
    <div class="book-cover-bottom-stripe" style="background-color: #333;"></div>
    <img class="book-cover-icon" style="width: 90px;height: 90px;top: 70px;" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFoAAABaCAYAAAA4qEECAAAKvUlEQVR4Xu1de3BUVx2OOjqjo+Mo2ezmnc2DvNoGjBSKgAIm0EIKRShQaFINhaQ8QiFSsIhBKUlrqUKthNaURyUpj0yLLU3Fos447TiMCvIPVnnMdNpCYRApJGFIwnp/d++5nP3Ouffu3Wz2cZNv5hvY3/mdc77fd8+93NcuCQkxDq/b1a3QZ8Qsd9K72GcIQQLNLMxI8TWvr/W1Nq1W+XLDct/SOfcKpivswrGGIAFv2r5nfmiLW9csUvvtbVybjeMOQYNiUF+oBsvIxsr1eFw416BFOA3mOa98nN/wZNcEnHPQYaBMZqybP10zOzkT5x40GGiTGSunfUedB+cfFFAKPxYJkxnZRkUdjgcV/dKGpYIhA0nN7GrU4lgoxd6K5GpmnDVxzOBa1VRsm3LRgUb0h6sWzhBiMtLcDQkJn0VNjkOW21UX7tVMV43BjjlojtVUZE6yWzAgVM4r086VFU4bWyq0yzhojMbCzZifbrxap4weobZdunjRd8+IuwzzkENGA2nls9WKbSx+7dNPfQyyPBnVvkmuXajNMVAKfMqWGRo3LV2gx3duXKHHERQbU5wnjIXU+t9CfY6B0epE8kay/B3rH9PjdJiQYXfLb4IaP9uTpOahPseAihue6hEKNzKZwD4T8zPSOFvloDwyEsfl+dDU8c43etsTjwqFG5kcKmiMvY2rhPEZf7JknvON/u1muQHhMpnQ/Kvn1bFefVqch/iL+mrnGy27IgynyQxzZ96vjrmmapYw344f+4/3qM8x8K+yet1Y4tmTx3z/u3IFfQoLzp4+rc8z/Vul+t/rK2c632h+9dKf61avAntuY/XypRgyBF203LhxA8MqclM86lwtzdt9D33vAV0D6nMMeJOtgBvFDN3d3UHnEoaM5mDH6Mq5DwadS1g4Z/aQ0Qx5af57HHW1S7BJCjtjlwzPHTI6GIzIz8OQLTAdqM8xYAUWZKZj7bZAY3R3dWE4aAwKo/dsWhmwqjs7r3MWWOPq1au2DhMI1tfxRvMXKOzmjl08cO9UDJni5InjAQYzDVlu11zU6AiwIomPTJ/Ur5VpB2gyt7F7UWPcI9Pt9vKF8gX/6Z0/oDdhhWxex75U4zV4xWBUfk5Qq3pOxTQ1jy5OCDu0G0dWGFkwXGo028ioM+5BReUZ3IumthP/+Dt6JEDb3XX+dP2TmCKA8uhdapyTM/ozqDWuYbSqiJX3+XfjcINtEJyPN9pxq9qsYL7ocMHKZOKMCaOcZXROcmKpVdHhNHtx1cOWJvNzot64RTCriy+8P2bffWex2p8ujHBsGSk3NTV1GGqOS1AxhRmpQpFGZGZPGjsGfTQF69fWVC+MaUStTx9qjktQMbMnjxWKNGPFuNtPRKxWOJ+H41iR9UPNcQkqZPuPaoQizTi+pFA3+EjHW2CtHKEY7ah3PKiQ0YXWbxDxNFvJ/AomXvzkgh5vbRQf/prRaSt6q53VVv+w/+GpDFO+7X/55dYfa32zxhUIphNftPFNAseYzMBMwEJ5NtTM1806eeIEeqyC2grTParRLJfhxV+/IJhObDG5MnSc0QRWGL1ygMUy3pWXw9kqgnLIZGb0fy9fxhQd+1tbhfGJ9BKPY01mwKKJXR1vBHw2A7XzRtvB7w8fFubWzHbW/Q4CX+CNt98UiCYsrqrUjXpwRoVu9PPL+n9/5M9HjwrzEXM9Xy9G3XEDK4OR5w+0CQYQv5mXJj0+hwNHOjoC5sIaYh52DDYjjcEfNvBVMjbP1i3PBsRDQdwZTYLpKxJoWihEo3msXeV/6Cvj9m1bA3KtsE3ZUHFlNIml997QsFBYVeZ/xkgm71lXLhhNn4sy/Kd9jD3v1PiyJca3NDcH9EVoeTexnpgEKwoNC5U01j2FGYbHZ7YRzNh3tFbZu/yX3DwRFMN6YhIpKSlfCqfJRN5IdWx4czQYo5Fdby+Ob6NJ6N35uYJZ/SEazWPlYzUhGS1b0VuamrR44mWsK6ZQXFz8hXCv5uqpZbqRBxvuE8yhz3QXDo20IvWjc2kcixFriykwkWhWf0jjjc5P183JVs5i0Bw6/qKRVsQNxsbqfOt3sW92uE0m0phW5kws8QpGmvHia983HIufF+uLCXg9SaujYXRF2Xf1Fcg4aUS2YC5PlsejcWODYLTCHqwz6mDi0SjG52oeFWJWrCqfrBvdvlE8Psswe7o/j+f4OzIFow+1twf0Q/3n9u5WP2OdUQeJ6u54QzCL2KUd9zBuRepT4k3RzaGrTLuYPd3/OhkSQbErh9qF+bHOqMPKSKt2GamP2WEjFNxf7j/UIGT6KJbtcR3GWqOGLLerVyYURZ9RdkeMm3EgjJYBj8/8/DG1qpkgFCoTjXEZWS6SBx8/euRIQJtdGGk7G2vHaRJz/fAhQSjPC9o9Zozz5M3bsO4J3Yje3l7BaEJXV5ewMYjt+/dhqimozyft+wQ9TBPWGzVYGciLxhgjrZ5zZ86gByrKJ/iffluBvkGLphN3vrQDUwNgpitmjC52ub5sJhRFH/pZgzQuM5I3a7NyHLWLjz/6UDA9Pz01IGdL4+b4MFoR8p6ZUJ652u8k8bHTr+wUTH7z9dd1Y3avFe8/h4oL58/7bmjfGmBg86BWRrU9MTEf6444SAjd1EGBRsSi1FUGvy5ToHxmBjCGA7Ix6c+P9rcKOnl93iTXFaw74iAhy2dWCAKNKDNahkuXLvmKs7MCjKGvF4cK3tyD+14NGPcvv9wi6OT1EbHuiAONs8PnauU332V4/9SpALPswqhvhXYBY1RHkbZ3Yd0Rh5HAYEh9i7yZWLsKatu7exeG1XhPTw+GgwIzdMkjVdhkaHZL/ePOMNoIrHAZ7WBUcZHQn3H+rJkBuexHVGQ6se6IQybMjCXKCqY/L792IGjT+vr6dHNu3ryJzaagPv/59/u+l3c0C0YT6R9yzEfNcWc0K47/uwys7ZmnNgkxO6CNYrcP5Y8uyBN0Y90RBZ1fBmP0D6b4n/vxuWYGVC9coOcbMTc1GbtJwfLpQoUu5a2AOmPDaJdrPIpCMuF0YYKxYND2yh6h8C01/rMVnnSv+pZyiOFB8XGlI9Wb/JhPbHhyXUA+64Pz0WesPaJQBFSjKBQoa6fYmpV1WKOK2mr/8zwkjsGzaZG8D/Gfx4/jFKanihQbruwtqFcp93NYf8TgdScusjJBRqMiGaiNXa6PzPEK/a24sWqhYPiGtbfvBpqBcj8+0CbojerrvFkeV1UoRjPxsrt1H37wgdqG+f0hms6IuH7tmnRuimUlu6Zi/RFDbmLiN2TCguGzS/z/idhI7seo2PO9ny+uFvL7Q5mpq1csw5CaN/6OImn/LLdrBdYfUYRqNF8ET6sHCKGQjd3Z2Yneqvjre+/qOdiX9c9yu+uw9ojCSFysETco8nHlKhH78H2z3cMmY+0RRbwYzZNe+/rXrhbfudY9QpuMVGNCtL9URCIK0lIEcU6iZnR04U1KKovHVR0sh2s3mrDuqICEVE8tF0Ra8dgL24RYrJFqy8j46tew5qggNfUrw0hQsGcMf9vu/5WvaO0JNO/BhvVCHMk0Yr1RhSLoFIlaNsP8sRYT31C5QGiLFJkGRn7PovcH+TasMyaQlpb2RV4k/SM5seROoTAsHElnBbR3hEJ6UdGKzMDS0oTPo7aYNlgGr/ajgrFK1DvQ+D8MyloZgHbpRwAAAABJRU5ErkJggg=="/>
  </div>
</a>


<a href="cplusplus-syntax.htm">
<div class="book-cover" style="background-color: #f9f6f1;border: 1px solid #ccc;"> 
    <div class="book-cover-title" style="font-size: 20px;color: #333;top: 20px;">C++ Syntax</div>
    <div class="book-cover-author">readbytes</div>
    <div class="book-cover-bottom-stripe" style="background-color: #333;"></div>
    <img class="book-cover-icon" style="width: 90px;height: 90px;top: 70px;" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFoAAABaCAYAAAA4qEECAAAFZ0lEQVR4Xu2dy4scVRSH8ye0iYtkERcmzgjT2OYBuhNREMVXBh/TgsYQx5ULDYTgVl3EFyg6uFJBV76IEXdKXAVBJCgISSTRGRmZiZlADBo6M5kp+3ZbnXt/p7q6btWtc++pqQPfpu/p7vP7UnSqi+m6GzbkrMbYO50u0Tqjgx5Kqe4brSa8+XplFf0UroQ3GbDltqNRs70Y3Tw5G22//2SXU0Fyy5MXc6GyqYyYWwd9WdfGbW9uxRe9vvlBtOvZKLrpwTOiUDO7QjlALxu3zWxFf5mq++RF/YU27/40au39lwSQAspygXICwhfRY2rhv5Z6URxcEuoAQUkuQV/oM7HwSN45vUoGlwaKKQOrI1t9zuhPaD19mQwtEZRSFrq71M/sqh3JMSikTHSH6LdXeoN6Ag4rlV3Ta0RG2aTKjhfU/6Q4rGRQAgf62QhKHnzjk3wKlwRK4EI7qq99g4wf3NR8nwwqmfE9s0QAF8olOarjB1QDDisZDM+NIbqhXYXDQaWDwbnRPj46xtkGDiodDM6N7nYgWl2hwkEl09r7DwnOzZbbr131G4iemFokw0oGQ/ug2XVKRI9PzpJhJYOhfdB66m8qevsDp8iwksHQPqi8aAzsi1o0E7VoJioteuzh30lgX1RaNIb1SS2aiVo0E5UVPTH1Fwnrk8qKxqC+qUUzUYtmwovoL49dioYV9uZhx/4VEjRmWM2fp70uYRc9qrA/DxhSZ1RhvyuCEL1wfiU6PXulB/bnAUPqnJnv8+cSTtEv7HeFd9G4XpyzJGQaWLjuisqJxoCjeOVjc572y7THBayim4+cNUKdONkhPUXBgKO495AxUrTvVdrjAq+ij//k/i9UMeAo7jlojFSLzsLE4/ZfuyspuvXYb0Yo16IxXBZQ9DOv0x4XsIqeOjRvhPri20ukpwgYLgt3HTBGir75kfa4gFU01h373f5ZA4bLChauu4BNdPtF82hWhT1FuHVfh4TLCtbR47SnKKWKTqu5hWXSXwQMZsOBGZzOLOzPA7voNz66QPpcgMHy8Py7OG2/sC8P7KLjurK8RvqLgMFsmDmC05mF/XkoVbTOjinz1E4V9uSl6I+AsF6YoT1FYROtwLpzeo705AFD2YKF6y5gFf3oQfPM48h3w8+jD3+4ZIDrOnGYtz7vgyHTuBvOo7/+nva4gFW0zTdDLFyPGdN+BBQXhkyDfDN8jfa4gFW0zbWOH365bIDrMXqYE7/2wZBpoOhKXOuwEZ0VDGTLuhD98+kO6bEFA9lyXxWvRyuwcN0GdccFDGTLe1+Z87Rfoj0uEC0aw+QBC9dd4V10XMsraz2wPw0Mk4WVq33WcID/C/tdwS766uqwiP3C/jQwTBZGFfa7gl204rnDC5hvUNg7DAySlWH1yTHa6xIvol2AQUKnFs2ESNHjk3MkSOiIFI0hJFCLZqIWzYQ40c0nLpAQEhAnGgNIoRbNRC2aCVGid6b8CCh0RInG4SVRi2YiUXSIN68ae8juR0ChkSg6xNux4eDSSLwdW4g3GMTBpZF4g0EFBvUNDi4N3a0SHeRNYCfaS2RwaWii+1s/xQ+oRQzsCxxaIoOjGe8fHdKNunFoaWzSdh/SRQd363kcXBrax4a5eVm8EMJmCmn33pDA5t2f0aMZRStUM4bnBAeXhu4SPfdKb/C54Q0OLomRklWFsoUTDi8F3d11N759A/o1quF5UzIcXgq6sy7n0GtiwZN6L4RCygIDSAB9oc/UwiOba+NIDBEy+tmF1ZGMhZ/ZijK3Qh3f8wcJEyJOt0LVC19UR12harbPOdncFzfWDQGVTb8KlwT6KlyNertqHffbVSdVo96A3ar+A5kzbYSE7G+UAAAAAElFTkSuQmCC"/>
  </div>
</a>


<a href="cplusplus-stl.htm">
<div class="book-cover" style="background-color: #f9f6f1;border: 1px solid #ccc;"> 
    <div class="book-cover-title" style="font-size: 20px;color: #333;top: 20px;">C++ STL</div>
    <div class="book-cover-author">readbytes</div>
    <div class="book-cover-bottom-stripe" style="background-color: #333;"></div>
    <img class="book-cover-icon" style="width: 90px;height: 90px;top: 70px;" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFoAAABaCAYAAAA4qEECAAADK0lEQVR4Xu2cvWsTcRjHo+DkIKiTjiJugqTJ0cG/QcRZ/wJXQTd3ByeHDiLJnS84dHMVBHUSRQUH90pNfmfb6CKi8fqSaj93ae4lzzV3+X7gS9vkeZ7f7/lwEDq0jYYQQgghxFzQ9t0wbTzf3WO/SAllpg3niAlQYJa0uu4W54kxeA96ZykwU4JwnTPFGGLyMqd3nTNFAnFx2cOZIiee//UK5TLsEQWg3D1ZHpxgvShATLCeajsoWKKNaAfuDyVvZuGhu8paURBK1lNtBAVLtBEULNFGULBEG0HBlRfNRUrMqwW/f473GZFQvxXWVQbPD5e4zEGlcXt4eHQvvrdbU2W4zEGn5Yd3+NoovHul4DKzHN69UnCZWQ7vXim8IHzJhWY1vLtIQSRujSInhTNEBppL345R6LiwV+SAUpPCHpETimVYLwpAuRJtBOVKtBHNR4OTFCzRRlCwRBtBwRJtBAVLtBEULNFGeN3wPiVvp/+OtVmJ5qzvmdl1z1kzV8Ql53+q0/6az765gBLyConqN9i/X9hfeyiAYX0S7cCtsi9NOKf2UADDesL6LOGsWsPlx+V8d/Vo3t5x4bzyGA4P8TK1TuBeU0FpxC5T83D/0uBF6h7uXxq8SN3D/Utj80OHl6ltgvAX9y+V2IUm53eUQZQvUT4nvJ8x/e/R14+RiBeeHz4bZfPn6PW3bT908Z7s4d6Vgwsxix13mj15iGb94Ows4bxKwWUY1heF89OGcyoHFypjOZ4zKV7gVjijUjSfrJ/hUqOwdtrwvH2yzN7KkbDUTsKfrLWgufTmSPzsf2F9ZeFitVtwVqBgiTaCgiXaCAqWaCMoWKKNoGCJNoKCJdoICpZoIyhYoo2gYIk2goIl2ggKlmgjKFiijaBgiTaCgiXagLbfu0jBW+m6NdaKAsQEj9Jxl1krChATvBPWiQJ4fviJgiV6yiw+3ThOuRI9ZbzA3aRYSZ4iFx73T1FqUtg3l1DKbrr9960gvBt9f207/Rst332I1U0Iz5tbKGaa4VlzTSQk8X84Fw3PEY3p/70KTxA7UFTeeB13ibPFf1BY1nCeEEIIIYQowl8t5mhjJHw+fQAAAABJRU5ErkJggg=="/>
  </div>
</a>



<a href='cplusplus.htm'><div class='book-cover' style='background-color: #f9f6f1;color: #111111;border: 1px solid #ccc;display: flex;justify-content: center;align-items: center;text-align: center;'>More C++ Books</div></a>
</div>
</div>
  </div>
  <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/prism.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
  
  <script>
    function copyCode(button) {
      const code = button.nextElementSibling.innerText;
      navigator.clipboard.writeText(code).then(() => {
        button.textContent = 'Copied!';
        setTimeout(() => { button.textContent = 'Copy'; }, 1500);
      });
    }
  </script>  
<div id="floatingLog" aria-live="polite" role="alert"></div>
<footer class="page-footer">
    <nav>
      <a href="https://readbytes.github.io">Home</a> | 
      Email:<script language="JavaScript" type="text/javascript">
var part1 = 'yinpeng';var part6 = '263';var part2 = Math.pow(2,6);var part3 = String.fromCharCode(part2);var part4 = 'hotmail dot com';var part5 = part1 + String.fromCharCode(part2) + part4;document.write(part1 + part6 + part3 + part4);
</script>
    </nav>
  <p>© 2025 — All rights reserved.</p>    
  </footer>

</body>
</html>