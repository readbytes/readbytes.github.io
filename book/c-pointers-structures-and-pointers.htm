<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>C Pointers Structures and Pointers</title>
<link rel='shortcut icon' href='https://java2s.com/style/favicon.ico'>
<link href="https://fonts.googleapis.com/css2?family=Merriweather&display=swap" rel="stylesheet" />
<link href="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet" />


  <script>
  const mode = localStorage.getItem('mode') || 'light';
  document.documentElement.classList.add(`${mode}-mode`);
  </script>   
<style> 
html {
  scroll-behavior: smooth;
}

body {
  font-family: 'Merriweather', serif;
  margin: 0;
  padding: 2rem 1rem;
  font-size: 15px;
  line-height: 1.5;
  transition: background-color 0.3s, color 0.3s;
}

.container {
  max-width: 700px;
  margin: 0 auto;
  padding: 1rem 2rem;
  box-shadow: 0 0 15px rgba(0,0,0,0.1);
}

h1, h2, h3 {
  font-weight: 600;
  margin-top: 2.5rem;
  margin-bottom: 1rem;
  line-height: 1.2;
}

h1 { font-size: 1.8rem; }
h2 { font-size: 1.4rem; }
h3 { font-size: 1.2rem; }

table {
  width: 100%;
  border-collapse: collapse;
  font-family: sans-serif;
  font-size: 1em;
  margin: 1em 0;
}

th, td {
  padding: 0.6em 1em;
  text-align: left;
  border: 1px solid;
}

tr:nth-child(even) {
  background-color: inherit;
}

tr:hover {
  background-color: inherit;
}

a {
  text-decoration: none;
  transition: color 0.2s;
}

a:hover {
  text-decoration: underline;
}

code {
  color: #d35400;
}

.book-title-chapter {
  font-family: 'Merriweather', serif;
  font-size: 2rem;
  font-weight: bold;
  text-align: center;
  margin-bottom: 2rem;
  border-bottom: 2px solid;
  padding-bottom: 0.5rem;
}

.book-subtitle-chapter {
  text-align: center;
  font-size: 1rem;
  margin-top: -1rem;
  margin-bottom: 2rem;
}

.related-books {
  margin-top: 40px;
}

.related-book-list {
  display: flex;
  flex-wrap: wrap;
  gap: 20px;
}

    .book-cover {
      width: 130px;
      height: 180px;
      font-family: Arial, sans-serif;
      position: relative;
      overflow: hidden;      
      line-height: normal;
      box-shadow: 2px 2px 4px rgba(0,0,0,0.1);
    }
    .book-cover-bottom-stripe {
      position: absolute;
      bottom: 0;
      left: 0;
      height: 5px;
      width: 100%;
    }
    .book-cover-title {
      position: absolute;
      width: 100%;
      text-align: center;
      font-weight: bold;
    }
     
    .book-cover-icon {
      position: absolute;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      align-items: center;
      justify-content: center; 
    }

    .book-cover-author {
      position: absolute;
      bottom: 10px;
      width: 100%;
      text-align: center;
      font-size: 8px;
      color: #333;
    }

.page-footer {
  margin-top: 4rem;
  padding: 1rem 0;
  text-align: center;
  font-size: 0.85rem;
  border-top: 1px solid;
}

.chapter-navi-section {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding-bottom: 10px;
}

.nav-link {
  color: inherit;
  text-decoration: none;
  opacity: 0.5;
  transition: opacity 0.3s ease, text-decoration 0.3s ease;
}

.nav-link:hover {
  opacity: 0.9;
  text-decoration: underline;
}

.prev { text-align: left; }
.toc-link { text-align: center; }
.next { text-align: right; }

.download-section {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 2rem;
  padding: 2rem 1rem;
  max-width: 600px;
  margin: 3rem auto;
  border-radius: 12px;
  box-shadow: 0 4px 10px rgba(0,0,0,0.05);
}

.download-info h2 {
  margin: 0 0 0.5rem;
  font-size: 1.2rem;
}

.format-label {
  margin: 0 0 0.5rem;
  font-size: 0.95rem;
}

.download-buttons {
  display: flex;
  gap: 1rem;
}

.download-button {
  background-color: #4A90E2;
  color: white;
  padding: 0.5em 1.2em;
  border-radius: 25px;
  font-size: 0.95rem;
  text-decoration: none;
  transition: background-color 0.3s ease;
}

.download-button:hover {
  background-color: #357ABD;
}

.code-block {
  position: relative;
  margin-bottom: 1em;
}

.copy-button {
  background: transparent;
  color: white;
  position: absolute;
  top: 8px;
  right: 8px;
  border: none;
  padding: 4px 8px;
  font-size: 12px;
  border-radius: 4px;
  cursor: pointer;
  z-index: 1;
}

.copy-button:hover {
  background-color: #0056b3;
}

.snippet-container {
  overflow: hidden;
}

.snippet-header {
  padding: 0.75rem 1rem;
  cursor: pointer;
  font-size: 1rem;
    background-color: #eeeeee;
    color:  #111111; 
    border-radius: 8px;
    cursor: pointer;
    box-shadow: 0 4px 6px rgba(0,0,0,0.1);  
}

.snippet-body {
  display: none;
  font-family: monospace;
}

.snippet-container.open .snippet-body {
  display: block;
}

.CodeMirror {
  border: 2px solid #ccc;
  border-radius: 4px;
  resize: vertical;
}

/* === Light Mode === */
html.light-mode {
  background-color: #f8f7f5;
  color: #333;
}

html.light-mode .container {
  background: white;
}

html.light-mode .book-title-chapter {
  color: #2c3e50;
  border-color: #ccc;
}
html.light-mode .book-subtitle-chapter{
  color: #888;
}

html.light-mode .page-footer,
html.light-mode .series-name,
html.light-mode .book-subtitle,
html.light-mode .format-label {
  color: #888;
}

html.light-mode .related-books h2 {
  color: #333;
  border-bottom: 2px solid #eee;
}

html.light-mode .book-title {
  color: #fff;
}

html.light-mode .book-cover {
  border: 1px solid #ccc;
}

html.light-mode th {
  background-color: #f2f2f2;
}

html.light-mode tr:nth-child(even) {
  background-color: #fafafa;
}

html.light-mode tr:hover {
  background-color: #e6f7ff;
}

html.light-mode a,
html.light-mode .page-footer a {
  color: #000;
}

/* === Dark Mode === */
html.dark-mode {
  background-color: #181818;
  color: #e0e0e0;
}

html.dark-mode .container {
  background: #222;
}

html.dark-mode .book-title-chapter {
  color: #ddd;
  border-color: #444;
}

html.dark-mode .snippet-header {
    background-color: #333;
    color:  #ddd; 
}


html.dark-mode .book-subtitle-chapter,
html.dark-mode .page-footer,
html.dark-mode .series-name,
html.dark-mode .book-subtitle,
html.dark-mode .book-footer,
html.dark-mode .format-label {
  color: #aaa;
}

html.dark-mode .related-books h2 {
  color: #ddd;
  border-bottom: 2px solid #333;
}

html.dark-mode .book-title {
  color: #fff;
}

html.dark-mode .book-cover {
  border: 1px solid #555;
}

html.dark-mode th {
  background-color: #333;
  color: #fff;
}

html.dark-mode td {
  border-color: #444;
}

html.dark-mode tr:nth-child(even) {
  background-color: #2a2a2a;
}

html.dark-mode tr:hover {
  background-color: #2c3e50;
}

html.dark-mode a,
html.dark-mode .page-footer a {
  color: #eee;
}

    .dialog-backdrop {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: rgba(0,0,0,0.5);
      display: none;
      justify-content: center;
      align-items: center;
      z-index: 10;
    }

    .dialog {
      background: white;
      padding: 20px;
      width: 90vw;
      height: 80vh;
      border-radius: 8px;
      box-shadow: 0 0 20px rgba(0,0,0,0.3);
      display: flex;
      flex-direction: column;
    }
    .dialog-content {
      display: flex;
      flex: 1;
      gap: 20px;
      margin-top: 10px;
    }
    .dialog h2 {
      margin-top: 0;
    }

    .textarea_dialog {
      width: 50%;
      height: 100%;
      resize: none;
      font-family: monospace;
      font-size: 14px;
      padding: 10px;
      box-sizing: border-box;
      border: 1px solid #ccc;
    }

    .iframe_dialog {
      width: 50%;
      height: 100%;
      border: 1px solid #ccc;
    }
    .controls_dialog {
      display: flex;
      justify-content: space-between;
      margin-top: 10px;
    }    
    button { padding: 0.5em 1em; background: green; color: white; border: none; cursor: pointer; }
    button:hover { background: #1e7e34; }
    .result_iframe { width:99%; height:200px; margin-top: 1em;  resize: both;border:1px solid #ccc;}        
</style>
</head>
<body> 
  <div class="container">
    <div class = "chapter-navi-section">
<a href="c-pointers-dynamic-memory-allocation-with-pointers.htm" class="nav-button prev">←</a>
<a href='c-pointers.htm#structures-and-pointers' class="nav-button toc-link">Index</a>
<a href="c-pointers-pointer-casting-and-void-pointers.htm" class="nav-button next">→</a>
</div>

    <h1 class="book-title-chapter" id = 'top'>Structures and Pointers</h1>
    <h3 class="book-subtitle-chapter">C Pointers</h3>   
    <!-- <h1 class ="chapter-title"></h1> -->
    <h2 id='pointer-to-structures-accessing-members-via-operator'>7.1 Pointer to Structures: Accessing Members via <code>-&gt;</code> Operator</h2><p>In C, <strong>structures</strong> allow you to group related variables (members) under a single name. When working with <strong>pointers to structures</strong>, C provides a convenient syntax to access these members: the <strong>arrow operator</strong> (<code>-&gt;</code>).</p><p>This section explains:</p><ul>
 <li>How to create and use structure pointers</li>
 <li>The difference between <code>.</code> and <code>-&gt;</code></li>
 <li>How the <code>-&gt;</code> operator simplifies member access</li>
 <li>Examples comparing both forms</li>
</ul><h3 id="understanding-structure-access">Understanding Structure Access</h3><h4 id="direct-access-with-the-dot-operator">Direct Access with the Dot Operator (<code>.</code>)</h4><p>When you have a <strong>structure variable</strong>, use the dot operator to access its members.</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-c">struct Point {
    int x;
    int y;
};

int main() {
    struct Point p1;
    p1.x = 10;
    p1.y = 20;

    printf("x = %d, y = %d\n", p1.x, p1.y);
    return 0;
}</code></pre>
</div><h3 id="using-pointers-to-structures">Using Pointers to Structures</h3><p>When using a pointer to a structure, you cannot directly use the dot operator without first dereferencing the pointer.</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-c">struct Point p1 = {10, 20};
struct Point *ptr = &amp;p1;

(*ptr).x = 30;  // Dereference then access</code></pre>
</div><p>This works but is verbose and harder to read. That’s where the arrow operator comes in.</p><h3 id="the-arrow-operator">The Arrow Operator (<code>-</code>)</h3><p>The <code>-&gt;</code> operator is shorthand for <code>(*ptr).member</code>.</p><h3 id="syntax">Syntax:</h3><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-c">pointer-&gt;member</code></pre>
</div><h3 id="example">Example:</h3><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-c">struct Point p1 = {10, 20};
struct Point *ptr = &amp;p1;

ptr-&gt;x = 30;
ptr-&gt;y = 40;

printf("x = %d, y = %d\n", ptr-&gt;x, ptr-&gt;y);</code></pre>
</div><p>This is equivalent to:</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-c">(*ptr).x = 30;
(*ptr).y = 40;</code></pre>
</div><p>But <code>ptr-&gt;x</code> is cleaner and preferred.</p><h3 id="example-dot-vs-arrow">Example: Dot vs. Arrow</h3><div class="code-block"><button class="copy-button" onclick="copyCode(this)">📋</button>
 <pre><code class="language-c">#include &lt;stdio.h&gt;

struct Person {
    char name[20];
    int age;
};

int main() {
    struct Person person1 = {"Alice", 25};
    struct Person *ptr = &amp;person1;

    // Accessing members directly
    printf("Name: %s, Age: %d\n", person1.name, person1.age);

    // Accessing members via pointer
    printf("Name: %s, Age: %d\n", ptr-&gt;name, ptr-&gt;age);

    return 0;
}</code></pre>
</div><p>Output:</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-bash">Name: Alice, Age: 25
Name: Alice, Age: 25</code></pre>
</div><p>✅ Both access methods work the same, but <code>-&gt;</code> is the correct choice when using pointers.</p><h3 id="why-use-structure-pointers">Why Use Structure Pointers?</h3><p>Pointers to structures are:</p><ul>
 <li>Efficient for passing large structures to functions</li>
 <li>Required for dynamic memory allocation of structs</li>
 <li>Useful for building linked data structures (linked lists, trees, etc.)</li>
</ul><h3 id="summary">Summary</h3><table>
 <thead>
  <tr>
   <th>Operator</th>
   <th>Use Case</th>
   <th>Example</th>
  </tr>
 </thead>
 <tbody>
  <tr>
   <td><code>.</code></td>
   <td>Direct structure access</td>
   <td><code>p1.x</code></td>
  </tr>
  <tr>
   <td><code>-&gt;</code></td>
   <td>Pointer to structure</td>
   <td><code>ptr-&gt;x</code></td>
  </tr>
 </tbody>
</table><ul>
 <li>Use <code>.</code> when you have the structure itself.</li>
 <li>Use <code>-&gt;</code> when you have a <strong>pointer</strong> to a structure.</li>
 <li><code>ptr-&gt;member</code> is shorthand for <code>(*ptr).member</code>.</li>
</ul><div class = "chapter-navi-section">
<a href="#top" class="nav-button prev">↑</a>
<a href='c-pointers.htm#structures-and-pointers' class="nav-button toc-link">Index</a>
<a href="#bottom" class="nav-button next">↓</a>
</div>
<h2 id='dynamic-allocation-of-structures'>7.2 Dynamic Allocation of Structures</h2><p>In C, structures group related data into a single unit. Sometimes, you don’t know how many structures you’ll need until runtime, or you want to manage memory efficiently by allocating structures dynamically on the heap. This allows for flexible and scalable programs.</p><p>This section explains:</p><ul>
 <li>How to dynamically allocate memory for structures using <code>malloc()</code></li>
 <li>Initializing structure members via pointers</li>
 <li>Properly freeing dynamically allocated structures to avoid memory leaks</li>
</ul><h3 id="allocating-memory-for-a-structure">Allocating Memory for a Structure</h3><p>To dynamically allocate a structure, you use <code>malloc()</code> with the size of the structure:</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-c">struct Person {
    char name[50];
    int age;
};

struct Person *p = malloc(sizeof(struct Person));</code></pre>
</div><p>Here:</p><ul>
 <li><code>p</code> is a pointer to a <code>Person</code> struct.</li>
 <li><code>malloc</code> allocates enough memory for one <code>Person</code>.</li>
 <li><code>p</code> now points to that memory block.</li>
</ul><h3 id="initializing-members-of-a-dynamically-allocated-structure">Initializing Members of a Dynamically Allocated Structure</h3><p>You can access and modify members via the pointer using the arrow operator <code>-&gt;</code>:</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-c">if (p != NULL) {  // Always check if malloc succeeded
    p-&gt;age = 30;
    snprintf(p-&gt;name, sizeof(p-&gt;name), "John Doe");
}</code></pre>
</div><h3 id="freeing-dynamically-allocated-structures">Freeing Dynamically Allocated Structures</h3><p>When you are done with the structure, <strong>free</strong> its memory to prevent leaks:</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-c">free(p);
p = NULL;  // Avoid dangling pointer</code></pre>
</div><h3 id="full-example-create-initialize-and-free-a-dynamic-structure">Full Example: Create, Initialize, and Free a Dynamic Structure</h3><div class="code-block"><button class="copy-button" onclick="copyCode(this)">📋</button>
 <pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

struct Person {
    char name[50];
    int age;
};

int main() {
    // Allocate memory
    struct Person *p = malloc(sizeof(struct Person));
    if (p == NULL) {
        printf("Memory allocation failed.\n");
        return 1;
    }

    // Initialize members
    p-&gt;age = 28;
    strcpy(p-&gt;name, "Alice");

    // Use the struct
    printf("Name: %s, Age: %d\n", p-&gt;name, p-&gt;age);

    // Clean up
    free(p);
    p = NULL;

    return 0;
}</code></pre>
</div><h3 id="important-notes">Important Notes</h3><ul>
 <li>Always check the return value of <code>malloc()</code> for <code>NULL</code> to avoid using invalid memory.</li>
 <li>Use the arrow operator <code>-&gt;</code> to access members through structure pointers.</li>
 <li>Free allocated memory when done to avoid leaks.</li>
 <li>Setting pointers to <code>NULL</code> after freeing is a good safety practice.</li>
</ul><h3 id="summary">Summary</h3><ul>
 <li>Use <code>malloc(sizeof(struct Type))</code> to dynamically allocate structures.</li>
 <li>Access members with <code>ptr-&gt;member</code>.</li>
 <li>Always free allocated memory with <code>free()</code> once finished.</li>
</ul><div class = "chapter-navi-section">
<a href="#top" class="nav-button prev">↑</a>
<a href='c-pointers.htm#structures-and-pointers' class="nav-button toc-link">Index</a>
<a href="#bottom" class="nav-button next">↓</a>
</div>
<h2 id='passing-structures-to-functions-by-pointer'>7.3 Passing Structures to Functions by Pointer</h2><p>In C, when you pass a structure to a function <strong>by value</strong>, a copy of the entire structure is made. This can be inefficient, especially for large structures, and modifications inside the function do not affect the original structure.</p><p>To improve efficiency and enable <strong>in-place modification</strong>, you can pass a <strong>pointer to the structure</strong> instead. This way, the function works directly with the original data.</p><h3 id="why-pass-pointers-to-structures">Why Pass Pointers to Structures?</h3><table>
 <thead>
  <tr>
   <th>By Value</th>
   <th>By Pointer</th>
  </tr>
 </thead>
 <tbody>
  <tr>
   <td>Copies entire structure</td>
   <td>Passes only the address (small and fast)</td>
  </tr>
  <tr>
   <td>Modifications inside function do <strong>not</strong> affect original</td>
   <td>Modifications affect the original structure</td>
  </tr>
  <tr>
   <td>Uses more memory and CPU time</td>
   <td>More efficient for large structures</td>
  </tr>
 </tbody>
</table><p>Passing pointers allows your functions to:</p><ul>
 <li>Avoid expensive copying</li>
 <li>Modify the caller’s structure directly</li>
 <li>Use less stack memory</li>
</ul><h3 id="syntax-function-parameters-with-structure-pointers">Syntax: Function Parameters with Structure Pointers</h3><p>Defining a function that takes a structure pointer:</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-c">void printPerson(struct Person *p) {
    printf("Name: %s, Age: %d\n", p-&gt;name, p-&gt;age);
}</code></pre>
</div><p>Calling the function:</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-c">struct Person person = {"Alice", 30};
printPerson(&amp;person);</code></pre>
</div><p>Modifying a Structure via Pointer Parameter</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-c">void haveBirthday(struct Person *p) {
    p-&gt;age += 1;  // Modify original structure’s member
}</code></pre>
</div><p>Using it in <code>main</code>:</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-c">int main() {
    struct Person person = {"Bob", 25};

    printf("Before birthday: %d\n", person.age);
    haveBirthday(&amp;person);
    printf("After birthday: %d\n", person.age);

    return 0;
}</code></pre>
</div><p><strong>Output:</strong></p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-bash">Before birthday: 25
After birthday: 26</code></pre>
</div><h3 id="complete-example">Complete Example</h3><div class="code-block"><button class="copy-button" onclick="copyCode(this)">📋</button>
 <pre><code class="language-c">#include &lt;stdio.h&gt;

struct Person {
    char name[50];
    int age;
};

void printPerson(struct Person *p) {
    printf("Name: %s, Age: %d\n", p-&gt;name, p-&gt;age);
}

void haveBirthday(struct Person *p) {
    p-&gt;age++;
}

int main() {
    struct Person person = {"Charlie", 40};

    printPerson(&amp;person);
    haveBirthday(&amp;person);
    printPerson(&amp;person);

    return 0;
}</code></pre>
</div><h3 id="summary">Summary</h3><ul>
 <li>Passing structures by pointer is efficient and allows modification.</li>
 <li>Use the <code>-&gt;</code> operator inside functions to access members.</li>
 <li>Always pass the address of the structure (<code>&amp;structVar</code>) when calling functions expecting a pointer.</li>
 <li>This technique is essential when working with large or dynamically allocated structures.</li>
</ul><div class = "chapter-navi-section">
<a href="#top" class="nav-button prev">↑</a>
<a href='c-pointers.htm#structures-and-pointers' class="nav-button toc-link">Index</a>
<a href="#bottom" class="nav-button next">↓</a>
</div>
<h2 id='examples-managing-complex-data-using-struct-pointers'>7.4 Examples: Managing Complex Data Using Struct Pointers</h2><p>One of the most powerful uses of pointers to structures is managing complex, interconnected data structures like <strong>linked lists</strong> and <strong>trees</strong>. These data structures rely on pointers within structs to create chains or hierarchies of elements, allowing dynamic and flexible data management.</p><p>In this section, we will explore practical examples demonstrating how to use struct pointers to:</p><ul>
 <li>Insert nodes</li>
 <li>Traverse the structure</li>
 <li>Delete nodes safely</li>
</ul><h3 id="example-1-singly-linked-list">Example 1: Singly Linked List</h3><p>A <strong>linked list</strong> is a sequence of nodes where each node contains data and a pointer to the next node.</p><h3 id="defining-a-node-structure">Defining a Node Structure</h3><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-c">struct Node {
    int data;
    struct Node *next;
};</code></pre>
</div><h3 id="inserting-a-node-at-the-head">Inserting a Node at the Head</h3><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

void insertAtHead(struct Node **head, int value) {
    struct Node *newNode = malloc(sizeof(struct Node));
    if (newNode == NULL) {
        printf("Memory allocation failed\n");
        return;
    }
    newNode-&gt;data = value;
    newNode-&gt;next = *head;
    *head = newNode;
}</code></pre>
</div><h3 id="traversing-the-list">Traversing the List</h3><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-c">void printList(struct Node *head) {
    struct Node *current = head;
    while (current != NULL) {
        printf("%d -&gt; ", current-&gt;data);
        current = current-&gt;next;
    }
    printf("NULL\n");
}</code></pre>
</div><h3 id="deleting-the-entire-list">Deleting the Entire List</h3><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-c">void freeList(struct Node *head) {
    struct Node *temp;
    while (head != NULL) {
        temp = head;
        head = head-&gt;next;
        free(temp);
    }
}</code></pre>
</div><h3 id="full-example-usage">Full Example Usage</h3><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-c">int main() {
    struct Node *head = NULL;

    insertAtHead(&amp;head, 10);
    insertAtHead(&amp;head, 20);
    insertAtHead(&amp;head, 30);

    printList(head);  // Output: 30 -&gt; 20 -&gt; 10 -&gt; NULL

    freeList(head);
    return 0;
}</code></pre>
</div><div class="snippet-container" id="J8fMw">
 <div class="snippet-header" onclick="toggleSnippet('J8fMw')">
  Click to view full runnable Code
 </div>
 <div class="snippet-body">
  <div class="code-block"><button class="copy-button" onclick="copyCode(this)">📋</button>
   <pre><code class="language-c">
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

// Define the node structure
struct Node {
    int data;
    struct Node *next;
};

// Insert a new node at the head of the list
void insertAtHead(struct Node **head, int value) {
    struct Node *newNode = malloc(sizeof(struct Node));
    if (newNode == NULL) {
        printf("Memory allocation failed\n");
        return;
    }
    newNode-&gt;data = value;
    newNode-&gt;next = *head;
    *head = newNode;
}

// Print the entire linked list
void printList(struct Node *head) {
    struct Node *current = head;
    while (current != NULL) {
        printf("%d -&gt; ", current-&gt;data);
        current = current-&gt;next;
    }
    printf("NULL\n");
}

// Free all nodes in the list
void freeList(struct Node *head) {
    struct Node *temp;
    while (head != NULL) {
        temp = head;
        head = head-&gt;next;
        free(temp);
    }
}

int main() {
    struct Node *head = NULL;

    insertAtHead(&amp;head, 10);
    insertAtHead(&amp;head, 20);
    insertAtHead(&amp;head, 30);

    printList(head);  // Output: 30 -&gt; 20 -&gt; 10 -&gt; NULL

    freeList(head);
    return 0;
} 
</code></pre>
  </div>
 </div>
</div><h3 id="example-2-binary-tree-nodes">Example 2: Binary Tree Nodes</h3><p>A <strong>binary tree</strong> node contains data and pointers to left and right child nodes.</p><h3 id="defining-the-tree-node">Defining the Tree Node</h3><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-c">struct TreeNode {
    int data;
    struct TreeNode *left;
    struct TreeNode *right;
};</code></pre>
</div><h3 id="creating-a-new-node">Creating a New Node</h3><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-c">struct TreeNode* createNode(int value) {
    struct TreeNode *node = malloc(sizeof(struct TreeNode));
    if (node == NULL) {
        printf("Memory allocation failed\n");
        return NULL;
    }
    node-&gt;data = value;
    node-&gt;left = NULL;
    node-&gt;right = NULL;
    return node;
}</code></pre>
</div><h3 id="inserting-a-node-in-a-binary-search-tree-bst">Inserting a Node in a Binary Search Tree (BST)</h3><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-c">struct TreeNode* insertNode(struct TreeNode *root, int value) {
    if (root == NULL) {
        return createNode(value);
    }
    if (value &lt; root-&gt;data) {
        root-&gt;left = insertNode(root-&gt;left, value);
    } else {
        root-&gt;right = insertNode(root-&gt;right, value);
    }
    return root;
}</code></pre>
</div><h3 id="in-order-traversal">In-order Traversal</h3><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-c">void inorderTraversal(struct TreeNode *root) {
    if (root != NULL) {
        inorderTraversal(root-&gt;left);
        printf("%d ", root-&gt;data);
        inorderTraversal(root-&gt;right);
    }
}</code></pre>
</div><h3 id="freeing-the-tree">Freeing the Tree</h3><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-c">void freeTree(struct TreeNode *root) {
    if (root != NULL) {
        freeTree(root-&gt;left);
        freeTree(root-&gt;right);
        free(root);
    }
}</code></pre>
</div><h3 id="full-example-usage">Full Example Usage</h3><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-c">int main() {
    struct TreeNode *root = NULL;

    root = insertNode(root, 50);
    insertNode(root, 30);
    insertNode(root, 70);
    insertNode(root, 20);
    insertNode(root, 40);
    insertNode(root, 60);
    insertNode(root, 80);

    inorderTraversal(root);  // Output: 20 30 40 50 60 70 80

    freeTree(root);
    return 0;
}</code></pre>
</div><div class="snippet-container" id="ctzSQ">
 <div class="snippet-header" onclick="toggleSnippet('ctzSQ')">
  Click to view full runnable Code
 </div>
 <div class="snippet-body">
  <div class="code-block"><button class="copy-button" onclick="copyCode(this)">📋</button>
   <pre><code class="language-c">
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

// Define the binary tree node structure
struct TreeNode {
    int data;
    struct TreeNode *left;
    struct TreeNode *right;
};

// Create a new tree node
struct TreeNode* createNode(int value) {
    struct TreeNode *node = malloc(sizeof(struct TreeNode));
    if (node == NULL) {
        printf("Memory allocation failed\n");
        return NULL;
    }
    node-&gt;data = value;
    node-&gt;left = NULL;
    node-&gt;right = NULL;
    return node;
}

// Insert a node into the BST
struct TreeNode* insertNode(struct TreeNode *root, int value) {
    if (root == NULL) {
        return createNode(value);
    }
    if (value &lt; root-&gt;data) {
        root-&gt;left = insertNode(root-&gt;left, value);
    } else {
        root-&gt;right = insertNode(root-&gt;right, value);
    }
    return root;
}

// In-order traversal (left, root, right)
void inorderTraversal(struct TreeNode *root) {
    if (root != NULL) {
        inorderTraversal(root-&gt;left);
        printf("%d ", root-&gt;data);
        inorderTraversal(root-&gt;right);
    }
}

// Free all nodes of the tree
void freeTree(struct TreeNode *root) {
    if (root != NULL) {
        freeTree(root-&gt;left);
        freeTree(root-&gt;right);
        free(root);
    }
}

int main() {
    struct TreeNode *root = NULL;

    root = insertNode(root, 50);
    insertNode(root, 30);
    insertNode(root, 70);
    insertNode(root, 20);
    insertNode(root, 40);
    insertNode(root, 60);
    insertNode(root, 80);

    printf("In-order traversal: ");
    inorderTraversal(root);  // Expected output: 20 30 40 50 60 70 80
    printf("\n");

    freeTree(root);
    return 0;
} 
</code></pre>
  </div>
 </div>
</div><h3 id="summary">Summary</h3><ul>
 <li>Struct pointers enable the creation of dynamic, linked data structures.</li>
 <li>The arrow operator (<code>-&gt;</code>) allows intuitive access to struct members through pointers.</li>
 <li>Proper memory allocation (<code>malloc</code>) and deallocation (<code>free</code>) ensure safe management.</li>
 <li>Traversal and insertion functions typically use recursion or loops with struct pointers.</li>
 <li>Managing complex data structures effectively requires careful pointer handling and cleanup.</li>
</ul><p>With these examples, you’re well-equipped to implement and manipulate dynamic data structures using pointers to structs in C!</p><div class = "chapter-navi-section">
<a href="c-pointers-dynamic-memory-allocation-with-pointers.htm" class="nav-button prev">←</a>
<a href='c-pointers.htm#structures-and-pointers' class="nav-button toc-link">Index</a>
<a href="c-pointers-pointer-casting-and-void-pointers.htm" class="nav-button next">→</a>
</div>
<section class="download-section">
  <div class="book-cover" style="background-color: #f9f6f1;border: 1px solid #ccc;"> 
    <div class="book-cover-title" style="font-size: 22px;color: #333;top: 20px;">C Pointers</div>
    <div class="book-cover-author">readbytes</div>
    <div class="book-cover-bottom-stripe" style="background-color: #333;"></div>
    <img class="book-cover-icon" style="width: 90px;height: 90px;top: 70px;" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFoAAABaCAYAAAA4qEECAAAD5ElEQVR4Xu2dwYoUVxhGr7hQn0F8AyH4Cq5cCwFxk2cQ3GXR1TK+QN5AssnWrRsfwWR0LbhJxKXoIhBQK2Olb5/v1tdV0/fHOPwHDtj/PbdudYHOuKpSkiRJkovFUP744qevvuSyZSin1d5TLlvGs85/7re553OzO3DfJXDPRd97bobylxy49HC2tZvylvkem/Je9uz8wHyPTfmzsWeng23toXs+Ch5GHWypgy11sKUOtjQMHkQdbKmDLXWwpQ62NAweRB1sqYMtdbClDrY0DB5EHWypgy11sKUOtjQMHkQdbKmDLXWwpQ62NAweRB1sqYMtdbClDrY0DB5EHWypgy11sKUOtjQMHkQdbKmDLXWwpQ62NAweRB1sqYMtdbClDrY0SZIkSZI18CdpGqMM0hhlkMYogzRGGaQxyiCNUQZpjDJIY5RBGqMM0hhlkMYogzRGGaQxyiCNUQZpjDJIY5RBT5fAPfO+W7xvabe2PUYZ9HQpQ7kjeynh+lzLNbqmPUYZ9NR/iYcH1uevdagnXJ/8pVxZ1PVQBj1d8iUmfi7XZW3ns+pKO7TTc3t0PZRBT5d8ibVNDTvXsxnKr0waTT9l0NMlX2Ji/GvMNTZDeYrP/0hbr9ecp+mpDHp66EscWh/dlgfS1LCv14fypPrz3ar5u5rXvV6rlzLo6Rq4t3WNafZjuSyz1p6zB31J2pr9Xq/VSxn0dAlDuSr7WtfYltfN+fj79dye8UHvf/4dn9nr+b2UQU9rlszpo/LDbFczt8YHTbTXe+ilDHpaU8+35adq/lj2tfY75vZND7p1raF8lDVep6cy6GnNmrVW4xjK8+Y+/6Bbvd5DL2XQ0xqujb8FTGzKfVl/UK5Ve180rWmdWz/oobz5b74p92Z63mM/ZdDTGq4dWndrkyflRrPZzeoHPf6bf+tfeZ3WNXorg57WcO3M29X6zebeuf+UaHfSmO0/6Dl3va71UgY9reGaa1qzOVvtxKb8Jn1L7o9QBmmMMkhjlEEaowzSGGWQxiiDNEYZpDHKII1RBmmMMkhjlEEaowzSGGWQxiiDNEYZpDHKII0xSZIkSZI18CcpdbClDrbUwZY62NIweBB1sKUOttTBljrY0jB4EHWwpQ621MGWOtjSMHgQdbClDrbUwZY62NIweBB1sKUOttTBljrY0jB4EHWwpQ621MGWOtjSMHgQdbClDrbUwZY62NIweBB1sKUOttTBljrY0jB4EHWwpQ621MGWOtjSMKJeSjZe13HMS8m23+NLyUZ44JIbnuCei773aPZfpLjuJYzbI17CeNyLI+tzX3HZsn/uuntOkiRJ/vd8BnnbnC2TD9qmAAAAAElFTkSuQmCC"/>
  </div>
  <div class="download-info">
    <h2 id='bottom'>Download This Ebook</h2>
    <p class="format-label">Available formats:</p>
    <div class="download-buttons">
      <a href="c-pointers.pdf" class="download-button">📄 PDF</a>
      <a href="c-pointers.epub" class="download-button">📘 EPUB</a>
    </div>
  </div>
</section><div class='related-books'>
<h2>C Introduction Books</h2>
<div class='related-book-list'>
<a href="c-for-beginners.htm">
<div class="book-cover" style="background-color: #f9f6f1;border: 1px solid #ccc;"> 
    <div class="book-cover-title" style="font-size: 18px;color: #333;top: 20px;">C for Beginners</div>
    <div class="book-cover-author">readbytes</div>
    <div class="book-cover-bottom-stripe" style="background-color: #333;"></div>
    <img class="book-cover-icon" style="width: 90px;height: 90px;top: 70px;" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFoAAABaCAYAAAA4qEECAAAMTUlEQVR4Xu2ce3BU1R3Ho06nnT4cB/bubjYJudkk5MUrEAjIMxDyMAHMA3AgIFIetSg0QBAcCGgFgUGhEohEyqNOLDpWUBFGOq1MU1uh2FYgvK3+UWlHiMNLoCCc3t+5+7tz7u8+dvPa7Ib9znwnu797zj2/3+eenL139+5GRYWpElzSecWMxiNqI8lRUT8AwH16JrEI6HYSgAVvO7mFOwK6jUUBR0C3sRSQrwHMxb+uNECOgG4DybLM1+GMFNkANwK6jWS1TJjZH+gEp3Mq7g/tdTom03b3lJoDOBDQHKrbyVauWK5zksdt26/TyutyTILCH1843gCSmh4IK2AJbukwbFtUOc8AGpzdMwP63qL9Oq2aO4tpW0vQShyE+wdPLi/Twbbq26nUXMAUrh3omJiYrsmxHg4adOvWLfbymtW8LcTvCdBel/RvKHDz4Q0GgIHaH2gldgdnc1PTRQ04aOrE8TzeaUHLLtdAKOyRiTkGcM31+oNrNNhmsCBGRWOXL1827RvWgoLEWdgWtgMtS5I7OSZaB9ZM/dJSWYrD8RPaP+zUHoDRSTHqKRq3WzplNraVTjY2ssTOcIrndUofQxFrP3zBAKitLIK0AHYfxJsu6tdoPDi0cVgJXu2hiJ7pXgOYtvTWY7UG0AmSNBTz0Ga6iQdl9vY9dvxPzD1shIVQKO1lBC1C7BcV9T34+8SUCrZjxw7dwcC2EAeH3dWhkuydYAJG1xxaz0EtrKzU4MHz7du3a8+fWbCAA6WQxfZKCffTmkJKCb63L5/dudAAIVheVv+MKUAKkx4Aup3WFjKC5BKVV31aeEcYcnmtrs4AMFCHJGicHbTYjjTmhNDMTOGGLGjlsvkWJLT1eK2h0I42h+mWxiNUqvLiIjZn9iwNbEpcrA50SrdYFudweGjNQZXskiZC8uNnFRsKDBXjjFT+LrWCLc5qOsPhxTJDkn5Maw+W+Ml+osdlKCzUTP/1/YFesqgqNJYOnBW0oFBzte+Mg4KioLENOjU+LnRA06JCzZCj8rrBPlj9cwMoeJ4ud9MgU8FHW3VbtmiQ4UNgsX/QFMqgcVYCYLQZaNFU9Tt3srIxxR1/ZRiKoHtnqLd+vbV8hg5y74Q4Ayx4TpcG1M2bN3UHgfYNqkIJNLz7B/nk9k3TAd5aNRlBvWeW/4plywywRWdlpEdAoxGECBiXCjtA+MaSlcfl57HPz52z3UdQ1NGgWwpYFLQTVZw7ip05dUoXC3Rf7aaOAl1YPpwXXzNvog5wYf8ePC5LUh+aq5Uo6DF5uRHQNZ+ob3dmJnbTAd5VPZ3HldO4czRHf6Kgx+WPZqdPntTF7inQuBy0ZpkwEwX9aEEeO3XihC7WM8nb4v23iYIBur0AoyjoksICdqLxuC42avCgVo/TKrUn6IrKMg5y1YxxOsDT8gepkJ3OPJpPS0RBlxYVssZjx3SxwpzhnRM07Bcvm01m8Xc0j9ZIdkr7rl29qkEtL36EHT/6mYBZWU6U0zyl6X20b9DU1qDbe5kwk3JAp2+p2ahBHa9ccv/9yBEBsxIbq1yGJyV9n/YNmtoKdHpyPAe5+4XZOsApvhtf2rPIRElKGtq/nwZ1wrgx7NBfPhYwMza5vJQldenyIO0bNLUW9KItcznIitxsHeAV04p9y4djPR2zrRUb+2CXtPg4DeqkslLWcPCggJmxKRPKWXePx0H7Bk2tAe1nmbhDx2pH3Q9jftPUxK5/+y0bPXQw+8OBAzrQZcq63dJPVpTJUiy7HZtbdd9eS0D7Adwu67CdYMwbN26wghHD2Ijs/mzm1AqeB8zsL7/4gn36t8P8uSzLD9G+dsJ6slK87PGiHJbse6tVdkm/pW39qjmge/dS377cs1K/DvdOiOVxl8v1I7r/9haMe/v2bd3shdj+ve8ry8dHbGhWX1acOzKgCaC0WYlwwalxHvbm2iqDOWy3czntb6tAQG86tIHvvH93WQf4nednYlJn6H6DJRhf1JIF83lOVEP6ZTKPx/ND2t+nB6BPcoyL3T26mTX9eR3fBwVMYdOd2MofaDy6obJMmAlzASv/1rvg4ytRPbyyZa7YDwCjvW41RuG2C+hwAGwlETw40ekcbNLmGmy7ceQVHWQwxEF2sFNio5t3FkNB544dzAegb18WZffkca/DkUX3EU5KcHadAnWsmVdqAIxOjHayu3fvssajR1n/1EQDZPDkguEs3uUaSfdvKQS95R8bOcg05QVABLxHuQDxzYz/0L7hJpzhFKyZ/c3qFbMfg2/krqFjWAoHB4fjMhGIAgH8je8FENtlpajrer/uXgNkMK7jyu4foOOZqlMDdkunoY6mhnUGsHT2glH4fPnsYjb3sSIDZNzujY4OnJUIumriaLWj01lF24WT4qO7pkEdJSMyDVDtAIv6/OwZdbtyBoPt0H2nrWJDXzrC7YvdoDkYBA3fW/UkdrhJt4ebKBTwh7VzdYBfXlDO42+9UU/5aoLtCNPOfAy31EDzMAiTofFwkwiW/sJBYrSLx3EWi99JhLMLKhGyP+ABg4b7Imgs3CRCfnLGdMMvG4Dhk/Ekj4sl+paCsqJCrQ/6+WVL+d/Bq/6kgcye/xuWlp1vAIz2xsQEBjqchYBgpl5sUM8aKGDR2BZntm4GrzvMeuRV8DWZwrRzxvBSAH2S5tYp5HVJFwDOlU/Wa+AqJ+dqM5MCDgi0CUTwgHnbDDHRAxe/rfR3fIlj01zDUrLT+SgUs+SJAtMziOvXrzP4SMsKNgV96dIle9Dr1LdXDXHBSd3VG37O/1H92Qqac9gJZwwFjP7vR2tYSlyMBo5CpqDB2WleHkNnzdqgARzwi+22kNWZLLFpxQ/rDh7NO2zkD7BoaGcFev5T6oUY7SP2paZw0VY5hSVoJeljkDi8yNGC0P/a/0teXLJHfR9ZBAZw+6QkG+CB66orDO2prECbAQ5L0PDbG5DwyH6phkJoUQho8fxK/rhhx0LdtsxJ1QZQKb18N+/4TD9bRHVq0Fg8LYAWg4Cp4EIFtvV/us4AiMICL1EOEJV4EAYtedu0L80pbEAHArg0J5O3OX1Kf5eoKNg+ZO1fDXCozUDDvXkQe7W2VvvmQGK08GMsgmluIQ9aSWwvJHf0d0sNSaO/++cmrUA7wfbshfUcZEbOBN3VHXWirJ5tAGg4JcT9i1/PsHK4gjYka2YRND5Gv7T6RVYwYjjzKrOPzloKGJ29oF63D8zl1drNGkwK2A40viiHNGg0TZ765LvqeTDq9e3bWHJqHz577aBaWR3XUWeWCxrWfH+gxfxDGjTosnKFBo9HBXCmgfIH9+Hl+w0xI2j1A9p4ScpU/r5/8cIFbd8wnjhTRVPAYn60xpCQCA4ENyJCrHF3tQEyFnLVd3suPKbwRIg0Jnrgs+/wNsWDe7EPNs6Bx28mREvD5sz8qbZvOraYA/hA3TzTbbTGkBAFjTKbLegesnpXFBouhQ2Q1x02wBW3i/tWQTteh3zS5Xjd+LB00PHN8hLzoTWGhMSCzEShUIsFoilYK8Bo34zWjOPy/NzSJni8V2ljBnpibhZ/nuTuko716CsMEWkFuRyH4PG5s2cIasbOf/UVL6Ysp69W4Oq5JTy29909urZWoCG+aGq+ATKCnjV1itYfTfLkP9h15zMV9M1P1XcIFV8n7UIbtPgcbCb80rxdG4hTyAiaAtZA16gzmu5HzAsljk+3gaziHS6rxPzBpJowtlgDkFnxXLNByy5nPfbPGzYEQZr+bJtVziC7bR0qu8RkT9dU2F5SmK+DKoKGe6LhOfxOEp7npsV306CLpoDR+2qe4qBx3AS3e4BdXvbbnL+nsZCQXdIopc1ZaHf1yhUdaARILyjMbAd69/qfAeg36LhWCiTnkFNzkqYzFGMiTArYH2jcVwS0icQ+FDTaH2hsB4/3b+JLRwQ0lR1oAHft8K900EWoeFrYsF39gICD3vx0BLSZ/IE2M8JO6+Yx3dYc0PeMRNCyy1H/XHW1Yekwg0lj08eoN9wnuF2vRECbiM9Ap7QP/sLtBTir8QDEux058Lhqap4laDwgvL3TWRoBbSKEJEoEJ7Tjv68qgjZrp4AuadH3Bju7EBT8vfD11zrYUSa/XoBwrbYDaG8EtFHijBQhgmW3o1Zsi6KzWFS8s2uJsn0Xjd/zsoJmFQfZbZPdD8kJbmkOjd/zsoNmpZb0iagFioAOkiKgg6SOAv1/XbvZ5NyymN4AAAAASUVORK5CYII="/>
  </div>
</a>


<a href="c-pointers.htm">
<div class="book-cover" style="background-color: #f9f6f1;border: 1px solid #ccc;"> 
    <div class="book-cover-title" style="font-size: 22px;color: #333;top: 20px;">C Pointers</div>
    <div class="book-cover-author">readbytes</div>
    <div class="book-cover-bottom-stripe" style="background-color: #333;"></div>
    <img class="book-cover-icon" style="width: 90px;height: 90px;top: 70px;" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFoAAABaCAYAAAA4qEECAAAD5ElEQVR4Xu2dwYoUVxhGr7hQn0F8AyH4Cq5cCwFxk2cQ3GXR1TK+QN5AssnWrRsfwWR0LbhJxKXoIhBQK2Olb5/v1tdV0/fHOPwHDtj/PbdudYHOuKpSkiRJkovFUP744qevvuSyZSin1d5TLlvGs85/7re553OzO3DfJXDPRd97bobylxy49HC2tZvylvkem/Je9uz8wHyPTfmzsWeng23toXs+Ch5GHWypgy11sKUOtjQMHkQdbKmDLXWwpQ62NAweRB1sqYMtdbClDrY0DB5EHWypgy11sKUOtjQMHkQdbKmDLXWwpQ62NAweRB1sqYMtdbClDrY0DB5EHWypgy11sKUOtjQMHkQdbKmDLXWwpQ62NAweRB1sqYMtdbClDrY0SZIkSZI18CdpGqMM0hhlkMYogzRGGaQxyiCNUQZpjDJIY5RBGqMM0hhlkMYogzRGGaQxyiCNUQZpjDJIY5RBT5fAPfO+W7xvabe2PUYZ9HQpQ7kjeynh+lzLNbqmPUYZ9NR/iYcH1uevdagnXJ/8pVxZ1PVQBj1d8iUmfi7XZW3ns+pKO7TTc3t0PZRBT5d8ibVNDTvXsxnKr0waTT9l0NMlX2Ji/GvMNTZDeYrP/0hbr9ecp+mpDHp66EscWh/dlgfS1LCv14fypPrz3ar5u5rXvV6rlzLo6Rq4t3WNafZjuSyz1p6zB31J2pr9Xq/VSxn0dAlDuSr7WtfYltfN+fj79dye8UHvf/4dn9nr+b2UQU9rlszpo/LDbFczt8YHTbTXe+ilDHpaU8+35adq/lj2tfY75vZND7p1raF8lDVep6cy6GnNmrVW4xjK8+Y+/6Bbvd5DL2XQ0xqujb8FTGzKfVl/UK5Ve180rWmdWz/oobz5b74p92Z63mM/ZdDTGq4dWndrkyflRrPZzeoHPf6bf+tfeZ3WNXorg57WcO3M29X6zebeuf+UaHfSmO0/6Dl3va71UgY9reGaa1qzOVvtxKb8Jn1L7o9QBmmMMkhjlEEaowzSGGWQxiiDNEYZpDHKII1RBmmMMkhjlEEaowzSGGWQxiiDNEYZpDHKII0xSZIkSZI18CcpdbClDrbUwZY62NIweBB1sKUOttTBljrY0jB4EHWwpQ621MGWOtjSMHgQdbClDrbUwZY62NIweBB1sKUOttTBljrY0jB4EHWwpQ621MGWOtjSMHgQdbClDrbUwZY62NIweBB1sKUOttTBljrY0jB4EHWwpQ621MGWOtjSMKJeSjZe13HMS8m23+NLyUZ44JIbnuCei773aPZfpLjuJYzbI17CeNyLI+tzX3HZsn/uuntOkiRJ/vd8BnnbnC2TD9qmAAAAAElFTkSuQmCC"/>
  </div>
</a>



<a href='c.htm'><div class='book-cover' style='background-color: #f9f6f1;color: #111111;border: 1px solid #ccc;display: flex;justify-content: center;align-items: center;text-align: center;'>More C Books</div></a>
</div>
</div>
  </div>
  <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/prism.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script>
  function toggleSnippet(id) {
      const box = document.getElementById(id);
      box.classList.toggle("open");
  }  
  </script>
  <script>
    function copyCode(button) {
      const code = button.nextElementSibling.innerText;
      navigator.clipboard.writeText(code).then(() => {
        button.textContent = 'Copied!';
        setTimeout(() => { button.textContent = 'Copy'; }, 1500);
      });
    }
  </script>  
<div id="floatingLog" aria-live="polite" role="alert"></div>
<footer class="page-footer">
    <nav>
      <a href="https://readbytes.github.io">Home</a> | 
      Email:<script language="JavaScript" type="text/javascript">
var part1 = 'yinpeng';var part6 = '263';var part2 = Math.pow(2,6);var part3 = String.fromCharCode(part2);var part4 = 'hotmail dot com';var part5 = part1 + String.fromCharCode(part2) + part4;document.write(part1 + part6 + part3 + part4);
</script>
    </nav>
  <p>© 2025 — All rights reserved.</p>    
  </footer>

</body>
</html>