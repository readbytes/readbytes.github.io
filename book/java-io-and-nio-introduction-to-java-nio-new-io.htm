<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Java IO and NIO Introduction to Java NIO (New IO)</title>
<link rel='shortcut icon' href='https://java2s.com/style/favicon.ico'>
<link href="https://fonts.googleapis.com/css2?family=Merriweather&display=swap" rel="stylesheet" />
<link href="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet" />


  <script>
  const mode = localStorage.getItem('mode') || 'light';
  document.documentElement.classList.add(`${mode}-mode`);
  </script>   
<style> 
html {
  scroll-behavior: smooth;
}

body {
  font-family: 'Merriweather', serif;
  margin: 0;
  padding: 2rem 1rem;
  font-size: 15px;
  line-height: 1.5;
  transition: background-color 0.3s, color 0.3s;
}

.container {
  max-width: 700px;
  margin: 0 auto;
  padding: 1rem 2rem;
  box-shadow: 0 0 15px rgba(0,0,0,0.1);
}

h1, h2, h3 {
  font-weight: 600;
  margin-top: 2.5rem;
  margin-bottom: 1rem;
  line-height: 1.2;
}

h1 { font-size: 1.8rem; }
h2 { font-size: 1.4rem; }
h3 { font-size: 1.2rem; }

table {
  width: 100%;
  border-collapse: collapse;
  font-family: sans-serif;
  font-size: 1em;
  margin: 1em 0;
}

th, td {
  padding: 0.6em 1em;
  text-align: left;
  border: 1px solid;
}

tr:nth-child(even) {
  background-color: inherit;
}

tr:hover {
  background-color: inherit;
}

a {
  text-decoration: none;
  transition: color 0.2s;
}

a:hover {
  text-decoration: underline;
}

code {
  color: #d35400;
}

.book-title-chapter {
  font-family: 'Merriweather', serif;
  font-size: 2rem;
  font-weight: bold;
  text-align: center;
  margin-bottom: 2rem;
  border-bottom: 2px solid;
  padding-bottom: 0.5rem;
}

.book-subtitle-chapter {
  text-align: center;
  font-size: 1rem;
  margin-top: -1rem;
  margin-bottom: 2rem;
}

.related-books {
  margin-top: 40px;
}

.related-book-list {
  display: flex;
  flex-wrap: wrap;
  gap: 20px;
}

    .book-cover {
      width: 130px;
      height: 180px;
      font-family: Arial, sans-serif;
      position: relative;
      overflow: hidden;      
      line-height: normal;
      box-shadow: 2px 2px 4px rgba(0,0,0,0.1);
    }
    .book-cover-bottom-stripe {
      position: absolute;
      bottom: 0;
      left: 0;
      height: 5px;
      width: 100%;
    }
    .book-cover-title {
      position: absolute;
      width: 100%;
      text-align: center;
      font-weight: bold;
    }
     
    .book-cover-icon {
      position: absolute;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      align-items: center;
      justify-content: center; 
    }

    .book-cover-author {
      position: absolute;
      bottom: 10px;
      width: 100%;
      text-align: center;
      font-size: 8px;
      color: #333;
    }

.page-footer {
  margin-top: 4rem;
  padding: 1rem 0;
  text-align: center;
  font-size: 0.85rem;
  border-top: 1px solid;
}

.chapter-navi-section {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding-bottom: 10px;
}

.nav-link {
  color: inherit;
  text-decoration: none;
  opacity: 0.5;
  transition: opacity 0.3s ease, text-decoration 0.3s ease;
}

.nav-link:hover {
  opacity: 0.9;
  text-decoration: underline;
}

.prev { text-align: left; }
.toc-link { text-align: center; }
.next { text-align: right; }

.download-section {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 2rem;
  padding: 2rem 1rem;
  max-width: 600px;
  margin: 3rem auto;
  border-radius: 12px;
  box-shadow: 0 4px 10px rgba(0,0,0,0.05);
}

.download-info h2 {
  margin: 0 0 0.5rem;
  font-size: 1.2rem;
}

.format-label {
  margin: 0 0 0.5rem;
  font-size: 0.95rem;
}

.download-buttons {
  display: flex;
  gap: 1rem;
}

.download-button {
  background-color: #4A90E2;
  color: white;
  padding: 0.5em 1.2em;
  border-radius: 25px;
  font-size: 0.95rem;
  text-decoration: none;
  transition: background-color 0.3s ease;
}

.download-button:hover {
  background-color: #357ABD;
}

.code-block {
  position: relative;
  margin-bottom: 1em;
}

.copy-button {
  background: transparent;
  color: white;
  position: absolute;
  top: 8px;
  right: 8px;
  border: none;
  padding: 4px 8px;
  font-size: 12px;
  border-radius: 4px;
  cursor: pointer;
  z-index: 1;
}

.copy-button:hover {
  background-color: #0056b3;
}

.snippet-container {
  overflow: hidden;
}

.snippet-header {
  padding: 0.75rem 1rem;
  cursor: pointer;
  font-size: 1rem;
    background-color: #eeeeee;
    color:  #111111; 
    border-radius: 8px;
    cursor: pointer;
    box-shadow: 0 4px 6px rgba(0,0,0,0.1);  
}

.snippet-body {
  display: none;
  font-family: monospace;
}

.snippet-container.open .snippet-body {
  display: block;
}

.CodeMirror {
  border: 2px solid #ccc;
  border-radius: 4px;
  resize: vertical;
}

/* === Light Mode === */
html.light-mode {
  background-color: #f8f7f5;
  color: #333;
}

html.light-mode .container {
  background: white;
}

html.light-mode .book-title-chapter {
  color: #2c3e50;
  border-color: #ccc;
}
html.light-mode .book-subtitle-chapter{
  color: #888;
}

html.light-mode .page-footer,
html.light-mode .series-name,
html.light-mode .book-subtitle,
html.light-mode .format-label {
  color: #888;
}

html.light-mode .related-books h2 {
  color: #333;
  border-bottom: 2px solid #eee;
}

html.light-mode .book-title {
  color: #fff;
}

html.light-mode .book-cover {
  border: 1px solid #ccc;
}

html.light-mode th {
  background-color: #f2f2f2;
}

html.light-mode tr:nth-child(even) {
  background-color: #fafafa;
}

html.light-mode tr:hover {
  background-color: #e6f7ff;
}

html.light-mode a,
html.light-mode .page-footer a {
  color: #000;
}

/* === Dark Mode === */
html.dark-mode {
  background-color: #181818;
  color: #e0e0e0;
}

html.dark-mode .container {
  background: #222;
}

html.dark-mode .book-title-chapter {
  color: #ddd;
  border-color: #444;
}

html.dark-mode .snippet-header {
    background-color: #333;
    color:  #ddd; 
}


html.dark-mode .book-subtitle-chapter,
html.dark-mode .page-footer,
html.dark-mode .series-name,
html.dark-mode .book-subtitle,
html.dark-mode .book-footer,
html.dark-mode .format-label {
  color: #aaa;
}

html.dark-mode .related-books h2 {
  color: #ddd;
  border-bottom: 2px solid #333;
}

html.dark-mode .book-title {
  color: #fff;
}

html.dark-mode .book-cover {
  border: 1px solid #555;
}

html.dark-mode th {
  background-color: #333;
  color: #fff;
}

html.dark-mode td {
  border-color: #444;
}

html.dark-mode tr:nth-child(even) {
  background-color: #2a2a2a;
}

html.dark-mode tr:hover {
  background-color: #2c3e50;
}

html.dark-mode a,
html.dark-mode .page-footer a {
  color: #eee;
}

    .dialog-backdrop {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: rgba(0,0,0,0.5);
      display: none;
      justify-content: center;
      align-items: center;
      z-index: 10;
    }

    .dialog {
      background: white;
      padding: 20px;
      width: 90vw;
      height: 80vh;
      border-radius: 8px;
      box-shadow: 0 0 20px rgba(0,0,0,0.3);
      display: flex;
      flex-direction: column;
    }
    .dialog-content {
      display: flex;
      flex: 1;
      gap: 20px;
      margin-top: 10px;
    }
    .dialog h2 {
      margin-top: 0;
    }

    .textarea_dialog {
      width: 50%;
      height: 100%;
      resize: none;
      font-family: monospace;
      font-size: 14px;
      padding: 10px;
      box-sizing: border-box;
      border: 1px solid #ccc;
    }

    .iframe_dialog {
      width: 50%;
      height: 100%;
      border: 1px solid #ccc;
    }
    .controls_dialog {
      display: flex;
      justify-content: space-between;
      margin-top: 10px;
    }    
    button { padding: 0.5em 1em; background: green; color: white; border: none; cursor: pointer; }
    button:hover { background: #1e7e34; }
    .result_iframe { width:99%; height:200px; margin-top: 1em;  resize: both;border:1px solid #ccc;}        
</style>
</head>
<body> 
  <div class="container">
    <div class = "chapter-navi-section">
<a href="java-io-and-nio-advanced-java-io-concepts.htm" class="nav-button prev">‚Üê</a>
<a href='java-io-and-nio.htm#introduction-to-java-nio-new-io' class="nav-button toc-link">Index</a>
<a href="java-io-and-nio-buffers-and-channels.htm" class="nav-button next">‚Üí</a>
</div>

    <h1 class="book-title-chapter" id = 'top'>Introduction to Java NIO (New IO)</h1>
    <h3 class="book-subtitle-chapter">Java IO and NIO</h3>   
    <!-- <h1 class ="chapter-title"></h1> -->
    <h2 id='motivation-behind-nio'>5.1 Motivation Behind NIO</h2><p>Java‚Äôs original IO (Input/Output) API, introduced in the early versions of Java, provides a straightforward, stream-based approach to reading and writing data. While it served the needs of many applications, especially desktop and simple server programs, it soon showed limitations in scalability, performance, and flexibility ‚Äî particularly for modern networked and high-throughput applications. This led to the development and introduction of <strong>Java NIO (New IO)</strong> in Java 1.4, a major overhaul designed to address these challenges.</p><h3 id="limitations-of-the-original-java-io-api">Limitations of the Original Java IO API</h3><p>The classic Java IO API is built on the concept of <strong>blocking, stream-oriented IO</strong>:</p><ul>
 <li><p><strong>Blocking IO</strong>: When a thread reads from or writes to a stream, it blocks ‚Äî that is, it waits until the operation completes before continuing execution. For example, reading from a socket or file input stream suspends the thread until data is available or the end of the stream is reached.</p></li>
 <li><p><strong>Stream-Oriented</strong>: Data is read or written sequentially as a flow of bytes or characters.</p></li>
</ul><p>While this model is simple and intuitive, it has several drawbacks in high-performance or large-scale applications:</p><h4 id="blocking-threads-wastes-resources">Blocking Threads Wastes Resources</h4><p>Because IO operations block the calling thread, each connection or file operation typically requires its own thread. In server applications handling thousands of simultaneous connections, this can lead to:</p><ul>
 <li><strong>Thread proliferation</strong>: Creating and managing a large number of threads consumes system memory and CPU time.</li>
 <li><strong>Context switching overhead</strong>: The operating system must frequently switch between many threads, degrading performance.</li>
 <li><strong>Difficult concurrency management</strong>: Writing thread-safe code with many threads is complex and error-prone.</li>
</ul><h4 id="poor-scalability">Poor Scalability</h4><p>Blocking IO works well for applications with a small number of IO channels, but as the number of concurrent connections grows, performance and scalability suffer:</p><ul>
 <li>Servers using one thread per client eventually reach resource limits.</li>
 <li>High latency and lower throughput result from thread contention and blocking waits.</li>
</ul><h4 id="lack-of-fine-grained-control">Lack of Fine-Grained Control</h4><p>The old IO API offers limited control over buffering, multiplexing, or non-blocking operations. Developers often have to rely on platform-specific or third-party tools to handle efficient, scalable IO.</p><h3 id="why-was-java-nio-introduced">Why Was Java NIO Introduced?</h3><p>Java NIO was introduced in Java 1.4 to provide a <strong>new foundation for scalable, high-performance IO operations</strong> in Java applications. Its design goals include:</p><ul>
 <li><strong>Non-blocking IO</strong>: Allow threads to initiate IO operations without waiting for completion, enabling a single thread to manage many IO channels.</li>
 <li><strong>Selectors for multiplexing</strong>: Efficiently monitor multiple channels for readiness, avoiding the need for many threads.</li>
 <li><strong>Buffer-oriented data handling</strong>: Use explicit buffers for reading and writing, enabling fine-grained control of data transfer.</li>
 <li><strong>Improved performance and scalability</strong>: Reduce overhead and improve responsiveness, especially in server and network applications.</li>
 <li><strong>Platform independence</strong>: Provide a consistent, portable API that abstracts underlying OS features like epoll, kqueue, or IOCP.</li>
</ul><h3 id="core-concepts-and-features-of-java-nio">Core Concepts and Features of Java NIO</h3><ul>
 <li><p><strong>Buffers</strong>: Unlike stream IO, NIO uses <strong>buffers</strong>‚Äîcontainers for fixed-size data arrays‚Äîwhich must be explicitly flipped, cleared, or compacted. This explicit data management improves efficiency and control.</p></li>
 <li><p><strong>Channels</strong>: Channels are like bidirectional IO pipes representing connections to files, sockets, or other IO entities. They can be non-blocking and allow asynchronous operations.</p></li>
 <li><p><strong>Selectors</strong>: Selectors let a single thread <strong>monitor multiple channels</strong> for events such as readiness to read or write, enabling multiplexed, non-blocking IO.</p></li>
</ul><h3 id="how-nio-improves-scalability-and-efficiency">How NIO Improves Scalability and Efficiency</h3><ul>
 <li><p><strong>Single-thread multiplexing</strong>: Instead of dedicating one thread per connection, one thread can handle thousands of connections by using selectors to react when channels are ready for IO.</p></li>
 <li><p><strong>Reduced context switching</strong>: Fewer threads mean less overhead from context switches and lower memory consumption.</p></li>
 <li><p><strong>Non-blocking mode</strong>: Threads don‚Äôt block waiting on IO; they continue executing, enhancing throughput and responsiveness.</p></li>
 <li><p><strong>Direct buffers</strong>: NIO supports direct buffers that interact more efficiently with the underlying OS and hardware, reducing copying and improving performance.</p></li>
 <li><p><strong>Asynchronous file and network IO</strong>: Some NIO APIs support asynchronous operations for even greater concurrency.</p></li>
</ul><h3 id="real-world-scenarios-where-nio-shines">Real-World Scenarios Where NIO Shines</h3><h4 id="high-performance-servers">High-Performance Servers</h4><p>Web servers, chat servers, game servers, and other network applications that handle thousands or millions of simultaneous connections benefit from NIO‚Äôs ability to multiplex many channels with a limited number of threads.</p><p>For example, a web server using NIO can manage many thousands of client sockets without allocating one thread per client, conserving system resources and improving response times.</p><h4 id="event-driven-architectures">Event-Driven Architectures</h4><p>NIO‚Äôs selector mechanism fits well with event-driven programming models, where IO readiness triggers events that drive application logic, such as in frameworks like Netty or Vert.x.</p><h4 id="file-processing-applications">File Processing Applications</h4><p>NIO‚Äôs memory-mapped files and efficient channel operations improve performance in applications that process large files or perform random access reads/writes.</p><h4 id="real-time-or-interactive-applications">Real-Time or Interactive Applications</h4><p>Applications that require low latency and high throughput, such as financial trading platforms or multimedia streaming, use NIO to avoid blocking delays and improve responsiveness.</p><h3 id="recap">Recap</h3><p>Java‚Äôs original IO API is simple and stream-based but suffers from blocking behavior and scalability issues when handling many simultaneous IO operations. <strong>Java NIO</strong> was introduced to overcome these limitations by providing:</p><ul>
 <li>Non-blocking IO capabilities,</li>
 <li>Efficient multiplexing through selectors,</li>
 <li>Explicit buffer management,</li>
 <li>Better scalability and resource efficiency.</li>
</ul><p>These improvements make NIO especially suitable for modern server applications, event-driven systems, and high-performance file processing, enabling Java applications to meet today‚Äôs demanding performance and scalability requirements.</p><div class = "chapter-navi-section">
<a href="#top" class="nav-button prev">‚Üë</a>
<a href='java-io-and-nio.htm#introduction-to-java-nio-new-io' class="nav-button toc-link">Index</a>
<a href="#bottom" class="nav-button next">‚Üì</a>
</div>
<h2 id='core-concepts-buffers-channels-and-selectors'>5.2 Core Concepts: Buffers, Channels, and Selectors</h2><p>Java NIO (New IO) introduces a new architecture for handling IO in Java applications, designed to improve scalability, efficiency, and control. The foundation of this architecture rests on three core components: <strong>Buffers</strong>, <strong>Channels</strong>, and <strong>Selectors</strong>. Understanding these concepts and how they interact is essential to effectively leveraging Java NIO‚Äôs power, especially in non-blocking IO operations.</p><h3 id="buffers-containers-for-data">Buffers: Containers for Data</h3><p>At the heart of NIO‚Äôs data handling is the <strong>Buffer</strong>. Unlike the classic Java IO‚Äôs stream-based sequential access, NIO adopts a <strong>buffer-oriented</strong> model.</p><h4 id="what-is-a-buffer">What is a Buffer?</h4><p>A <strong>Buffer</strong> is a fixed-size block of memory that holds data to be read or written. It acts as a container or workspace where bytes or other primitive data types are stored before they are transferred to or from an IO source.</p><p>Buffers in NIO come in several types corresponding to different primitive data:</p><ul>
 <li><code>ByteBuffer</code> (most common)</li>
 <li><code>CharBuffer</code></li>
 <li><code>IntBuffer</code></li>
 <li><code>FloatBuffer</code></li>
 <li>...and more.</li>
</ul><h4 id="buffer-structure-and-key-properties">Buffer Structure and Key Properties</h4><p>Each buffer maintains:</p><ul>
 <li><strong>Capacity</strong>: The total size of the buffer.</li>
 <li><strong>Position</strong>: The current index where the next read or write will occur.</li>
 <li><strong>Limit</strong>: The index one past the last valid data element (for reading) or the maximum writable position.</li>
</ul><p>Before reading from or writing to a buffer, you manipulate these properties via methods like:</p><ul>
 <li><code>clear()</code>: Prepares the buffer for writing (position set to 0, limit set to capacity).</li>
 <li><code>flip()</code>: Prepares the buffer for reading after writing (limit set to current position, position reset to 0).</li>
 <li><code>rewind()</code>: Resets position to 0 to reread data.</li>
 <li><code>compact()</code>: Moves unread data to the start for additional writing.</li>
</ul><h3 id="analogy-buffer-as-a-container">Analogy: Buffer as a Container</h3><p>Think of a buffer like a glass container:</p><ul>
 <li><strong>Capacity</strong> = size of the container.</li>
 <li><strong>Position</strong> = where you‚Äôre currently pouring liquid in or scooping liquid out.</li>
 <li><strong>Limit</strong> = the maximum level of liquid that you‚Äôre allowed to read/write.</li>
</ul><p>Before drinking (reading) from the glass, you first pour (write) some liquid, then flip your intention to drinking by resetting the position to the start.</p><h3 id="channels-the-data-pathways">Channels: The Data Pathways</h3><p>While buffers hold data, <strong>Channels</strong> are the conduits or pipes that connect buffers to IO devices like files, network sockets, or pipes.</p><h4 id="what-is-a-channel">What is a Channel?</h4><p>A <strong>Channel</strong> is a bi-directional communication channel for reading, writing, or both, between a Java program and an IO source/sink.</p><ul>
 <li>Channels can be <strong>readable</strong>, <strong>writable</strong>, or both.</li>
 <li>They represent entities such as files (<code>FileChannel</code>), sockets (<code>SocketChannel</code>), and datagram connections (<code>DatagramChannel</code>).</li>
</ul><h4 id="how-channels-work-with-buffers">How Channels Work with Buffers</h4><p>Channels do not operate on streams of bytes like old IO; instead, they <strong>transfer data to or from buffers</strong>.</p><ul>
 <li>To <strong>read</strong> data, a channel fills a buffer.</li>
 <li>To <strong>write</strong> data, a channel drains data from a buffer.</li>
</ul><p>Because buffers are containers, this separation allows for efficient, flexible data handling.</p><h3 id="example-reading-from-a-file-using-channel-and-buffer">Example: Reading from a File Using Channel and Buffer</h3><div class="code-block"><button class="copy-button" onclick="copyCode(this)">üìã</button>
 <pre><code class="language-java">import java.nio.*;
import java.nio.channels.*;
import java.nio.file.*;

public class FileReadExample {
    public static void main(String[] args) throws Exception {
        Path path = Paths.get("example.txt");
        try (FileChannel fileChannel = FileChannel.open(path, StandardOpenOption.READ)) {
            ByteBuffer buffer = ByteBuffer.allocate(1024);

            int bytesRead = fileChannel.read(buffer);
            while (bytesRead != -1) {
                buffer.flip(); // Prepare buffer for reading

                while (buffer.hasRemaining()) {
                    System.out.print((char) buffer.get()); // Read bytes from buffer
                }
                buffer.clear(); // Prepare buffer for next read
                bytesRead = fileChannel.read(buffer);
            }
        }
    }
}</code></pre>
</div><p>This example shows how the <code>FileChannel</code> reads data into a <code>ByteBuffer</code>, then the program reads from the buffer.</p><h3 id="selectors-multiplexing-multiple-channels">Selectors: Multiplexing Multiple Channels</h3><p>One of the most powerful features of NIO is the <strong>Selector</strong>, which enables a single thread to monitor multiple channels for events, such as readiness to read or write.</p><h3 id="what-is-a-selector">What is a Selector?</h3><p>A <strong>Selector</strong> is an object that can <strong>monitor multiple channels</strong> simultaneously, waiting for events on any of them without blocking the thread.</p><p>Instead of dedicating one thread per connection or file operation (as in traditional blocking IO), a Selector lets a single thread react when any registered channel is ready for IO.</p><h3 id="how-does-a-selector-work">How Does a Selector Work?</h3><ol>
 <li>You register multiple channels with the selector, specifying interest operations (e.g., OP_READ, OP_WRITE).</li>
 <li>The selector blocks until at least one channel is ready.</li>
 <li>It provides a set of <strong>SelectionKeys</strong>, representing channels ready for IO.</li>
 <li>Your program handles these ready channels accordingly.</li>
</ol><h3 id="analogy-selector-as-a-traffic-controller">Analogy: Selector as a Traffic Controller</h3><p>Imagine a traffic controller watching multiple roads (channels). Instead of blocking at each road, the controller waits until a vehicle arrives on any road and directs traffic accordingly. This approach avoids idle waiting at each road and efficiently manages multiple lanes with fewer resources.</p><h3 id="example-registering-a-channel-with-a-selector">Example: Registering a Channel with a Selector</h3><div class="code-block"><button class="copy-button" onclick="copyCode(this)">üìã</button>
 <pre><code class="language-java">import java.nio.channels.*;
import java.net.InetSocketAddress;

public class SelectorExample {
    public static void main(String[] args) throws Exception {
        Selector selector = Selector.open();

        // Open a socket channel and configure non-blocking mode
        SocketChannel socketChannel = SocketChannel.open();
        socketChannel.configureBlocking(false);

        // Connect to server
        socketChannel.connect(new InetSocketAddress("example.com", 80));

        // Register channel with selector for connect events
        socketChannel.register(selector, SelectionKey.OP_CONNECT);

        while (true) {
            selector.select(); // Wait for ready channels

            for (SelectionKey key : selector.selectedKeys()) {
                if (key.isConnectable()) {
                    // Finish connection process...
                }
                // Handle other events...
            }
            selector.selectedKeys().clear(); // Clear handled keys
        }
    }
}</code></pre>
</div><h3 id="how-buffers-channels-and-selectors-work-together">How Buffers, Channels, and Selectors Work Together</h3><ul>
 <li><strong>Buffers</strong> hold the data being read or written.</li>
 <li><strong>Channels</strong> transfer data between buffers and IO sources/sinks.</li>
 <li><strong>Selectors</strong> allow a single thread to efficiently manage multiple channels, waiting for events and enabling non-blocking IO.</li>
</ul><p>Together, they enable scalable, high-performance applications where threads do not block waiting for IO but instead react to readiness events, reading/writing data in controlled buffer chunks.</p><h3 id="summary">Summary</h3><ul>
 <li><strong>Buffers</strong>: Fixed-size containers managing data with explicit control over reading/writing positions.</li>
 <li><strong>Channels</strong>: Data conduits connecting buffers with IO sources or destinations.</li>
 <li><strong>Selectors</strong>: Multiplexers that monitor multiple channels for IO readiness, allowing efficient non-blocking IO with few threads.</li>
</ul><p>This architecture contrasts with classic blocking IO and enables modern applications such as high-performance servers, real-time systems, and event-driven frameworks to handle large numbers of simultaneous IO operations efficiently.</p><div class = "chapter-navi-section">
<a href="#top" class="nav-button prev">‚Üë</a>
<a href='java-io-and-nio.htm#introduction-to-java-nio-new-io' class="nav-button toc-link">Index</a>
<a href="#bottom" class="nav-button next">‚Üì</a>
</div>
<h2 id='differences-between-io-and-nio'>5.3 Differences Between IO and NIO</h2><p>Java provides two main APIs for input/output operations: <strong>Traditional Java IO</strong> (introduced in Java 1.0) and <strong>Java NIO</strong> (New IO, introduced in Java 1.4). Both enable reading and writing data, but they differ significantly in design philosophy, performance characteristics, and typical use cases.</p><p>Understanding these differences is crucial when choosing the right approach for your application, especially when dealing with scalable or high-performance IO needs.</p><h3 id="blocking-vs-non-blocking-io">Blocking vs Non-Blocking IO</h3><h4 id="traditional-java-io-blocking-io">Traditional Java IO: Blocking IO</h4><p>Traditional Java IO is built on <strong>blocking IO</strong>. When a thread calls a read or write operation on an InputStream or OutputStream, it <strong>blocks</strong>, meaning the thread waits until the data is fully read or written before proceeding.</p><p><strong>Example:</strong></p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">‚ñØ</button>
 <pre><code class="language-java">InputStream input = new FileInputStream("file.txt");
int data = input.read();  // Blocks until a byte is available or EOF</code></pre>
</div><p><strong>Implications:</strong></p><ul>
 <li>Each blocking operation consumes a thread, which must wait idly.</li>
 <li>For network servers, this often means one thread per client connection.</li>
 <li>Excessive threads cause overhead from context switching and memory usage.</li>
 <li>Scaling to thousands of concurrent connections is challenging.</li>
</ul><h4 id="java-nio-non-blocking-io">Java NIO: Non-Blocking IO</h4><p>Java NIO introduces <strong>non-blocking IO</strong> and <strong>selectors</strong>, enabling a single thread to manage multiple channels (connections) without waiting.</p><p>Channels can be configured to non-blocking mode, so calls like <code>read()</code> or <code>write()</code> return immediately:</p><ul>
 <li>If data is available, they read/write some or all data.</li>
 <li>If no data is available, they return zero or a special value, letting the thread continue other work.</li>
</ul><p>A <strong>Selector</strong> monitors many channels, notifying when one or more are ready for IO, avoiding thread-blocking.</p><p><strong>Example:</strong></p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">üìã</button>
 <pre><code class="language-java">import java.nio.channels.SelectionKey;
import java.nio.channels.Selector;
import java.nio.channels.SocketChannel;
import java.util.Set;

public class Test {

    public static void main(String[] argv) throws Exception {
        SocketChannel channel = SocketChannel.open();
        channel.configureBlocking(false);
        Selector selector = Selector.open();
        channel.register(selector, SelectionKey.OP_READ);

        while (true) {
            selector.select();  // Blocks until at least one channel is ready
            Set&lt;SelectionKey&gt; keys = selector.selectedKeys();
            for (SelectionKey key : keys) {
                if (key.isReadable()) {
                    // Read data without blocking
                }
            }
            keys.clear();
        }
    }
}</code></pre>
</div><p><strong>Implications:</strong></p><ul>
 <li>One thread can manage thousands of connections efficiently.</li>
 <li>Greatly improves scalability and resource utilization.</li>
 <li>Requires more complex programming to handle readiness events.</li>
</ul><h3 id="stream-based-vs-buffer-based-data-handling">Stream-Based vs Buffer-Based Data Handling</h3><h4 id="traditional-io-stream-based">Traditional IO: Stream-Based</h4><p>Java IO models data as <strong>streams</strong> ‚Äî continuous flows of bytes or characters.</p><ul>
 <li>Data is read or written <strong>sequentially</strong>, one byte/char at a time.</li>
 <li>The API abstracts away the internal buffering or memory management.</li>
 <li>Developers typically read or write bytes in a loop.</li>
</ul><p><strong>Example:</strong></p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">‚ñØ</button>
 <pre><code class="language-Java">byte[] buffer = new byte[1024];
int bytesRead = inputStream.read(buffer);</code></pre>
</div><p>The <code>read()</code> method blocks until at least one byte is available and fills the buffer.</p><h4 id="java-nio-buffer-based">Java NIO: Buffer-Based</h4><p>Java NIO operates with <strong>buffers</strong>‚Äîfixed-size containers that explicitly hold data.</p><ul>
 <li>Data is <strong>read into</strong> a buffer or <strong>written from</strong> a buffer.</li>
 <li>Buffers have positions and limits that must be managed manually.</li>
 <li>This explicit control enables more efficient, flexible data processing.</li>
</ul><p><strong>Example:</strong></p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">‚ñØ</button>
 <pre><code class="language-Java">ByteBuffer buffer = ByteBuffer.allocate(1024);
int bytesRead = channel.read(buffer);
buffer.flip();  // Prepare to read from buffer
while(buffer.hasRemaining()) {
    byte b = buffer.get();
}
buffer.clear(); // Prepare buffer for next write</code></pre>
</div><h3 id="synchronous-vs-asynchronous-processing">Synchronous vs Asynchronous Processing</h3><h4 id="traditional-io-mostly-synchronous">Traditional IO: Mostly Synchronous</h4><p>Traditional Java IO operations are synchronous and blocking ‚Äî the program flow waits for IO completion.</p><ul>
 <li>Simpler to program and reason about.</li>
 <li>May lead to thread starvation or performance bottlenecks under heavy load.</li>
</ul><h4 id="java-nio-supports-asynchronous-and-synchronous-non-blocking">Java NIO: Supports Asynchronous and Synchronous Non-Blocking</h4><p>NIO supports:</p><ul>
 <li><strong>Non-blocking synchronous IO</strong> via selectors (as described above).</li>
 <li><strong>Asynchronous IO</strong> (introduced later as NIO.2 in Java 7) with classes like <code>AsynchronousFileChannel</code> that allow the OS to notify completion via callbacks or futures.</li>
</ul><p>This enables event-driven architectures, where the program reacts to IO events without being stuck waiting.</p><h3 id="data-flow-differences">Data Flow Differences</h3><p><strong>Traditional IO Data Flow:</strong></p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">‚ñØ</button>
 <pre><code class="language-bash">Application Thread
    ‚Üì (blocking read)
InputStream/File/Socket
    ‚Üì sequential data flow</code></pre>
</div><ul>
 <li>Each IO call blocks the thread until data arrives.</li>
 <li>One thread per IO operation.</li>
</ul><p><strong>NIO Data Flow:</strong></p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">‚ñØ</button>
 <pre><code class="language-bash">Application Thread
    ‚Üì
Selector &lt;-- multiple Channels (non-blocking)
    ‚Üì
Buffers &lt;--&gt; Channels</code></pre>
</div><ul>
 <li>The selector notifies when channels are ready.</li>
 <li>One thread handles many channels.</li>
 <li>Buffers explicitly hold data in memory.</li>
</ul><h3 id="impact-on-application-design">Impact on Application Design</h3><ul>
 <li><strong>Traditional IO</strong> is easier for simple or small-scale applications.</li>
 <li><strong>NIO</strong> requires managing buffers, selectors, and readiness events but excels in scalable, high-concurrency scenarios like servers or real-time applications.</li>
 <li>NIO fits well with <strong>event-driven architectures</strong> and frameworks like Netty, enabling highly responsive network applications.</li>
</ul><h3 id="summary-table">Summary Table</h3><table>
 <thead>
  <tr>
   <th>Feature</th>
   <th>Traditional Java IO</th>
   <th>Java NIO</th>
  </tr>
 </thead>
 <tbody>
  <tr>
   <td>IO Model</td>
   <td>Blocking, stream-based</td>
   <td>Non-blocking, buffer-based</td>
  </tr>
  <tr>
   <td>Thread Usage</td>
   <td>One thread per IO operation</td>
   <td>One thread manages many channels</td>
  </tr>
  <tr>
   <td>Data Handling</td>
   <td>Sequential byte/char streams</td>
   <td>Explicit buffers with position/limit</td>
  </tr>
  <tr>
   <td>Scalability</td>
   <td>Limited by thread overhead</td>
   <td>High scalability via selectors</td>
  </tr>
  <tr>
   <td>Programming Complexity</td>
   <td>Simpler API</td>
   <td>More complex, event-driven</td>
  </tr>
  <tr>
   <td>Asynchronous Support</td>
   <td>No native async</td>
   <td>Supports async with NIO.2</td>
  </tr>
  <tr>
   <td>Typical Use Cases</td>
   <td>Simple file IO, small apps</td>
   <td>High-performance servers, network apps</td>
  </tr>
 </tbody>
</table><h3 id="recap">Recap</h3><p>While the traditional Java IO API remains useful for simple, blocking IO tasks, Java NIO offers a modern, scalable alternative designed for the demands of today‚Äôs networked, concurrent, and high-performance applications. By moving from blocking streams to non-blocking buffers and selectors, NIO allows Java developers to build efficient and scalable systems without the overhead of thread-per-connection models.</p><div class = "chapter-navi-section">
<a href="#top" class="nav-button prev">‚Üë</a>
<a href='java-io-and-nio.htm#introduction-to-java-nio-new-io' class="nav-button toc-link">Index</a>
<a href="#bottom" class="nav-button next">‚Üì</a>
</div>
<h2 id='non-blocking-io-and-selectors-overview'>5.4 Non-blocking IO and Selectors Overview</h2><p>Java NIO (New IO) introduced a revolutionary way to handle IO operations that vastly improves scalability and performance for applications dealing with multiple simultaneous IO channels, such as servers handling many client connections.</p><p>At the core of this improvement lies the concept of <strong>non-blocking IO</strong> combined with <strong>selectors</strong>, allowing a <strong>single thread to efficiently manage many IO channels</strong> without blocking or dedicating one thread per connection. This section explores how selectors work, their relationship with channels, and how they enable scalable non-blocking IO.</p><h3 id="understanding-non-blocking-io">Understanding Non-blocking IO</h3><p>In traditional IO, when you read from or write to a channel (e.g., a socket or file), the thread blocks until the operation completes. For example, reading from a socket input stream blocks until data arrives. This is simple but inefficient for high concurrency ‚Äî threads spend much time waiting and consume resources.</p><p><strong>Non-blocking IO</strong> changes this behavior:</p><ul>
 <li>When a thread attempts to read from or write to a channel in non-blocking mode, the operation returns immediately.</li>
 <li>If data is available, some or all of it is processed.</li>
 <li>If no data is available (e.g., no bytes to read), the method returns zero or a special value indicating no action.</li>
 <li>The thread can then continue doing other work instead of waiting.</li>
</ul><p>This non-blocking mode is <strong>enabled by setting a channel to non-blocking</strong>, typically via:</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">‚ñØ</button>
 <pre><code class="language-Java">channel.configureBlocking(false);</code></pre>
</div><h3 id="selectors-multiplexing-multiple-channels">Selectors: Multiplexing Multiple Channels</h3><p>Non-blocking IO alone is useful, but applications often need to manage many channels simultaneously (e.g., thousands of client sockets). Managing many channels in a single thread requires a mechanism to <strong>know which channels are ready for reading, writing, or connecting without busy-waiting or polling inefficiently</strong>.</p><p>This is where the <strong><code>Selector</code></strong> class comes in.</p><h4 id="what-is-a-selector">What is a Selector?</h4><p>A <strong>Selector</strong> is a multiplexing tool that allows a single thread to monitor multiple channels for various IO events, such as:</p><ul>
 <li><strong>Read readiness</strong> ‚Äî data available to read.</li>
 <li><strong>Write readiness</strong> ‚Äî channel ready to accept data.</li>
 <li><strong>Connect readiness</strong> ‚Äî a connection operation finished.</li>
 <li><strong>Accept readiness</strong> ‚Äî new incoming connection ready to be accepted.</li>
</ul><p>The Selector <strong>blocks the thread until at least one registered channel is ready for one of the requested operations</strong>, enabling efficient waiting without wasting CPU cycles.</p><h3 id="how-selectors-work">How Selectors Work</h3><ol>
 <li><strong>Open a Selector</strong></li>
</ol><div class="code-block"><button class="copy-button" onclick="copyCode(this)">‚ñØ</button>
 <pre><code class="language-Java">Selector selector = Selector.open();</code></pre>
</div><ol start="2">
 <li><strong>Configure Channels as Non-blocking and Register with Selector</strong></li>
</ol><p>Each channel you want to monitor must be configured to non-blocking mode and registered with the selector, specifying which operations you want to listen for:</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">‚ñØ</button>
 <pre><code class="language-Java">channel.configureBlocking(false);
SelectionKey key = channel.register(selector, SelectionKey.OP_READ | SelectionKey.OP_WRITE);</code></pre>
</div><ol start="3">
 <li><strong>Waiting for Ready Channels</strong></li>
</ol><p>The selector‚Äôs <code>select()</code> method blocks until one or more channels are ready:</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">‚ñØ</button>
 <pre><code class="language-Java">int readyChannels = selector.select();</code></pre>
</div><ol start="4">
 <li><strong>Processing Selected Keys</strong></li>
</ol><p>After <code>select()</code> returns, you retrieve the set of <strong><code>SelectionKey</code></strong> objects representing ready channels:</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">üìã</button>
 <pre><code class="language-java">import java.nio.channels.SelectionKey;
import java.nio.channels.Selector;
import java.nio.channels.SocketChannel;
import java.util.Iterator;
import java.util.Set;

public class Test {

    public static void main(String[] argv) throws Exception {
        SocketChannel channel = SocketChannel.open();
        channel.configureBlocking(false);
        Selector selector = Selector.open();
        Set&lt;SelectionKey&gt; selectedKeys = selector.selectedKeys();
        Iterator&lt;SelectionKey&gt; keyIterator = selectedKeys.iterator();

        while (keyIterator.hasNext()) {
            SelectionKey key = keyIterator.next();
            
            if (key.isReadable()) {
                // Read data from channel
            } else if (key.isWritable()) {
                // Write data to channel
            } else if (key.isAcceptable()) {
                // Accept a new connection
            } else if (key.isConnectable()) {
                // Finish connection process
            }
            
            keyIterator.remove(); // Important: Remove the key to avoid processing it again
        }
    }
}</code></pre>
</div><h3 id="selectionkey-the-channels-registration-token">SelectionKey: The Channels Registration Token</h3><p>When you register a channel with a selector, you get a <code>SelectionKey</code> representing the relationship. It tracks:</p><ul>
 <li>Which operations the channel is interested in (<code>interestOps</code>).</li>
 <li>Which operations are ready (<code>readyOps</code>).</li>
 <li>Attachment objects for storing related data or state.</li>
</ul><h3 id="advantages-of-using-selectors-and-non-blocking-io">Advantages of Using Selectors and Non-blocking IO</h3><ul>
 <li><strong>Scalability:</strong> A single thread can manage thousands of channels efficiently, avoiding the overhead of one thread per connection.</li>
 <li><strong>Resource Efficiency:</strong> Threads aren‚Äôt blocked and don‚Äôt waste CPU cycles polling or waiting.</li>
 <li><strong>Responsiveness:</strong> Applications can respond immediately when channels are ready for IO.</li>
 <li><strong>Fits Event-driven Models:</strong> The selector pattern aligns well with event-driven programming, facilitating reactive and asynchronous designs.</li>
</ul><h3 id="conceptual-example-echo-server-using-selectors">Conceptual Example: Echo Server Using Selectors</h3><div class="code-block"><button class="copy-button" onclick="copyCode(this)">üìã</button>
 <pre><code class="language-java">import java.net.InetSocketAddress;
import java.nio.ByteBuffer;
import java.nio.channels.SelectionKey;
import java.nio.channels.Selector;
import java.nio.channels.ServerSocketChannel;
import java.nio.channels.SocketChannel;
import java.util.Iterator;
import java.util.Set;

public class Test {

    public static void main(String[] argv) throws Exception {
        SocketChannel channel = SocketChannel.open();
        channel.configureBlocking(false);
        Selector selector = Selector.open();
        ServerSocketChannel serverChannel = ServerSocketChannel.open();
        serverChannel.bind(new InetSocketAddress(8080));
        serverChannel.configureBlocking(false);
        serverChannel.register(selector, SelectionKey.OP_ACCEPT);

        while (true) {
            selector.select(); // Wait for events

            Set&lt;SelectionKey&gt; keys = selector.selectedKeys();
            Iterator&lt;SelectionKey&gt; iter = keys.iterator();

            while (iter.hasNext()) {
                SelectionKey key = iter.next();

                if (key.isAcceptable()) {
                    // Accept connection
                    ServerSocketChannel server = (ServerSocketChannel) key.channel();
                    SocketChannel client = server.accept();
                    client.configureBlocking(false);
                    client.register(selector, SelectionKey.OP_READ);
                }

                if (key.isReadable()) {
                    SocketChannel client = (SocketChannel) key.channel();
                    ByteBuffer buffer = ByteBuffer.allocate(256);
                    int bytesRead = client.read(buffer);
                    if (bytesRead == -1) {
                        client.close(); // Client closed connection
                    } else {
                        buffer.flip();
                        client.write(buffer); // Echo data back
                    }
                }

                iter.remove(); // Remove handled key
            }
        }
    }
}</code></pre>
</div><p>This simple echo server handles multiple clients concurrently on a single thread without blocking.</p><h3 id="summary">Summary</h3><ul>
 <li><strong>Non-blocking IO</strong> allows IO operations to return immediately, avoiding thread blocking.</li>
 <li><strong>Selectors</strong> multiplex many non-blocking channels, notifying when channels are ready for IO.</li>
 <li>A single thread can efficiently monitor and service many channels using a selector.</li>
 <li><code>SelectionKey</code>s represent channel registrations and track IO readiness.</li>
 <li>This model enables scalable, resource-efficient, and responsive IO applications, especially suitable for servers and event-driven systems.</li>
</ul><div class = "chapter-navi-section">
<a href="java-io-and-nio-advanced-java-io-concepts.htm" class="nav-button prev">‚Üê</a>
<a href='java-io-and-nio.htm#introduction-to-java-nio-new-io' class="nav-button toc-link">Index</a>
<a href="java-io-and-nio-buffers-and-channels.htm" class="nav-button next">‚Üí</a>
</div>
<section class="download-section">
  <div class="book-cover" style="background-color: #f9f6f1;border: 1px solid #ccc;"> 
    <div class="book-cover-title" style="font-size: 18px;color: #333;top: 20px;">Java IO and NIO</div>
    <div class="book-cover-author">readbytes</div>
    <div class="book-cover-bottom-stripe" style="background-color: #333;"></div>
    <img class="book-cover-icon" style="width: 80px;height: 90px;top: 60px;" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFoAAABaCAYAAAA4qEECAAADAElEQVR4Xu2Zu6oTURSGjze0UfANtLAUzgOI4DOItc+VKk1uJ12aadNa21vbCpYK4wQmcPiYzL5k7eXM2f8HP0JYa/3ZX2PEmxshxAPi7u6uLRH2VA3lWId9VdK27WOKsQ47q6RpmucUYx12VolEOyHRToyJ5mwI7ufeeZBItBMS7YREOyHRTki0ExLthEQ7IdFOSLQTEu2ERDsxJtoq7KwSiXZCop04Ho9PKcY67KwWirEO+6qGcqzCHhGBJDoh0U5ItAP7/f6bRDtAyV3+ckYYQNHr9fo1Z8SVtG37iKI5Mzv4IKuwJwXeuvbef4ePsQ77YuGdLp85MysGHmQa9sXAG7l3JgUfZB32heh+0t3yRvfZD87NDj7KOuwLwf2cG5OEj7IO+8bg7imr1eoV55Lh0VC4bwE7cru4n3Jns9l85d7YPmdCSV8oADtyu7gfe4fzMbucCyV9oQDsyO3i/tid7i+395xjuHMfzoaSvlAAduR2cf/+ne7PT/x8JL94mwzsjCZ5wTN8XAjuTynT/nKJcH9KmfaXS4T7U8q0v1wi3J9Skr8cH3cJ7l3I98Ph8HLg86SuM9zPvRMDO0JJXwjQ/Wx6yx3kI3cGZqK6CPdz78TAjlDSF0ZYLpcvOH9O0zQX/xnL2ZiuIbifeycGdoSSvjACZ2N2TnA+do9wP/dODOwIhfvZ8HCfn5wbYmDPNOybLXxYn9+cu8TArmnYN1v4sNTHcdc67JslfFTOw7hvHfbNEj6q+3n3gTMheMM67JsdfNA1j+Idq7BnlvBR2+32DWfElazX63cUzRlhACVLdCEk2QmJdmC3232RaAcoucsfzogAAxJNwp6qoRzrsK9aKMY6i8XiGTurhGKsc/ofGHZWCcVYR6J7KMY6Et1DMedwLgT3JRpQjEQXgmIkuhAUI9GFoBiJLgTFSHQhKEaiC0ExEl0IipHoQlCMRBeCYiS6EBQj0YWgGOtIdA/FWEeieyjGOhLdQzHW2e/3T9hZJRRjHfZVDeVYhT1CiDnzD27IzgFe/xOvAAAAAElFTkSuQmCC"/>
  </div>
  <div class="download-info">
    <h2 id='bottom'>Download This Ebook</h2>
    <p class="format-label">Available formats:</p>
    <div class="download-buttons">
      <a href="java-io-and-nio.pdf" class="download-button">üìÑ PDF</a>
      <a href="java-io-and-nio.epub" class="download-button">üìò EPUB</a>
    </div>
  </div>
</section><div class='related-books'>
<h2>Java In-Depth Books</h2>
<div class='related-book-list'>
<a href="java-io-and-nio.htm">
<div class="book-cover" style="background-color: #f9f6f1;border: 1px solid #ccc;"> 
    <div class="book-cover-title" style="font-size: 18px;color: #333;top: 20px;">Java IO and NIO</div>
    <div class="book-cover-author">readbytes</div>
    <div class="book-cover-bottom-stripe" style="background-color: #333;"></div>
    <img class="book-cover-icon" style="width: 80px;height: 90px;top: 60px;" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFoAAABaCAYAAAA4qEECAAADAElEQVR4Xu2Zu6oTURSGjze0UfANtLAUzgOI4DOItc+VKk1uJ12aadNa21vbCpYK4wQmcPiYzL5k7eXM2f8HP0JYa/3ZX2PEmxshxAPi7u6uLRH2VA3lWId9VdK27WOKsQ47q6RpmucUYx12VolEOyHRToyJ5mwI7ufeeZBItBMS7YREOyHRTki0ExLthEQ7IdFOSLQTEu2ERDsxJtoq7KwSiXZCop04Ho9PKcY67KwWirEO+6qGcqzCHhGBJDoh0U5ItAP7/f6bRDtAyV3+ckYYQNHr9fo1Z8SVtG37iKI5Mzv4IKuwJwXeuvbef4ePsQ77YuGdLp85MysGHmQa9sXAG7l3JgUfZB32heh+0t3yRvfZD87NDj7KOuwLwf2cG5OEj7IO+8bg7imr1eoV55Lh0VC4bwE7cru4n3Jns9l85d7YPmdCSV8oADtyu7gfe4fzMbucCyV9oQDsyO3i/tid7i+395xjuHMfzoaSvlAAduR2cf/+ne7PT/x8JL94mwzsjCZ5wTN8XAjuTynT/nKJcH9KmfaXS4T7U8q0v1wi3J9Skr8cH3cJ7l3I98Ph8HLg86SuM9zPvRMDO0JJXwjQ/Wx6yx3kI3cGZqK6CPdz78TAjlDSF0ZYLpcvOH9O0zQX/xnL2ZiuIbifeycGdoSSvjACZ2N2TnA+do9wP/dODOwIhfvZ8HCfn5wbYmDPNOybLXxYn9+cu8TArmnYN1v4sNTHcdc67JslfFTOw7hvHfbNEj6q+3n3gTMheMM67JsdfNA1j+Idq7BnlvBR2+32DWfElazX63cUzRlhACVLdCEk2QmJdmC3232RaAcoucsfzogAAxJNwp6qoRzrsK9aKMY6i8XiGTurhGKsc/ofGHZWCcVYR6J7KMY6Et1DMedwLgT3JRpQjEQXgmIkuhAUI9GFoBiJLgTFSHQhKEaiC0ExEl0IipHoQlCMRBeCYiS6EBQj0YWgGOtIdA/FWEeieyjGOhLdQzHW2e/3T9hZJRRjHfZVDeVYhT1CiDnzD27IzgFe/xOvAAAAAElFTkSuQmCC"/>
  </div>
</a>


<a href="java-collections.htm">
<div class="book-cover" style="background-color: #f9f6f1;border: 1px solid #ccc;"> 
    <div class="book-cover-title" style="font-size: 18px;color: #333;top: 20px;">Java Collections</div>
    <div class="book-cover-author">readbytes</div>
    <div class="book-cover-bottom-stripe" style="background-color: #333;"></div>
    <img class="book-cover-icon" style="width: 80px;height: 90px;top: 60px;" src='data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFoAAABaCAYAAAA4qEECAAADAElEQVR4Xu2dQYrUUBRFIw50JI7FrYgrcAPOXYPORHci7sah4EAQFyA6dNKosZK2Ee8/dOclP7/+i/fAmaR+Xr17KehJV2oYjDHGGGM6YRxzmgZdPKvdMt4vl03vLU15ZsYnsORB7Apd7mh2gS51VM/K+LVc6LA+0/QNKZax9RnvlG+C/tI7+6PYuYLV0MHoc72rX8ZvsP9Gq6BDyWzo/jXcjA4sfKN39E+RoYaf9F2CFAPFjGiG3b0Y5r9111LcJGZEM7QW0UNqRjTDWXwQXCojmoEk9MxmHwWGZ0QzkMT4ujy31b/D4UU8uITp/J4uRDOQxPiyPFfDy+HwQnFoCdPZFi5AM5BE/0VP51r5brgRzUASexU9/piG60VxEdO5lt6AZiCJ3Yoep+Fw8Z8DS5gHNfLncCOagSSWFE2M38tzanFBXcS9k/OwBi5AM5DE2qIn9JxaXFAXM33S5oE7+nFYhGYgiRxFX7FH4V+GEJqBJHIV3QGagSRcdBDNQBIuOohmIAkXHUQzkISLDqIZSMJFB9EMJOGig2gGknDRQTQDSbjoIJqBJHIUfffkPLCC74dNaAaSyFH0PKyiL4bVaAaS6L/oedAOrkQzkISLDqIZSMJFB9EMJNF/0bdPzsMquxLNQBL9Fz3x4eQ8sJIb0AwkkaPoK56efLvSV0MVNANJ5Cq6AzQDSbjoIJqBJFx0EM1AEi46iGYgCRcdRDOQhIsOohlIwkUH0Qwk4aKDaAaScNFBNANJuOggmoEkXHQQzUASLjqIZiAJFx1EM5CEiw6iGUjCRQfRDCSxtuh2X63oDM1AEkuKXmtxQc2IZiCJ3Yqu9vW3ztAMJLFX0ZfD4YXiUDI0A0m46CCagSTyfOm+EzQDSeiZzT4ODM+IZjiLD4NLZUQztBbRQ2pGNMPu1nh4lR/H9sfP+i5BioFgNnT/Gm5GB6Ib/im8Nf0+MtMPgb3Wquhwqw1Vwg/qbkix0EHtAl3qaHaDfx6kIf7Bm8YUyyY1Dbp4Fo0xxhhj/kd+A/PkOH57kF8HAAAAAElFTkSuQmCC'/>
  </div>
</a>


<a href="java-regex.htm">
<div class="book-cover" style="background-color: #f9f6f1;border: 1px solid #ccc;"> 
    <div class="book-cover-title" style="font-size: 18px;color: #333;top: 20px;">Java Regex</div>
    <div class="book-cover-author">readbytes</div>
    <div class="book-cover-bottom-stripe" style="background-color: #333;"></div>
    <img class="book-cover-icon" style="width: 80px;height: 90px;top: 60px;" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFoAAABaCAYAAAA4qEECAAAFo0lEQVR4Xu2d3WscVRiH+y/YXuuFkov6H9je2huvlAQvFalCEW8qiFRFQcGrmoJ4U5TSLWglFqRIlJqCH6XWalM/0lrT1O1ukt3sV5qPTZrP3XHfLTM983vPztc5s+zZPQ88N5l3Z9inwzA70Dl79iQks29oM7N3yBkoW98ZO6RC62ANdvDBtYF9lJEcxHNi+CWnOvmXs5rN9aX03eg74vcWxV6xObX3iUdxp2P7DzqDztiTB1lsaoX9InF631BJ3NH408N4vIFn/NCwL/aZVjPsGAj+a1mCwV7YUwqeyZZoxDqz8ZpsiYfY7mzQNdtGVkdsiH3b2Mj6CIztbrB3F+qMHxqRh84Iv/gsehDO6oe/IN0/ju0/gPOWhNAPO3ZW27M5HXyhTwtP4Sx68S4f9NRPuJbgnEURsa0Xmp5QWfQyMfLwqZ8XunrtT5yzKEKPWFnoem4O5xKxsVbS5vbmMu7eKOr5OUnovHro1ep0KppKPT+vP/TGWpkF0qWp2NBdwobuEjY0MnXbcb4cd5xCGbco0XOhb8wuOhdnGp4//7fl254ah9/urAZ6KrQYGL01V0sndLPJw8pUxJjQ5OXsBh5KjVZjFjRIBXoqdKWcZXHRK/kGHi45GDJMBXoqNFku3WVx0V9nNcTGiK7nLgRvT0jPhSZLacfGeK7Xb4bPJaQnQz+InWNx0USXEQzn+vsUTvKZfgxNFhfyLC4a68x+7QMejrwieVqJM+QX3+BUZHo6NDlfnGNx0auzdPsQAQxHXprEKT7jqkDPhyZni/MsLhopNoY7kcEJPuN6bBQnY2FEaDJXLLC4aGhsjIfgdtdX3sHJ2BgTmswVwmMHXrMxoBgb/+76snpkwqjQZKnusLhox7uRryd4yDA1YVxoYmG1yeKi0jP7nzs8ZJAaMTI0UVhJEPvN4zxmJzVjbGhidik8tu8ygjE7mQJGha7XZvBQTnYxPHb7zF6o8qAyU8KY0Gv37uJhPGZq4bEXpnI8KpoiRoTe3lzBQzCmq51j59aabSu/3OBxSU23cEH0fOgHT+ej8W+Fx3Yju9YuXO16ZCKV0DvVSWfrzlnm+tyP/pCVW2xGNAlibIzsunT+p65GJroamhRD4zbVyC7TFR4XXf7qIn4sVVIJ3bj9meNce0OqGLM5+Rbb7jMhePmQWXzqWWf15Of40dRIJfTmwmV2hiY1LhhUJkV2Xfn4FO4iFXo+NBkVDCpTjOzFPvEp7ko7RoQmw8CgMjGw6PJourGNCU12AoPKXHpvlMVFl4+fxF1rw6jQJIJBZbpgWJnLH34i7F0fxoamnzEYVKZI6ZkXWViZS+9+5PucDowNjUFlIlt/3GRRO7n4+vv4cSWMDI1BZcpYP/89Cxpk7cgx3EVijAuNQWV2AkOSbZpN9nfX6uHkP5xE+i50EBgRwe1e7BeO4mhs+ip0GBjw/nc/4AibCZqNQ9+EjgLGI50G/yzOeLMK9EXoqBQPPMfixYm9cek3HIuM8aHjgvFcmzs7OMpm2v8oCTE6dBJ2q/dYPC/29rZvFrcPZGgVdss1FtCLvX6/PVN5/lW2beBC62C3VGURw2z/D66EGBdaJ7vFMosZpAoDHZqIGluVgQ/dJuAnuI7IhA0NVEaOtOMuHrVP74zEhu4SNnSXkIdWfHnVbr3AAunSVOjkZaF1vI4NA+nQZKSvY7MvGNSP9AWDpEUvYlv7EtgU8UK7Sz/Z0Ongnc34/mi7apA+xNWHxND21fOa8S4buHiZu4GWJbKo8W2nxRTE0PasVkdsiZ3b2NjqhEYmaNkhGzs5Yrszjzz+GPb1QQtq2djxEZu17pvL2FWK70M2dijYC3sGgmc2LUtk8SPeXcQ6kxFcdo+kG/FBR+tSqCK4U1F6QlW7/rezms33pfTdxKdwMrGXMhm7XLWo/uWqZdgF2OPxPxXwJpKIkhiiAAAAAElFTkSuQmCC"/>
  </div>
</a>


<a href="java-functional-programming.htm">
<div class="book-cover" style="background-color: #f9f6f1;border: 1px solid #ccc;"> 
    <div class="book-cover-title" style="font-size: 18px;color: #333;top: 20px;">Java Functional Programming</div>
    <div class="book-cover-author">readbytes</div>
    <div class="book-cover-bottom-stripe" style="background-color: #333;"></div>
    <img class="book-cover-icon" style="width: 80px;height: 80px;top: 80px;" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFoAAABaCAYAAAA4qEECAAADzUlEQVR4Xu2bO4sUURCFlxVBzfwLJkb+A1MxEgMRDBQDRTBRwchARk00MRFBAwNBzEQwMBfEBz7wbWIkiIGJoInio9wZdmZ7T1V3V91bPVhaH3xJ973n3jk2vdO968JCkiRJkiRRIYphWOgI/zB/uyHBDxHFUODmIxkK3HwkQ4Gbj2QY6BDffCTDgBuPZhhw49EMA248miGgW3zj0QwBbjqiIcBNRzQEuOlohoA+8Y1HMgy4cauJEizO5EZMS0RoUSjPYKIEi7OaKMHirCZKsDiTi5iWiNAmoTyDiRIszmqiBIsz+QXTklZYeQYTJXSUl2cxUYLFWU2UYHEmb2Na0gorz2CihJ7w8iwmSrA4q4kSLM7kYUxLWmHlGUyU0C9ensVECRZnNQS4abPPMNEOy7S4BdN00L5GxmU8q4cuNXL24tll2KYrLIXW8yyLJdAJnkP3cFQ/9FzIGeEgHOBgCZhh1Qod5xkzH+PoduiVMH/qqDkQT3q4trGAEpZh1AId4/OZb3EWh14K89DRdDCecNIKzjdp+IelHcL8Nj/g7BU6r2R0+3gCHvRyN26tHdoszDdoAef2KpQt3pN7ZAc81YLzrFrAuSrfNOY/Es4rZAdcfbCywS7YPIvfMa0buiBkaFz6ATn+POy4xmvjhfGgsxpwjsUSigsr8el0UTzh7c9Vn5FBe4Q5BkuZXKFCnqsPmwviyQHsAsdarWF8tWGem/dxMRwwkG3gOJMvMM1O7S8aRJtX8hQ2aCDbwHEWvXAte3pPlmCDBxKhK3yMRU9cbiOKp0k+aQg3+K7pTdUPyHeYVgELL9At7/zqLA9KH0YmNh5qqqHPwgJWLzby8JxBb1y+Wxve+vXCwguc5Lzmxy164lLy1IL32SJ0Qwi3+k04ZtSLqttFm3dxlUJY8Lzdijsqo+QtnFqPK5u2CcFz1APT++RSPe7ZLHSO1qL6zYiXmu/WXdAaIXRO1lD8mnSpsOKHmpu4CyMscB5W/m8rlqex8TBS+lBTDQYObS2Y16vwxFfydbAaDBzaWmgXz2y14/46fg3Kxre5E2cXwoKH8geuXIb4hzNo11u4ZVRX9kmcVQELH0hP6BTPnym9T26h8559Gkc7wBYZQG/oLF+D/WZEgfht5AyOcoLeC4s5OwR0oLHGVTyrh643cvbjWWewGFc/4mr/MXRQKMjJBMCCvEwAWsdL8jARwJKqvYMrJDNYWRUmHWBZNSY9YGGlJj1gYUWew9REhBVnNFFCX3l5FhMDWJ7WpAAssc+kAiyzzcQJLHbibxyVJEmSJMk/xB+4wdarC+OVAQAAAABJRU5ErkJggg=="/>
  </div>
</a>


<a href="java-streams.htm">
<div class="book-cover" style="background-color: #f9f6f1;border: 1px solid #ccc;"> 
    <div class="book-cover-title" style="font-size: 18px;color: #333;top: 20px;">Java Streams</div>
    <div class="book-cover-author">readbytes</div>
    <div class="book-cover-bottom-stripe" style="background-color: #333;"></div>
    <img class="book-cover-icon" style="width: 80px;height: 80px;top: 60px;" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFoAAABaCAYAAAA4qEECAAACbklEQVR4Xu3cP4oUQRiG8S8xEzESDI1MPIRHEQQPYTK9iCyewMxrGIiCoaFnWFkMTIwUxD894KI8VbNdVdNfzdR87w+eRKa2ul+WVZM1G8+3ud+d+mhBvbZ0DO/uWEAcoVfhcIBehcQRvAvt1dz7gjjaVfxcrhcmxTiwvkudcGAN7YQDa2gnHFhDO+HAGtoJB24ZmmdzhcdBWobh2VzhcZCWYXg2V3gcpGUYns0VHgdpGYZnc4XHQVqG4dlc4XGQlmF4Nld4HKRlGJ7NFR4HaRmGZ3MN48Hcu7lLS19ihI7SPUsfdPSOCh/ulDoKfKhT7KC2P3P5QKfawfBBTr2D4ENEqDs+QJS64uWR6ubc0ssj1Q0vjlYXvLS1X3Mv5x7NPTyi+Jy5uuClNY2Az5zL3RtLLy1pJHz2XO544VLbHw+j4TvkcscLlxoR3yGXO154XaPie+Ry9djSC69rVHyPXK62/xTjhbu6+HtmRHyXXK6iDH1wGroTDd2Jhu5EQ3eioTvR0J1o6E40tAMOt1YCHGitBDjQWglwoLUS4EBrJcCB1kqAA62VwFOnREREROSIPbP7/CNZ28Y+2KT/hPjbjnyVOPl/ZA3tZLLzZGiN7YAD/+smPyqt0nH1Xe2Cw7LndpdHpBZH3ZXs4YndSAbdleyBYy4ljTjkUtKAI5a0sS/8MrKEI5YmFTZ2mQxYmlTgeDVt7DO/nOzC8WqTApPdSoarTQpM9ikZrjYpMNmPZLjapMDZ/JcZh6tNCkx2OxmuNinE4WraDPnbZw5ksp/JgKVJJQ5YmjTgiEvJHib7mgyaS1Yy2dtk3DP7zo9F9wfJyGVFhM8g5gAAAABJRU5ErkJggg=="/>
  </div>
</a>



<a href='java.htm'><div class='book-cover' style='background-color: #f9f6f1;color: #111111;border: 1px solid #ccc;display: flex;justify-content: center;align-items: center;text-align: center;'>More Java Books</div></a>
</div>
</div>
  </div>
  <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/prism.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
  
  <script>
    function copyCode(button) {
      const code = button.nextElementSibling.innerText;
      navigator.clipboard.writeText(code).then(() => {
        button.textContent = 'Copied!';
        setTimeout(() => { button.textContent = 'Copy'; }, 1500);
      });
    }
  </script>  
<div id="floatingLog" aria-live="polite" role="alert"></div>
<footer class="page-footer">
    <nav>
      <a href="https://readbytes.github.io">Home</a> | 
      Email:<script language="JavaScript" type="text/javascript">
var part1 = 'yinpeng';var part6 = '263';var part2 = Math.pow(2,6);var part3 = String.fromCharCode(part2);var part4 = 'hotmail dot com';var part5 = part1 + String.fromCharCode(part2) + part4;document.write(part1 + part6 + part3 + part4);
</script>
    </nav>
  <p>¬© 2025 ‚Äî All rights reserved.</p>    
  </footer>

</body>
</html>