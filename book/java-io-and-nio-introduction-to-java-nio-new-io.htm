<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Java IO and NIO Introduction to Java NIO (New IO)</title>
<link rel='shortcut icon' href='https://java2s.com/style/favicon.ico'>
<link href="https://fonts.googleapis.com/css2?family=Merriweather&display=swap" rel="stylesheet" />
<link href="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet" />


  <script>
  const mode = localStorage.getItem('mode') || 'light';
  document.documentElement.classList.add(`${mode}-mode`);
  </script>   
<style> 
html {
  scroll-behavior: smooth;
}

body {
  font-family: 'Merriweather', serif;
  margin: 0;
  padding: 2rem 1rem;
  font-size: 15px;
  line-height: 1.5;
  transition: background-color 0.3s, color 0.3s;
}

.container {
  max-width: 700px;
  margin: 0 auto;
  padding: 1rem 2rem;
  box-shadow: 0 0 15px rgba(0,0,0,0.1);
}

h1, h2, h3 {
  font-weight: 600;
  margin-top: 2.5rem;
  margin-bottom: 1rem;
  line-height: 1.2;
}

h1 { font-size: 1.8rem; }
h2 { font-size: 1.4rem; }
h3 { font-size: 1.2rem; }

table {
  width: 100%;
  border-collapse: collapse;
  font-family: sans-serif;
  font-size: 1em;
  margin: 1em 0;
}

th, td {
  padding: 0.6em 1em;
  text-align: left;
  border: 1px solid;
}

tr:nth-child(even) {
  background-color: inherit;
}

tr:hover {
  background-color: inherit;
}

a {
  text-decoration: none;
  transition: color 0.2s;
}

a:hover {
  text-decoration: underline;
}

code {
  color: #d35400;
}

.book-title-chapter {
  font-family: 'Merriweather', serif;
  font-size: 2rem;
  font-weight: bold;
  text-align: center;
  margin-bottom: 2rem;
  border-bottom: 2px solid;
  padding-bottom: 0.5rem;
}

.book-subtitle-chapter {
  text-align: center;
  font-size: 1rem;
  margin-top: -1rem;
  margin-bottom: 2rem;
}

.related-books {
  margin-top: 40px;
}

.related-book-list {
  display: flex;
  flex-wrap: wrap;
  gap: 20px;
}

    .book-cover {
      width: 130px;
      height: 180px;
      font-family: Arial, sans-serif;
      position: relative;
      overflow: hidden;      
      line-height: normal;
      box-shadow: 2px 2px 4px rgba(0,0,0,0.1);
    }
    .book-cover-bottom-stripe {
      position: absolute;
      bottom: 0;
      left: 0;
      height: 5px;
      width: 100%;
    }
    .book-cover-title {
      position: absolute;
      width: 100%;
      text-align: center;
      font-weight: bold;
    }
     
    .book-cover-icon {
      position: absolute;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      align-items: center;
      justify-content: center; 
    }

    .book-cover-author {
      position: absolute;
      bottom: 10px;
      width: 100%;
      text-align: center;
      font-size: 8px;
      color: #333;
    }

.page-footer {
  margin-top: 4rem;
  padding: 1rem 0;
  text-align: center;
  font-size: 0.85rem;
  border-top: 1px solid;
}

.chapter-navi-section {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding-bottom: 10px;
}

.nav-link {
  color: inherit;
  text-decoration: none;
  opacity: 0.5;
  transition: opacity 0.3s ease, text-decoration 0.3s ease;
}

.nav-link:hover {
  opacity: 0.9;
  text-decoration: underline;
}

.prev { text-align: left; }
.toc-link { text-align: center; }
.next { text-align: right; }

.download-section {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 2rem;
  padding: 2rem 1rem;
  max-width: 600px;
  margin: 3rem auto;
  border-radius: 12px;
  box-shadow: 0 4px 10px rgba(0,0,0,0.05);
}

.download-info h2 {
  margin: 0 0 0.5rem;
  font-size: 1.2rem;
}

.format-label {
  margin: 0 0 0.5rem;
  font-size: 0.95rem;
}

.download-buttons {
  display: flex;
  gap: 1rem;
}

.download-button {
  background-color: #4A90E2;
  color: white;
  padding: 0.5em 1.2em;
  border-radius: 25px;
  font-size: 0.95rem;
  text-decoration: none;
  transition: background-color 0.3s ease;
}

.download-button:hover {
  background-color: #357ABD;
}

.code-block {
  position: relative;
  margin-bottom: 1em;
}

.copy-button {
  background: transparent;
  color: white;
  position: absolute;
  top: 8px;
  right: 8px;
  border: none;
  padding: 4px 8px;
  font-size: 12px;
  border-radius: 4px;
  cursor: pointer;
  z-index: 1;
}

.copy-button:hover {
  background-color: #0056b3;
}

.snippet-container {
  overflow: hidden;
}

.snippet-header {
  padding: 0.75rem 1rem;
  cursor: pointer;
  font-size: 1rem;
    background-color: #eeeeee;
    color:  #111111; 
    border-radius: 8px;
    cursor: pointer;
    box-shadow: 0 4px 6px rgba(0,0,0,0.1);  
}

.snippet-body {
  display: none;
  font-family: monospace;
}

.snippet-container.open .snippet-body {
  display: block;
}

.CodeMirror {
  border: 2px solid #ccc;
  border-radius: 4px;
  resize: vertical;
}

/* === Light Mode === */
html.light-mode {
  background-color: #f8f7f5;
  color: #333;
}

html.light-mode .container {
  background: white;
}

html.light-mode .book-title-chapter {
  color: #2c3e50;
  border-color: #ccc;
}
html.light-mode .book-subtitle-chapter{
  color: #888;
}

html.light-mode .page-footer,
html.light-mode .series-name,
html.light-mode .book-subtitle,
html.light-mode .format-label {
  color: #888;
}

html.light-mode .related-books h2 {
  color: #333;
  border-bottom: 2px solid #eee;
}

html.light-mode .book-title {
  color: #fff;
}

html.light-mode .book-cover {
  border: 1px solid #ccc;
}

html.light-mode th {
  background-color: #f2f2f2;
}

html.light-mode tr:nth-child(even) {
  background-color: #fafafa;
}

html.light-mode tr:hover {
  background-color: #e6f7ff;
}

html.light-mode a,
html.light-mode .page-footer a {
  color: #000;
}

/* === Dark Mode === */
html.dark-mode {
  background-color: #181818;
  color: #e0e0e0;
}

html.dark-mode .container {
  background: #222;
}

html.dark-mode .book-title-chapter {
  color: #ddd;
  border-color: #444;
}

html.dark-mode .snippet-header {
    background-color: #333;
    color:  #ddd; 
}


html.dark-mode .book-subtitle-chapter,
html.dark-mode .page-footer,
html.dark-mode .series-name,
html.dark-mode .book-subtitle,
html.dark-mode .book-footer,
html.dark-mode .format-label {
  color: #aaa;
}

html.dark-mode .related-books h2 {
  color: #ddd;
  border-bottom: 2px solid #333;
}

html.dark-mode .book-title {
  color: #fff;
}

html.dark-mode .book-cover {
  border: 1px solid #555;
}

html.dark-mode th {
  background-color: #333;
  color: #fff;
}

html.dark-mode td {
  border-color: #444;
}

html.dark-mode tr:nth-child(even) {
  background-color: #2a2a2a;
}

html.dark-mode tr:hover {
  background-color: #2c3e50;
}

html.dark-mode a,
html.dark-mode .page-footer a {
  color: #eee;
}

    .dialog-backdrop {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: rgba(0,0,0,0.5);
      display: none;
      justify-content: center;
      align-items: center;
      z-index: 10;
    }

    .dialog {
      background: white;
      padding: 20px;
      width: 90vw;
      height: 80vh;
      border-radius: 8px;
      box-shadow: 0 0 20px rgba(0,0,0,0.3);
      display: flex;
      flex-direction: column;
    }
    .dialog-content {
      display: flex;
      flex: 1;
      gap: 20px;
      margin-top: 10px;
    }
    .dialog h2 {
      margin-top: 0;
    }

    .textarea_dialog {
      width: 50%;
      height: 100%;
      resize: none;
      font-family: monospace;
      font-size: 14px;
      padding: 10px;
      box-sizing: border-box;
      border: 1px solid #ccc;
    }

    .iframe_dialog {
      width: 50%;
      height: 100%;
      border: 1px solid #ccc;
    }
    .controls_dialog {
      display: flex;
      justify-content: space-between;
      margin-top: 10px;
    }    
    button { padding: 0.5em 1em; background: green; color: white; border: none; cursor: pointer; }
    button:hover { background: #1e7e34; }
    .result_iframe { width:99%; height:200px; margin-top: 1em;  resize: both;border:1px solid #ccc;}        
</style>
</head>
<body> 
  <div class="container">
    <div class = "chapter-navi-section">
<a href="java-io-and-nio-advanced-java-io-concepts.htm" class="nav-button prev">←</a>
<a href='java-io-and-nio.htm#introduction-to-java-nio-new-io' class="nav-button toc-link">Index</a>
<a href="java-io-and-nio-buffers-and-channels.htm" class="nav-button next">→</a>
</div>

    <h1 class="book-title-chapter" id = 'top'>Introduction to Java NIO (New IO)</h1>
    <h3 class="book-subtitle-chapter">Java IO and NIO</h3>   
    <!-- <h1 class ="chapter-title"></h1> -->
    <h2 id='motivation-behind-nio'>5.1 Motivation Behind NIO</h2><p>Java’s original IO (Input/Output) API, introduced in the early versions of Java, provides a straightforward, stream-based approach to reading and writing data. While it served the needs of many applications, especially desktop and simple server programs, it soon showed limitations in scalability, performance, and flexibility — particularly for modern networked and high-throughput applications. This led to the development and introduction of <strong>Java NIO (New IO)</strong> in Java 1.4, a major overhaul designed to address these challenges.</p><h3 id="limitations-of-the-original-java-io-api">Limitations of the Original Java IO API</h3><p>The classic Java IO API is built on the concept of <strong>blocking, stream-oriented IO</strong>:</p><ul>
 <li><p><strong>Blocking IO</strong>: When a thread reads from or writes to a stream, it blocks — that is, it waits until the operation completes before continuing execution. For example, reading from a socket or file input stream suspends the thread until data is available or the end of the stream is reached.</p></li>
 <li><p><strong>Stream-Oriented</strong>: Data is read or written sequentially as a flow of bytes or characters.</p></li>
</ul><p>While this model is simple and intuitive, it has several drawbacks in high-performance or large-scale applications:</p><h4 id="blocking-threads-wastes-resources">Blocking Threads Wastes Resources</h4><p>Because IO operations block the calling thread, each connection or file operation typically requires its own thread. In server applications handling thousands of simultaneous connections, this can lead to:</p><ul>
 <li><strong>Thread proliferation</strong>: Creating and managing a large number of threads consumes system memory and CPU time.</li>
 <li><strong>Context switching overhead</strong>: The operating system must frequently switch between many threads, degrading performance.</li>
 <li><strong>Difficult concurrency management</strong>: Writing thread-safe code with many threads is complex and error-prone.</li>
</ul><h4 id="poor-scalability">Poor Scalability</h4><p>Blocking IO works well for applications with a small number of IO channels, but as the number of concurrent connections grows, performance and scalability suffer:</p><ul>
 <li>Servers using one thread per client eventually reach resource limits.</li>
 <li>High latency and lower throughput result from thread contention and blocking waits.</li>
</ul><h4 id="lack-of-fine-grained-control">Lack of Fine-Grained Control</h4><p>The old IO API offers limited control over buffering, multiplexing, or non-blocking operations. Developers often have to rely on platform-specific or third-party tools to handle efficient, scalable IO.</p><h3 id="why-was-java-nio-introduced">Why Was Java NIO Introduced?</h3><p>Java NIO was introduced in Java 1.4 to provide a <strong>new foundation for scalable, high-performance IO operations</strong> in Java applications. Its design goals include:</p><ul>
 <li><strong>Non-blocking IO</strong>: Allow threads to initiate IO operations without waiting for completion, enabling a single thread to manage many IO channels.</li>
 <li><strong>Selectors for multiplexing</strong>: Efficiently monitor multiple channels for readiness, avoiding the need for many threads.</li>
 <li><strong>Buffer-oriented data handling</strong>: Use explicit buffers for reading and writing, enabling fine-grained control of data transfer.</li>
 <li><strong>Improved performance and scalability</strong>: Reduce overhead and improve responsiveness, especially in server and network applications.</li>
 <li><strong>Platform independence</strong>: Provide a consistent, portable API that abstracts underlying OS features like epoll, kqueue, or IOCP.</li>
</ul><h3 id="core-concepts-and-features-of-java-nio">Core Concepts and Features of Java NIO</h3><ul>
 <li><p><strong>Buffers</strong>: Unlike stream IO, NIO uses <strong>buffers</strong>—containers for fixed-size data arrays—which must be explicitly flipped, cleared, or compacted. This explicit data management improves efficiency and control.</p></li>
 <li><p><strong>Channels</strong>: Channels are like bidirectional IO pipes representing connections to files, sockets, or other IO entities. They can be non-blocking and allow asynchronous operations.</p></li>
 <li><p><strong>Selectors</strong>: Selectors let a single thread <strong>monitor multiple channels</strong> for events such as readiness to read or write, enabling multiplexed, non-blocking IO.</p></li>
</ul><h3 id="how-nio-improves-scalability-and-efficiency">How NIO Improves Scalability and Efficiency</h3><ul>
 <li><p><strong>Single-thread multiplexing</strong>: Instead of dedicating one thread per connection, one thread can handle thousands of connections by using selectors to react when channels are ready for IO.</p></li>
 <li><p><strong>Reduced context switching</strong>: Fewer threads mean less overhead from context switches and lower memory consumption.</p></li>
 <li><p><strong>Non-blocking mode</strong>: Threads don’t block waiting on IO; they continue executing, enhancing throughput and responsiveness.</p></li>
 <li><p><strong>Direct buffers</strong>: NIO supports direct buffers that interact more efficiently with the underlying OS and hardware, reducing copying and improving performance.</p></li>
 <li><p><strong>Asynchronous file and network IO</strong>: Some NIO APIs support asynchronous operations for even greater concurrency.</p></li>
</ul><h3 id="real-world-scenarios-where-nio-shines">Real-World Scenarios Where NIO Shines</h3><h4 id="high-performance-servers">High-Performance Servers</h4><p>Web servers, chat servers, game servers, and other network applications that handle thousands or millions of simultaneous connections benefit from NIO’s ability to multiplex many channels with a limited number of threads.</p><p>For example, a web server using NIO can manage many thousands of client sockets without allocating one thread per client, conserving system resources and improving response times.</p><h4 id="event-driven-architectures">Event-Driven Architectures</h4><p>NIO’s selector mechanism fits well with event-driven programming models, where IO readiness triggers events that drive application logic, such as in frameworks like Netty or Vert.x.</p><h4 id="file-processing-applications">File Processing Applications</h4><p>NIO’s memory-mapped files and efficient channel operations improve performance in applications that process large files or perform random access reads/writes.</p><h4 id="real-time-or-interactive-applications">Real-Time or Interactive Applications</h4><p>Applications that require low latency and high throughput, such as financial trading platforms or multimedia streaming, use NIO to avoid blocking delays and improve responsiveness.</p><h3 id="recap">Recap</h3><p>Java’s original IO API is simple and stream-based but suffers from blocking behavior and scalability issues when handling many simultaneous IO operations. <strong>Java NIO</strong> was introduced to overcome these limitations by providing:</p><ul>
 <li>Non-blocking IO capabilities,</li>
 <li>Efficient multiplexing through selectors,</li>
 <li>Explicit buffer management,</li>
 <li>Better scalability and resource efficiency.</li>
</ul><p>These improvements make NIO especially suitable for modern server applications, event-driven systems, and high-performance file processing, enabling Java applications to meet today’s demanding performance and scalability requirements.</p><div class = "chapter-navi-section">
<a href="#top" class="nav-button prev">↑</a>
<a href='java-io-and-nio.htm#introduction-to-java-nio-new-io' class="nav-button toc-link">Index</a>
<a href="#bottom" class="nav-button next">↓</a>
</div>
<h2 id='core-concepts-buffers-channels-and-selectors'>5.2 Core Concepts: Buffers, Channels, and Selectors</h2><p>Java NIO (New IO) introduces a new architecture for handling IO in Java applications, designed to improve scalability, efficiency, and control. The foundation of this architecture rests on three core components: <strong>Buffers</strong>, <strong>Channels</strong>, and <strong>Selectors</strong>. Understanding these concepts and how they interact is essential to effectively leveraging Java NIO’s power, especially in non-blocking IO operations.</p><h3 id="buffers-containers-for-data">Buffers: Containers for Data</h3><p>At the heart of NIO’s data handling is the <strong>Buffer</strong>. Unlike the classic Java IO’s stream-based sequential access, NIO adopts a <strong>buffer-oriented</strong> model.</p><h4 id="what-is-a-buffer">What is a Buffer?</h4><p>A <strong>Buffer</strong> is a fixed-size block of memory that holds data to be read or written. It acts as a container or workspace where bytes or other primitive data types are stored before they are transferred to or from an IO source.</p><p>Buffers in NIO come in several types corresponding to different primitive data:</p><ul>
 <li><code>ByteBuffer</code> (most common)</li>
 <li><code>CharBuffer</code></li>
 <li><code>IntBuffer</code></li>
 <li><code>FloatBuffer</code></li>
 <li>...and more.</li>
</ul><h4 id="buffer-structure-and-key-properties">Buffer Structure and Key Properties</h4><p>Each buffer maintains:</p><ul>
 <li><strong>Capacity</strong>: The total size of the buffer.</li>
 <li><strong>Position</strong>: The current index where the next read or write will occur.</li>
 <li><strong>Limit</strong>: The index one past the last valid data element (for reading) or the maximum writable position.</li>
</ul><p>Before reading from or writing to a buffer, you manipulate these properties via methods like:</p><ul>
 <li><code>clear()</code>: Prepares the buffer for writing (position set to 0, limit set to capacity).</li>
 <li><code>flip()</code>: Prepares the buffer for reading after writing (limit set to current position, position reset to 0).</li>
 <li><code>rewind()</code>: Resets position to 0 to reread data.</li>
 <li><code>compact()</code>: Moves unread data to the start for additional writing.</li>
</ul><h3 id="analogy-buffer-as-a-container">Analogy: Buffer as a Container</h3><p>Think of a buffer like a glass container:</p><ul>
 <li><strong>Capacity</strong> = size of the container.</li>
 <li><strong>Position</strong> = where you’re currently pouring liquid in or scooping liquid out.</li>
 <li><strong>Limit</strong> = the maximum level of liquid that you’re allowed to read/write.</li>
</ul><p>Before drinking (reading) from the glass, you first pour (write) some liquid, then flip your intention to drinking by resetting the position to the start.</p><h3 id="channels-the-data-pathways">Channels: The Data Pathways</h3><p>While buffers hold data, <strong>Channels</strong> are the conduits or pipes that connect buffers to IO devices like files, network sockets, or pipes.</p><h4 id="what-is-a-channel">What is a Channel?</h4><p>A <strong>Channel</strong> is a bi-directional communication channel for reading, writing, or both, between a Java program and an IO source/sink.</p><ul>
 <li>Channels can be <strong>readable</strong>, <strong>writable</strong>, or both.</li>
 <li>They represent entities such as files (<code>FileChannel</code>), sockets (<code>SocketChannel</code>), and datagram connections (<code>DatagramChannel</code>).</li>
</ul><h4 id="how-channels-work-with-buffers">How Channels Work with Buffers</h4><p>Channels do not operate on streams of bytes like old IO; instead, they <strong>transfer data to or from buffers</strong>.</p><ul>
 <li>To <strong>read</strong> data, a channel fills a buffer.</li>
 <li>To <strong>write</strong> data, a channel drains data from a buffer.</li>
</ul><p>Because buffers are containers, this separation allows for efficient, flexible data handling.</p><h3 id="example-reading-from-a-file-using-channel-and-buffer">Example: Reading from a File Using Channel and Buffer</h3><div class="code-block"><button class="copy-button" onclick="copyCode(this)">📋</button>
 <pre><code class="language-java">import java.nio.*;
import java.nio.channels.*;
import java.nio.file.*;

public class FileReadExample {
    public static void main(String[] args) throws Exception {
        Path path = Paths.get("example.txt");
        try (FileChannel fileChannel = FileChannel.open(path, StandardOpenOption.READ)) {
            ByteBuffer buffer = ByteBuffer.allocate(1024);

            int bytesRead = fileChannel.read(buffer);
            while (bytesRead != -1) {
                buffer.flip(); // Prepare buffer for reading

                while (buffer.hasRemaining()) {
                    System.out.print((char) buffer.get()); // Read bytes from buffer
                }
                buffer.clear(); // Prepare buffer for next read
                bytesRead = fileChannel.read(buffer);
            }
        }
    }
}</code></pre>
</div><p>This example shows how the <code>FileChannel</code> reads data into a <code>ByteBuffer</code>, then the program reads from the buffer.</p><h3 id="selectors-multiplexing-multiple-channels">Selectors: Multiplexing Multiple Channels</h3><p>One of the most powerful features of NIO is the <strong>Selector</strong>, which enables a single thread to monitor multiple channels for events, such as readiness to read or write.</p><h3 id="what-is-a-selector">What is a Selector?</h3><p>A <strong>Selector</strong> is an object that can <strong>monitor multiple channels</strong> simultaneously, waiting for events on any of them without blocking the thread.</p><p>Instead of dedicating one thread per connection or file operation (as in traditional blocking IO), a Selector lets a single thread react when any registered channel is ready for IO.</p><h3 id="how-does-a-selector-work">How Does a Selector Work?</h3><ol>
 <li>You register multiple channels with the selector, specifying interest operations (e.g., OP_READ, OP_WRITE).</li>
 <li>The selector blocks until at least one channel is ready.</li>
 <li>It provides a set of <strong>SelectionKeys</strong>, representing channels ready for IO.</li>
 <li>Your program handles these ready channels accordingly.</li>
</ol><h3 id="analogy-selector-as-a-traffic-controller">Analogy: Selector as a Traffic Controller</h3><p>Imagine a traffic controller watching multiple roads (channels). Instead of blocking at each road, the controller waits until a vehicle arrives on any road and directs traffic accordingly. This approach avoids idle waiting at each road and efficiently manages multiple lanes with fewer resources.</p><h3 id="example-registering-a-channel-with-a-selector">Example: Registering a Channel with a Selector</h3><div class="code-block"><button class="copy-button" onclick="copyCode(this)">📋</button>
 <pre><code class="language-java">import java.nio.channels.*;
import java.net.InetSocketAddress;

public class SelectorExample {
    public static void main(String[] args) throws Exception {
        Selector selector = Selector.open();

        // Open a socket channel and configure non-blocking mode
        SocketChannel socketChannel = SocketChannel.open();
        socketChannel.configureBlocking(false);

        // Connect to server
        socketChannel.connect(new InetSocketAddress("example.com", 80));

        // Register channel with selector for connect events
        socketChannel.register(selector, SelectionKey.OP_CONNECT);

        while (true) {
            selector.select(); // Wait for ready channels

            for (SelectionKey key : selector.selectedKeys()) {
                if (key.isConnectable()) {
                    // Finish connection process...
                }
                // Handle other events...
            }
            selector.selectedKeys().clear(); // Clear handled keys
        }
    }
}</code></pre>
</div><h3 id="how-buffers-channels-and-selectors-work-together">How Buffers, Channels, and Selectors Work Together</h3><ul>
 <li><strong>Buffers</strong> hold the data being read or written.</li>
 <li><strong>Channels</strong> transfer data between buffers and IO sources/sinks.</li>
 <li><strong>Selectors</strong> allow a single thread to efficiently manage multiple channels, waiting for events and enabling non-blocking IO.</li>
</ul><p>Together, they enable scalable, high-performance applications where threads do not block waiting for IO but instead react to readiness events, reading/writing data in controlled buffer chunks.</p><h3 id="summary">Summary</h3><ul>
 <li><strong>Buffers</strong>: Fixed-size containers managing data with explicit control over reading/writing positions.</li>
 <li><strong>Channels</strong>: Data conduits connecting buffers with IO sources or destinations.</li>
 <li><strong>Selectors</strong>: Multiplexers that monitor multiple channels for IO readiness, allowing efficient non-blocking IO with few threads.</li>
</ul><p>This architecture contrasts with classic blocking IO and enables modern applications such as high-performance servers, real-time systems, and event-driven frameworks to handle large numbers of simultaneous IO operations efficiently.</p><div class = "chapter-navi-section">
<a href="#top" class="nav-button prev">↑</a>
<a href='java-io-and-nio.htm#introduction-to-java-nio-new-io' class="nav-button toc-link">Index</a>
<a href="#bottom" class="nav-button next">↓</a>
</div>
<h2 id='differences-between-io-and-nio'>5.3 Differences Between IO and NIO</h2><p>Java provides two main APIs for input/output operations: <strong>Traditional Java IO</strong> (introduced in Java 1.0) and <strong>Java NIO</strong> (New IO, introduced in Java 1.4). Both enable reading and writing data, but they differ significantly in design philosophy, performance characteristics, and typical use cases.</p><p>Understanding these differences is crucial when choosing the right approach for your application, especially when dealing with scalable or high-performance IO needs.</p><h3 id="blocking-vs-non-blocking-io">Blocking vs Non-Blocking IO</h3><h4 id="traditional-java-io-blocking-io">Traditional Java IO: Blocking IO</h4><p>Traditional Java IO is built on <strong>blocking IO</strong>. When a thread calls a read or write operation on an InputStream or OutputStream, it <strong>blocks</strong>, meaning the thread waits until the data is fully read or written before proceeding.</p><p><strong>Example:</strong></p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-java">InputStream input = new FileInputStream("file.txt");
int data = input.read();  // Blocks until a byte is available or EOF</code></pre>
</div><p><strong>Implications:</strong></p><ul>
 <li>Each blocking operation consumes a thread, which must wait idly.</li>
 <li>For network servers, this often means one thread per client connection.</li>
 <li>Excessive threads cause overhead from context switching and memory usage.</li>
 <li>Scaling to thousands of concurrent connections is challenging.</li>
</ul><h4 id="java-nio-non-blocking-io">Java NIO: Non-Blocking IO</h4><p>Java NIO introduces <strong>non-blocking IO</strong> and <strong>selectors</strong>, enabling a single thread to manage multiple channels (connections) without waiting.</p><p>Channels can be configured to non-blocking mode, so calls like <code>read()</code> or <code>write()</code> return immediately:</p><ul>
 <li>If data is available, they read/write some or all data.</li>
 <li>If no data is available, they return zero or a special value, letting the thread continue other work.</li>
</ul><p>A <strong>Selector</strong> monitors many channels, notifying when one or more are ready for IO, avoiding thread-blocking.</p><p><strong>Example:</strong></p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">📋</button>
 <pre><code class="language-java">import java.nio.channels.SelectionKey;
import java.nio.channels.Selector;
import java.nio.channels.SocketChannel;
import java.util.Set;

public class Test {

    public static void main(String[] argv) throws Exception {
        SocketChannel channel = SocketChannel.open();
        channel.configureBlocking(false);
        Selector selector = Selector.open();
        channel.register(selector, SelectionKey.OP_READ);

        while (true) {
            selector.select();  // Blocks until at least one channel is ready
            Set&lt;SelectionKey&gt; keys = selector.selectedKeys();
            for (SelectionKey key : keys) {
                if (key.isReadable()) {
                    // Read data without blocking
                }
            }
            keys.clear();
        }
    }
}</code></pre>
</div><p><strong>Implications:</strong></p><ul>
 <li>One thread can manage thousands of connections efficiently.</li>
 <li>Greatly improves scalability and resource utilization.</li>
 <li>Requires more complex programming to handle readiness events.</li>
</ul><h3 id="stream-based-vs-buffer-based-data-handling">Stream-Based vs Buffer-Based Data Handling</h3><h4 id="traditional-io-stream-based">Traditional IO: Stream-Based</h4><p>Java IO models data as <strong>streams</strong> — continuous flows of bytes or characters.</p><ul>
 <li>Data is read or written <strong>sequentially</strong>, one byte/char at a time.</li>
 <li>The API abstracts away the internal buffering or memory management.</li>
 <li>Developers typically read or write bytes in a loop.</li>
</ul><p><strong>Example:</strong></p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-Java">byte[] buffer = new byte[1024];
int bytesRead = inputStream.read(buffer);</code></pre>
</div><p>The <code>read()</code> method blocks until at least one byte is available and fills the buffer.</p><h4 id="java-nio-buffer-based">Java NIO: Buffer-Based</h4><p>Java NIO operates with <strong>buffers</strong>—fixed-size containers that explicitly hold data.</p><ul>
 <li>Data is <strong>read into</strong> a buffer or <strong>written from</strong> a buffer.</li>
 <li>Buffers have positions and limits that must be managed manually.</li>
 <li>This explicit control enables more efficient, flexible data processing.</li>
</ul><p><strong>Example:</strong></p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-Java">ByteBuffer buffer = ByteBuffer.allocate(1024);
int bytesRead = channel.read(buffer);
buffer.flip();  // Prepare to read from buffer
while(buffer.hasRemaining()) {
    byte b = buffer.get();
}
buffer.clear(); // Prepare buffer for next write</code></pre>
</div><h3 id="synchronous-vs-asynchronous-processing">Synchronous vs Asynchronous Processing</h3><h4 id="traditional-io-mostly-synchronous">Traditional IO: Mostly Synchronous</h4><p>Traditional Java IO operations are synchronous and blocking — the program flow waits for IO completion.</p><ul>
 <li>Simpler to program and reason about.</li>
 <li>May lead to thread starvation or performance bottlenecks under heavy load.</li>
</ul><h4 id="java-nio-supports-asynchronous-and-synchronous-non-blocking">Java NIO: Supports Asynchronous and Synchronous Non-Blocking</h4><p>NIO supports:</p><ul>
 <li><strong>Non-blocking synchronous IO</strong> via selectors (as described above).</li>
 <li><strong>Asynchronous IO</strong> (introduced later as NIO.2 in Java 7) with classes like <code>AsynchronousFileChannel</code> that allow the OS to notify completion via callbacks or futures.</li>
</ul><p>This enables event-driven architectures, where the program reacts to IO events without being stuck waiting.</p><h3 id="data-flow-differences">Data Flow Differences</h3><p><strong>Traditional IO Data Flow:</strong></p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-bash">Application Thread
    ↓ (blocking read)
InputStream/File/Socket
    ↓ sequential data flow</code></pre>
</div><ul>
 <li>Each IO call blocks the thread until data arrives.</li>
 <li>One thread per IO operation.</li>
</ul><p><strong>NIO Data Flow:</strong></p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-bash">Application Thread
    ↓
Selector &lt;-- multiple Channels (non-blocking)
    ↓
Buffers &lt;--&gt; Channels</code></pre>
</div><ul>
 <li>The selector notifies when channels are ready.</li>
 <li>One thread handles many channels.</li>
 <li>Buffers explicitly hold data in memory.</li>
</ul><h3 id="impact-on-application-design">Impact on Application Design</h3><ul>
 <li><strong>Traditional IO</strong> is easier for simple or small-scale applications.</li>
 <li><strong>NIO</strong> requires managing buffers, selectors, and readiness events but excels in scalable, high-concurrency scenarios like servers or real-time applications.</li>
 <li>NIO fits well with <strong>event-driven architectures</strong> and frameworks like Netty, enabling highly responsive network applications.</li>
</ul><h3 id="summary-table">Summary Table</h3><table>
 <thead>
  <tr>
   <th>Feature</th>
   <th>Traditional Java IO</th>
   <th>Java NIO</th>
  </tr>
 </thead>
 <tbody>
  <tr>
   <td>IO Model</td>
   <td>Blocking, stream-based</td>
   <td>Non-blocking, buffer-based</td>
  </tr>
  <tr>
   <td>Thread Usage</td>
   <td>One thread per IO operation</td>
   <td>One thread manages many channels</td>
  </tr>
  <tr>
   <td>Data Handling</td>
   <td>Sequential byte/char streams</td>
   <td>Explicit buffers with position/limit</td>
  </tr>
  <tr>
   <td>Scalability</td>
   <td>Limited by thread overhead</td>
   <td>High scalability via selectors</td>
  </tr>
  <tr>
   <td>Programming Complexity</td>
   <td>Simpler API</td>
   <td>More complex, event-driven</td>
  </tr>
  <tr>
   <td>Asynchronous Support</td>
   <td>No native async</td>
   <td>Supports async with NIO.2</td>
  </tr>
  <tr>
   <td>Typical Use Cases</td>
   <td>Simple file IO, small apps</td>
   <td>High-performance servers, network apps</td>
  </tr>
 </tbody>
</table><h3 id="recap">Recap</h3><p>While the traditional Java IO API remains useful for simple, blocking IO tasks, Java NIO offers a modern, scalable alternative designed for the demands of today’s networked, concurrent, and high-performance applications. By moving from blocking streams to non-blocking buffers and selectors, NIO allows Java developers to build efficient and scalable systems without the overhead of thread-per-connection models.</p><div class = "chapter-navi-section">
<a href="#top" class="nav-button prev">↑</a>
<a href='java-io-and-nio.htm#introduction-to-java-nio-new-io' class="nav-button toc-link">Index</a>
<a href="#bottom" class="nav-button next">↓</a>
</div>
<h2 id='non-blocking-io-and-selectors-overview'>5.4 Non-blocking IO and Selectors Overview</h2><p>Java NIO (New IO) introduced a revolutionary way to handle IO operations that vastly improves scalability and performance for applications dealing with multiple simultaneous IO channels, such as servers handling many client connections.</p><p>At the core of this improvement lies the concept of <strong>non-blocking IO</strong> combined with <strong>selectors</strong>, allowing a <strong>single thread to efficiently manage many IO channels</strong> without blocking or dedicating one thread per connection. This section explores how selectors work, their relationship with channels, and how they enable scalable non-blocking IO.</p><h3 id="understanding-non-blocking-io">Understanding Non-blocking IO</h3><p>In traditional IO, when you read from or write to a channel (e.g., a socket or file), the thread blocks until the operation completes. For example, reading from a socket input stream blocks until data arrives. This is simple but inefficient for high concurrency — threads spend much time waiting and consume resources.</p><p><strong>Non-blocking IO</strong> changes this behavior:</p><ul>
 <li>When a thread attempts to read from or write to a channel in non-blocking mode, the operation returns immediately.</li>
 <li>If data is available, some or all of it is processed.</li>
 <li>If no data is available (e.g., no bytes to read), the method returns zero or a special value indicating no action.</li>
 <li>The thread can then continue doing other work instead of waiting.</li>
</ul><p>This non-blocking mode is <strong>enabled by setting a channel to non-blocking</strong>, typically via:</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-Java">channel.configureBlocking(false);</code></pre>
</div><h3 id="selectors-multiplexing-multiple-channels">Selectors: Multiplexing Multiple Channels</h3><p>Non-blocking IO alone is useful, but applications often need to manage many channels simultaneously (e.g., thousands of client sockets). Managing many channels in a single thread requires a mechanism to <strong>know which channels are ready for reading, writing, or connecting without busy-waiting or polling inefficiently</strong>.</p><p>This is where the <strong><code>Selector</code></strong> class comes in.</p><h4 id="what-is-a-selector">What is a Selector?</h4><p>A <strong>Selector</strong> is a multiplexing tool that allows a single thread to monitor multiple channels for various IO events, such as:</p><ul>
 <li><strong>Read readiness</strong> — data available to read.</li>
 <li><strong>Write readiness</strong> — channel ready to accept data.</li>
 <li><strong>Connect readiness</strong> — a connection operation finished.</li>
 <li><strong>Accept readiness</strong> — new incoming connection ready to be accepted.</li>
</ul><p>The Selector <strong>blocks the thread until at least one registered channel is ready for one of the requested operations</strong>, enabling efficient waiting without wasting CPU cycles.</p><h3 id="how-selectors-work">How Selectors Work</h3><ol>
 <li><strong>Open a Selector</strong></li>
</ol><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-Java">Selector selector = Selector.open();</code></pre>
</div><ol start="2">
 <li><strong>Configure Channels as Non-blocking and Register with Selector</strong></li>
</ol><p>Each channel you want to monitor must be configured to non-blocking mode and registered with the selector, specifying which operations you want to listen for:</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-Java">channel.configureBlocking(false);
SelectionKey key = channel.register(selector, SelectionKey.OP_READ | SelectionKey.OP_WRITE);</code></pre>
</div><ol start="3">
 <li><strong>Waiting for Ready Channels</strong></li>
</ol><p>The selector’s <code>select()</code> method blocks until one or more channels are ready:</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-Java">int readyChannels = selector.select();</code></pre>
</div><ol start="4">
 <li><strong>Processing Selected Keys</strong></li>
</ol><p>After <code>select()</code> returns, you retrieve the set of <strong><code>SelectionKey</code></strong> objects representing ready channels:</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">📋</button>
 <pre><code class="language-java">import java.nio.channels.SelectionKey;
import java.nio.channels.Selector;
import java.nio.channels.SocketChannel;
import java.util.Iterator;
import java.util.Set;

public class Test {

    public static void main(String[] argv) throws Exception {
        SocketChannel channel = SocketChannel.open();
        channel.configureBlocking(false);
        Selector selector = Selector.open();
        Set&lt;SelectionKey&gt; selectedKeys = selector.selectedKeys();
        Iterator&lt;SelectionKey&gt; keyIterator = selectedKeys.iterator();

        while (keyIterator.hasNext()) {
            SelectionKey key = keyIterator.next();
            
            if (key.isReadable()) {
                // Read data from channel
            } else if (key.isWritable()) {
                // Write data to channel
            } else if (key.isAcceptable()) {
                // Accept a new connection
            } else if (key.isConnectable()) {
                // Finish connection process
            }
            
            keyIterator.remove(); // Important: Remove the key to avoid processing it again
        }
    }
}</code></pre>
</div><h3 id="selectionkey-the-channels-registration-token">SelectionKey: The Channels Registration Token</h3><p>When you register a channel with a selector, you get a <code>SelectionKey</code> representing the relationship. It tracks:</p><ul>
 <li>Which operations the channel is interested in (<code>interestOps</code>).</li>
 <li>Which operations are ready (<code>readyOps</code>).</li>
 <li>Attachment objects for storing related data or state.</li>
</ul><h3 id="advantages-of-using-selectors-and-non-blocking-io">Advantages of Using Selectors and Non-blocking IO</h3><ul>
 <li><strong>Scalability:</strong> A single thread can manage thousands of channels efficiently, avoiding the overhead of one thread per connection.</li>
 <li><strong>Resource Efficiency:</strong> Threads aren’t blocked and don’t waste CPU cycles polling or waiting.</li>
 <li><strong>Responsiveness:</strong> Applications can respond immediately when channels are ready for IO.</li>
 <li><strong>Fits Event-driven Models:</strong> The selector pattern aligns well with event-driven programming, facilitating reactive and asynchronous designs.</li>
</ul><h3 id="conceptual-example-echo-server-using-selectors">Conceptual Example: Echo Server Using Selectors</h3><div class="code-block"><button class="copy-button" onclick="copyCode(this)">📋</button>
 <pre><code class="language-java">import java.net.InetSocketAddress;
import java.nio.ByteBuffer;
import java.nio.channels.SelectionKey;
import java.nio.channels.Selector;
import java.nio.channels.ServerSocketChannel;
import java.nio.channels.SocketChannel;
import java.util.Iterator;
import java.util.Set;

public class Test {

    public static void main(String[] argv) throws Exception {
        SocketChannel channel = SocketChannel.open();
        channel.configureBlocking(false);
        Selector selector = Selector.open();
        ServerSocketChannel serverChannel = ServerSocketChannel.open();
        serverChannel.bind(new InetSocketAddress(8080));
        serverChannel.configureBlocking(false);
        serverChannel.register(selector, SelectionKey.OP_ACCEPT);

        while (true) {
            selector.select(); // Wait for events

            Set&lt;SelectionKey&gt; keys = selector.selectedKeys();
            Iterator&lt;SelectionKey&gt; iter = keys.iterator();

            while (iter.hasNext()) {
                SelectionKey key = iter.next();

                if (key.isAcceptable()) {
                    // Accept connection
                    ServerSocketChannel server = (ServerSocketChannel) key.channel();
                    SocketChannel client = server.accept();
                    client.configureBlocking(false);
                    client.register(selector, SelectionKey.OP_READ);
                }

                if (key.isReadable()) {
                    SocketChannel client = (SocketChannel) key.channel();
                    ByteBuffer buffer = ByteBuffer.allocate(256);
                    int bytesRead = client.read(buffer);
                    if (bytesRead == -1) {
                        client.close(); // Client closed connection
                    } else {
                        buffer.flip();
                        client.write(buffer); // Echo data back
                    }
                }

                iter.remove(); // Remove handled key
            }
        }
    }
}</code></pre>
</div><p>This simple echo server handles multiple clients concurrently on a single thread without blocking.</p><h3 id="summary">Summary</h3><ul>
 <li><strong>Non-blocking IO</strong> allows IO operations to return immediately, avoiding thread blocking.</li>
 <li><strong>Selectors</strong> multiplex many non-blocking channels, notifying when channels are ready for IO.</li>
 <li>A single thread can efficiently monitor and service many channels using a selector.</li>
 <li><code>SelectionKey</code>s represent channel registrations and track IO readiness.</li>
 <li>This model enables scalable, resource-efficient, and responsive IO applications, especially suitable for servers and event-driven systems.</li>
</ul><div class = "chapter-navi-section">
<a href="java-io-and-nio-advanced-java-io-concepts.htm" class="nav-button prev">←</a>
<a href='java-io-and-nio.htm#introduction-to-java-nio-new-io' class="nav-button toc-link">Index</a>
<a href="java-io-and-nio-buffers-and-channels.htm" class="nav-button next">→</a>
</div>
<section class="download-section">
  <div class="book-cover" style="background-color: #f9f6f1;border: 1px solid #ccc;"> 
    <div class="book-cover-title" style="font-size: 18px;color: #333;top: 20px;">Java IO and NIO</div>
    <div class="book-cover-author">readbytes</div>
    <div class="book-cover-bottom-stripe" style="background-color: #333;"></div>
    <img class="book-cover-icon" style="width: 80px;height: 90px;top: 60px;" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFoAAABaCAYAAAA4qEECAAADAElEQVR4Xu2Zu6oTURSGjze0UfANtLAUzgOI4DOItc+VKk1uJ12aadNa21vbCpYK4wQmcPiYzL5k7eXM2f8HP0JYa/3ZX2PEmxshxAPi7u6uLRH2VA3lWId9VdK27WOKsQ47q6RpmucUYx12VolEOyHRToyJ5mwI7ufeeZBItBMS7YREOyHRTki0ExLthEQ7IdFOSLQTEu2ERDsxJtoq7KwSiXZCop04Ho9PKcY67KwWirEO+6qGcqzCHhGBJDoh0U5ItAP7/f6bRDtAyV3+ckYYQNHr9fo1Z8SVtG37iKI5Mzv4IKuwJwXeuvbef4ePsQ77YuGdLp85MysGHmQa9sXAG7l3JgUfZB32heh+0t3yRvfZD87NDj7KOuwLwf2cG5OEj7IO+8bg7imr1eoV55Lh0VC4bwE7cru4n3Jns9l85d7YPmdCSV8oADtyu7gfe4fzMbucCyV9oQDsyO3i/tid7i+395xjuHMfzoaSvlAAduR2cf/+ne7PT/x8JL94mwzsjCZ5wTN8XAjuTynT/nKJcH9KmfaXS4T7U8q0v1wi3J9Skr8cH3cJ7l3I98Ph8HLg86SuM9zPvRMDO0JJXwjQ/Wx6yx3kI3cGZqK6CPdz78TAjlDSF0ZYLpcvOH9O0zQX/xnL2ZiuIbifeycGdoSSvjACZ2N2TnA+do9wP/dODOwIhfvZ8HCfn5wbYmDPNOybLXxYn9+cu8TArmnYN1v4sNTHcdc67JslfFTOw7hvHfbNEj6q+3n3gTMheMM67JsdfNA1j+Idq7BnlvBR2+32DWfElazX63cUzRlhACVLdCEk2QmJdmC3232RaAcoucsfzogAAxJNwp6qoRzrsK9aKMY6i8XiGTurhGKsc/ofGHZWCcVYR6J7KMY6Et1DMedwLgT3JRpQjEQXgmIkuhAUI9GFoBiJLgTFSHQhKEaiC0ExEl0IipHoQlCMRBeCYiS6EBQj0YWgGOtIdA/FWEeieyjGOhLdQzHW2e/3T9hZJRRjHfZVDeVYhT1CiDnzD27IzgFe/xOvAAAAAElFTkSuQmCC"/>
  </div>
  <div class="download-info">
    <h2 id='bottom'>Download This Ebook</h2>
    <p class="format-label">Available formats:</p>
    <div class="download-buttons">
      <a href="java-io-and-nio.pdf" class="download-button">📄 PDF</a>
      <a href="java-io-and-nio.epub" class="download-button">📘 EPUB</a>
    </div>
  </div>
</section><div class='related-books'>
<h2>Java In-Depth Books</h2>
<div class='related-book-list'>
<a href="java-io-and-nio.htm">
<div class="book-cover" style="background-color: #f9f6f1;border: 1px solid #ccc;"> 
    <div class="book-cover-title" style="font-size: 18px;color: #333;top: 20px;">Java IO and NIO</div>
    <div class="book-cover-author">readbytes</div>
    <div class="book-cover-bottom-stripe" style="background-color: #333;"></div>
    <img class="book-cover-icon" style="width: 80px;height: 90px;top: 60px;" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFoAAABaCAYAAAA4qEECAAADAElEQVR4Xu2Zu6oTURSGjze0UfANtLAUzgOI4DOItc+VKk1uJ12aadNa21vbCpYK4wQmcPiYzL5k7eXM2f8HP0JYa/3ZX2PEmxshxAPi7u6uLRH2VA3lWId9VdK27WOKsQ47q6RpmucUYx12VolEOyHRToyJ5mwI7ufeeZBItBMS7YREOyHRTki0ExLthEQ7IdFOSLQTEu2ERDsxJtoq7KwSiXZCop04Ho9PKcY67KwWirEO+6qGcqzCHhGBJDoh0U5ItAP7/f6bRDtAyV3+ckYYQNHr9fo1Z8SVtG37iKI5Mzv4IKuwJwXeuvbef4ePsQ77YuGdLp85MysGHmQa9sXAG7l3JgUfZB32heh+0t3yRvfZD87NDj7KOuwLwf2cG5OEj7IO+8bg7imr1eoV55Lh0VC4bwE7cru4n3Jns9l85d7YPmdCSV8oADtyu7gfe4fzMbucCyV9oQDsyO3i/tid7i+395xjuHMfzoaSvlAAduR2cf/+ne7PT/x8JL94mwzsjCZ5wTN8XAjuTynT/nKJcH9KmfaXS4T7U8q0v1wi3J9Skr8cH3cJ7l3I98Ph8HLg86SuM9zPvRMDO0JJXwjQ/Wx6yx3kI3cGZqK6CPdz78TAjlDSF0ZYLpcvOH9O0zQX/xnL2ZiuIbifeycGdoSSvjACZ2N2TnA+do9wP/dODOwIhfvZ8HCfn5wbYmDPNOybLXxYn9+cu8TArmnYN1v4sNTHcdc67JslfFTOw7hvHfbNEj6q+3n3gTMheMM67JsdfNA1j+Idq7BnlvBR2+32DWfElazX63cUzRlhACVLdCEk2QmJdmC3232RaAcoucsfzogAAxJNwp6qoRzrsK9aKMY6i8XiGTurhGKsc/ofGHZWCcVYR6J7KMY6Et1DMedwLgT3JRpQjEQXgmIkuhAUI9GFoBiJLgTFSHQhKEaiC0ExEl0IipHoQlCMRBeCYiS6EBQj0YWgGOtIdA/FWEeieyjGOhLdQzHW2e/3T9hZJRRjHfZVDeVYhT1CiDnzD27IzgFe/xOvAAAAAElFTkSuQmCC"/>
  </div>
</a>


<a href="java-collections.htm">
<div class="book-cover" style="background-color: #f9f6f1;border: 1px solid #ccc;"> 
    <div class="book-cover-title" style="font-size: 18px;color: #333;top: 20px;">Java Collections</div>
    <div class="book-cover-author">readbytes</div>
    <div class="book-cover-bottom-stripe" style="background-color: #333;"></div>
    <img class="book-cover-icon" style="width: 80px;height: 90px;top: 60px;" src='data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFoAAABaCAYAAAA4qEECAAADAElEQVR4Xu2dQYrUUBRFIw50JI7FrYgrcAPOXYPORHci7sah4EAQFyA6dNKosZK2Ee8/dOclP7/+i/fAmaR+Xr17KehJV2oYjDHGGGM6YRxzmgZdPKvdMt4vl03vLU15ZsYnsORB7Apd7mh2gS51VM/K+LVc6LA+0/QNKZax9RnvlG+C/tI7+6PYuYLV0MHoc72rX8ZvsP9Gq6BDyWzo/jXcjA4sfKN39E+RoYaf9F2CFAPFjGiG3b0Y5r9111LcJGZEM7QW0UNqRjTDWXwQXCojmoEk9MxmHwWGZ0QzkMT4ujy31b/D4UU8uITp/J4uRDOQxPiyPFfDy+HwQnFoCdPZFi5AM5BE/0VP51r5brgRzUASexU9/piG60VxEdO5lt6AZiCJ3Yoep+Fw8Z8DS5gHNfLncCOagSSWFE2M38tzanFBXcS9k/OwBi5AM5DE2qIn9JxaXFAXM33S5oE7+nFYhGYgiRxFX7FH4V+GEJqBJHIV3QGagSRcdBDNQBIuOohmIAkXHUQzkISLDqIZSMJFB9EMJOGig2gGknDRQTQDSbjoIJqBJHIUfffkPLCC74dNaAaSyFH0PKyiL4bVaAaS6L/oedAOrkQzkISLDqIZSMJFB9EMJNF/0bdPzsMquxLNQBL9Fz3x4eQ8sJIb0AwkkaPoK56efLvSV0MVNANJ5Cq6AzQDSbjoIJqBJFx0EM1AEi46iGYgCRcdRDOQhIsOohlIwkUH0Qwk4aKDaAaScNFBNANJuOggmoEkXHQQzUASLjqIZiAJFx1EM5CEiw6iGUjCRQfRDCSxtuh2X63oDM1AEkuKXmtxQc2IZiCJ3Yqu9vW3ztAMJLFX0ZfD4YXiUDI0A0m46CCagSTyfOm+EzQDSeiZzT4ODM+IZjiLD4NLZUQztBbRQ2pGNMPu1nh4lR/H9sfP+i5BioFgNnT/Gm5GB6Ib/im8Nf0+MtMPgb3Wquhwqw1Vwg/qbkix0EHtAl3qaHaDfx6kIf7Bm8YUyyY1Dbp4Fo0xxhhj/kd+A/PkOH57kF8HAAAAAElFTkSuQmCC'/>
  </div>
</a>


<a href="java-regex.htm">
<div class="book-cover" style="background-color: #f9f6f1;border: 1px solid #ccc;"> 
    <div class="book-cover-title" style="font-size: 18px;color: #333;top: 20px;">Java Regex</div>
    <div class="book-cover-author">readbytes</div>
    <div class="book-cover-bottom-stripe" style="background-color: #333;"></div>
    <img class="book-cover-icon" style="width: 80px;height: 90px;top: 60px;" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFoAAABaCAYAAAA4qEECAAAFo0lEQVR4Xu2d3WscVRiH+y/YXuuFkov6H9je2huvlAQvFalCEW8qiFRFQcGrmoJ4U5TSLWglFqRIlJqCH6XWalM/0lrT1O1ukt3sV5qPTZrP3XHfLTM983vPztc5s+zZPQ88N5l3Z9inwzA70Dl79iQks29oM7N3yBkoW98ZO6RC62ANdvDBtYF9lJEcxHNi+CWnOvmXs5rN9aX03eg74vcWxV6xObX3iUdxp2P7DzqDztiTB1lsaoX9InF631BJ3NH408N4vIFn/NCwL/aZVjPsGAj+a1mCwV7YUwqeyZZoxDqz8ZpsiYfY7mzQNdtGVkdsiH3b2Mj6CIztbrB3F+qMHxqRh84Iv/gsehDO6oe/IN0/ju0/gPOWhNAPO3ZW27M5HXyhTwtP4Sx68S4f9NRPuJbgnEURsa0Xmp5QWfQyMfLwqZ8XunrtT5yzKEKPWFnoem4O5xKxsVbS5vbmMu7eKOr5OUnovHro1ep0KppKPT+vP/TGWpkF0qWp2NBdwobuEjY0MnXbcb4cd5xCGbco0XOhb8wuOhdnGp4//7fl254ah9/urAZ6KrQYGL01V0sndLPJw8pUxJjQ5OXsBh5KjVZjFjRIBXoqdKWcZXHRK/kGHi45GDJMBXoqNFku3WVx0V9nNcTGiK7nLgRvT0jPhSZLacfGeK7Xb4bPJaQnQz+InWNx0USXEQzn+vsUTvKZfgxNFhfyLC4a68x+7QMejrwieVqJM+QX3+BUZHo6NDlfnGNx0auzdPsQAQxHXprEKT7jqkDPhyZni/MsLhopNoY7kcEJPuN6bBQnY2FEaDJXLLC4aGhsjIfgdtdX3sHJ2BgTmswVwmMHXrMxoBgb/+76snpkwqjQZKnusLhox7uRryd4yDA1YVxoYmG1yeKi0jP7nzs8ZJAaMTI0UVhJEPvN4zxmJzVjbGhidik8tu8ygjE7mQJGha7XZvBQTnYxPHb7zF6o8qAyU8KY0Gv37uJhPGZq4bEXpnI8KpoiRoTe3lzBQzCmq51j59aabSu/3OBxSU23cEH0fOgHT+ej8W+Fx3Yju9YuXO16ZCKV0DvVSWfrzlnm+tyP/pCVW2xGNAlibIzsunT+p65GJroamhRD4zbVyC7TFR4XXf7qIn4sVVIJ3bj9meNce0OqGLM5+Rbb7jMhePmQWXzqWWf15Of40dRIJfTmwmV2hiY1LhhUJkV2Xfn4FO4iFXo+NBkVDCpTjOzFPvEp7ko7RoQmw8CgMjGw6PJourGNCU12AoPKXHpvlMVFl4+fxF1rw6jQJIJBZbpgWJnLH34i7F0fxoamnzEYVKZI6ZkXWViZS+9+5PucDowNjUFlIlt/3GRRO7n4+vv4cSWMDI1BZcpYP/89Cxpk7cgx3EVijAuNQWV2AkOSbZpN9nfX6uHkP5xE+i50EBgRwe1e7BeO4mhs+ip0GBjw/nc/4AibCZqNQ9+EjgLGI50G/yzOeLMK9EXoqBQPPMfixYm9cek3HIuM8aHjgvFcmzs7OMpm2v8oCTE6dBJ2q/dYPC/29rZvFrcPZGgVdss1FtCLvX6/PVN5/lW2beBC62C3VGURw2z/D66EGBdaJ7vFMosZpAoDHZqIGluVgQ/dJuAnuI7IhA0NVEaOtOMuHrVP74zEhu4SNnSXkIdWfHnVbr3AAunSVOjkZaF1vI4NA+nQZKSvY7MvGNSP9AWDpEUvYlv7EtgU8UK7Sz/Z0Ongnc34/mi7apA+xNWHxND21fOa8S4buHiZu4GWJbKo8W2nxRTE0PasVkdsiZ3b2NjqhEYmaNkhGzs5Yrszjzz+GPb1QQtq2djxEZu17pvL2FWK70M2dijYC3sGgmc2LUtk8SPeXcQ6kxFcdo+kG/FBR+tSqCK4U1F6QlW7/rezms33pfTdxKdwMrGXMhm7XLWo/uWqZdgF2OPxPxXwJpKIkhiiAAAAAElFTkSuQmCC"/>
  </div>
</a>


<a href="java-functional-programming.htm">
<div class="book-cover" style="background-color: #f9f6f1;border: 1px solid #ccc;"> 
    <div class="book-cover-title" style="font-size: 18px;color: #333;top: 20px;">Java Functional Programming</div>
    <div class="book-cover-author">readbytes</div>
    <div class="book-cover-bottom-stripe" style="background-color: #333;"></div>
    <img class="book-cover-icon" style="width: 80px;height: 80px;top: 80px;" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFoAAABaCAYAAAA4qEECAAADzUlEQVR4Xu2bO4sUURCFlxVBzfwLJkb+A1MxEgMRDBQDRTBRwchARk00MRFBAwNBzEQwMBfEBz7wbWIkiIGJoInio9wZdmZ7T1V3V91bPVhaH3xJ973n3jk2vdO968JCkiRJkiRRIYphWOgI/zB/uyHBDxHFUODmIxkK3HwkQ4Gbj2QY6BDffCTDgBuPZhhw49EMA248miGgW3zj0QwBbjqiIcBNRzQEuOlohoA+8Y1HMgy4cauJEizO5EZMS0RoUSjPYKIEi7OaKMHirCZKsDiTi5iWiNAmoTyDiRIszmqiBIsz+QXTklZYeQYTJXSUl2cxUYLFWU2UYHEmb2Na0gorz2CihJ7w8iwmSrA4q4kSLM7kYUxLWmHlGUyU0C9ensVECRZnNQS4abPPMNEOy7S4BdN00L5GxmU8q4cuNXL24tll2KYrLIXW8yyLJdAJnkP3cFQ/9FzIGeEgHOBgCZhh1Qod5xkzH+PoduiVMH/qqDkQT3q4trGAEpZh1AId4/OZb3EWh14K89DRdDCecNIKzjdp+IelHcL8Nj/g7BU6r2R0+3gCHvRyN26tHdoszDdoAef2KpQt3pN7ZAc81YLzrFrAuSrfNOY/Es4rZAdcfbCywS7YPIvfMa0buiBkaFz6ATn+POy4xmvjhfGgsxpwjsUSigsr8el0UTzh7c9Vn5FBe4Q5BkuZXKFCnqsPmwviyQHsAsdarWF8tWGem/dxMRwwkG3gOJMvMM1O7S8aRJtX8hQ2aCDbwHEWvXAte3pPlmCDBxKhK3yMRU9cbiOKp0k+aQg3+K7pTdUPyHeYVgELL9At7/zqLA9KH0YmNh5qqqHPwgJWLzby8JxBb1y+Wxve+vXCwguc5Lzmxy164lLy1IL32SJ0Qwi3+k04ZtSLqttFm3dxlUJY8Lzdijsqo+QtnFqPK5u2CcFz1APT++RSPe7ZLHSO1qL6zYiXmu/WXdAaIXRO1lD8mnSpsOKHmpu4CyMscB5W/m8rlqex8TBS+lBTDQYObS2Y16vwxFfydbAaDBzaWmgXz2y14/46fg3Kxre5E2cXwoKH8geuXIb4hzNo11u4ZVRX9kmcVQELH0hP6BTPnym9T26h8559Gkc7wBYZQG/oLF+D/WZEgfht5AyOcoLeC4s5OwR0oLHGVTyrh643cvbjWWewGFc/4mr/MXRQKMjJBMCCvEwAWsdL8jARwJKqvYMrJDNYWRUmHWBZNSY9YGGlJj1gYUWew9REhBVnNFFCX3l5FhMDWJ7WpAAssc+kAiyzzcQJLHbibxyVJEmSJMk/xB+4wdarC+OVAQAAAABJRU5ErkJggg=="/>
  </div>
</a>


<a href="java-streams.htm">
<div class="book-cover" style="background-color: #f9f6f1;border: 1px solid #ccc;"> 
    <div class="book-cover-title" style="font-size: 18px;color: #333;top: 20px;">Java Streams</div>
    <div class="book-cover-author">readbytes</div>
    <div class="book-cover-bottom-stripe" style="background-color: #333;"></div>
    <img class="book-cover-icon" style="width: 80px;height: 80px;top: 60px;" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFoAAABaCAYAAAA4qEECAAACbklEQVR4Xu3cP4oUQRiG8S8xEzESDI1MPIRHEQQPYTK9iCyewMxrGIiCoaFnWFkMTIwUxD894KI8VbNdVdNfzdR87w+eRKa2ul+WVZM1G8+3ud+d+mhBvbZ0DO/uWEAcoVfhcIBehcQRvAvt1dz7gjjaVfxcrhcmxTiwvkudcGAN7YQDa2gnHFhDO+HAGtoJB24ZmmdzhcdBWobh2VzhcZCWYXg2V3gcpGUYns0VHgdpGYZnc4XHQVqG4dlc4XGQlmF4Nld4HKRlGJ7NFR4HaRmGZ3MN48Hcu7lLS19ihI7SPUsfdPSOCh/ulDoKfKhT7KC2P3P5QKfawfBBTr2D4ENEqDs+QJS64uWR6ubc0ssj1Q0vjlYXvLS1X3Mv5x7NPTyi+Jy5uuClNY2Az5zL3RtLLy1pJHz2XO544VLbHw+j4TvkcscLlxoR3yGXO154XaPie+Ry9djSC69rVHyPXK62/xTjhbu6+HtmRHyXXK6iDH1wGroTDd2Jhu5EQ3eioTvR0J1o6E40tAMOt1YCHGitBDjQWglwoLUS4EBrJcCB1kqAA62VwFOnREREROSIPbP7/CNZ28Y+2KT/hPjbjnyVOPl/ZA3tZLLzZGiN7YAD/+smPyqt0nH1Xe2Cw7LndpdHpBZH3ZXs4YndSAbdleyBYy4ljTjkUtKAI5a0sS/8MrKEI5YmFTZ2mQxYmlTgeDVt7DO/nOzC8WqTApPdSoarTQpM9ikZrjYpMNmPZLjapMDZ/JcZh6tNCkx2OxmuNinE4WraDPnbZw5ksp/JgKVJJQ5YmjTgiEvJHib7mgyaS1Yy2dtk3DP7zo9F9wfJyGVFhM8g5gAAAABJRU5ErkJggg=="/>
  </div>
</a>



<a href='java.htm'><div class='book-cover' style='background-color: #f9f6f1;color: #111111;border: 1px solid #ccc;display: flex;justify-content: center;align-items: center;text-align: center;'>More Java Books</div></a>
</div>
</div>
  </div>
  <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/prism.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
  
  <script>
    function copyCode(button) {
      const code = button.nextElementSibling.innerText;
      navigator.clipboard.writeText(code).then(() => {
        button.textContent = 'Copied!';
        setTimeout(() => { button.textContent = 'Copy'; }, 1500);
      });
    }
  </script>  
<div id="floatingLog" aria-live="polite" role="alert"></div>
<footer class="page-footer">
    <nav>
      <a href="https://readbytes.github.io">Home</a> | 
      Email:<script language="JavaScript" type="text/javascript">
var part1 = 'yinpeng';var part6 = '263';var part2 = Math.pow(2,6);var part3 = String.fromCharCode(part2);var part4 = 'hotmail dot com';var part5 = part1 + String.fromCharCode(part2) + part4;document.write(part1 + part6 + part3 + part4);
</script>
    </nav>
  <p>© 2025 — All rights reserved.</p>    
  </footer>

</body>
</html>