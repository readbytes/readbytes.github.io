<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>JavaScript Algorithms Trees and Binary Search Trees</title>
<link rel='shortcut icon' href='https://java2s.com/style/favicon.ico'>
<link href="https://fonts.googleapis.com/css2?family=Merriweather&display=swap" rel="stylesheet" />
<link href="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet" />

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/codemirror.min.css" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/theme/material.css"> <!-- Dark theme -->
<script src="https://cdn.jsdelivr.net/npm/typescript@5/lib/typescript.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/codemirror.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/mode/htmlmixed/htmlmixed.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/mode/xml/xml.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/mode/css/css.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/mode/javascript/javascript.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/mode/javascript/typescript.min.js"></script>
<style>
    #floatingLog {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(20, 20, 20, 0.95);
      color: white;
      font-family: monospace;
      font-size: 14px;
      padding: 16px 20px;
      border-radius: 8px;
      box-shadow: 0 4px 16px rgba(0, 0, 0, 0.4);
      max-width: 80%;
      max-height: 200px;
      overflow-y: auto;
      display: none;
      z-index: 9999;
      pointer-events: none;
      white-space: pre-wrap;
      text-align: center;
    }
</style>
<script>
  const codeMirrorMap = new Map();
  const iframeMap = new Map();
  
 

  let dismissTimer;
  function showFloatingLog(message) {
	const floatingLog = document.getElementById('floatingLog');

    if (floatingLog.style.display !== 'block') {
      floatingLog.textContent = '';
      floatingLog.style.display = 'block'; 
    }

    floatingLog.textContent += message + '\n';
    floatingLog.scrollTop = floatingLog.scrollHeight; 
    clearTimeout(dismissTimer);
    dismissTimer = setTimeout(() => {
      floatingLog.style.display = 'none';
      floatingLog.textContent = '';
    }, 2000);
  }
  window.addEventListener('message', (event) => {
	    if (!iframeMap.has(event.source)) return;

	    if (event.data?.type === 'console-log') {
	      showFloatingLog(event.data.message);
	    }
  });  
  function renderIframe(button,textarea_id, iframe_id) {
      const html = codeMirrorMap.get(textarea_id).getValue();
      const iframe = document.getElementById(iframe_id);
  
      const oldIframe = iframe;
      const newIframe = document.createElement('iframe');
      newIframe.className ="result_iframe";
      
      newIframe.id = iframe_id;
      oldIframe.replaceWith(newIframe);
 

      // Track the iframe in the map
      iframeMap.set(newIframe.contentWindow, button);

      const overrideScript = `
        <script>
          (function() {
            const originalLog = console.log;
            console.log = function(...args) {
              originalLog.apply(console, args);
              window.parent.postMessage({
                type: 'console-log',
                message: args.map(a => {
                  try { return JSON.stringify(a); }
                  catch { return String(a); }
                }).join(' ')
              }, '*');
            };
          })();
        <\/script>
      `;

      const iframeHTML = `
        <!DOCTYPE html>
        <html>
        <body>
          ${overrideScript}
          ${html}
        </body>
        </html>
      `;
 
      const doc = newIframe.contentDocument || newIframe.contentWindow.document;
      doc.open();
      doc.write(iframeHTML);
      doc.close();

      
  }
  function renderIframeForClientTypescript(textarea_id, iframe_id) {
      let code = codeMirrorMap.get(textarea_id).getValue();
      code = ts.transpile(code);
      const iframe = document.getElementById(iframe_id);
      const doc = iframe.contentDocument || iframe.contentWindow.document;

const html = `
  <!DOCTYPE html>
  <html>
    <head>
      <title>Output</title>
      <style>
        body { font-family: monospace; padding: 1em; background: #f4f4f4; color: #222; }
        pre { white-space: pre-wrap; word-break: break-word; }
        .error { color: red; }
      </style>
    </head>
    <body>
      <pre id="log"></pre>
      <script>
        (function(){
          const logEl = document.getElementById('log');
          const origLog = console.log;
          const origError = console.error;

          console.log = (...args) => {
            logEl.textContent += args.join(' ') + '\\n';
            origLog.apply(console, args);
          };
          console.table = (...args) => {
            logEl.textContent += args.join(' ') + '\\n';
            origLog.apply(console, args);
          };

          console.error = (...args) => {
            logEl.innerHTML +='<span class="error">' + args.join(' ') + '</span>';
            origError.apply(console, args);
          };
          window.addEventListener("error", function (event) {
              console.error("Caught by event listener:", event.message);
          });    
          try {             
              ${code};
          } catch (err) {
            console.error(err.stack || err.message);
          }
        })();
      <\/script>
    </body>
  </html>
`;

      iframe.style.display = "block";
      iframe.srcdoc = html;  
  }

    function renderIframeForClientJavascript(textarea_id, iframe_id) {
        const code = codeMirrorMap.get(textarea_id).getValue();
        const iframe = document.getElementById(iframe_id);
        const doc = iframe.contentDocument || iframe.contentWindow.document;

  const html = `
    <!DOCTYPE html>
    <html>
      <head>
        <title>Output</title>
        <style>
          body { font-family: monospace; padding: 1em; background: #1e1e1e; color: #eee; }
          pre { white-space: pre-wrap; word-break: break-word; }
          .error { color: red; }
        </style>
      </head>
      <body>
        <pre id="log"></pre>
        <script>
          (function(){
            const logEl = document.getElementById('log');
            const origLog = console.log;
            const origError = console.error;

            console.log = (...args) => {
              logEl.textContent += args.join(' ') + '\\n';
              origLog.apply(console, args);
            };
            console.table = (...args) => {
              logEl.textContent += args.join(' ') + '\\n';
              origLog.apply(console, args);
            };

            console.error = (...args) => {
              logEl.innerHTML +='<span class="error">' + args.join(' ') + '</span>';
              origError.apply(console, args);
            };
            window.addEventListener("error", function (event) {
                console.error("Caught by event listener:", event.message);
            });    
            try {
             ${code}; 
            } catch (err) {
              console.error(err.stack || err.message);
            }
          })();
        <\/script>
      </body>
    </html>
  `;
        iframe.style.display = "block";
        iframe.srcdoc = html;  
    }
    function toggleSnippetAndRefresh(id, textarea_id) {
      const box = document.getElementById(id);
      box.classList.toggle("open");
      codeMirrorMap.get(textarea_id).refresh();
    }

  </script>
  <script>
  const mode = localStorage.getItem('mode') || 'light';
  document.documentElement.classList.add(`${mode}-mode`);
  </script>   
<style> 
html {
  scroll-behavior: smooth;
}

body {
  font-family: 'Merriweather', serif;
  margin: 0;
  padding: 2rem 1rem;
  font-size: 15px;
  line-height: 1.5;
  transition: background-color 0.3s, color 0.3s;
}

.container {
  max-width: 700px;
  margin: 0 auto;
  padding: 1rem 2rem;
  box-shadow: 0 0 15px rgba(0,0,0,0.1);
}

h1, h2, h3 {
  font-weight: 600;
  margin-top: 2.5rem;
  margin-bottom: 1rem;
  line-height: 1.2;
}

h1 { font-size: 1.8rem; }
h2 { font-size: 1.4rem; }
h3 { font-size: 1.2rem; }

table {
  width: 100%;
  border-collapse: collapse;
  font-family: sans-serif;
  font-size: 1em;
  margin: 1em 0;
}

th, td {
  padding: 0.6em 1em;
  text-align: left;
  border: 1px solid;
}

tr:nth-child(even) {
  background-color: inherit;
}

tr:hover {
  background-color: inherit;
}

a {
  text-decoration: none;
  transition: color 0.2s;
}

a:hover {
  text-decoration: underline;
}

code {
  color: #d35400;
}

.book-title-chapter {
  font-family: 'Merriweather', serif;
  font-size: 2rem;
  font-weight: bold;
  text-align: center;
  margin-bottom: 2rem;
  border-bottom: 2px solid;
  padding-bottom: 0.5rem;
}

.book-subtitle-chapter {
  text-align: center;
  font-size: 1rem;
  margin-top: -1rem;
  margin-bottom: 2rem;
}

.related-books {
  margin-top: 40px;
}

.related-book-list {
  display: flex;
  flex-wrap: wrap;
  gap: 20px;
}

    .book-cover {
      width: 130px;
      height: 180px;
      font-family: Arial, sans-serif;
      position: relative;
      overflow: hidden;      
      line-height: normal;
      box-shadow: 2px 2px 4px rgba(0,0,0,0.1);
    }
    .book-cover-bottom-stripe {
      position: absolute;
      bottom: 0;
      left: 0;
      height: 5px;
      width: 100%;
    }
    .book-cover-title {
      position: absolute;
      width: 100%;
      text-align: center;
      font-weight: bold;
    }
     
    .book-cover-icon {
      position: absolute;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      align-items: center;
      justify-content: center; 
    }

    .book-cover-author {
      position: absolute;
      bottom: 10px;
      width: 100%;
      text-align: center;
      font-size: 8px;
      color: #333;
    }

.page-footer {
  margin-top: 4rem;
  padding: 1rem 0;
  text-align: center;
  font-size: 0.85rem;
  border-top: 1px solid;
}

.chapter-navi-section {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding-bottom: 10px;
}

.nav-link {
  color: inherit;
  text-decoration: none;
  opacity: 0.5;
  transition: opacity 0.3s ease, text-decoration 0.3s ease;
}

.nav-link:hover {
  opacity: 0.9;
  text-decoration: underline;
}

.prev { text-align: left; }
.toc-link { text-align: center; }
.next { text-align: right; }

.download-section {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 2rem;
  padding: 2rem 1rem;
  max-width: 600px;
  margin: 3rem auto;
  border-radius: 12px;
  box-shadow: 0 4px 10px rgba(0,0,0,0.05);
}

.download-info h2 {
  margin: 0 0 0.5rem;
  font-size: 1.2rem;
}

.format-label {
  margin: 0 0 0.5rem;
  font-size: 0.95rem;
}

.download-buttons {
  display: flex;
  gap: 1rem;
}

.download-button {
  background-color: #4A90E2;
  color: white;
  padding: 0.5em 1.2em;
  border-radius: 25px;
  font-size: 0.95rem;
  text-decoration: none;
  transition: background-color 0.3s ease;
}

.download-button:hover {
  background-color: #357ABD;
}

.code-block {
  position: relative;
  margin-bottom: 1em;
}

.copy-button {
  background: transparent;
  color: white;
  position: absolute;
  top: 8px;
  right: 8px;
  border: none;
  padding: 4px 8px;
  font-size: 12px;
  border-radius: 4px;
  cursor: pointer;
  z-index: 1;
}

.copy-button:hover {
  background-color: #0056b3;
}

.snippet-container {
  overflow: hidden;
}

.snippet-header {
  padding: 0.75rem 1rem;
  cursor: pointer;
  font-size: 1rem;
    background-color: #eeeeee;
    color:  #111111; 
    border-radius: 8px;
    cursor: pointer;
    box-shadow: 0 4px 6px rgba(0,0,0,0.1);  
}

.snippet-body {
  display: none;
  font-family: monospace;
}

.snippet-container.open .snippet-body {
  display: block;
}

.CodeMirror {
  border: 2px solid #ccc;
  border-radius: 4px;
  resize: vertical;
}

/* === Light Mode === */
html.light-mode {
  background-color: #f8f7f5;
  color: #333;
}

html.light-mode .container {
  background: white;
}

html.light-mode .book-title-chapter {
  color: #2c3e50;
  border-color: #ccc;
}
html.light-mode .book-subtitle-chapter{
  color: #888;
}

html.light-mode .page-footer,
html.light-mode .series-name,
html.light-mode .book-subtitle,
html.light-mode .format-label {
  color: #888;
}

html.light-mode .related-books h2 {
  color: #333;
  border-bottom: 2px solid #eee;
}

html.light-mode .book-title {
  color: #fff;
}

html.light-mode .book-cover {
  border: 1px solid #ccc;
}

html.light-mode th {
  background-color: #f2f2f2;
}

html.light-mode tr:nth-child(even) {
  background-color: #fafafa;
}

html.light-mode tr:hover {
  background-color: #e6f7ff;
}

html.light-mode a,
html.light-mode .page-footer a {
  color: #000;
}

/* === Dark Mode === */
html.dark-mode {
  background-color: #181818;
  color: #e0e0e0;
}

html.dark-mode .container {
  background: #222;
}

html.dark-mode .book-title-chapter {
  color: #ddd;
  border-color: #444;
}

html.dark-mode .snippet-header {
    background-color: #333;
    color:  #ddd; 
}


html.dark-mode .book-subtitle-chapter,
html.dark-mode .page-footer,
html.dark-mode .series-name,
html.dark-mode .book-subtitle,
html.dark-mode .book-footer,
html.dark-mode .format-label {
  color: #aaa;
}

html.dark-mode .related-books h2 {
  color: #ddd;
  border-bottom: 2px solid #333;
}

html.dark-mode .book-title {
  color: #fff;
}

html.dark-mode .book-cover {
  border: 1px solid #555;
}

html.dark-mode th {
  background-color: #333;
  color: #fff;
}

html.dark-mode td {
  border-color: #444;
}

html.dark-mode tr:nth-child(even) {
  background-color: #2a2a2a;
}

html.dark-mode tr:hover {
  background-color: #2c3e50;
}

html.dark-mode a,
html.dark-mode .page-footer a {
  color: #eee;
}

    .dialog-backdrop {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: rgba(0,0,0,0.5);
      display: none;
      justify-content: center;
      align-items: center;
      z-index: 10;
    }

    .dialog {
      background: white;
      padding: 20px;
      width: 90vw;
      height: 80vh;
      border-radius: 8px;
      box-shadow: 0 0 20px rgba(0,0,0,0.3);
      display: flex;
      flex-direction: column;
    }
    .dialog-content {
      display: flex;
      flex: 1;
      gap: 20px;
      margin-top: 10px;
    }
    .dialog h2 {
      margin-top: 0;
    }

    .textarea_dialog {
      width: 50%;
      height: 100%;
      resize: none;
      font-family: monospace;
      font-size: 14px;
      padding: 10px;
      box-sizing: border-box;
      border: 1px solid #ccc;
    }

    .iframe_dialog {
      width: 50%;
      height: 100%;
      border: 1px solid #ccc;
    }
    .controls_dialog {
      display: flex;
      justify-content: space-between;
      margin-top: 10px;
    }    
    button { padding: 0.5em 1em; background: green; color: white; border: none; cursor: pointer; }
    button:hover { background: #1e7e34; }
    .result_iframe { width:99%; height:200px; margin-top: 1em;  resize: both;border:1px solid #ccc;}        
</style>
</head>
<body> 
  <div class="container">
    <div class = "chapter-navi-section">
<a href="javascript-algorithms-hash-tables.htm" class="nav-button prev">←</a>
<a href='javascript-algorithms.htm#trees-and-binary-search-trees' class="nav-button toc-link">Index</a>
<a href="javascript-algorithms-heaps-and-priority-queues.htm" class="nav-button next">→</a>
</div>

    <h1 class="book-title-chapter" id = 'top'>Trees and Binary Search Trees</h1>
    <h3 class="book-subtitle-chapter">JavaScript Algorithms</h3>   
    <!-- <h1 class ="chapter-title"></h1> -->
    <h2 id='recursive-tree-traversals'>10.1 Recursive Tree Traversals</h2><p>In tree data structures, <strong>traversal</strong> refers to visiting each node in a specific order. Unlike arrays or linked lists, trees are hierarchical and non-linear, so multiple traversal strategies exist. The three most common <strong>depth-first traversal</strong> techniques are:</p><ul>
 <li><strong>Preorder Traversal</strong></li>
 <li><strong>Inorder Traversal</strong></li>
 <li><strong>Postorder Traversal</strong></li>
</ul><p>Each of these follows a different order in processing the <strong>current node</strong>, its <strong>left subtree</strong>, and <strong>right subtree</strong>.</p><p>All three can be naturally implemented using <strong>recursion</strong>, which fits the hierarchical nature of trees: each node's children are themselves roots of smaller subtrees.</p><h3 id="tree-structure-example">Tree Structure Example</h3><p>To illustrate, consider this binary tree:</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-bash">A
       / \
      B   C
     / \   \
    D   E   F</code></pre>
</div><p>This structure will help visualize the different traversal orders.</p><div class="snippet-container" id="<!DOCTYPE html>
<html lang=&quot;en&quot;>
<head>
  <meta charset=&quot;UTF-8&quot;>
  <title>Tree Traversal Visualization (Canvas)</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      text-align: center;
      margin: 20px;
    }
    canvas {
      border: 1px solid #ccc;
      background: #f9f9f9;
    }
    button {
      margin: 5px;
      padding: 8px 16px;
      font-size: 16px;
    }
    #visitedOutput {
      margin-top: 20px;
      font-size: 18px;
      min-height: 30px;
    }
    .node-box {
      display: inline-block;
      background: #4a90e2;
      color: white;
      padding: 5px 10px;
      border-radius: 5px;
      margin: 2px;
    }
    .message {
      margin-top: 10px;
      color: green;
      font-weight: bold;
    }
  </style>
</head>
<body>

<h2>Tree Traversal Visualization (Canvas)</h2>

<div>
  <button onclick=&quot;startTraversal('preorder')&quot;>Preorder</button>
  <button onclick=&quot;startTraversal('inorder')&quot;>Inorder</button>
  <button onclick=&quot;startTraversal('postorder')&quot;>Postorder</button>
</div>

<canvas id=&quot;canvas&quot; width=&quot;800&quot; height=&quot;400&quot;></canvas>

<div id=&quot;visitedOutput&quot;></div>
<div id=&quot;message&quot; class=&quot;message&quot;></div>

<script>
const canvas = document.getElementById(&quot;canvas&quot;);
const ctx = canvas.getContext(&quot;2d&quot;);
const visitedOutput = document.getElementById(&quot;visitedOutput&quot;);
const messageBox = document.getElementById(&quot;message&quot;);

const NODE_RADIUS = 20;
const LEVEL_HEIGHT = 80;

class TreeNode {
  constructor(value, x = 0, y = 0) {
    this.value = value;
    this.left = null;
    this.right = null;
    this.x = x;
    this.y = y;
  }
}

// Sample Binary Tree
//        A
//      /   \
//     B     C
//    / \   / \
//   D   E F   G

const A = new TreeNode(&quot;A&quot;);
const B = new TreeNode(&quot;B&quot;);
const C = new TreeNode(&quot;C&quot;);
const D = new TreeNode(&quot;D&quot;);
const E = new TreeNode(&quot;E&quot;);
const F = new TreeNode(&quot;F&quot;);
const G = new TreeNode(&quot;G&quot;);

A.left = B; A.right = C;
B.left = D; B.right = E;
C.left = F; C.right = G;

const treeRoot = A;

// Assign coordinates for display
function assignCoordinates(node, depth, index, spacing) {
  if (!node) return;
  node.x = index * spacing + spacing / 2;
  node.y = depth * LEVEL_HEIGHT + NODE_RADIUS * 2;
  assignCoordinates(node.left, depth + 1, index * 2, spacing / 2);
  assignCoordinates(node.right, depth + 1, index * 2 + 1, spacing / 2);
}

function drawTree(node) {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  drawConnections(node);
  drawNodes(node);
}

function drawConnections(node) {
  if (!node) return;
  ctx.strokeStyle = &quot;#aaa&quot;;
  ctx.lineWidth = 2;

  if (node.left) {
    ctx.beginPath();
    ctx.moveTo(node.x, node.y);
    ctx.lineTo(node.left.x, node.left.y);
    ctx.stroke();
    drawConnections(node.left);
  }

  if (node.right) {
    ctx.beginPath();
    ctx.moveTo(node.x, node.y);
    ctx.lineTo(node.right.x, node.right.y);
    ctx.stroke();
    drawConnections(node.right);
  }
}

function drawNodes(node, highlightNode = null) {
  if (!node) return;

  // Draw current node
  ctx.beginPath();
  ctx.fillStyle = (node === highlightNode) ? &quot;#f5a623&quot; : &quot;#4a90e2&quot;;
  ctx.strokeStyle = &quot;#333&quot;;
  ctx.lineWidth = 2;
  ctx.arc(node.x, node.y, NODE_RADIUS, 0, 2 * Math.PI);
  ctx.fill();
  ctx.stroke();

  // Draw text
  ctx.fillStyle = &quot;#fff&quot;;
  ctx.font = &quot;16px Arial&quot;;
  ctx.textAlign = &quot;center&quot;;
  ctx.textBaseline = &quot;middle&quot;;
  ctx.fillText(node.value, node.x, node.y);

  drawNodes(node.left, highlightNode);
  drawNodes(node.right, highlightNode);
}

// Traversal functions
function preorder(node, result = []) {
  if (!node) return result;
  result.push(node);
  preorder(node.left, result);
  preorder(node.right, result);
  return result;
}

function inorder(node, result = []) {
  if (!node) return result;
  inorder(node.left, result);
  result.push(node);
  inorder(node.right, result);
  return result;
}

function postorder(node, result = []) {
  if (!node) return result;
  postorder(node.left, result);
  postorder(node.right, result);
  result.push(node);
  return result;
}

function startTraversal(type) {
  visitedOutput.innerHTML = &quot;&quot;;
  messageBox.innerText = &quot;&quot;;

  let order;
  if (type === &quot;preorder&quot;) {
    order = preorder(treeRoot);
  } else if (type === &quot;inorder&quot;) {
    order = inorder(treeRoot);
  } else if (type === &quot;postorder&quot;) {
    order = postorder(treeRoot);
  }

  let i = 0;
  function step() {
    if (i >= order.length) {
      messageBox.innerText = `✅ ${type[0].toUpperCase() + type.slice(1)} traversal complete!`;
      return;
    }
    drawTree(treeRoot);
    drawNodes(treeRoot, order[i]);

    // Show visited node under canvas
    const nodeBox = document.createElement(&quot;span&quot;);
    nodeBox.className = &quot;node-box&quot;;
    nodeBox.textContent = order[i].value;
    visitedOutput.appendChild(nodeBox);

    i++;
    setTimeout(step, 800);
  }

  step();
}

// Initialize
assignCoordinates(treeRoot, 0, 1, canvas.width / 2);
drawTree(treeRoot);
</script>

</body>
</html>ID"><textarea id="WTWsI" style="display: none;">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
  &lt;meta charset="UTF-8"&gt;
  &lt;title&gt;Tree Traversal Visualization (Canvas)&lt;/title&gt;
  &lt;style&gt;
    body {
      font-family: Arial, sans-serif;
      text-align: center;
      margin: 20px;
    }
    canvas {
      border: 1px solid #ccc;
      background: #f9f9f9;
    }
    button {
      margin: 5px;
      padding: 8px 16px;
      font-size: 16px;
    }
    #visitedOutput {
      margin-top: 20px;
      font-size: 18px;
      min-height: 30px;
    }
    .node-box {
      display: inline-block;
      background: #4a90e2;
      color: white;
      padding: 5px 10px;
      border-radius: 5px;
      margin: 2px;
    }
    .message {
      margin-top: 10px;
      color: green;
      font-weight: bold;
    }
  &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;h2&gt;Tree Traversal Visualization (Canvas)&lt;/h2&gt;

&lt;div&gt;
  &lt;button onclick="startTraversal('preorder')"&gt;Preorder&lt;/button&gt;
  &lt;button onclick="startTraversal('inorder')"&gt;Inorder&lt;/button&gt;
  &lt;button onclick="startTraversal('postorder')"&gt;Postorder&lt;/button&gt;
&lt;/div&gt;

&lt;canvas id="canvas" width="800" height="400"&gt;&lt;/canvas&gt;

&lt;div id="visitedOutput"&gt;&lt;/div&gt;
&lt;div id="message" class="message"&gt;&lt;/div&gt;

&lt;script&gt;
const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");
const visitedOutput = document.getElementById("visitedOutput");
const messageBox = document.getElementById("message");

const NODE_RADIUS = 20;
const LEVEL_HEIGHT = 80;

class TreeNode {
  constructor(value, x = 0, y = 0) {
    this.value = value;
    this.left = null;
    this.right = null;
    this.x = x;
    this.y = y;
  }
}

// Sample Binary Tree
//        A
//      /   \
//     B     C
//    / \   / \
//   D   E F   G

const A = new TreeNode("A");
const B = new TreeNode("B");
const C = new TreeNode("C");
const D = new TreeNode("D");
const E = new TreeNode("E");
const F = new TreeNode("F");
const G = new TreeNode("G");

A.left = B; A.right = C;
B.left = D; B.right = E;
C.left = F; C.right = G;

const treeRoot = A;

// Assign coordinates for display
function assignCoordinates(node, depth, index, spacing) {
  if (!node) return;
  node.x = index * spacing + spacing / 2;
  node.y = depth * LEVEL_HEIGHT + NODE_RADIUS * 2;
  assignCoordinates(node.left, depth + 1, index * 2, spacing / 2);
  assignCoordinates(node.right, depth + 1, index * 2 + 1, spacing / 2);
}

function drawTree(node) {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  drawConnections(node);
  drawNodes(node);
}

function drawConnections(node) {
  if (!node) return;
  ctx.strokeStyle = "#aaa";
  ctx.lineWidth = 2;

  if (node.left) {
    ctx.beginPath();
    ctx.moveTo(node.x, node.y);
    ctx.lineTo(node.left.x, node.left.y);
    ctx.stroke();
    drawConnections(node.left);
  }

  if (node.right) {
    ctx.beginPath();
    ctx.moveTo(node.x, node.y);
    ctx.lineTo(node.right.x, node.right.y);
    ctx.stroke();
    drawConnections(node.right);
  }
}

function drawNodes(node, highlightNode = null) {
  if (!node) return;

  // Draw current node
  ctx.beginPath();
  ctx.fillStyle = (node === highlightNode) ? "#f5a623" : "#4a90e2";
  ctx.strokeStyle = "#333";
  ctx.lineWidth = 2;
  ctx.arc(node.x, node.y, NODE_RADIUS, 0, 2 * Math.PI);
  ctx.fill();
  ctx.stroke();

  // Draw text
  ctx.fillStyle = "#fff";
  ctx.font = "16px Arial";
  ctx.textAlign = "center";
  ctx.textBaseline = "middle";
  ctx.fillText(node.value, node.x, node.y);

  drawNodes(node.left, highlightNode);
  drawNodes(node.right, highlightNode);
}

// Traversal functions
function preorder(node, result = []) {
  if (!node) return result;
  result.push(node);
  preorder(node.left, result);
  preorder(node.right, result);
  return result;
}

function inorder(node, result = []) {
  if (!node) return result;
  inorder(node.left, result);
  result.push(node);
  inorder(node.right, result);
  return result;
}

function postorder(node, result = []) {
  if (!node) return result;
  postorder(node.left, result);
  postorder(node.right, result);
  result.push(node);
  return result;
}

function startTraversal(type) {
  visitedOutput.innerHTML = "";
  messageBox.innerText = "";

  let order;
  if (type === "preorder") {
    order = preorder(treeRoot);
  } else if (type === "inorder") {
    order = inorder(treeRoot);
  } else if (type === "postorder") {
    order = postorder(treeRoot);
  }

  let i = 0;
  function step() {
    if (i &gt;= order.length) {
      messageBox.innerText = `✅ ${type[0].toUpperCase() + type.slice(1)} traversal complete!`;
      return;
    }
    drawTree(treeRoot);
    drawNodes(treeRoot, order[i]);

    // Show visited node under canvas
    const nodeBox = document.createElement("span");
    nodeBox.className = "node-box";
    nodeBox.textContent = order[i].value;
    visitedOutput.appendChild(nodeBox);

    i++;
    setTimeout(step, 800);
  }

  step();
}

// Initialize
assignCoordinates(treeRoot, 0, 1, canvas.width / 2);
drawTree(treeRoot);
&lt;/script&gt;

&lt;/body&gt;
&lt;/html&gt;</textarea> <iframe id="O4yjM" class="result_iframe" style="border:none;"></iframe>
 <script>{
const textarea = document.getElementById("WTWsI");
const iframe = document.getElementById("O4yjM");
const html = textarea.value;
const iframeHTML = `${html}`;
const doc = iframe.contentDocument || iframe.contentWindow.document;
doc.open();
doc.write(iframeHTML);
doc.close();
setTimeout(() => {
iframe.style.height = '0px';
const contentHeight = Math.max(
  doc.body.scrollHeight,
  doc.documentElement.scrollHeight
);
iframe.style.height = contentHeight + 'px';
}, 50);
}
		</script>
</div><h3 id="preorder-traversal-node-left-right">Preorder Traversal: <code>Node Left Right</code></h3><p>In <strong>preorder</strong>, you visit the current node before its children.</p><h4 id="javascript-implementation">JavaScript Implementation</h4><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-js">function preorder(node) {
  if (!node) return;

  console.log(node.value);      // Visit node
  preorder(node.left);          // Traverse left subtree
  preorder(node.right);         // Traverse right subtree
}</code></pre>
</div><h4 id="order-of-visit-for-the-sample-tree">Order of Visit (for the sample tree):</h4><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-bash">A → B → D → E → C → F</code></pre>
</div><h4 id="applications">Applications</h4><ul>
 <li>Copying trees</li>
 <li>Generating prefix expressions from expression trees</li>
 <li>Serializing a tree structure</li>
</ul><h3 id="inorder-traversal-left-node-right">Inorder Traversal: <code>Left Node Right</code></h3><p>In <strong>inorder</strong>, you process the left subtree first, then the current node, then the right subtree.</p><h4 id="javascript-implementation">JavaScript Implementation</h4><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-js">function inorder(node) {
  if (!node) return;

  inorder(node.left);           // Traverse left subtree
  console.log(node.value);      // Visit node
  inorder(node.right);          // Traverse right subtree
}</code></pre>
</div><h4 id="order-of-visit-for-the-sample-tree">Order of Visit (for the sample tree):</h4><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-bash">D → B → E → A → C → F</code></pre>
</div><h4 id="applications">Applications</h4><ul>
 <li><strong>Binary Search Trees</strong>: Inorder traversal returns values in <strong>sorted order</strong>.</li>
 <li>Expression trees: Producing <strong>infix notation</strong>.</li>
</ul><h3 id="postorder-traversal-left-right-node">Postorder Traversal: <code>Left Right Node</code></h3><p>In <strong>postorder</strong>, you visit children before the parent.</p><h4 id="javascript-implementation">JavaScript Implementation</h4><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-js">function postorder(node) {
  if (!node) return;

  postorder(node.left);         // Traverse left subtree
  postorder(node.right);        // Traverse right subtree
  console.log(node.value);      // Visit node
}</code></pre>
</div><h4 id="order-of-visit-for-the-sample-tree">Order of Visit (for the sample tree):</h4><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-bash">D → E → B → F → C → A</code></pre>
</div><h4 id="applications">Applications</h4><ul>
 <li>Deleting or freeing trees (children removed before parents)</li>
 <li>Generating <strong>postfix expressions</strong> from expression trees</li>
 <li>Evaluating expression trees</li>
</ul><h3 id="example-tree-node-class">Example: Tree Node Class</h3><p>Here’s a simple class to define binary tree nodes for our examples:</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-js">class TreeNode {
  constructor(value) {
    this.value = value;
    this.left = null;
    this.right = null;
  }
}</code></pre>
</div><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-js">// Build sample tree:
//         A
//        / \
//       B   C
//      / \   \
//     D   E   F

const root = new TreeNode("A");
root.left = new TreeNode("B");
root.right = new TreeNode("C");
root.left.left = new TreeNode("D");
root.left.right = new TreeNode("E");
root.right.right = new TreeNode("F");</code></pre>
</div><p>Now you can call any traversal:</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-js">inorder(root);   // Output: D B E A C F</code></pre>
</div><h3 id="visual-comparison-summary">Visual Comparison Summary</h3><table>
 <thead>
  <tr>
   <th>Traversal</th>
   <th>Order</th>
   <th>Example Output</th>
  </tr>
 </thead>
 <tbody>
  <tr>
   <td>Preorder</td>
   <td>Node → Left → Right</td>
   <td>A B D E C F</td>
  </tr>
  <tr>
   <td>Inorder</td>
   <td>Left → Node → Right</td>
   <td>D B E A C F</td>
  </tr>
  <tr>
   <td>Postorder</td>
   <td>Left → Right → Node</td>
   <td>D E B F C A</td>
  </tr>
 </tbody>
</table><h3 id="why-recursion-works">Why Recursion Works</h3><p>Recursive traversal mirrors the recursive nature of trees: each node is the root of its own subtree. By breaking the tree into smaller problems (left and right subtrees), recursion processes nodes elegantly in the desired order.</p><h3 id="practical-use-cases">Practical Use Cases</h3><ul>
 <li><strong>Expression Trees</strong>: Preorder generates prefix (Polish) notation, inorder gives infix (human-readable), and postorder gives postfix (Reverse Polish Notation).</li>
 <li><strong>Searching</strong>: In binary search trees, an inorder traversal visits nodes in sorted order.</li>
 <li><strong>File Systems</strong>: Directory trees can be traversed recursively using preorder or postorder depending on the task (e.g. scanning or deleting files).</li>
</ul><h3 id="summary">Summary</h3><p>Recursive tree traversals—<strong>preorder</strong>, <strong>inorder</strong>, and <strong>postorder</strong>—are fundamental tools for navigating and processing trees. Each follows a distinct order and serves specific use cases in algorithms and real-world applications. With a few lines of recursive JavaScript code, you can explore and manipulate complex tree structures with clarity and control.</p><div class = "chapter-navi-section">
<a href="#top" class="nav-button prev">↑</a>
<a href='javascript-algorithms.htm#trees-and-binary-search-trees' class="nav-button toc-link">Index</a>
<a href="#bottom" class="nav-button next">↓</a>
</div>
<h2 id='balanced-vs-unbalanced-trees'>10.2 Balanced vs Unbalanced Trees</h2><p>A fundamental concept in working with trees, especially <strong>Binary Search Trees (BSTs)</strong>, is whether the tree is <strong>balanced</strong> or <strong>unbalanced</strong>. The shape of a tree dramatically impacts how efficiently you can perform operations like search, insertion, and deletion.</p><h3 id="what-is-a-balanced-tree">What Is a Balanced Tree?</h3><p>A tree is considered <strong>balanced</strong> when the heights of its left and right subtrees for every node are roughly equal. More formally, for any node in the tree, the difference in height between its left and right child subtrees is at most 1 (this is the condition for <strong>AVL trees</strong>, a common balanced BST).</p><p>Balanced trees keep their height <strong>as small as possible</strong>, close to <code>O(log n)</code> for <code>n</code> nodes, meaning operations that depend on height remain efficient.</p><h3 id="what-is-an-unbalanced-tree">What Is an Unbalanced Tree?</h3><p>An <strong>unbalanced</strong> tree is one where the subtrees differ significantly in height. In the worst case, a BST can degenerate into a structure like a linked list, with all nodes skewed to one side (left or right).</p><h3 id="height-and-its-impact-on-performance">Height and Its Impact on Performance</h3><p>The <strong>height</strong> of a tree is the length of the longest path from the root to a leaf node.</p><table>
 <thead>
  <tr>
   <th>Tree Type</th>
   <th>Height</th>
   <th>Search Time Complexity</th>
  </tr>
 </thead>
 <tbody>
  <tr>
   <td>Balanced BST</td>
   <td>~log₂(n)</td>
   <td>O(log n)</td>
  </tr>
  <tr>
   <td>Unbalanced (skewed)</td>
   <td>~n (linear)</td>
   <td>O(n)</td>
  </tr>
 </tbody>
</table><h4 id="diagram-balanced-vs-skewed-bst-6-nodes">Diagram: Balanced vs Skewed BST (6 nodes)</h4><p>Balanced BST:</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-bash">Tree:

      4
    /   \
   2     6
  / \   /
 1   3 5</code></pre>
</div><p>Skewed BST:</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-bash">1
 \
  2
   \
    3
     \
      4
       \
        5
         \
          6</code></pre>
</div><p>Notice how the balanced tree has height 3 (log₂6 ≈ 2.58), but the skewed tree’s height is 6, the number of nodes.</p><h3 id="consequences-of-unbalance">Consequences of Unbalance</h3><p>In an unbalanced tree:</p><ul>
 <li><strong>Search operations degrade</strong> to linear time, as you may need to traverse many nodes.</li>
 <li><strong>Insertion and deletion</strong> can also become costly.</li>
 <li>This negates the main advantage of BSTs, which is fast searching.</li>
</ul><h3 id="balancing-strategies-conceptual">Balancing Strategies (Conceptual)</h3><p>To maintain efficient operations, self-balancing trees adjust their structure automatically during insertions and deletions:</p><ul>
 <li><strong>AVL Trees</strong>: Strictly maintain balance by checking heights and performing rotations after insert/delete.</li>
 <li><strong>Red-Black Trees</strong>: Maintain a looser balance using color properties and rotations for balancing.</li>
 <li><strong>B-Trees</strong>: Used in databases and filesystems, optimized for storage on disk blocks.</li>
</ul><p>These trees ensure height remains close to <code>O(log n)</code> and preserve fast search times.</p><h3 id="javascript-example-searching-balanced-vs-skewed-trees">JavaScript Example: Searching Balanced vs Skewed Trees</h3><div>
 <div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
  <pre><code class="language-js">class TreeNode {
  constructor(value) {
    this.value = value;
    this.left = null;
    this.right = null;
  }
}

// Insert nodes to create a skewed BST (like a linked list)
function createSkewedTree() {
  let root = new TreeNode(1);
  let current = root;
  for (let i = 2; i &lt;= 6; i++) {
    current.right = new TreeNode(i);
    current = current.right;
  }
  return root;
}

// Insert nodes to create a balanced BST manually
function createBalancedTree() {
  const root = new TreeNode(4);
  root.left = new TreeNode(2);
  root.right = new TreeNode(6);
  root.left.left = new TreeNode(1);
  root.left.right = new TreeNode(3);
  root.right.left = new TreeNode(5);
  return root;
}

function searchBST(root, target) {
  if (!root) return false;
  if (root.value === target) return true;
  if (target &lt; root.value) return searchBST(root.left, target);
  return searchBST(root.right, target);
}

const balanced = createBalancedTree();
const skewed = createSkewedTree();

console.time("Balanced Search");
console.log(searchBST(balanced, 6)); // true
console.timeEnd("Balanced Search");

console.time("Skewed Search");
console.log(searchBST(skewed, 6)); // true
console.timeEnd("Skewed Search");</code></pre>
 </div>
 <div class="snippet-container" id="G9suL">
  <div class="snippet-header" onclick="toggleSnippetAndRefresh('G9suL','69Ttt')">
   Try it in editor
  </div>
  <div class="snippet-body"><textarea id="69Ttt">class TreeNode {
  constructor(value) {
    this.value = value;
    this.left = null;
    this.right = null;
  }
}

// Insert nodes to create a skewed BST (like a linked list)
function createSkewedTree() {
  let root = new TreeNode(1);
  let current = root;
  for (let i = 2; i &lt;= 6; i++) {
    current.right = new TreeNode(i);
    current = current.right;
  }
  return root;
}

// Insert nodes to create a balanced BST manually
function createBalancedTree() {
  const root = new TreeNode(4);
  root.left = new TreeNode(2);
  root.right = new TreeNode(6);
  root.left.left = new TreeNode(1);
  root.left.right = new TreeNode(3);
  root.right.left = new TreeNode(5);
  return root;
}

function searchBST(root, target) {
  if (!root) return false;
  if (root.value === target) return true;
  if (target &lt; root.value) return searchBST(root.left, target);
  return searchBST(root.right, target);
}

const balanced = createBalancedTree();
const skewed = createSkewedTree();

console.time("Balanced Search");
console.log(searchBST(balanced, 6)); // true
console.timeEnd("Balanced Search");

console.time("Skewed Search");
console.log(searchBST(skewed, 6)); // true
console.timeEnd("Skewed Search");</textarea> <br> <button onclick="renderIframeForClientJavascript('69Ttt','SlyX2')">Run</button> <iframe id="SlyX2" class="result_iframe" style="display: none;"></iframe>
   <script>
  {let editor1 = CodeMirror.fromTextArea(document.getElementById("69Ttt"), {
    mode: "javascript",
    lineNumbers:false,
    tabSize: 2
    });
    const mode = localStorage.getItem("mode") || "light";  
    const newTheme = mode === "dark" ? "material" : "default";
    editor1.setOption("theme", newTheme);

   codeMirrorMap.set("69Ttt", editor1);}
  </script>
  </div>
 </div>
</div><p>You’ll notice the skewed tree search takes longer because it must traverse more nodes sequentially, while the balanced tree cuts down the search path quickly.</p><h3 id="summary">Summary</h3><p>The <strong>balance</strong> of a tree is critical for maintaining the <strong>logarithmic efficiency</strong> of search and update operations. Balanced trees keep their height small and operations fast, while unbalanced trees risk degenerating into inefficient structures. Self-balancing trees like AVL and Red-Black trees automate maintaining this balance, ensuring predictable performance—making them essential for practical use of BSTs in real applications.</p><div class = "chapter-navi-section">
<a href="#top" class="nav-button prev">↑</a>
<a href='javascript-algorithms.htm#trees-and-binary-search-trees' class="nav-button toc-link">Index</a>
<a href="#bottom" class="nav-button next">↓</a>
</div>
<h2 id='binary-search-tree-from-scratch'>10.3 Binary Search Tree from Scratch</h2><p>A <strong>Binary Search Tree (BST)</strong> is a powerful data structure that maintains sorted data and allows fast insertion, search, and deletion operations. Each node in a BST has at most two children: a <strong>left</strong> child containing values less than the node’s value, and a <strong>right</strong> child containing values greater than the node’s value. This property ensures that in-order traversal of a BST returns values in <strong>sorted order</strong>.</p><p>In this section, we'll build a BST from scratch in JavaScript, covering insertion, search, and deletion with clear explanations.</p><div class="snippet-container" id="<!DOCTYPE html>
<html lang=&quot;en&quot;>
<head>
  <meta charset=&quot;UTF-8&quot; />
  <title>Animated AVL Tree Visualization</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      text-align: center;
      margin: 20px;
    }
    canvas {
      border: 1px solid #ccc;
      background: #f4f4f4;
      display: block;
      margin: 10px auto;
    }
    input, button {
      padding: 6px 10px;
      font-size: 16px;
      margin: 5px;
    }
    #output {
      margin-top: 15px;
      font-size: 18px;
    }
  </style>
</head>
<body>

<h2>Animated AVL Tree with Search Path Highlight</h2>

<input type=&quot;number&quot; id=&quot;valueInput&quot; placeholder=&quot;Enter number&quot;>
<button onclick=&quot;insert()&quot;>Insert</button>
<button onclick=&quot;remove()&quot;>Delete</button>
<button onclick=&quot;showInorder()&quot;>Inorder Traversal</button>

<canvas id=&quot;canvas&quot; width=&quot;1000&quot; height=&quot;500&quot;></canvas>
<div id=&quot;output&quot;></div>

<script>
const canvas = document.getElementById(&quot;canvas&quot;);
const ctx = canvas.getContext(&quot;2d&quot;);
const output = document.getElementById(&quot;output&quot;);

class AVLNode {
  constructor(value) {
    this.value = value;
    this.left = null;
    this.right = null;
    this.height = 1;
    this.x = 0;
    this.y = 0;
  }
}

let root = null;
let highlightNodes = [];

function height(n) {
  return n ? n.height : 0;
}
function updateHeight(n) {
  n.height = 1 + Math.max(height(n.left), height(n.right));
}
function balanceFactor(n) {
  return height(n.left) - height(n.right);
}
function rotateRight(y) {
  const x = y.left;
  const T2 = x.right;
  x.right = y;
  y.left = T2;
  updateHeight(y);
  updateHeight(x);
  return x;
}
function rotateLeft(x) {
  const y = x.right;
  const T2 = y.left;
  y.left = x;
  x.right = T2;
  updateHeight(x);
  updateHeight(y);
  return y;
}
function balance(node) {
  updateHeight(node);
  const bf = balanceFactor(node);
  if (bf > 1) {
    if (balanceFactor(node.left) < 0) node.left = rotateLeft(node.left);
    return rotateRight(node);
  }
  if (bf < -1) {
    if (balanceFactor(node.right) > 0) node.right = rotateRight(node.right);
    return rotateLeft(node);
  }
  return node;
}

function insertNode(node, value, path = []) {
  if (!node) {
    highlightNodes = path;
    return new AVLNode(value);
  }
  path.push(node);
  if (value < node.value) node.left = insertNode(node.left, value, path);
  else if (value > node.value) node.right = insertNode(node.right, value, path);
  else {
    highlightNodes = path;
    return node;
  }
  return balance(node);
}

function deleteNode(node, value, path = []) {
  if (!node) {
    highlightNodes = path;
    return null;
  }
  path.push(node);
  if (value < node.value) node.left = deleteNode(node.left, value, path);
  else if (value > node.value) node.right = deleteNode(node.right, value, path);
  else {
    if (!node.left || !node.right) return node.left || node.right;
    const minLarger = minValueNode(node.right);
    node.value = minLarger.value;
    node.right = deleteNode(node.right, minLarger.value);
  }
  return balance(node);
}

function minValueNode(n) {
  while (n.left) n = n.left;
  return n;
}

function inorder(node, res = []) {
  if (!node) return res;
  inorder(node.left, res);
  res.push(node.value);
  inorder(node.right, res);
  return res;
}

// === Tree Layout and Drawing ===

function layoutTree(node, depth = 0, range = [50, canvas.width - 50]) {
  if (!node) return;
  const [start, end] = range;
  const mid = (start + end) / 2;
  node.x = mid;
  node.y = 60 + depth * 70;
  layoutTree(node.left, depth + 1, [start, mid - 30]);
  layoutTree(node.right, depth + 1, [mid + 30, end]);
}

function drawTree(node) {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  layoutTree(node);
  drawEdges(node);
  drawNodes(node);
}

function drawEdges(n) {
  if (!n) return;
  ctx.strokeStyle = &quot;#999&quot;;
  if (n.left) {
    ctx.beginPath();
    ctx.moveTo(n.x, n.y);
    ctx.lineTo(n.left.x, n.left.y);
    ctx.stroke();
    drawEdges(n.left);
  }
  if (n.right) {
    ctx.beginPath();
    ctx.moveTo(n.x, n.y);
    ctx.lineTo(n.right.x, n.right.y);
    ctx.stroke();
    drawEdges(n.right);
  }
}

function drawNodes(n) {
  if (!n) return;
  ctx.beginPath();
  ctx.fillStyle = highlightNodes.includes(n) ? &quot;#f39c12&quot; : &quot;#3498db&quot;;
  ctx.arc(n.x, n.y, 20, 0, Math.PI * 2);
  ctx.fill();
  ctx.strokeStyle = &quot;#000&quot;;
  ctx.stroke();

  ctx.fillStyle = &quot;#fff&quot;;
  ctx.font = &quot;16px Arial&quot;;
  ctx.textAlign = &quot;center&quot;;
  ctx.textBaseline = &quot;middle&quot;;
  ctx.fillText(n.value, n.x, n.y);

  drawNodes(n.left);
  drawNodes(n.right);
}

// === Controls ===

function insert() {
  const val = parseInt(document.getElementById(&quot;valueInput&quot;).value);
  if (isNaN(val)) return;
  highlightNodes = [];
  root = insertNode(root, val);
  drawTree(root);
  setTimeout(() => {
    highlightNodes = [];
    drawTree(root);
  }, 1000);
  document.getElementById(&quot;valueInput&quot;).value = &quot;&quot;;
  output.textContent = &quot;&quot;;
}

function remove() {
  const val = parseInt(document.getElementById(&quot;valueInput&quot;).value);
  if (isNaN(val)) return;
  highlightNodes = [];
  root = deleteNode(root, val);
  drawTree(root);
  setTimeout(() => {
    highlightNodes = [];
    drawTree(root);
  }, 1000);
  document.getElementById(&quot;valueInput&quot;).value = &quot;&quot;;
  output.textContent = &quot;&quot;;
}

function showInorder() {
  const result = inorder(root);
  output.textContent = &quot;Inorder Traversal (Sorted): &quot; + result.join(&quot;, &quot;);
}

// Initial draw
drawTree(root);
</script>

</body>
</html>ID"><textarea id="HCLDQ" style="display: none;">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
  &lt;meta charset="UTF-8" /&gt;
  &lt;title&gt;Animated AVL Tree Visualization&lt;/title&gt;
  &lt;style&gt;
    body {
      font-family: Arial, sans-serif;
      text-align: center;
      margin: 20px;
    }
    canvas {
      border: 1px solid #ccc;
      background: #f4f4f4;
      display: block;
      margin: 10px auto;
    }
    input, button {
      padding: 6px 10px;
      font-size: 16px;
      margin: 5px;
    }
    #output {
      margin-top: 15px;
      font-size: 18px;
    }
  &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;h2&gt;Animated AVL Tree with Search Path Highlight&lt;/h2&gt;

&lt;input type="number" id="valueInput" placeholder="Enter number"&gt;
&lt;button onclick="insert()"&gt;Insert&lt;/button&gt;
&lt;button onclick="remove()"&gt;Delete&lt;/button&gt;
&lt;button onclick="showInorder()"&gt;Inorder Traversal&lt;/button&gt;

&lt;canvas id="canvas" width="1000" height="500"&gt;&lt;/canvas&gt;
&lt;div id="output"&gt;&lt;/div&gt;

&lt;script&gt;
const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");
const output = document.getElementById("output");

class AVLNode {
  constructor(value) {
    this.value = value;
    this.left = null;
    this.right = null;
    this.height = 1;
    this.x = 0;
    this.y = 0;
  }
}

let root = null;
let highlightNodes = [];

function height(n) {
  return n ? n.height : 0;
}
function updateHeight(n) {
  n.height = 1 + Math.max(height(n.left), height(n.right));
}
function balanceFactor(n) {
  return height(n.left) - height(n.right);
}
function rotateRight(y) {
  const x = y.left;
  const T2 = x.right;
  x.right = y;
  y.left = T2;
  updateHeight(y);
  updateHeight(x);
  return x;
}
function rotateLeft(x) {
  const y = x.right;
  const T2 = y.left;
  y.left = x;
  x.right = T2;
  updateHeight(x);
  updateHeight(y);
  return y;
}
function balance(node) {
  updateHeight(node);
  const bf = balanceFactor(node);
  if (bf &gt; 1) {
    if (balanceFactor(node.left) &lt; 0) node.left = rotateLeft(node.left);
    return rotateRight(node);
  }
  if (bf &lt; -1) {
    if (balanceFactor(node.right) &gt; 0) node.right = rotateRight(node.right);
    return rotateLeft(node);
  }
  return node;
}

function insertNode(node, value, path = []) {
  if (!node) {
    highlightNodes = path;
    return new AVLNode(value);
  }
  path.push(node);
  if (value &lt; node.value) node.left = insertNode(node.left, value, path);
  else if (value &gt; node.value) node.right = insertNode(node.right, value, path);
  else {
    highlightNodes = path;
    return node;
  }
  return balance(node);
}

function deleteNode(node, value, path = []) {
  if (!node) {
    highlightNodes = path;
    return null;
  }
  path.push(node);
  if (value &lt; node.value) node.left = deleteNode(node.left, value, path);
  else if (value &gt; node.value) node.right = deleteNode(node.right, value, path);
  else {
    if (!node.left || !node.right) return node.left || node.right;
    const minLarger = minValueNode(node.right);
    node.value = minLarger.value;
    node.right = deleteNode(node.right, minLarger.value);
  }
  return balance(node);
}

function minValueNode(n) {
  while (n.left) n = n.left;
  return n;
}

function inorder(node, res = []) {
  if (!node) return res;
  inorder(node.left, res);
  res.push(node.value);
  inorder(node.right, res);
  return res;
}

// === Tree Layout and Drawing ===

function layoutTree(node, depth = 0, range = [50, canvas.width - 50]) {
  if (!node) return;
  const [start, end] = range;
  const mid = (start + end) / 2;
  node.x = mid;
  node.y = 60 + depth * 70;
  layoutTree(node.left, depth + 1, [start, mid - 30]);
  layoutTree(node.right, depth + 1, [mid + 30, end]);
}

function drawTree(node) {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  layoutTree(node);
  drawEdges(node);
  drawNodes(node);
}

function drawEdges(n) {
  if (!n) return;
  ctx.strokeStyle = "#999";
  if (n.left) {
    ctx.beginPath();
    ctx.moveTo(n.x, n.y);
    ctx.lineTo(n.left.x, n.left.y);
    ctx.stroke();
    drawEdges(n.left);
  }
  if (n.right) {
    ctx.beginPath();
    ctx.moveTo(n.x, n.y);
    ctx.lineTo(n.right.x, n.right.y);
    ctx.stroke();
    drawEdges(n.right);
  }
}

function drawNodes(n) {
  if (!n) return;
  ctx.beginPath();
  ctx.fillStyle = highlightNodes.includes(n) ? "#f39c12" : "#3498db";
  ctx.arc(n.x, n.y, 20, 0, Math.PI * 2);
  ctx.fill();
  ctx.strokeStyle = "#000";
  ctx.stroke();

  ctx.fillStyle = "#fff";
  ctx.font = "16px Arial";
  ctx.textAlign = "center";
  ctx.textBaseline = "middle";
  ctx.fillText(n.value, n.x, n.y);

  drawNodes(n.left);
  drawNodes(n.right);
}

// === Controls ===

function insert() {
  const val = parseInt(document.getElementById("valueInput").value);
  if (isNaN(val)) return;
  highlightNodes = [];
  root = insertNode(root, val);
  drawTree(root);
  setTimeout(() =&gt; {
    highlightNodes = [];
    drawTree(root);
  }, 1000);
  document.getElementById("valueInput").value = "";
  output.textContent = "";
}

function remove() {
  const val = parseInt(document.getElementById("valueInput").value);
  if (isNaN(val)) return;
  highlightNodes = [];
  root = deleteNode(root, val);
  drawTree(root);
  setTimeout(() =&gt; {
    highlightNodes = [];
    drawTree(root);
  }, 1000);
  document.getElementById("valueInput").value = "";
  output.textContent = "";
}

function showInorder() {
  const result = inorder(root);
  output.textContent = "Inorder Traversal (Sorted): " + result.join(", ");
}

// Initial draw
drawTree(root);
&lt;/script&gt;

&lt;/body&gt;
&lt;/html&gt;</textarea> <iframe id="BxNNT" class="result_iframe" style="border:none;"></iframe>
 <script>{
const textarea = document.getElementById("HCLDQ");
const iframe = document.getElementById("BxNNT");
const html = textarea.value;
const iframeHTML = `${html}`;
const doc = iframe.contentDocument || iframe.contentWindow.document;
doc.open();
doc.write(iframeHTML);
doc.close();
setTimeout(() => {
iframe.style.height = '0px';
const contentHeight = Math.max(
  doc.body.scrollHeight,
  doc.documentElement.scrollHeight
);
iframe.style.height = contentHeight + 'px';
}, 50);
}
		</script>
</div><h3 id="bst-node-structure">BST Node Structure</h3><p>First, define a simple <code>TreeNode</code> class that holds a value and pointers to left and right children.</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-js">class TreeNode {
  constructor(value) {
    this.value = value;
    this.left = null;
    this.right = null;
  }
}</code></pre>
</div><h3 id="insertion">Insertion</h3><p>When inserting a value into a BST:</p><ul>
 <li><p>If the tree is empty, the new node becomes the root.</p></li>
 <li><p>Otherwise, compare the new value with the current node:</p>
  <ul>
   <li>If less, recurse left.</li>
   <li>If greater, recurse right.</li>
  </ul></li>
 <li><p>Insert the new node where the subtree is empty (<code>null</code>).</p></li>
</ul><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-js">class BinarySearchTree {
  constructor() {
    this.root = null;
  }

  insert(value) {
    this.root = this._insertRec(this.root, value);
  }

  _insertRec(node, value) {
    if (node === null) {
      return new TreeNode(value);
    }

    if (value &lt; node.value) {
      node.left = this._insertRec(node.left, value);
    } else if (value &gt; node.value) {
      node.right = this._insertRec(node.right, value);
    } 
    // If value equals node.value, duplicates are ignored here

    return node;
  }
}</code></pre>
</div><h3 id="searching">Searching</h3><p>Searching a BST takes advantage of the order property:</p><ul>
 <li>If the node is <code>null</code>, the value isn’t found.</li>
 <li>If the current node’s value equals the target, return true.</li>
 <li>If target &lt; node’s value, search left.</li>
 <li>Otherwise, search right.</li>
</ul><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-js">search(value) {
    return this._searchRec(this.root, value);
  }

  _searchRec(node, value) {
    if (node === null) return false;
    if (node.value === value) return true;

    if (value &lt; node.value) {
      return this._searchRec(node.left, value);
    } else {
      return this._searchRec(node.right, value);
    }
  }</code></pre>
</div><h3 id="deletion">Deletion</h3><p>Deletion is the trickiest BST operation because it requires maintaining the BST property after removal.</p><p>There are three cases when deleting a node:</p><ol>
 <li><strong>Node with no children (leaf):</strong> Simply remove it by returning <code>null</code>.</li>
 <li><strong>Node with one child:</strong> Replace the node with its child.</li>
 <li><strong>Node with two children:</strong> Replace the node’s value with the <strong>minimum value in its right subtree</strong> (in-order successor), then delete that successor.</li>
</ol><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-js">delete(value) {
    this.root = this._deleteRec(this.root, value);
  }

  _deleteRec(node, value) {
    if (node === null) return null;

    if (value &lt; node.value) {
      node.left = this._deleteRec(node.left, value);
    } else if (value &gt; node.value) {
      node.right = this._deleteRec(node.right, value);
    } else {
      // Node to delete found

      // Case 1: No children
      if (!node.left &amp;&amp; !node.right) {
        return null;
      }

      // Case 2: One child
      if (!node.left) return node.right;
      if (!node.right) return node.left;

      // Case 3: Two children
      const minRight = this._minValueNode(node.right);
      node.value = minRight.value;
      node.right = this._deleteRec(node.right, minRight.value);
    }
    return node;
  }

  _minValueNode(node) {
    while (node.left !== null) {
      node = node.left;
    }
    return node;
  }</code></pre>
</div><h3 id="inorder-traversal-sorting">Inorder Traversal (Sorting)</h3><p>An in-order traversal of a BST visits nodes in sorted ascending order:</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-js">inorder() {
    const result = [];
    this._inorderRec(this.root, result);
    return result;
  }

  _inorderRec(node, result) {
    if (!node) return;
    this._inorderRec(node.left, result);
    result.push(node.value);
    this._inorderRec(node.right, result);
  }</code></pre>
</div><h3 id="complete-example-and-test-cases">Complete Example and Test Cases</h3><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-js">const bst = new BinarySearchTree();

bst.insert(50);
bst.insert(30);
bst.insert(70);
bst.insert(20);
bst.insert(40);
bst.insert(60);
bst.insert(80);

console.log(bst.search(40));   // true
console.log(bst.search(25));   // false

console.log("Inorder:", bst.inorder()); 
// Output: [20, 30, 40, 50, 60, 70, 80]

bst.delete(20);  // Delete leaf
bst.delete(30);  // Delete node with one child
bst.delete(50);  // Delete node with two children (root)

console.log("Inorder after deletes:", bst.inorder()); 
// Output: [40, 60, 70, 80]</code></pre>
</div><h3 id="key-takeaways">Key Takeaways</h3><ul>
 <li>BSTs maintain <strong>order</strong> by placing smaller values in the left subtree and larger in the right.</li>
 <li>Recursive insertion and search naturally fit the tree’s hierarchical structure.</li>
 <li>Deletion requires careful handling to maintain tree properties.</li>
 <li>Inorder traversal returns sorted values, making BSTs useful for dynamic sorting and searching.</li>
</ul><h3 id="summary">Summary</h3><p>Building a BST from scratch demystifies its internal workings. By mastering insertion, search, and deletion, you gain insight into how balanced trees and more advanced data structures function. BSTs form the backbone of many algorithms and libraries, making them a foundational skill in JavaScript algorithmic programming.</p><div class = "chapter-navi-section">
<a href="javascript-algorithms-hash-tables.htm" class="nav-button prev">←</a>
<a href='javascript-algorithms.htm#trees-and-binary-search-trees' class="nav-button toc-link">Index</a>
<a href="javascript-algorithms-heaps-and-priority-queues.htm" class="nav-button next">→</a>
</div>
<section class="download-section">
  <div class="book-cover" style="background-color: #f9f6f1;border: 1px solid #ccc;"> 
    <div class="book-cover-title" style="font-size: 18px;color: #333;top: 20px;">JavaScript Algorithms</div>
    <div class="book-cover-author">readbytes</div>
    <div class="book-cover-bottom-stripe" style="background-color: #333;"></div>
    <img class="book-cover-icon" style="width: 80px;height: 80px;top: 70px;" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFoAAABaCAYAAAA4qEECAAAErElEQVR4Xu2dPWgUQRiGo6BB8I+AlV3w9gzptLBWsLQ89O7ARrDXSivTCTaCnWhn7pQTxOoInpjCeEQQLC2CjVqoVSwMFpp1Jtzo7Luzs/Nd7uZ29r4HPpDsu7vPvIl7+SGTmRmGYRiGYZjCEzVacdnn9NX7+3DdXkGhMg+u3Su6SNztzsZvevH/efED8zrJbM+6EGJ2K5Hv9w9gRpHnXMyik2VsYVaHWJx7tt/bTOQ3urOYUch3QJ5z0YtOCeuQiqNlvybyto/ktbVDcG2jc5GLNgoriMW5Z/svPyfy693DmFHE71ePwrUznQta9ISeyViyKBIziri/Mpe8tt25kEXjMR1ScbQsPC5W5jCjMJT8DTM6MuO6vrHjIkIszj2LL3y2ktOPiy+Y0VE5l/V5IU+EVBwtm/wUzva4SL/wOZUsJ2993rCJEIujZJMl2174Up/C5T8u9LGtzyu6SNkH1+6VhUargkJlHVy7f5aW9qJUqeZy5zguufToBeAxZoRw0Z7goj3BRXuCi/YEF+0BvWQue0xgwfrMiy+aMM8QEUW+w2IHb8fC/+C5jCOGMhOPiqi+vG47zjiABVbr7XOYUWC2Um+fxwwDiKJeYXGYMYHniNnGDDPAUJZTyYph30nTg+G7f5VLj89gzBW8lu2xMzWIIt5iMZgZBrzmqK4bJFhENOLnatRsfcR7YKb0YAELF5+cwsyowHudrLcvYKZ0iIV+wIVjZhzgPaMR/+8pFIbFeilZUWm2Vyd5/5GxWOvsx4VkTbXROovn+wJdMqfevoHnFoKUaMbgeZMAnbIGzysEKGmZiX4DKKo/um5wMg6eWwhsgtVm62cRFoEOJg/xtltZxwqBTV4inuEHcZHztc4RzI0LvLeY15iRBF+0wrDgsX6qZXpUYEanNEVLROY3ZfHDgvdwuU+pipYs1h7OpUqI4z2YGxa8dqXefooZE6UrWoGFiMn8nRIXoubyTbymeLPzO7C0RUuiRvuXoRwyeI1hrlPqoiUnap1jWNLilU7mr0sgeK746rOFGRdKX7QCC4tyHiXi+DU8BzMUpqZoiSzXpTzMZOUoTFXROxh+xKV/gYPHqvVlp88q8pi+ogdgoabBc3bD1BYtEdfcxnLHeK/pLVoiHxvJktsPMDMKpr5oX3DRnuCiPcFFe4KL9gQX7Qku2hNctCe4aE94K1puD6mXNsmpOv74KUTnxEdmEQb9TOA5kx70M6KfcO/u8/j2nWffxb+XskZm9MHjw2YjgrTKygnFeUaF5cSEjZ4c9kJyz/Z7mxTpEJ0T0nhMhyRBy+5sTuXioAjR2UmaKEHJ/tsBLM9BJ0TnXGmiBCWb2GbN5oCE6GyVJkq4Z3FXxo3ubJaDiRCdM6VJErSscTtik0MWITobpYkS7lncKVfblREdbITonJImSVCyKAz7i1KkQ3ROSJMkaNnc7Ygp0iE6Z0pjTockjC8iBmEJRTpEZ6M0ZnRIwrhTrmU7Yop0iM4paTyusyvhnO2IKdIhOqdeWLLYlbDtL0oM/jaKi4MiRGcnaZIwPt8c/zZKnoNOiM4J6SIM+pnAcyY96GekYJtvf0I/EyE6MwzDMAzDjI+/5MPGam/zucIAAAAASUVORK5CYII="/>
  </div>
  <div class="download-info">
    <h2 id='bottom'>Download This Ebook</h2>
    <p class="format-label">Available formats:</p>
    <div class="download-buttons">
      <a href="javascript-algorithms.pdf" class="download-button">📄 PDF</a>
      <a href="javascript-algorithms.epub" class="download-button">📘 EPUB</a>
    </div>
  </div>
</section><div class='related-books'>
<h2>Java Introduction Books</h2>
<div class='related-book-list'>
<a href="javascript-algorithms.htm">
<div class="book-cover" style="background-color: #f9f6f1;border: 1px solid #ccc;"> 
    <div class="book-cover-title" style="font-size: 18px;color: #333;top: 20px;">JavaScript Algorithms</div>
    <div class="book-cover-author">readbytes</div>
    <div class="book-cover-bottom-stripe" style="background-color: #333;"></div>
    <img class="book-cover-icon" style="width: 80px;height: 80px;top: 70px;" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFoAAABaCAYAAAA4qEECAAAErElEQVR4Xu2dPWgUQRiGo6BB8I+AlV3w9gzptLBWsLQ89O7ARrDXSivTCTaCnWhn7pQTxOoInpjCeEQQLC2CjVqoVSwMFpp1Jtzo7Luzs/Nd7uZ29r4HPpDsu7vPvIl7+SGTmRmGYRiGYZjCEzVacdnn9NX7+3DdXkGhMg+u3Su6SNztzsZvevH/efED8zrJbM+6EGJ2K5Hv9w9gRpHnXMyik2VsYVaHWJx7tt/bTOQ3urOYUch3QJ5z0YtOCeuQiqNlvybyto/ktbVDcG2jc5GLNgoriMW5Z/svPyfy693DmFHE71ePwrUznQta9ISeyViyKBIziri/Mpe8tt25kEXjMR1ScbQsPC5W5jCjMJT8DTM6MuO6vrHjIkIszj2LL3y2ktOPiy+Y0VE5l/V5IU+EVBwtm/wUzva4SL/wOZUsJ2993rCJEIujZJMl2174Up/C5T8u9LGtzyu6SNkH1+6VhUargkJlHVy7f5aW9qJUqeZy5zguufToBeAxZoRw0Z7goj3BRXuCi/YEF+0BvWQue0xgwfrMiy+aMM8QEUW+w2IHb8fC/+C5jCOGMhOPiqi+vG47zjiABVbr7XOYUWC2Um+fxwwDiKJeYXGYMYHniNnGDDPAUJZTyYph30nTg+G7f5VLj89gzBW8lu2xMzWIIt5iMZgZBrzmqK4bJFhENOLnatRsfcR7YKb0YAELF5+cwsyowHudrLcvYKZ0iIV+wIVjZhzgPaMR/+8pFIbFeilZUWm2Vyd5/5GxWOvsx4VkTbXROovn+wJdMqfevoHnFoKUaMbgeZMAnbIGzysEKGmZiX4DKKo/um5wMg6eWwhsgtVm62cRFoEOJg/xtltZxwqBTV4inuEHcZHztc4RzI0LvLeY15iRBF+0wrDgsX6qZXpUYEanNEVLROY3ZfHDgvdwuU+pipYs1h7OpUqI4z2YGxa8dqXefooZE6UrWoGFiMn8nRIXoubyTbymeLPzO7C0RUuiRvuXoRwyeI1hrlPqoiUnap1jWNLilU7mr0sgeK746rOFGRdKX7QCC4tyHiXi+DU8BzMUpqZoiSzXpTzMZOUoTFXROxh+xKV/gYPHqvVlp88q8pi+ogdgoabBc3bD1BYtEdfcxnLHeK/pLVoiHxvJktsPMDMKpr5oX3DRnuCiPcFFe4KL9gQX7Qku2hNctCe4aE94K1puD6mXNsmpOv74KUTnxEdmEQb9TOA5kx70M6KfcO/u8/j2nWffxb+XskZm9MHjw2YjgrTKygnFeUaF5cSEjZ4c9kJyz/Z7mxTpEJ0T0nhMhyRBy+5sTuXioAjR2UmaKEHJ/tsBLM9BJ0TnXGmiBCWb2GbN5oCE6GyVJkq4Z3FXxo3ubJaDiRCdM6VJErSscTtik0MWITobpYkS7lncKVfblREdbITonJImSVCyKAz7i1KkQ3ROSJMkaNnc7Ygp0iE6Z0pjTockjC8iBmEJRTpEZ6M0ZnRIwrhTrmU7Yop0iM4paTyusyvhnO2IKdIhOqdeWLLYlbDtL0oM/jaKi4MiRGcnaZIwPt8c/zZKnoNOiM4J6SIM+pnAcyY96GekYJtvf0I/EyE6MwzDMAzDjI+/5MPGam/zucIAAAAASUVORK5CYII="/>
  </div>
</a>



<a href='java.htm'><div class='book-cover' style='background-color: #f9f6f1;color: #111111;border: 1px solid #ccc;display: flex;justify-content: center;align-items: center;text-align: center;'>More Java Books</div></a>
</div>
</div>
  </div>
  <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/prism.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
  
  <script>
    function copyCode(button) {
      const code = button.nextElementSibling.innerText;
      navigator.clipboard.writeText(code).then(() => {
        button.textContent = 'Copied!';
        setTimeout(() => { button.textContent = 'Copy'; }, 1500);
      });
    }
  </script>  
<div id="floatingLog" aria-live="polite" role="alert"></div>
<footer class="page-footer">
    <nav>
      <a href="https://readbytes.github.io">Home</a> | 
      Email:<script language="JavaScript" type="text/javascript">
var part1 = 'yinpeng';var part6 = '263';var part2 = Math.pow(2,6);var part3 = String.fromCharCode(part2);var part4 = 'hotmail dot com';var part5 = part1 + String.fromCharCode(part2) + part4;document.write(part1 + part6 + part3 + part4);
</script>
    </nav>
  <p>© 2025 — All rights reserved.</p>    
  </footer>

</body>
</html>