<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Java IO and NIO Introduction to Java IO and NIO</title>
<link rel='shortcut icon' href='https://java2s.com/style/favicon.ico'>
<link href="https://fonts.googleapis.com/css2?family=Merriweather&display=swap" rel="stylesheet" />
<link href="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet" />


  <script>
  const mode = localStorage.getItem('mode') || 'light';
  document.documentElement.classList.add(`${mode}-mode`);
  </script>   
<style> 
html {
  scroll-behavior: smooth;
}

body {
  font-family: 'Merriweather', serif;
  margin: 0;
  padding: 2rem 1rem;
  font-size: 15px;
  line-height: 1.5;
  transition: background-color 0.3s, color 0.3s;
}

.container {
  max-width: 700px;
  margin: 0 auto;
  padding: 1rem 2rem;
  box-shadow: 0 0 15px rgba(0,0,0,0.1);
}

h1, h2, h3 {
  font-weight: 600;
  margin-top: 2.5rem;
  margin-bottom: 1rem;
  line-height: 1.2;
}

h1 { font-size: 1.8rem; }
h2 { font-size: 1.4rem; }
h3 { font-size: 1.2rem; }

table {
  width: 100%;
  border-collapse: collapse;
  font-family: sans-serif;
  font-size: 1em;
  margin: 1em 0;
}

th, td {
  padding: 0.6em 1em;
  text-align: left;
  border: 1px solid;
}

tr:nth-child(even) {
  background-color: inherit;
}

tr:hover {
  background-color: inherit;
}

a {
  text-decoration: none;
  transition: color 0.2s;
}

a:hover {
  text-decoration: underline;
}

code {
  color: #d35400;
}

.book-title-chapter {
  font-family: 'Merriweather', serif;
  font-size: 2rem;
  font-weight: bold;
  text-align: center;
  margin-bottom: 2rem;
  border-bottom: 2px solid;
  padding-bottom: 0.5rem;
}

.book-subtitle-chapter {
  text-align: center;
  font-size: 1rem;
  margin-top: -1rem;
  margin-bottom: 2rem;
}

.related-books {
  margin-top: 40px;
}

.related-book-list {
  display: flex;
  flex-wrap: wrap;
  gap: 20px;
}

    .book-cover {
      width: 130px;
      height: 180px;
      font-family: Arial, sans-serif;
      position: relative;
      overflow: hidden;      
      line-height: normal;
      box-shadow: 2px 2px 4px rgba(0,0,0,0.1);
    }
    .book-cover-bottom-stripe {
      position: absolute;
      bottom: 0;
      left: 0;
      height: 5px;
      width: 100%;
    }
    .book-cover-title {
      position: absolute;
      width: 100%;
      text-align: center;
      font-weight: bold;
    }
     
    .book-cover-icon {
      position: absolute;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      align-items: center;
      justify-content: center; 
    }

    .book-cover-author {
      position: absolute;
      bottom: 10px;
      width: 100%;
      text-align: center;
      font-size: 8px;
      color: #333;
    }

.page-footer {
  margin-top: 4rem;
  padding: 1rem 0;
  text-align: center;
  font-size: 0.85rem;
  border-top: 1px solid;
}

.chapter-navi-section {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding-bottom: 10px;
}

.nav-link {
  color: inherit;
  text-decoration: none;
  opacity: 0.5;
  transition: opacity 0.3s ease, text-decoration 0.3s ease;
}

.nav-link:hover {
  opacity: 0.9;
  text-decoration: underline;
}

.prev { text-align: left; }
.toc-link { text-align: center; }
.next { text-align: right; }

.download-section {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 2rem;
  padding: 2rem 1rem;
  max-width: 600px;
  margin: 3rem auto;
  border-radius: 12px;
  box-shadow: 0 4px 10px rgba(0,0,0,0.05);
}

.download-info h2 {
  margin: 0 0 0.5rem;
  font-size: 1.2rem;
}

.format-label {
  margin: 0 0 0.5rem;
  font-size: 0.95rem;
}

.download-buttons {
  display: flex;
  gap: 1rem;
}

.download-button {
  background-color: #4A90E2;
  color: white;
  padding: 0.5em 1.2em;
  border-radius: 25px;
  font-size: 0.95rem;
  text-decoration: none;
  transition: background-color 0.3s ease;
}

.download-button:hover {
  background-color: #357ABD;
}

.code-block {
  position: relative;
  margin-bottom: 1em;
}

.copy-button {
  background: transparent;
  color: white;
  position: absolute;
  top: 8px;
  right: 8px;
  border: none;
  padding: 4px 8px;
  font-size: 12px;
  border-radius: 4px;
  cursor: pointer;
  z-index: 1;
}

.copy-button:hover {
  background-color: #0056b3;
}

.snippet-container {
  overflow: hidden;
}

.snippet-header {
  padding: 0.75rem 1rem;
  cursor: pointer;
  font-size: 1rem;
    background-color: #eeeeee;
    color:  #111111; 
    border-radius: 8px;
    cursor: pointer;
    box-shadow: 0 4px 6px rgba(0,0,0,0.1);  
}

.snippet-body {
  display: none;
  font-family: monospace;
}

.snippet-container.open .snippet-body {
  display: block;
}

.CodeMirror {
  border: 2px solid #ccc;
  border-radius: 4px;
  resize: vertical;
}

/* === Light Mode === */
html.light-mode {
  background-color: #f8f7f5;
  color: #333;
}

html.light-mode .container {
  background: white;
}

html.light-mode .book-title-chapter {
  color: #2c3e50;
  border-color: #ccc;
}
html.light-mode .book-subtitle-chapter{
  color: #888;
}

html.light-mode .page-footer,
html.light-mode .series-name,
html.light-mode .book-subtitle,
html.light-mode .format-label {
  color: #888;
}

html.light-mode .related-books h2 {
  color: #333;
  border-bottom: 2px solid #eee;
}

html.light-mode .book-title {
  color: #fff;
}

html.light-mode .book-cover {
  border: 1px solid #ccc;
}

html.light-mode th {
  background-color: #f2f2f2;
}

html.light-mode tr:nth-child(even) {
  background-color: #fafafa;
}

html.light-mode tr:hover {
  background-color: #e6f7ff;
}

html.light-mode a,
html.light-mode .page-footer a {
  color: #000;
}

/* === Dark Mode === */
html.dark-mode {
  background-color: #181818;
  color: #e0e0e0;
}

html.dark-mode .container {
  background: #222;
}

html.dark-mode .book-title-chapter {
  color: #ddd;
  border-color: #444;
}

html.dark-mode .snippet-header {
    background-color: #333;
    color:  #ddd; 
}


html.dark-mode .book-subtitle-chapter,
html.dark-mode .page-footer,
html.dark-mode .series-name,
html.dark-mode .book-subtitle,
html.dark-mode .book-footer,
html.dark-mode .format-label {
  color: #aaa;
}

html.dark-mode .related-books h2 {
  color: #ddd;
  border-bottom: 2px solid #333;
}

html.dark-mode .book-title {
  color: #fff;
}

html.dark-mode .book-cover {
  border: 1px solid #555;
}

html.dark-mode th {
  background-color: #333;
  color: #fff;
}

html.dark-mode td {
  border-color: #444;
}

html.dark-mode tr:nth-child(even) {
  background-color: #2a2a2a;
}

html.dark-mode tr:hover {
  background-color: #2c3e50;
}

html.dark-mode a,
html.dark-mode .page-footer a {
  color: #eee;
}

    .dialog-backdrop {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: rgba(0,0,0,0.5);
      display: none;
      justify-content: center;
      align-items: center;
      z-index: 10;
    }

    .dialog {
      background: white;
      padding: 20px;
      width: 90vw;
      height: 80vh;
      border-radius: 8px;
      box-shadow: 0 0 20px rgba(0,0,0,0.3);
      display: flex;
      flex-direction: column;
    }
    .dialog-content {
      display: flex;
      flex: 1;
      gap: 20px;
      margin-top: 10px;
    }
    .dialog h2 {
      margin-top: 0;
    }

    .textarea_dialog {
      width: 50%;
      height: 100%;
      resize: none;
      font-family: monospace;
      font-size: 14px;
      padding: 10px;
      box-sizing: border-box;
      border: 1px solid #ccc;
    }

    .iframe_dialog {
      width: 50%;
      height: 100%;
      border: 1px solid #ccc;
    }
    .controls_dialog {
      display: flex;
      justify-content: space-between;
      margin-top: 10px;
    }    
    button { padding: 0.5em 1em; background: green; color: white; border: none; cursor: pointer; }
    button:hover { background: #1e7e34; }
    .result_iframe { width:99%; height:200px; margin-top: 1em;  resize: both;border:1px solid #ccc;}        
</style>
</head>
<body> 
  <div class="container">
    <div class = "chapter-navi-section">
<a href="" class="nav-button prev"></a>
<a href='java-io-and-nio.htm#introduction-to-java-io-and-nio' class="nav-button toc-link">Index</a>
<a href="java-io-and-nio-java-io-fundamentals.htm" class="nav-button next">â†’</a>
</div>

    <h1 class="book-title-chapter" id = 'top'>Introduction to Java IO and NIO</h1>
    <h3 class="book-subtitle-chapter">Java IO and NIO</h3>   
    <!-- <h1 class ="chapter-title"></h1> -->
    <h2 id='what-is-java-io'>1.1 What is Java IO?</h2><p>Java IO (Input/Output) is a fundamental part of the Java programming language that enables programs to communicate with the outside world. Whether reading user input, writing data to a file, receiving data from a network, or processing binary streams, Java IO provides the tools and abstractions needed to perform these operations efficiently and reliably.</p><p>At its core, IO in Java is about <strong>data movement</strong>. The two main directions are:</p><ul>
 <li><strong>Input</strong> â€“ receiving data from an external source (e.g., keyboard input, a file, or a network).</li>
 <li><strong>Output</strong> â€“ sending data to an external destination (e.g., displaying text on the screen, writing to a file, or sending data over a socket).</li>
</ul><p>Without IO, Java programs would operate in isolation â€” like a person with no way to hear or speak. IO allows programs to be dynamic, interactive, and integrated with files, devices, and networks.</p><h3 id="purpose-of-java-io">Purpose of Java IO</h3><p>Java IO serves several key purposes:</p><ol>
 <li><p><strong>Data Communication</strong> Java IO enables reading from and writing to different sources like files, consoles, memory buffers, and network sockets. This is essential for real-world applications that interact with users or systems.</p></li>
 <li><p><strong>Persistence</strong> Programs often need to save information so that it can be retrieved later. Java IO allows this persistence by supporting file operations such as saving user settings, application logs, and serialized objects.</p></li>
 <li><p><strong>Interoperability</strong> Java IO helps bridge communication between systems. For example, reading and writing files in various formats allows Java programs to interact with data generated by other software systems.</p></li>
</ol><h3 id="real-world-analogy">Real-World Analogy</h3><p>To better understand IO, consider the analogy of a <strong>postal system</strong>:</p><ul>
 <li>You (the program) may want to <strong>read</strong> a letter sent to you (input).</li>
 <li>You may also want to <strong>write</strong> and send a letter to someone else (output).</li>
</ul><p>The <strong>IO system</strong> is the infrastructure that allows this to happenâ€”envelopes (data streams), addresses (file paths or URLs), and mail carriers (stream objects) all play a part in making the communication successful.</p><p>Similarly, Java uses classes and interfaces like <code>InputStream</code>, <code>OutputStream</code>, <code>Reader</code>, and <code>Writer</code> to facilitate the transfer of data between programs and external sources or destinations.</p><h3 id="java-io-architecture-overview">Java IO Architecture Overview</h3><p>Javaâ€™s IO system is built around the concept of <strong>streams</strong>, which represent a continuous flow of data. This data can be in the form of <strong>bytes</strong> (binary data) or <strong>characters</strong> (text data). The stream abstraction allows developers to work with data without needing to know the exact source or destinationâ€”it could be a file, network socket, or memory buffer.</p><p>The core Java IO library is located in the <code>java.io</code> package and includes classes for:</p><ul>
 <li><strong>Byte streams</strong> (e.g., <code>InputStream</code>, <code>OutputStream</code>)</li>
 <li><strong>Character streams</strong> (e.g., <code>Reader</code>, <code>Writer</code>)</li>
 <li><strong>File handling</strong> (e.g., <code>File</code>, <code>FileReader</code>, <code>FileWriter</code>)</li>
 <li><strong>Buffered and data streams</strong> for optimized and structured IO</li>
 <li><strong>Object serialization</strong> for saving and restoring objects</li>
</ul><p>Later versions of Java introduced <strong>NIO (New IO)</strong> and <strong>AIO (Asynchronous IO)</strong> in the <code>java.nio</code> and <code>java.nio.channels</code> packages, which provide more efficient and scalable alternatives for high-performance applications.</p><h3 id="why-java-io-is-essential">Why Java IO is Essential</h3><p>Java IO is indispensable for a variety of programming tasks:</p><ul>
 <li><strong>Console-based applications</strong> rely on reading user input and displaying output.</li>
 <li><strong>Desktop applications</strong> read and write configuration files or load resources.</li>
 <li><strong>Web servers</strong> use IO to handle requests and send responses over the network.</li>
 <li><strong>Data-driven applications</strong> interact with logs, databases, and data files.</li>
 <li><strong>Cloud-based and distributed systems</strong> rely heavily on asynchronous and non-blocking IO to support massive concurrency.</li>
</ul><p>Mastering Java IO is not just about syntaxâ€”it's about understanding how data flows between systems and how to manage it efficiently and securely.</p><h3 id="types-of-io-operations-in-java">Types of IO Operations in Java</h3><p>Java supports several types of IO operations, each designed for specific needs:</p><ol>
 <li><p><strong>Byte-Oriented IO</strong> Operates at the byte level and is ideal for handling binary data such as images, audio files, or any non-text content. Classes include <code>InputStream</code>, <code>OutputStream</code>, and their subclasses.</p></li>
 <li><p><strong>Character-Oriented IO</strong> Designed for handling textual data using Unicode characters. It uses <code>Reader</code> and <code>Writer</code> classes to process text reliably, especially with international characters and encoding.</p></li>
 <li><p><strong>Buffered IO</strong> Adds a layer of buffering to IO operations, which enhances performance by reducing the number of interactions with the underlying source or destination. Classes like <code>BufferedReader</code> and <code>BufferedOutputStream</code> fall into this category.</p></li>
 <li><p><strong>Data Streams and Object Streams</strong> These allow reading and writing Java primitive types and objects in a portable, structured format. This includes classes like <code>DataInputStream</code>, <code>DataOutputStream</code>, <code>ObjectInputStream</code>, and <code>ObjectOutputStream</code>.</p></li>
 <li><p><strong>NIO (New IO)</strong> A scalable, non-blocking IO API introduced in Java 1.4 for high-performance applications. It introduces channels, buffers, and selectors.</p></li>
 <li><p><strong>AIO (Asynchronous IO)</strong> Introduced in Java 7 (NIO.2), this allows asynchronous, callback-based IO processing for file and socket operations.</p></li>
</ol><div class = "chapter-navi-section">
<a href="#top" class="nav-button prev">â†‘</a>
<a href='java-io-and-nio.htm#introduction-to-java-io-and-nio' class="nav-button toc-link">Index</a>
<a href="#bottom" class="nav-button next">â†“</a>
</div>
<h2 id='history-and-evolution-of-java-io'>1.2 History and Evolution of Java IO</h2><p>The Java Input/Output (IO) system has evolved significantly since the languageâ€™s early days. What began as a relatively simple stream-based API in Java 1.0 has grown into a comprehensive and high-performance framework capable of supporting the demands of modern applications, including asynchronous IO, file watching, memory mapping, and scalable non-blocking networking.</p><h3 id="the-original-io-api-java-io">The Original IO API (java.io)</h3><p>The first version of Java, released in 1996, introduced the <code>java.io</code> package â€” a set of classes and interfaces designed around the concept of <strong>streams</strong>. Streams abstract data input and output as sequences of bytes or characters, making IO operations device-agnostic. The design was elegant in its simplicity:</p><ul>
 <li><strong>Byte streams</strong> (<code>InputStream</code>, <code>OutputStream</code>) handled binary data.</li>
 <li><strong>Character streams</strong> (<code>Reader</code>, <code>Writer</code>) were introduced to manage textual data with support for Unicode.</li>
</ul><p>Developers could wrap streams for buffering (<code>BufferedInputStream</code>), filtering (<code>FilterInputStream</code>), or for handling data primitives (<code>DataInputStream</code>, <code>DataOutputStream</code>). For object serialization, Java provided <code>ObjectInputStream</code> and <code>ObjectOutputStream</code>.</p><p>While effective for many use cases, this IO model had <strong>several limitations</strong>, particularly in applications that required high concurrency, performance tuning, or low-level control over data transfer.</p><h3 id="limitations-of-the-original-io-model">Limitations of the Original IO Model</h3><ol>
 <li><p><strong>Blocking IO</strong>: The original stream-based IO was blocking by design. When a thread performed a read or write operation, it would block (pause) until the operation was complete. In a server handling many clients, this meant a separate thread was needed for each connection â€” a scalability bottleneck.</p></li>
 <li><p><strong>Lack of Multiplexing</strong>: Java IO lacked the ability to monitor multiple data sources with a single thread. Other languages and systems (e.g., C with <code>select()</code> or <code>epoll</code>) already supported this.</p></li>
 <li><p><strong>Limited File and Socket Control</strong>: The original API offered minimal access to underlying system-level features like file locking, memory-mapped files, or direct buffer management.</p></li>
 <li><p><strong>No Asynchronous IO</strong>: There was no built-in mechanism for non-blocking or asynchronous file or socket IO, limiting responsiveness in GUI or network-heavy applications.</p></li>
</ol><p>These shortcomings led to the introduction of a new architecture.</p><h3 id="the-birth-of-java-nio-new-io-java-1-4">The Birth of Java NIO (New IO) Java 1.4</h3><p>With the release of Java 1.4 in 2002, the <strong>java.nio</strong> (New IO) package was introduced. It was a major redesign focused on performance, scalability, and fine-grained control over IO operations. Java NIO was not a replacement but a supplement to the existing IO API.</p><p>Key innovations in Java NIO included:</p><ul>
 <li><p><strong>Channels</strong>: Unlike streams, channels support bi-directional data flow and are non-blocking. Examples include <code>FileChannel</code>, <code>SocketChannel</code>, and <code>DatagramChannel</code>.</p></li>
 <li><p><strong>Buffers</strong>: NIO introduced <code>ByteBuffer</code>, <code>CharBuffer</code>, and others as containers for data. Buffers enabled efficient read/write operations, and unlike streams, they gave the programmer control over how data was stored and accessed.</p></li>
 <li><p><strong>Selectors</strong>: Selectors allowed a single thread to monitor multiple channels for IO readiness (read, write, accept, connect), enabling scalable event-driven servers.</p></li>
 <li><p><strong>Memory-Mapped Files</strong>: Developers could map files directly into memory using <code>MappedByteBuffer</code>, providing ultra-fast file access and manipulation.</p></li>
</ul><p>Java NIO marked a turning point in IO programming by aligning Java with system-level capabilities offered by native OS APIs.</p><h3 id="enhancements-in-java-nio-2-java-7">Enhancements in Java NIO.2 Java 7</h3><p>Java 7 introduced <strong>NIO.2</strong>, an enhanced version of NIO that added several much-needed features:</p><ul>
 <li><p><strong>Asynchronous IO (AIO)</strong>: The <code>java.nio.channels</code> package was expanded to support asynchronous file and socket channels (<code>AsynchronousFileChannel</code>, <code>AsynchronousSocketChannel</code>) with <code>Future</code> and <code>CompletionHandler</code> support, allowing true non-blocking, callback-based IO.</p></li>
 <li><p><strong>Improved File Handling</strong>: The <code>java.nio.file</code> package introduced the powerful <code>Path</code>, <code>Files</code>, and <code>FileSystems</code> classes, replacing the older <code>File</code> class for most use cases. It also included symbolic link handling, directory walking, and file attribute APIs.</p></li>
 <li><p><strong>WatchService API</strong>: NIO.2 included the ability to monitor file system changes like create, delete, and modify events â€” crucial for building reactive applications and file watchers.</p></li>
</ul><h3 id="recent-developments-and-beyond">Recent Developments and Beyond</h3><p>Since Java 8 and onwards, enhancements to IO and NIO have been more incremental but no less important:</p><ul>
 <li>Java 9 added improved support for reactive programming via the <code>Flow</code> API.</li>
 <li>Java 11 introduced additional file utility methods and enhanced character set support.</li>
 <li>Future releases, such as Java 21 and beyond, continue to refine IO with <strong>Project Loom</strong>, which introduces lightweight virtual threadsâ€”making traditional blocking IO more scalable by drastically reducing the cost of thread-per-connection models.</li>
</ul><div class = "chapter-navi-section">
<a href="#top" class="nav-button prev">â†‘</a>
<a href='java-io-and-nio.htm#introduction-to-java-io-and-nio' class="nav-button toc-link">Index</a>
<a href="#bottom" class="nav-button next">â†“</a>
</div>
<h2 id='overview-of-stream-based-io'>1.3 Overview of Stream-Based IO</h2><p>In Java, a <strong>stream</strong> is a sequence of data elements made available over time. Think of a stream as a channel or conduit through which data flows. It could represent a flow of bytes coming from a file, data being read from the keyboard, or characters being sent to a printer.</p><p>Streams in Java abstract the underlying source or destination of the data. This means that the same <code>InputStream</code> interface can be used to read data from a file, a socket, or even memory â€” the developer doesnâ€™t have to worry about the underlying mechanics of the data source or sink.</p><p>Streams in Java come in two major categories:</p><ul>
 <li><strong>Input Streams</strong> â€“ for reading data into a program.</li>
 <li><strong>Output Streams</strong> â€“ for writing data out from a program.</li>
</ul><p>This model allows Java to provide a flexible, extensible, and consistent way of handling IO across different types of data sources and destinations.</p><h3 id="how-streams-abstract-io">How Streams Abstract IO</h3><p>The stream abstraction hides the complexity of IO operations and provides a simple programming model:</p><ul>
 <li>For <strong>input</strong>, data flows <strong>into</strong> the program from an external source.</li>
 <li>For <strong>output</strong>, data flows <strong>out</strong> of the program to an external destination.</li>
</ul><p>This model is <strong>linear</strong> â€” data is read or written sequentially, one element at a time (usually a byte or character). You donâ€™t need to load entire files into memory or manually manage file pointers. Instead, the stream interface provides high-level methods such as <code>read()</code>, <code>write()</code>, <code>close()</code>, and others.</p><p>This abstraction allows developers to work with different types of data streams using the same programming paradigm, whether reading a file from disk, a web response from a URL, or user input from the console.</p><h3 id="types-of-streams-in-java">Types of Streams in Java</h3><p>Java divides its stream classes into two main groups:</p><ol>
 <li><p><strong>Byte Streams</strong> (binary data)</p>
  <ul>
   <li>Classes: <code>InputStream</code> and <code>OutputStream</code> (abstract base classes)</li>
   <li>Used for: reading and writing raw bytes (e.g., images, audio, binary files)</li>
  </ul></li>
 <li><p><strong>Character Streams</strong> (text data)</p>
  <ul>
   <li>Classes: <code>Reader</code> and <code>Writer</code> (abstract base classes)</li>
   <li>Used for: reading and writing characters, with support for Unicode and encodings</li>
  </ul></li>
</ol><p>We'll look at both byte and character stream examples below.</p><h3 id="byte-stream-example-reading-and-writing-bytes">Byte Stream Example: Reading and Writing Bytes</h3><p>The following example shows how to use <code>FileInputStream</code> and <code>FileOutputStream</code> to copy a file.</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">ðŸ“‹</button>
 <pre><code class="language-java">import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;

public class ByteStreamExample {
    public static void main(String[] args) {
        try (
            FileInputStream input = new FileInputStream("input.dat");
            FileOutputStream output = new FileOutputStream("output.dat");
        ) {
            int byteData;
            while ((byteData = input.read()) != -1) {
                output.write(byteData);
            }
            System.out.println("File copied successfully using byte streams.");
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}</code></pre>
</div><p><strong>Explanation:</strong></p><ul>
 <li><code>FileInputStream</code> reads one byte at a time from <code>input.dat</code>.</li>
 <li><code>FileOutputStream</code> writes that byte to <code>output.dat</code>.</li>
 <li>This is a simple and direct way to copy binary data.</li>
</ul><h3 id="character-stream-example-reading-and-writing-text">Character Stream Example: Reading and Writing Text</h3><p>When dealing with text, itâ€™s better to use character streams to handle encoding properly.</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">ðŸ“‹</button>
 <pre><code class="language-java">import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;

public class CharacterStreamExample {
    public static void main(String[] args) {
        try (
            FileReader reader = new FileReader("input.txt");
            FileWriter writer = new FileWriter("output.txt");
        ) {
            int charData;
            while ((charData = reader.read()) != -1) {
                writer.write(charData);
            }
            System.out.println("File copied successfully using character streams.");
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}</code></pre>
</div><p><strong>Explanation:</strong></p><ul>
 <li><code>FileReader</code> reads characters from a text file.</li>
 <li><code>FileWriter</code> writes characters to another text file.</li>
 <li>Character streams are ideal for handling Unicode text.</li>
</ul><h3 id="stream-chaining-wrapping-streams">Stream Chaining (Wrapping Streams)</h3><p>Java IO encourages <strong>composition</strong> of stream objects for added functionality. For example, you can wrap a <code>FileInputStream</code> with a <code>BufferedInputStream</code> for performance.</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">ðŸ“‹</button>
 <pre><code class="language-java">import java.io.*;

public class BufferedStreamExample {
    public static void main(String[] args) {
        try (
            BufferedInputStream bufferedInput = new BufferedInputStream(new FileInputStream("input.txt"));
            BufferedOutputStream bufferedOutput = new BufferedOutputStream(new FileOutputStream("output.txt"));
        ) {
            int data;
            while ((data = bufferedInput.read()) != -1) {
                bufferedOutput.write(data);
            }
            System.out.println("File copied with buffering.");
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}</code></pre>
</div><p><strong>Buffered streams</strong> reduce the number of disk access operations, making reading and writing faster by using an internal buffer.</p><h3 id="key-methods-in-stream-based-io">Key Methods in Stream-Based IO</h3><p>Here are some common methods used in stream-based IO:</p><ul>
 <li><code>read()</code> â€“ reads a byte or character from an input stream.</li>
 <li><code>write(int b)</code> â€“ writes a byte or character to an output stream.</li>
 <li><code>close()</code> â€“ closes the stream and releases system resources.</li>
 <li><code>flush()</code> â€“ forces any buffered output to be written.</li>
</ul><h3 id="recap">Recap</h3><p>Stream-based IO in Java provides a simple and powerful way to work with data. Whether you're handling files, network sockets, or console input/output, the stream abstraction lets you focus on <strong>how</strong> data flows rather than <strong>where</strong> it comes from or goes.</p><p>Streams make IO operations consistent and composable across different sources and formats. By separating byte and character handling, Java also helps ensure correctness in processing both binary and textual data. As we move further into the Java IO ecosystem, youâ€™ll see how these foundational concepts scale into more advanced topics like buffered IO, object serialization, and non-blocking channels.</p><div class = "chapter-navi-section">
<a href="#top" class="nav-button prev">â†‘</a>
<a href='java-io-and-nio.htm#introduction-to-java-io-and-nio' class="nav-button toc-link">Index</a>
<a href="#bottom" class="nav-button next">â†“</a>
</div>
<h2 id='blocking-vs-non-blocking-io'>1.4 Blocking vs Non-blocking IO</h2><p>When writing IO-based programs in Java, one of the most important design considerations is whether to use <strong>blocking</strong> or <strong>non-blocking</strong> IO. The distinction lies in <strong>how a thread behaves when it attempts to read or write data</strong> and whether it must wait for the operation to complete.</p><h3 id="blocking-io-traditional-and-simple">Blocking IO: Traditional and Simple</h3><h4 id="definition">Definition</h4><p><strong>Blocking IO</strong> refers to an IO model where the thread making a read or write call <strong>waits (blocks)</strong> until the operation completes. This model is straightforward and easy to implement, but it becomes inefficient when dealing with many concurrent IO tasks.</p><p>In Java, the classic IO streams (<code>InputStream</code>, <code>OutputStream</code>, <code>Reader</code>, <code>Writer</code>) follow the <strong>blocking IO model</strong>.</p><h4 id="how-it-works">How It Works</h4><p>Imagine you're at a bank teller window (the thread), and you're waiting for a transaction to finish (the IO operation). You <strong>cannot leave</strong> until the teller is done â€” even if it takes a long time.</p><p>Hereâ€™s a simple blocking IO example:</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">ðŸ“‹</button>
 <pre><code class="language-java">import java.io.BufferedReader;
import java.io.InputStreamReader;

public class Test {

    public static void main(String[] argv) throws Exception {
        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
        System.out.print("Enter something: ");
        String input = reader.readLine(); // This blocks until the user presses Enter
        System.out.println("You entered: " + input);

    }
}</code></pre>
</div><p>In this case, the thread is blocked at <code>readLine()</code> until the user provides input.</p><h4 id="advantages-of-blocking-io">Advantages of Blocking IO</h4><ul>
 <li>Simple and intuitive to implement.</li>
 <li>Suitable for applications with limited and predictable concurrency (e.g., desktop apps, scripts).</li>
</ul><h4 id="drawbacks-of-blocking-io">Drawbacks of Blocking IO</h4><ul>
 <li><strong>Scalability limits</strong>: One thread per connection becomes expensive in terms of memory and context-switching.</li>
 <li><strong>Inefficiency under high load</strong>: Many threads may spend most of their time idle, waiting for IO.</li>
</ul><h3 id="non-blocking-io-scalable-and-efficient">Non-Blocking IO: Scalable and Efficient</h3><h4 id="definition">Definition</h4><p><strong>Non-blocking IO</strong> allows threads to <strong>initiate IO operations and continue doing other work</strong> while waiting for the operation to complete. Instead of waiting, the program is notified when the data is ready to be read or written.</p><p>In Java, this model is supported by the <strong>Java NIO (New IO)</strong> package, introduced in Java 1.4. NIO uses <code>SelectableChannel</code>, <code>Selector</code>, and <code>Buffer</code> classes to achieve non-blocking behavior.</p><h4 id="how-it-works">How It Works</h4><p>Back to our bank analogy: with non-blocking IO, you fill out a request slip (register interest in IO), drop it in a box, and move on. The bank calls your number (via a selector) when your transaction is ready.</p><p>Here's a conceptual snippet using NIO:</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">ðŸ“‹</button>
 <pre><code class="language-java">import java.nio.channels.SelectionKey;
import java.nio.channels.Selector;
import java.nio.channels.SocketChannel;
import java.util.Set;

public class Test {

    public static void main(String[] argv) throws Exception {
        SocketChannel channel = SocketChannel.open();
        channel.configureBlocking(false);
        Selector selector = Selector.open();
        channel.register(selector, SelectionKey.OP_READ);

        // Later in event loop
        selector.select(); // Blocks until at least one channel is ready
        Set&lt;SelectionKey&gt; readyKeys = selector.selectedKeys();
        for (SelectionKey key : readyKeys) {
            if (key.isReadable()) {
                // Data is ready to be read from the channel
            }
        }
    }
}</code></pre>
</div><h4 id="advantages-of-non-blocking-io">Advantages of Non-Blocking IO</h4><ul>
 <li><strong>Highly scalable</strong>: One thread can handle thousands of connections.</li>
 <li><strong>Efficient resource usage</strong>: Threads arenâ€™t blocked waiting on IO.</li>
 <li>Ideal for <strong>network servers</strong>, <strong>real-time systems</strong>, and <strong>high-concurrency applications</strong>.</li>
</ul><h4 id="drawbacks-of-non-blocking-io">Drawbacks of Non-Blocking IO</h4><ul>
 <li><strong>More complex code</strong>: Requires managing selectors, buffers, and event loops.</li>
 <li><strong>Callback and state management</strong> can become tricky.</li>
 <li>Not always beneficial for small, simple applications.</li>
</ul><h3 id="visualizing-the-difference">Visualizing the Difference</h3><p>Imagine an <strong>airport check-in</strong> scenario:</p><ul>
 <li><strong>Blocking IO</strong>: Every passenger waits in line at a single desk until the desk is free.</li>
 <li><strong>Non-blocking IO</strong>: All passengers enter a lounge, check in on tablets, and are notified when their boarding pass is ready.</li>
</ul><table>
 <thead>
  <tr>
   <th>Feature</th>
   <th>Blocking IO</th>
   <th>Non-blocking IO</th>
  </tr>
 </thead>
 <tbody>
  <tr>
   <td>Thread behavior</td>
   <td>Waits until IO is complete</td>
   <td>Continues other work while waiting</td>
  </tr>
  <tr>
   <td>Simplicity</td>
   <td>Simple and straightforward</td>
   <td>More complex (selectors, buffers)</td>
  </tr>
  <tr>
   <td>Scalability</td>
   <td>Limited (1 thread per connection)</td>
   <td>High (many connections per thread)</td>
  </tr>
  <tr>
   <td>Resource efficiency</td>
   <td>Low (many idle threads)</td>
   <td>High (fewer threads used efficiently)</td>
  </tr>
  <tr>
   <td>Common usage</td>
   <td>Desktop apps, file operations</td>
   <td>Web servers, chat servers, real-time IO</td>
  </tr>
 </tbody>
</table><h3 id="use-case-scenarios">Use Case Scenarios</h3><h4 id="blocking-io-best-when">Blocking IO Best When:</h4><ul>
 <li>Your application handles a <strong>small number of users or files</strong>.</li>
 <li>IO operations are quick or infrequent.</li>
 <li>Simplicity and readability are more important than scalability.</li>
</ul><p><strong>Example:</strong> A desktop word processor saving and loading text files. It doesnâ€™t need to handle thousands of simultaneous IO operations.</p><h4 id="non-blocking-io-best-when">Non-blocking IO Best When:</h4><ul>
 <li>You are building <strong>high-performance servers</strong> (e.g., web servers, chat systems).</li>
 <li>You need to handle <strong>thousands of client connections concurrently</strong>.</li>
 <li>Latency and responsiveness are critical.</li>
</ul><p><strong>Example:</strong> A multiplayer game server that needs to serve hundreds of players over TCP with minimal delay.</p><h3 id="recap">Recap</h3><p>Choosing between blocking and non-blocking IO depends on your application's needs. <strong>Blocking IO is easier to implement</strong> and ideal for small-scale applications. <strong>Non-blocking IO scales far better</strong>, especially when handling many concurrent IO operations, but requires more effort and careful design.</p><p>In modern Java, developers can also explore <strong>asynchronous IO (AIO)</strong> and emerging features like <strong>virtual threads</strong> from Project Loom, which attempt to combine the simplicity of blocking IO with the scalability of non-blocking IO â€” providing even more flexibility in managing IO workloads.</p><div class = "chapter-navi-section">
<a href="#top" class="nav-button prev">â†‘</a>
<a href='java-io-and-nio.htm#introduction-to-java-io-and-nio' class="nav-button toc-link">Index</a>
<a href="#bottom" class="nav-button next">â†“</a>
</div>
<h2 id='synchronous-vs-asynchronous-io'>1.5 Synchronous vs Asynchronous IO</h2><p>In Java, how a program handles input and output (IO) operations has a profound impact on its performance and responsiveness. Two major models exist: <strong>synchronous IO</strong> and <strong>asynchronous IO</strong>. Both are essential in different scenarios and serve as the backbone of modern file and network communication.</p><h3 id="what-is-synchronous-io">What Is Synchronous IO?</h3><p><strong>Synchronous IO</strong> means that a thread initiates an IO operation and then <strong>waits until the operation completes</strong> before continuing. This model follows a <strong>step-by-step, blocking execution flow</strong>, making it predictable and easy to understand.</p><h4 id="execution-flow">Execution Flow</h4><ul>
 <li>The program executes one instruction at a time.</li>
 <li>When a read/write operation is triggered, the thread <strong>blocks</strong> until it finishes.</li>
 <li>Afterward, the next instruction is executed.</li>
</ul><p>This behavior is analogous to standing in line at a coffee shop: you place your order, wait until itâ€™s ready, then proceed.</p><h4 id="java-apis-for-synchronous-io">Java APIs for Synchronous IO</h4><p>Most of Javaâ€™s classic IO classes use synchronous behavior. Examples include:</p><ul>
 <li><code>FileInputStream</code> / <code>FileOutputStream</code></li>
 <li><code>BufferedReader</code> / <code>BufferedWriter</code></li>
 <li><code>Socket</code> / <code>ServerSocket</code></li>
 <li><code>FileReader</code> / <code>FileWriter</code></li>
</ul><p><strong>Example:</strong></p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">ðŸ“‹</button>
 <pre><code class="language-java">import java.io.BufferedReader;
import java.io.FileReader;

public class Test {

    public static void main(String[] argv) throws Exception {
        BufferedReader reader = new BufferedReader(new FileReader("data.txt"));
        String line = reader.readLine(); // Synchronous: thread waits until a line is read
        System.out.println(line);
        reader.close();

    }
}</code></pre>
</div><h4 id="use-cases-for-synchronous-io">Use Cases for Synchronous IO</h4><ul>
 <li>Applications with <strong>limited concurrency</strong>.</li>
 <li>Simple <strong>desktop utilities</strong>, scripts, or CLI tools.</li>
 <li>Situations where <strong>code clarity</strong> and <strong>sequential flow</strong> matter more than throughput.</li>
</ul><h4 id="benefits-of-synchronous-io">Benefits of Synchronous IO</h4><ul>
 <li>Simpler code: Linear, easier to read and debug.</li>
 <li>Good performance for small workloads or isolated IO tasks.</li>
</ul><h4 id="drawbacks">Drawbacks</h4><ul>
 <li><strong>Inefficient under high load</strong>: Threads spend time waiting.</li>
 <li><strong>Scalability limits</strong>: Each IO task requires a dedicated thread.</li>
</ul><h3 id="what-is-asynchronous-io">What Is Asynchronous IO?</h3><p><strong>Asynchronous IO</strong> (AIO) allows a thread to initiate an IO operation and then <strong>continue executing other tasks</strong>. When the IO operation completes, the thread is notified via a <strong>callback</strong>, <strong>future</strong>, or <strong>event</strong>, rather than blocking.</p><h4 id="execution-flow">Execution Flow</h4><ul>
 <li>The thread starts an IO operation.</li>
 <li>Instead of waiting, it continues other work.</li>
 <li>When the IO is complete, the result is processed through a notification mechanism.</li>
</ul><p>This is like ordering a drink at a kiosk and receiving a text when itâ€™s ready, so you donâ€™t have to wait in line.</p><h4 id="java-apis-for-asynchronous-io">Java APIs for Asynchronous IO</h4><p>Java introduced built-in support for asynchronous IO in <strong>Java 7</strong> with the <code>java.nio.channels</code> package. Key classes include:</p><ul>
 <li><code>AsynchronousFileChannel</code></li>
 <li><code>AsynchronousSocketChannel</code></li>
 <li><code>CompletionHandler</code></li>
 <li><code>Future</code> (from <code>java.util.concurrent</code>)</li>
</ul><p><strong>Example using Future:</strong></p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">ðŸ“‹</button>
 <pre><code class="language-java">import java.nio.ByteBuffer;
import java.nio.channels.AsynchronousFileChannel;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.StandardOpenOption;
import java.util.concurrent.Future;

public class Test {

    public static void main(String[] argv) throws Exception {
        Path path = Paths.get("data.txt");
        AsynchronousFileChannel channel = AsynchronousFileChannel.open(path, StandardOpenOption.READ);
        ByteBuffer buffer = ByteBuffer.allocate(1024);

        Future&lt;Integer&gt; result = channel.read(buffer, 0); // Non-blocking
        while (!result.isDone()) {
            System.out.println("Doing other work...");
        }
        // Now read is complete
        System.out.println("Bytes read: " + result.get());
        channel.close();
    }
}</code></pre>
</div><p><strong>Example using CompletionHandler:</strong></p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">ðŸ“‹</button>
 <pre><code class="language-java">import java.nio.ByteBuffer;
import java.nio.channels.AsynchronousFileChannel;
import java.nio.channels.CompletionHandler;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.StandardOpenOption;

public class Test {

    public static void main(String[] argv) throws Exception {
        Path path = Paths.get("data.txt");
        AsynchronousFileChannel channel = AsynchronousFileChannel.open(path, StandardOpenOption.READ);
        ByteBuffer buffer = ByteBuffer.allocate(1024);

        channel.read(buffer, 0, buffer, new CompletionHandler&lt;Integer, ByteBuffer&gt;() {
            @Override
            public void completed(Integer bytesRead, ByteBuffer buf) {
                System.out.println("Read completed: " + bytesRead + " bytes");
            }

            @Override
            public void failed(Throwable exc, ByteBuffer buf) {
                System.err.println("Read failed: " + exc.getMessage());
            }
        });
    }
}</code></pre>
</div><h4 id="use-cases-for-asynchronous-io">Use Cases for Asynchronous IO</h4><ul>
 <li><strong>Scalable network servers</strong> (e.g., web servers, chat systems).</li>
 <li><strong>Responsive GUIs</strong> and mobile apps where UI should not freeze during IO.</li>
 <li><strong>High-throughput applications</strong> where IO latency must be masked with parallel computation.</li>
</ul><h4 id="benefits-of-asynchronous-io">Benefits of Asynchronous IO</h4><ul>
 <li>Better <strong>CPU utilization</strong>: threads arenâ€™t idle while waiting on IO.</li>
 <li><strong>Highly scalable</strong>: suitable for thousands of simultaneous IO operations.</li>
 <li>Supports <strong>event-driven</strong> and <strong>reactive programming</strong> models.</li>
</ul><h4 id="drawbacks">Drawbacks</h4><ul>
 <li><strong>Complex code</strong>: harder to follow, especially with nested callbacks.</li>
 <li>Requires <strong>careful error handling</strong> and state management.</li>
 <li>Debugging and testing are more involved.</li>
</ul><h3 id="key-differences-at-a-glance">Key Differences at a Glance</h3><table>
 <thead>
  <tr>
   <th>Feature</th>
   <th>Synchronous IO</th>
   <th>Asynchronous IO</th>
  </tr>
 </thead>
 <tbody>
  <tr>
   <td>Execution model</td>
   <td>Blocking</td>
   <td>Non-blocking</td>
  </tr>
  <tr>
   <td>Thread behavior</td>
   <td>Waits for IO to complete</td>
   <td>Continues immediately after starting IO</td>
  </tr>
  <tr>
   <td>Complexity</td>
   <td>Simple</td>
   <td>More complex</td>
  </tr>
  <tr>
   <td>Performance (high concurrency)</td>
   <td>Poor</td>
   <td>Excellent</td>
  </tr>
  <tr>
   <td>API examples</td>
   <td><code>FileInputStream</code>, <code>BufferedReader</code></td>
   <td><code>AsynchronousFileChannel</code>, <code>CompletionHandler</code></td>
  </tr>
  <tr>
   <td>Use case</td>
   <td>Command-line tools, scripts</td>
   <td>Network servers, UI apps, high-load systems</td>
  </tr>
 </tbody>
</table><h3 id="recap">Recap</h3><p>The choice between <strong>synchronous</strong> and <strong>asynchronous IO</strong> depends on your application's scale, complexity, and responsiveness requirements. <strong>Synchronous IO</strong> is ideal for simple tasks and sequential processing. Itâ€™s easy to implement and sufficient when the number of concurrent operations is small.</p><p>In contrast, <strong>asynchronous IO</strong> is designed for <strong>scalability and performance</strong>, particularly in IO-bound, multi-client environments. Javaâ€™s support for AIO with <code>AsynchronousChannel</code> classes empowers developers to write responsive, high-throughput applications â€” though at the cost of increased code complexity.</p><p>As you continue exploring Java IO and NIO, youâ€™ll see how combining different models â€” or even using newer features like <strong>virtual threads</strong> from Project Loom â€” can help you balance simplicity and performance in your applications.</p><div class = "chapter-navi-section">
<a href="" class="nav-button prev"></a>
<a href='java-io-and-nio.htm#introduction-to-java-io-and-nio' class="nav-button toc-link">Index</a>
<a href="java-io-and-nio-java-io-fundamentals.htm" class="nav-button next">â†’</a>
</div>
<section class="download-section">
  <div class="book-cover" style="background-color: #f9f6f1;border: 1px solid #ccc;"> 
    <div class="book-cover-title" style="font-size: 18px;color: #333;top: 20px;">Java IO and NIO</div>
    <div class="book-cover-author">readbytes</div>
    <div class="book-cover-bottom-stripe" style="background-color: #333;"></div>
    <img class="book-cover-icon" style="width: 80px;height: 90px;top: 60px;" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFoAAABaCAYAAAA4qEECAAADAElEQVR4Xu2Zu6oTURSGjze0UfANtLAUzgOI4DOItc+VKk1uJ12aadNa21vbCpYK4wQmcPiYzL5k7eXM2f8HP0JYa/3ZX2PEmxshxAPi7u6uLRH2VA3lWId9VdK27WOKsQ47q6RpmucUYx12VolEOyHRToyJ5mwI7ufeeZBItBMS7YREOyHRTki0ExLthEQ7IdFOSLQTEu2ERDsxJtoq7KwSiXZCop04Ho9PKcY67KwWirEO+6qGcqzCHhGBJDoh0U5ItAP7/f6bRDtAyV3+ckYYQNHr9fo1Z8SVtG37iKI5Mzv4IKuwJwXeuvbef4ePsQ77YuGdLp85MysGHmQa9sXAG7l3JgUfZB32heh+0t3yRvfZD87NDj7KOuwLwf2cG5OEj7IO+8bg7imr1eoV55Lh0VC4bwE7cru4n3Jns9l85d7YPmdCSV8oADtyu7gfe4fzMbucCyV9oQDsyO3i/tid7i+395xjuHMfzoaSvlAAduR2cf/+ne7PT/x8JL94mwzsjCZ5wTN8XAjuTynT/nKJcH9KmfaXS4T7U8q0v1wi3J9Skr8cH3cJ7l3I98Ph8HLg86SuM9zPvRMDO0JJXwjQ/Wx6yx3kI3cGZqK6CPdz78TAjlDSF0ZYLpcvOH9O0zQX/xnL2ZiuIbifeycGdoSSvjACZ2N2TnA+do9wP/dODOwIhfvZ8HCfn5wbYmDPNOybLXxYn9+cu8TArmnYN1v4sNTHcdc67JslfFTOw7hvHfbNEj6q+3n3gTMheMM67JsdfNA1j+Idq7BnlvBR2+32DWfElazX63cUzRlhACVLdCEk2QmJdmC3232RaAcoucsfzogAAxJNwp6qoRzrsK9aKMY6i8XiGTurhGKsc/ofGHZWCcVYR6J7KMY6Et1DMedwLgT3JRpQjEQXgmIkuhAUI9GFoBiJLgTFSHQhKEaiC0ExEl0IipHoQlCMRBeCYiS6EBQj0YWgGOtIdA/FWEeieyjGOhLdQzHW2e/3T9hZJRRjHfZVDeVYhT1CiDnzD27IzgFe/xOvAAAAAElFTkSuQmCC"/>
  </div>
  <div class="download-info">
    <h2 id='bottom'>Download This Ebook</h2>
    <p class="format-label">Available formats:</p>
    <div class="download-buttons">
      <a href="java-io-and-nio.pdf" class="download-button">ðŸ“„ PDF</a>
      <a href="java-io-and-nio.epub" class="download-button">ðŸ“˜ EPUB</a>
    </div>
  </div>
</section><div class='related-books'>
<h2>Java In-Depth Books</h2>
<div class='related-book-list'>
<a href="java-io-and-nio.htm">
<div class="book-cover" style="background-color: #f9f6f1;border: 1px solid #ccc;"> 
    <div class="book-cover-title" style="font-size: 18px;color: #333;top: 20px;">Java IO and NIO</div>
    <div class="book-cover-author">readbytes</div>
    <div class="book-cover-bottom-stripe" style="background-color: #333;"></div>
    <img class="book-cover-icon" style="width: 80px;height: 90px;top: 60px;" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFoAAABaCAYAAAA4qEECAAADAElEQVR4Xu2Zu6oTURSGjze0UfANtLAUzgOI4DOItc+VKk1uJ12aadNa21vbCpYK4wQmcPiYzL5k7eXM2f8HP0JYa/3ZX2PEmxshxAPi7u6uLRH2VA3lWId9VdK27WOKsQ47q6RpmucUYx12VolEOyHRToyJ5mwI7ufeeZBItBMS7YREOyHRTki0ExLthEQ7IdFOSLQTEu2ERDsxJtoq7KwSiXZCop04Ho9PKcY67KwWirEO+6qGcqzCHhGBJDoh0U5ItAP7/f6bRDtAyV3+ckYYQNHr9fo1Z8SVtG37iKI5Mzv4IKuwJwXeuvbef4ePsQ77YuGdLp85MysGHmQa9sXAG7l3JgUfZB32heh+0t3yRvfZD87NDj7KOuwLwf2cG5OEj7IO+8bg7imr1eoV55Lh0VC4bwE7cru4n3Jns9l85d7YPmdCSV8oADtyu7gfe4fzMbucCyV9oQDsyO3i/tid7i+395xjuHMfzoaSvlAAduR2cf/+ne7PT/x8JL94mwzsjCZ5wTN8XAjuTynT/nKJcH9KmfaXS4T7U8q0v1wi3J9Skr8cH3cJ7l3I98Ph8HLg86SuM9zPvRMDO0JJXwjQ/Wx6yx3kI3cGZqK6CPdz78TAjlDSF0ZYLpcvOH9O0zQX/xnL2ZiuIbifeycGdoSSvjACZ2N2TnA+do9wP/dODOwIhfvZ8HCfn5wbYmDPNOybLXxYn9+cu8TArmnYN1v4sNTHcdc67JslfFTOw7hvHfbNEj6q+3n3gTMheMM67JsdfNA1j+Idq7BnlvBR2+32DWfElazX63cUzRlhACVLdCEk2QmJdmC3232RaAcoucsfzogAAxJNwp6qoRzrsK9aKMY6i8XiGTurhGKsc/ofGHZWCcVYR6J7KMY6Et1DMedwLgT3JRpQjEQXgmIkuhAUI9GFoBiJLgTFSHQhKEaiC0ExEl0IipHoQlCMRBeCYiS6EBQj0YWgGOtIdA/FWEeieyjGOhLdQzHW2e/3T9hZJRRjHfZVDeVYhT1CiDnzD27IzgFe/xOvAAAAAElFTkSuQmCC"/>
  </div>
</a>


<a href="java-collections.htm">
<div class="book-cover" style="background-color: #f9f6f1;border: 1px solid #ccc;"> 
    <div class="book-cover-title" style="font-size: 18px;color: #333;top: 20px;">Java Collections</div>
    <div class="book-cover-author">readbytes</div>
    <div class="book-cover-bottom-stripe" style="background-color: #333;"></div>
    <img class="book-cover-icon" style="width: 80px;height: 90px;top: 60px;" src='data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFoAAABaCAYAAAA4qEECAAADAElEQVR4Xu2dQYrUUBRFIw50JI7FrYgrcAPOXYPORHci7sah4EAQFyA6dNKosZK2Ee8/dOclP7/+i/fAmaR+Xr17KehJV2oYjDHGGGM6YRxzmgZdPKvdMt4vl03vLU15ZsYnsORB7Apd7mh2gS51VM/K+LVc6LA+0/QNKZax9RnvlG+C/tI7+6PYuYLV0MHoc72rX8ZvsP9Gq6BDyWzo/jXcjA4sfKN39E+RoYaf9F2CFAPFjGiG3b0Y5r9111LcJGZEM7QW0UNqRjTDWXwQXCojmoEk9MxmHwWGZ0QzkMT4ujy31b/D4UU8uITp/J4uRDOQxPiyPFfDy+HwQnFoCdPZFi5AM5BE/0VP51r5brgRzUASexU9/piG60VxEdO5lt6AZiCJ3Yoep+Fw8Z8DS5gHNfLncCOagSSWFE2M38tzanFBXcS9k/OwBi5AM5DE2qIn9JxaXFAXM33S5oE7+nFYhGYgiRxFX7FH4V+GEJqBJHIV3QGagSRcdBDNQBIuOohmIAkXHUQzkISLDqIZSMJFB9EMJOGig2gGknDRQTQDSbjoIJqBJHIUfffkPLCC74dNaAaSyFH0PKyiL4bVaAaS6L/oedAOrkQzkISLDqIZSMJFB9EMJNF/0bdPzsMquxLNQBL9Fz3x4eQ8sJIb0AwkkaPoK56efLvSV0MVNANJ5Cq6AzQDSbjoIJqBJFx0EM1AEi46iGYgCRcdRDOQhIsOohlIwkUH0Qwk4aKDaAaScNFBNANJuOggmoEkXHQQzUASLjqIZiAJFx1EM5CEiw6iGUjCRQfRDCSxtuh2X63oDM1AEkuKXmtxQc2IZiCJ3Yqu9vW3ztAMJLFX0ZfD4YXiUDI0A0m46CCagSTyfOm+EzQDSeiZzT4ODM+IZjiLD4NLZUQztBbRQ2pGNMPu1nh4lR/H9sfP+i5BioFgNnT/Gm5GB6Ib/im8Nf0+MtMPgb3Wquhwqw1Vwg/qbkix0EHtAl3qaHaDfx6kIf7Bm8YUyyY1Dbp4Fo0xxhhj/kd+A/PkOH57kF8HAAAAAElFTkSuQmCC'/>
  </div>
</a>


<a href="java-regex.htm">
<div class="book-cover" style="background-color: #f9f6f1;border: 1px solid #ccc;"> 
    <div class="book-cover-title" style="font-size: 18px;color: #333;top: 20px;">Java Regex</div>
    <div class="book-cover-author">readbytes</div>
    <div class="book-cover-bottom-stripe" style="background-color: #333;"></div>
    <img class="book-cover-icon" style="width: 80px;height: 90px;top: 60px;" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFoAAABaCAYAAAA4qEECAAAFo0lEQVR4Xu2d3WscVRiH+y/YXuuFkov6H9je2huvlAQvFalCEW8qiFRFQcGrmoJ4U5TSLWglFqRIlJqCH6XWalM/0lrT1O1ukt3sV5qPTZrP3XHfLTM983vPztc5s+zZPQ88N5l3Z9inwzA70Dl79iQks29oM7N3yBkoW98ZO6RC62ANdvDBtYF9lJEcxHNi+CWnOvmXs5rN9aX03eg74vcWxV6xObX3iUdxp2P7DzqDztiTB1lsaoX9InF631BJ3NH408N4vIFn/NCwL/aZVjPsGAj+a1mCwV7YUwqeyZZoxDqz8ZpsiYfY7mzQNdtGVkdsiH3b2Mj6CIztbrB3F+qMHxqRh84Iv/gsehDO6oe/IN0/ju0/gPOWhNAPO3ZW27M5HXyhTwtP4Sx68S4f9NRPuJbgnEURsa0Xmp5QWfQyMfLwqZ8XunrtT5yzKEKPWFnoem4O5xKxsVbS5vbmMu7eKOr5OUnovHro1ep0KppKPT+vP/TGWpkF0qWp2NBdwobuEjY0MnXbcb4cd5xCGbco0XOhb8wuOhdnGp4//7fl254ah9/urAZ6KrQYGL01V0sndLPJw8pUxJjQ5OXsBh5KjVZjFjRIBXoqdKWcZXHRK/kGHi45GDJMBXoqNFku3WVx0V9nNcTGiK7nLgRvT0jPhSZLacfGeK7Xb4bPJaQnQz+InWNx0USXEQzn+vsUTvKZfgxNFhfyLC4a68x+7QMejrwieVqJM+QX3+BUZHo6NDlfnGNx0auzdPsQAQxHXprEKT7jqkDPhyZni/MsLhopNoY7kcEJPuN6bBQnY2FEaDJXLLC4aGhsjIfgdtdX3sHJ2BgTmswVwmMHXrMxoBgb/+76snpkwqjQZKnusLhox7uRryd4yDA1YVxoYmG1yeKi0jP7nzs8ZJAaMTI0UVhJEPvN4zxmJzVjbGhidik8tu8ygjE7mQJGha7XZvBQTnYxPHb7zF6o8qAyU8KY0Gv37uJhPGZq4bEXpnI8KpoiRoTe3lzBQzCmq51j59aabSu/3OBxSU23cEH0fOgHT+ej8W+Fx3Yju9YuXO16ZCKV0DvVSWfrzlnm+tyP/pCVW2xGNAlibIzsunT+p65GJroamhRD4zbVyC7TFR4XXf7qIn4sVVIJ3bj9meNce0OqGLM5+Rbb7jMhePmQWXzqWWf15Of40dRIJfTmwmV2hiY1LhhUJkV2Xfn4FO4iFXo+NBkVDCpTjOzFPvEp7ko7RoQmw8CgMjGw6PJourGNCU12AoPKXHpvlMVFl4+fxF1rw6jQJIJBZbpgWJnLH34i7F0fxoamnzEYVKZI6ZkXWViZS+9+5PucDowNjUFlIlt/3GRRO7n4+vv4cSWMDI1BZcpYP/89Cxpk7cgx3EVijAuNQWV2AkOSbZpN9nfX6uHkP5xE+i50EBgRwe1e7BeO4mhs+ip0GBjw/nc/4AibCZqNQ9+EjgLGI50G/yzOeLMK9EXoqBQPPMfixYm9cek3HIuM8aHjgvFcmzs7OMpm2v8oCTE6dBJ2q/dYPC/29rZvFrcPZGgVdss1FtCLvX6/PVN5/lW2beBC62C3VGURw2z/D66EGBdaJ7vFMosZpAoDHZqIGluVgQ/dJuAnuI7IhA0NVEaOtOMuHrVP74zEhu4SNnSXkIdWfHnVbr3AAunSVOjkZaF1vI4NA+nQZKSvY7MvGNSP9AWDpEUvYlv7EtgU8UK7Sz/Z0Ongnc34/mi7apA+xNWHxND21fOa8S4buHiZu4GWJbKo8W2nxRTE0PasVkdsiZ3b2NjqhEYmaNkhGzs5Yrszjzz+GPb1QQtq2djxEZu17pvL2FWK70M2dijYC3sGgmc2LUtk8SPeXcQ6kxFcdo+kG/FBR+tSqCK4U1F6QlW7/rezms33pfTdxKdwMrGXMhm7XLWo/uWqZdgF2OPxPxXwJpKIkhiiAAAAAElFTkSuQmCC"/>
  </div>
</a>


<a href="java-functional-programming.htm">
<div class="book-cover" style="background-color: #f9f6f1;border: 1px solid #ccc;"> 
    <div class="book-cover-title" style="font-size: 18px;color: #333;top: 20px;">Java Functional Programming</div>
    <div class="book-cover-author">readbytes</div>
    <div class="book-cover-bottom-stripe" style="background-color: #333;"></div>
    <img class="book-cover-icon" style="width: 80px;height: 80px;top: 80px;" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFoAAABaCAYAAAA4qEECAAADzUlEQVR4Xu2bO4sUURCFlxVBzfwLJkb+A1MxEgMRDBQDRTBRwchARk00MRFBAwNBzEQwMBfEBz7wbWIkiIGJoInio9wZdmZ7T1V3V91bPVhaH3xJ973n3jk2vdO968JCkiRJkiRRIYphWOgI/zB/uyHBDxHFUODmIxkK3HwkQ4Gbj2QY6BDffCTDgBuPZhhw49EMA248miGgW3zj0QwBbjqiIcBNRzQEuOlohoA+8Y1HMgy4cauJEizO5EZMS0RoUSjPYKIEi7OaKMHirCZKsDiTi5iWiNAmoTyDiRIszmqiBIsz+QXTklZYeQYTJXSUl2cxUYLFWU2UYHEmb2Na0gorz2CihJ7w8iwmSrA4q4kSLM7kYUxLWmHlGUyU0C9ensVECRZnNQS4abPPMNEOy7S4BdN00L5GxmU8q4cuNXL24tll2KYrLIXW8yyLJdAJnkP3cFQ/9FzIGeEgHOBgCZhh1Qod5xkzH+PoduiVMH/qqDkQT3q4trGAEpZh1AId4/OZb3EWh14K89DRdDCecNIKzjdp+IelHcL8Nj/g7BU6r2R0+3gCHvRyN26tHdoszDdoAef2KpQt3pN7ZAc81YLzrFrAuSrfNOY/Es4rZAdcfbCywS7YPIvfMa0buiBkaFz6ATn+POy4xmvjhfGgsxpwjsUSigsr8el0UTzh7c9Vn5FBe4Q5BkuZXKFCnqsPmwviyQHsAsdarWF8tWGem/dxMRwwkG3gOJMvMM1O7S8aRJtX8hQ2aCDbwHEWvXAte3pPlmCDBxKhK3yMRU9cbiOKp0k+aQg3+K7pTdUPyHeYVgELL9At7/zqLA9KH0YmNh5qqqHPwgJWLzby8JxBb1y+Wxve+vXCwguc5Lzmxy164lLy1IL32SJ0Qwi3+k04ZtSLqttFm3dxlUJY8Lzdijsqo+QtnFqPK5u2CcFz1APT++RSPe7ZLHSO1qL6zYiXmu/WXdAaIXRO1lD8mnSpsOKHmpu4CyMscB5W/m8rlqex8TBS+lBTDQYObS2Y16vwxFfydbAaDBzaWmgXz2y14/46fg3Kxre5E2cXwoKH8geuXIb4hzNo11u4ZVRX9kmcVQELH0hP6BTPnym9T26h8559Gkc7wBYZQG/oLF+D/WZEgfht5AyOcoLeC4s5OwR0oLHGVTyrh643cvbjWWewGFc/4mr/MXRQKMjJBMCCvEwAWsdL8jARwJKqvYMrJDNYWRUmHWBZNSY9YGGlJj1gYUWew9REhBVnNFFCX3l5FhMDWJ7WpAAssc+kAiyzzcQJLHbibxyVJEmSJMk/xB+4wdarC+OVAQAAAABJRU5ErkJggg=="/>
  </div>
</a>


<a href="java-streams.htm">
<div class="book-cover" style="background-color: #f9f6f1;border: 1px solid #ccc;"> 
    <div class="book-cover-title" style="font-size: 18px;color: #333;top: 20px;">Java Streams</div>
    <div class="book-cover-author">readbytes</div>
    <div class="book-cover-bottom-stripe" style="background-color: #333;"></div>
    <img class="book-cover-icon" style="width: 80px;height: 80px;top: 60px;" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFoAAABaCAYAAAA4qEECAAACbklEQVR4Xu3cP4oUQRiG8S8xEzESDI1MPIRHEQQPYTK9iCyewMxrGIiCoaFnWFkMTIwUxD894KI8VbNdVdNfzdR87w+eRKa2ul+WVZM1G8+3ud+d+mhBvbZ0DO/uWEAcoVfhcIBehcQRvAvt1dz7gjjaVfxcrhcmxTiwvkudcGAN7YQDa2gnHFhDO+HAGtoJB24ZmmdzhcdBWobh2VzhcZCWYXg2V3gcpGUYns0VHgdpGYZnc4XHQVqG4dlc4XGQlmF4Nld4HKRlGJ7NFR4HaRmGZ3MN48Hcu7lLS19ihI7SPUsfdPSOCh/ulDoKfKhT7KC2P3P5QKfawfBBTr2D4ENEqDs+QJS64uWR6ubc0ssj1Q0vjlYXvLS1X3Mv5x7NPTyi+Jy5uuClNY2Az5zL3RtLLy1pJHz2XO544VLbHw+j4TvkcscLlxoR3yGXO154XaPie+Ry9djSC69rVHyPXK62/xTjhbu6+HtmRHyXXK6iDH1wGroTDd2Jhu5EQ3eioTvR0J1o6E40tAMOt1YCHGitBDjQWglwoLUS4EBrJcCB1kqAA62VwFOnREREROSIPbP7/CNZ28Y+2KT/hPjbjnyVOPl/ZA3tZLLzZGiN7YAD/+smPyqt0nH1Xe2Cw7LndpdHpBZH3ZXs4YndSAbdleyBYy4ljTjkUtKAI5a0sS/8MrKEI5YmFTZ2mQxYmlTgeDVt7DO/nOzC8WqTApPdSoarTQpM9ikZrjYpMNmPZLjapMDZ/JcZh6tNCkx2OxmuNinE4WraDPnbZw5ksp/JgKVJJQ5YmjTgiEvJHib7mgyaS1Yy2dtk3DP7zo9F9wfJyGVFhM8g5gAAAABJRU5ErkJggg=="/>
  </div>
</a>



<a href='java.htm'><div class='book-cover' style='background-color: #f9f6f1;color: #111111;border: 1px solid #ccc;display: flex;justify-content: center;align-items: center;text-align: center;'>More Java Books</div></a>
</div>
</div>
  </div>
  <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/prism.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
  
  <script>
    function copyCode(button) {
      const code = button.nextElementSibling.innerText;
      navigator.clipboard.writeText(code).then(() => {
        button.textContent = 'Copied!';
        setTimeout(() => { button.textContent = 'Copy'; }, 1500);
      });
    }
  </script>  
<div id="floatingLog" aria-live="polite" role="alert"></div>
<footer class="page-footer">
    <nav>
      <a href="https://readbytes.github.io">Home</a> | 
      Email:<script language="JavaScript" type="text/javascript">
var part1 = 'yinpeng';var part6 = '263';var part2 = Math.pow(2,6);var part3 = String.fromCharCode(part2);var part4 = 'hotmail dot com';var part5 = part1 + String.fromCharCode(part2) + part4;document.write(part1 + part6 + part3 + part4);
</script>
    </nav>
  <p>Â© 2025 â€” All rights reserved.</p>    
  </footer>

</body>
</html>