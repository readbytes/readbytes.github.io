<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Java IO and NIO Selectors and Non-blocking IO</title>
<link rel='shortcut icon' href='https://java2s.com/style/favicon.ico'>
<link href="https://fonts.googleapis.com/css2?family=Merriweather&display=swap" rel="stylesheet" />
<link href="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet" />


  <script>
  const mode = localStorage.getItem('mode') || 'light';
  document.documentElement.classList.add(`${mode}-mode`);
  </script>   
<style> 
html {
  scroll-behavior: smooth;
}

body {
  font-family: 'Merriweather', serif;
  margin: 0;
  padding: 2rem 1rem;
  font-size: 15px;
  line-height: 1.5;
  transition: background-color 0.3s, color 0.3s;
}

.container {
  max-width: 700px;
  margin: 0 auto;
  padding: 1rem 2rem;
  box-shadow: 0 0 15px rgba(0,0,0,0.1);
}

h1, h2, h3 {
  font-weight: 600;
  margin-top: 2.5rem;
  margin-bottom: 1rem;
  line-height: 1.2;
}

h1 { font-size: 1.8rem; }
h2 { font-size: 1.4rem; }
h3 { font-size: 1.2rem; }

table {
  width: 100%;
  border-collapse: collapse;
  font-family: sans-serif;
  font-size: 1em;
  margin: 1em 0;
}

th, td {
  padding: 0.6em 1em;
  text-align: left;
  border: 1px solid;
}

tr:nth-child(even) {
  background-color: inherit;
}

tr:hover {
  background-color: inherit;
}

a {
  text-decoration: none;
  transition: color 0.2s;
}

a:hover {
  text-decoration: underline;
}

code {
  color: #d35400;
}

.book-title-chapter {
  font-family: 'Merriweather', serif;
  font-size: 2rem;
  font-weight: bold;
  text-align: center;
  margin-bottom: 2rem;
  border-bottom: 2px solid;
  padding-bottom: 0.5rem;
}

.book-subtitle-chapter {
  text-align: center;
  font-size: 1rem;
  margin-top: -1rem;
  margin-bottom: 2rem;
}

.related-books {
  margin-top: 40px;
}

.related-book-list {
  display: flex;
  flex-wrap: wrap;
  gap: 20px;
}

    .book-cover {
      width: 130px;
      height: 180px;
      font-family: Arial, sans-serif;
      position: relative;
      overflow: hidden;      
      line-height: normal;
      box-shadow: 2px 2px 4px rgba(0,0,0,0.1);
    }
    .book-cover-bottom-stripe {
      position: absolute;
      bottom: 0;
      left: 0;
      height: 5px;
      width: 100%;
    }
    .book-cover-title {
      position: absolute;
      width: 100%;
      text-align: center;
      font-weight: bold;
    }
     
    .book-cover-icon {
      position: absolute;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      align-items: center;
      justify-content: center; 
    }

    .book-cover-author {
      position: absolute;
      bottom: 10px;
      width: 100%;
      text-align: center;
      font-size: 8px;
      color: #333;
    }

.page-footer {
  margin-top: 4rem;
  padding: 1rem 0;
  text-align: center;
  font-size: 0.85rem;
  border-top: 1px solid;
}

.chapter-navi-section {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding-bottom: 10px;
}

.nav-link {
  color: inherit;
  text-decoration: none;
  opacity: 0.5;
  transition: opacity 0.3s ease, text-decoration 0.3s ease;
}

.nav-link:hover {
  opacity: 0.9;
  text-decoration: underline;
}

.prev { text-align: left; }
.toc-link { text-align: center; }
.next { text-align: right; }

.download-section {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 2rem;
  padding: 2rem 1rem;
  max-width: 600px;
  margin: 3rem auto;
  border-radius: 12px;
  box-shadow: 0 4px 10px rgba(0,0,0,0.05);
}

.download-info h2 {
  margin: 0 0 0.5rem;
  font-size: 1.2rem;
}

.format-label {
  margin: 0 0 0.5rem;
  font-size: 0.95rem;
}

.download-buttons {
  display: flex;
  gap: 1rem;
}

.download-button {
  background-color: #4A90E2;
  color: white;
  padding: 0.5em 1.2em;
  border-radius: 25px;
  font-size: 0.95rem;
  text-decoration: none;
  transition: background-color 0.3s ease;
}

.download-button:hover {
  background-color: #357ABD;
}

.code-block {
  position: relative;
  margin-bottom: 1em;
}

.copy-button {
  background: transparent;
  color: white;
  position: absolute;
  top: 8px;
  right: 8px;
  border: none;
  padding: 4px 8px;
  font-size: 12px;
  border-radius: 4px;
  cursor: pointer;
  z-index: 1;
}

.copy-button:hover {
  background-color: #0056b3;
}

.snippet-container {
  overflow: hidden;
}

.snippet-header {
  padding: 0.75rem 1rem;
  cursor: pointer;
  font-size: 1rem;
    background-color: #eeeeee;
    color:  #111111; 
    border-radius: 8px;
    cursor: pointer;
    box-shadow: 0 4px 6px rgba(0,0,0,0.1);  
}

.snippet-body {
  display: none;
  font-family: monospace;
}

.snippet-container.open .snippet-body {
  display: block;
}

.CodeMirror {
  border: 2px solid #ccc;
  border-radius: 4px;
  resize: vertical;
}

/* === Light Mode === */
html.light-mode {
  background-color: #f8f7f5;
  color: #333;
}

html.light-mode .container {
  background: white;
}

html.light-mode .book-title-chapter {
  color: #2c3e50;
  border-color: #ccc;
}
html.light-mode .book-subtitle-chapter{
  color: #888;
}

html.light-mode .page-footer,
html.light-mode .series-name,
html.light-mode .book-subtitle,
html.light-mode .format-label {
  color: #888;
}

html.light-mode .related-books h2 {
  color: #333;
  border-bottom: 2px solid #eee;
}

html.light-mode .book-title {
  color: #fff;
}

html.light-mode .book-cover {
  border: 1px solid #ccc;
}

html.light-mode th {
  background-color: #f2f2f2;
}

html.light-mode tr:nth-child(even) {
  background-color: #fafafa;
}

html.light-mode tr:hover {
  background-color: #e6f7ff;
}

html.light-mode a,
html.light-mode .page-footer a {
  color: #000;
}

/* === Dark Mode === */
html.dark-mode {
  background-color: #181818;
  color: #e0e0e0;
}

html.dark-mode .container {
  background: #222;
}

html.dark-mode .book-title-chapter {
  color: #ddd;
  border-color: #444;
}

html.dark-mode .snippet-header {
    background-color: #333;
    color:  #ddd; 
}


html.dark-mode .book-subtitle-chapter,
html.dark-mode .page-footer,
html.dark-mode .series-name,
html.dark-mode .book-subtitle,
html.dark-mode .book-footer,
html.dark-mode .format-label {
  color: #aaa;
}

html.dark-mode .related-books h2 {
  color: #ddd;
  border-bottom: 2px solid #333;
}

html.dark-mode .book-title {
  color: #fff;
}

html.dark-mode .book-cover {
  border: 1px solid #555;
}

html.dark-mode th {
  background-color: #333;
  color: #fff;
}

html.dark-mode td {
  border-color: #444;
}

html.dark-mode tr:nth-child(even) {
  background-color: #2a2a2a;
}

html.dark-mode tr:hover {
  background-color: #2c3e50;
}

html.dark-mode a,
html.dark-mode .page-footer a {
  color: #eee;
}

    .dialog-backdrop {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: rgba(0,0,0,0.5);
      display: none;
      justify-content: center;
      align-items: center;
      z-index: 10;
    }

    .dialog {
      background: white;
      padding: 20px;
      width: 90vw;
      height: 80vh;
      border-radius: 8px;
      box-shadow: 0 0 20px rgba(0,0,0,0.3);
      display: flex;
      flex-direction: column;
    }
    .dialog-content {
      display: flex;
      flex: 1;
      gap: 20px;
      margin-top: 10px;
    }
    .dialog h2 {
      margin-top: 0;
    }

    .textarea_dialog {
      width: 50%;
      height: 100%;
      resize: none;
      font-family: monospace;
      font-size: 14px;
      padding: 10px;
      box-sizing: border-box;
      border: 1px solid #ccc;
    }

    .iframe_dialog {
      width: 50%;
      height: 100%;
      border: 1px solid #ccc;
    }
    .controls_dialog {
      display: flex;
      justify-content: space-between;
      margin-top: 10px;
    }    
    button { padding: 0.5em 1em; background: green; color: white; border: none; cursor: pointer; }
    button:hover { background: #1e7e34; }
    .result_iframe { width:99%; height:200px; margin-top: 1em;  resize: both;border:1px solid #ccc;}        
</style>
</head>
<body> 
  <div class="container">
    <div class = "chapter-navi-section">
<a href="java-io-and-nio-buffers-and-channels.htm" class="nav-button prev">←</a>
<a href='java-io-and-nio.htm#selectors-and-non-blocking-io' class="nav-button toc-link">Index</a>
<a href="java-io-and-nio-asynchronous-io.htm" class="nav-button next">→</a>
</div>

    <h1 class="book-title-chapter" id = 'top'>Selectors and Non-blocking IO</h1>
    <h3 class="book-subtitle-chapter">Java IO and NIO</h3>   
    <!-- <h1 class ="chapter-title"></h1> -->
    <h2 id='understanding-selectors'>7.1 Understanding Selectors</h2><p>Java NIO (New IO) revolutionized the way Java applications handle input/output by introducing non-blocking IO and scalable architectures. At the heart of this scalable non-blocking model lies the <strong><code>Selector</code></strong>, an object that allows a single thread to monitor multiple channels (e.g., <code>SocketChannel</code>, <code>ServerSocketChannel</code>) for events like <strong>read</strong>, <strong>write</strong>, and <strong>connect</strong> readiness.</p><p>This mechanism enables efficient resource usage and is the cornerstone for building high-performance servers and event-driven applications.</p><h3 id="what-is-a-selector">What is a Selector?</h3><p>A <strong>Selector</strong> is a Java NIO component that can monitor <strong>multiple channels</strong> simultaneously and detect when one or more of them are <strong>ready</strong> for a certain type of IO operation (such as accepting a connection, reading, or writing). Instead of dedicating a thread per socket connection, a single thread can use a selector to manage <strong>hundreds or thousands of connections</strong>.</p><p>Selectors support the following <strong>channel types</strong>:</p><ul>
 <li><code>SocketChannel</code> (client connections)</li>
 <li><code>ServerSocketChannel</code> (server sockets)</li>
 <li><code>DatagramChannel</code> (UDP sockets)</li>
</ul><p>These channels must be in <strong>non-blocking mode</strong> to be used with a <code>Selector</code>.</p><h3 id="why-use-selectors">Why Use Selectors?</h3><p>Traditionally, handling multiple client connections meant using one thread per connection. This model does not scale well, especially in environments with many idle or slow connections. Selectors solve this problem by enabling <strong>multiplexed IO</strong> — a single thread checks multiple channels to see which ones are ready, then acts accordingly.</p><h4 id="real-world-analogy">Real-world Analogy:</h4><p>Imagine a <strong>security guard</strong> monitoring multiple <strong>doors</strong> (channels). Instead of standing at each door waiting (blocking), the guard walks through a hallway (selector) and checks which doors have visitors (read/write events). This is far more efficient than assigning a guard per door.</p><h3 id="key-concepts">Key Concepts</h3><ul>
 <li><strong>Channel registration</strong>: A channel is registered with a selector and specifies the kind of operation to monitor (<code>OP_ACCEPT</code>, <code>OP_CONNECT</code>, <code>OP_READ</code>, <code>OP_WRITE</code>).</li>
 <li><strong>SelectionKey</strong>: When a channel is registered, a <code>SelectionKey</code> is returned. This key represents the registration and holds the interest and readiness sets.</li>
 <li><strong>Selected keys</strong>: When the selector detects that a channel is ready, it returns a set of selection keys representing the channels that are ready for operations.</li>
</ul><h3 id="common-selection-operations">Common Selection Operations</h3><ul>
 <li><code>OP_ACCEPT</code>: A server socket is ready to accept a new connection.</li>
 <li><code>OP_CONNECT</code>: A socket channel finished its connection process.</li>
 <li><code>OP_READ</code>: A channel is ready for reading.</li>
 <li><code>OP_WRITE</code>: A channel is ready for writing.</li>
</ul><h3 id="basic-workflow">Basic Workflow</h3><ol>
 <li><strong>Create a selector</strong></li>
 <li><strong>Configure channels to non-blocking mode</strong></li>
 <li><strong>Register channels with the selector</strong></li>
 <li><strong>Call <code>select()</code> to wait for readiness</strong></li>
 <li><strong>Process selected keys and perform IO</strong></li>
 <li><strong>Repeat the loop</strong></li>
</ol><h3 id="basic-code-example-server-using-selector">Basic Code Example: Server Using Selector</h3><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-java">import java.io.IOException;
import java.net.InetSocketAddress;
import java.nio.ByteBuffer;
import java.nio.channels.*;
import java.util.Iterator;
import java.util.Set;

public class SelectorExample {
    public static void main(String[] args) throws IOException {
        // Step 1: Create Selector
        Selector selector = Selector.open();

        // Step 2: Create ServerSocketChannel and bind port
        ServerSocketChannel serverChannel = ServerSocketChannel.open();
        serverChannel.bind(new InetSocketAddress(5000));
        serverChannel.configureBlocking(false);

        // Step 3: Register ServerChannel with Selector for OP_ACCEPT
        serverChannel.register(selector, SelectionKey.OP_ACCEPT);
        System.out.println("Server started. Listening on port 5000...");

        // Step 4: Event loop
        while (true) {
            // Wait for events (blocking with timeout optional)
            selector.select();

            // Get keys for channels that are ready
            Set&lt;SelectionKey&gt; selectedKeys = selector.selectedKeys();
            Iterator&lt;SelectionKey&gt; iter = selectedKeys.iterator();

            while (iter.hasNext()) {
                SelectionKey key = iter.next();

                // Step 5: Check what event occurred
                if (key.isAcceptable()) {
                    // Accept the new client connection
                    ServerSocketChannel server = (ServerSocketChannel) key.channel();
                    SocketChannel client = server.accept();
                    client.configureBlocking(false);
                    client.register(selector, SelectionKey.OP_READ);
                    System.out.println("New client connected.");
                } else if (key.isReadable()) {
                    // Read data from client
                    SocketChannel client = (SocketChannel) key.channel();
                    ByteBuffer buffer = ByteBuffer.allocate(256);
                    int bytesRead = client.read(buffer);
                    if (bytesRead == -1) {
                        client.close();
                        System.out.println("Client disconnected.");
                    } else {
                        String msg = new String(buffer.array()).trim();
                        System.out.println("Received: " + msg);
                    }
                }

                // Remove processed key to avoid reprocessing
                iter.remove();
            }
        }
    }
}</code></pre>
</div><h3 id="explanation-of-the-code">Explanation of the Code:</h3><ul>
 <li>A <code>Selector</code> is created to monitor events.</li>
 <li>A <code>ServerSocketChannel</code> is configured for non-blocking mode and registered with the selector for <code>OP_ACCEPT</code>.</li>
 <li>In the event loop, <code>select()</code> blocks until one or more channels are ready.</li>
 <li><code>SelectionKey.isAcceptable()</code> detects new incoming connections.</li>
 <li><code>SelectionKey.isReadable()</code> handles incoming data from clients.</li>
 <li>Each client <code>SocketChannel</code> is also set to non-blocking mode and registered with the selector.</li>
</ul><h3 id="benefits-of-using-selectors">Benefits of Using Selectors</h3><ul>
 <li><strong>Scalability</strong>: A single thread can manage thousands of connections.</li>
 <li><strong>Efficiency</strong>: Reduces thread context switching and memory usage.</li>
 <li><strong>Flexibility</strong>: Fine-grained control over how IO is handled for each channel.</li>
 <li><strong>Asynchronous Behavior</strong>: Applications can perform other tasks while waiting for IO readiness.</li>
</ul><h3 id="summary">Summary</h3><ul>
 <li>A <strong>Selector</strong> allows a single thread to monitor multiple channels for IO readiness.</li>
 <li>Channels must be in <strong>non-blocking</strong> mode to work with selectors.</li>
 <li>Events like <code>OP_ACCEPT</code>, <code>OP_READ</code>, and <code>OP_WRITE</code> allow you to handle different types of IO operations.</li>
 <li><strong>SelectionKeys</strong> track the readiness and registration status of channels.</li>
 <li>This model is ideal for building <strong>high-performance servers</strong> such as chat apps, HTTP servers, proxies, or real-time data processors.</li>
</ul><p>Selectors enable event-driven IO models that are <strong>scalable</strong>, <strong>efficient</strong>, and <strong>well-suited</strong> for modern networked applications.</p><div class = "chapter-navi-section">
<a href="#top" class="nav-button prev">↑</a>
<a href='java-io-and-nio.htm#selectors-and-non-blocking-io' class="nav-button toc-link">Index</a>
<a href="#bottom" class="nav-button next">↓</a>
</div>
<h2 id='registering-channels-with-selectors'>7.2 Registering Channels with Selectors</h2><p>One of the most powerful features of Java NIO is its support for <strong>non-blocking IO</strong> using <strong>selectors</strong>. Selectors allow a single thread to manage multiple IO channels efficiently. To use this mechanism, channels must first be registered with a <code>Selector</code>. This section explains how registration works, the meaning of selection operations like <code>OP_READ</code> and <code>OP_WRITE</code>, and how to configure interest sets to monitor specific IO events.</p><h3 id="selectable-channels-in-java-nio">Selectable Channels in Java NIO</h3><p>Not all channels in Java NIO are selectable. Only those that implement the <code>SelectableChannel</code> interface can be registered with a <code>Selector</code>. The key channel types that support this include:</p><ul>
 <li><code>SocketChannel</code> – for client TCP connections.</li>
 <li><code>ServerSocketChannel</code> – for server-side listening sockets.</li>
 <li><code>DatagramChannel</code> – for UDP-based communication.</li>
 <li><code>Pipe.SourceChannel</code> and <code>Pipe.SinkChannel</code> – for inter-thread communication.</li>
</ul><p>All these channels must be configured to <strong>non-blocking mode</strong> before being registered with a selector.</p><h3 id="what-happens-during-registration">What Happens During Registration?</h3><p>When you register a channel with a selector, you’re asking the selector to watch that channel for specific events, such as when it's ready to read data or accept a new connection.</p><p>This is done using the channel’s <code>register()</code> method:</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-Java">SelectionKey key = channel.register(selector, ops);</code></pre>
</div><ul>
 <li><code>channel</code> – A <code>SelectableChannel</code> such as <code>SocketChannel</code>.</li>
 <li><code>selector</code> – The <code>Selector</code> instance that will monitor this channel.</li>
 <li><code>ops</code> – A set of interest operations (like <code>OP_READ</code> or <code>OP_WRITE</code>) the channel wants to be notified about.</li>
 <li><code>key</code> – A <code>SelectionKey</code> object representing this registration.</li>
</ul><h3 id="selection-operations-interest-ops">Selection Operations (Interest Ops)</h3><p>When registering a channel, you specify the <strong>interest set</strong> — a bitmask that tells the selector which operations to monitor on the channel.</p><p>The selection operations include:</p><table>
 <thead>
  <tr>
   <th>Constant</th>
   <th>Description</th>
  </tr>
 </thead>
 <tbody>
  <tr>
   <td><code>SelectionKey.OP_ACCEPT</code></td>
   <td>Channel is ready to accept a new connection (for <code>ServerSocketChannel</code>)</td>
  </tr>
  <tr>
   <td><code>SelectionKey.OP_CONNECT</code></td>
   <td>Channel has completed connection process (for <code>SocketChannel</code>)</td>
  </tr>
  <tr>
   <td><code>SelectionKey.OP_READ</code></td>
   <td>Channel is ready for reading data</td>
  </tr>
  <tr>
   <td><code>SelectionKey.OP_WRITE</code></td>
   <td>Channel is ready for writing data</td>
  </tr>
 </tbody>
</table><p>These constants are bit flags and can be <strong>combined</strong> using the bitwise OR (<code>|</code>) operator.</p><p>Example:</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-Java">int ops = SelectionKey.OP_READ | SelectionKey.OP_WRITE;
channel.register(selector, ops);</code></pre>
</div><p>This tells the selector to notify us when the channel is either ready to read <strong>or</strong> write.</p><h3 id="configuring-a-channel-and-registering-with-a-selector">Configuring a Channel and Registering with a Selector</h3><p>Before registration, the channel <strong>must</strong> be configured as <strong>non-blocking</strong>:</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-Java">SocketChannel socketChannel = SocketChannel.open();
socketChannel.configureBlocking(false);</code></pre>
</div><p>Then it can be registered:</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-Java">Selector selector = Selector.open();
socketChannel.register(selector, SelectionKey.OP_CONNECT);</code></pre>
</div><h3 id="code-example-registering-multiple-channels">Code Example: Registering Multiple Channels</h3><p>Here’s a complete example showing how to register <code>ServerSocketChannel</code> and accept incoming connections, then register each new <code>SocketChannel</code> for reading:</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-java">import java.io.IOException;
import java.net.InetSocketAddress;
import java.nio.ByteBuffer;
import java.nio.channels.*;
import java.util.Iterator;
import java.util.Set;

public class ChannelRegistrationExample {
    public static void main(String[] args) throws IOException {
        // Step 1: Create a selector
        Selector selector = Selector.open();

        // Step 2: Create a non-blocking ServerSocketChannel
        ServerSocketChannel serverChannel = ServerSocketChannel.open();
        serverChannel.bind(new InetSocketAddress(4000));
        serverChannel.configureBlocking(false);

        // Step 3: Register server channel with selector for ACCEPT operation
        serverChannel.register(selector, SelectionKey.OP_ACCEPT);

        System.out.println("Server listening on port 4000...");

        // Step 4: Event loop
        while (true) {
            selector.select(); // Block until at least one channel is ready

            Set&lt;SelectionKey&gt; selectedKeys = selector.selectedKeys();
            Iterator&lt;SelectionKey&gt; iter = selectedKeys.iterator();

            while (iter.hasNext()) {
                SelectionKey key = iter.next();

                if (key.isAcceptable()) {
                    // Accept connection
                    ServerSocketChannel server = (ServerSocketChannel) key.channel();
                    SocketChannel client = server.accept();
                    client.configureBlocking(false);

                    // Register client for READ operation
                    client.register(selector, SelectionKey.OP_READ);
                    System.out.println("Accepted new client connection.");
                } else if (key.isReadable()) {
                    // Read data from client
                    SocketChannel client = (SocketChannel) key.channel();
                    ByteBuffer buffer = ByteBuffer.allocate(256);
                    int bytesRead = client.read(buffer);

                    if (bytesRead == -1) {
                        client.close(); // Client closed connection
                        System.out.println("Client disconnected.");
                    } else {
                        buffer.flip();
                        byte[] data = new byte[buffer.remaining()];
                        buffer.get(data);
                        System.out.println("Received: " + new String(data));
                    }
                }

                iter.remove(); // Remove processed key
            }
        }
    }
}</code></pre>
</div><h3 id="explanation-of-the-code">Explanation of the Code</h3><ul>
 <li><strong>ServerSocketChannel</strong> is registered for <code>OP_ACCEPT</code>, allowing the selector to notify when a client attempts to connect.</li>
 <li>On accepting a connection, the <strong>SocketChannel</strong> is configured to non-blocking mode and registered with the selector for <code>OP_READ</code>.</li>
 <li>The selector monitors both the server and client channels, dispatching events accordingly.</li>
 <li>Only one thread handles all the connections efficiently.</li>
</ul><h3 id="the-selectionkey-object">The SelectionKey Object</h3><p>When a channel is registered, a <code>SelectionKey</code> is returned. This object provides:</p><ul>
 <li><code>channel()</code> – The registered channel.</li>
 <li><code>selector()</code> – The selector managing the key.</li>
 <li><code>interestOps()</code> – The set of operations the key is interested in.</li>
 <li><code>readyOps()</code> – The set of operations the channel is ready for.</li>
</ul><p>You can also <strong>attach objects</strong> to the key (e.g., buffers or session info):</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-Java">SelectionKey key = clientChannel.register(selector, SelectionKey.OP_READ);
key.attach(ByteBuffer.allocate(1024));</code></pre>
</div><p>Later, you can retrieve the attachment:</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-Java">ByteBuffer buffer = (ByteBuffer) key.attachment();</code></pre>
</div><h3 id="summary">Summary</h3><ul>
 <li>Channels must be in <strong>non-blocking</strong> mode to register with a <code>Selector</code>.</li>
 <li>The <strong><code>register()</code></strong> method binds a channel to a selector with a specified interest set (<code>OP_READ</code>, <code>OP_WRITE</code>, etc.).</li>
 <li>You can register <strong>multiple channels</strong> with one selector to efficiently manage multiple IO operations.</li>
 <li><strong><code>SelectionKey</code></strong> represents each registration and provides APIs to inspect readiness and attach metadata.</li>
</ul><p>Using selectors and channel registration together forms the backbone of scalable, non-blocking network servers in Java.</p><div class = "chapter-navi-section">
<a href="#top" class="nav-button prev">↑</a>
<a href='java-io-and-nio.htm#selectors-and-non-blocking-io' class="nav-button toc-link">Index</a>
<a href="#bottom" class="nav-button next">↓</a>
</div>
<h2 id='handling-selectionkeys-and-events'>7.3 Handling SelectionKeys and Events</h2><p>In Java NIO’s non-blocking IO system, the <code>Selector</code> class works closely with the <code>SelectionKey</code> class to monitor and handle IO readiness events across multiple channels. Understanding how to work with <code>SelectionKey</code> objects is essential for building efficient and scalable applications.</p><p>This section explores what <code>SelectionKey</code> represents, the types of events it tracks, and how to process these keys during event-driven IO operations.</p><h3 id="what-is-a-selectionkey">What is a <code>SelectionKey</code>?</h3><p>A <code>SelectionKey</code> represents the registration of a <strong>channel</strong> with a <strong>selector</strong>. It is created when a <code>SelectableChannel</code> (such as a <code>SocketChannel</code>) is registered to a <code>Selector</code> using the <code>register()</code> method:</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-Java">SelectionKey key = channel.register(selector, SelectionKey.OP_READ);</code></pre>
</div><p>This key maintains information about:</p><ul>
 <li>The <strong>channel</strong> it is associated with</li>
 <li>The <strong>selector</strong> managing it</li>
 <li>The <strong>interest set</strong> (what events the application is interested in)</li>
 <li>The <strong>ready set</strong> (what events the channel is ready for)</li>
 <li>Optional <strong>attachment</strong> (a user-defined object for tracking context)</li>
</ul><h3 id="selection-operations-event-types">Selection Operations (Event Types)</h3><p>The <code>SelectionKey</code> class defines four constants representing IO readiness events:</p><table>
 <thead>
  <tr>
   <th>Constant</th>
   <th>Meaning</th>
  </tr>
 </thead>
 <tbody>
  <tr>
   <td><code>OP_ACCEPT</code></td>
   <td>Ready to accept a new incoming connection (server socket)</td>
  </tr>
  <tr>
   <td><code>OP_CONNECT</code></td>
   <td>A non-blocking connection has finished establishing</td>
  </tr>
  <tr>
   <td><code>OP_READ</code></td>
   <td>Channel has data available to read</td>
  </tr>
  <tr>
   <td><code>OP_WRITE</code></td>
   <td>Channel is ready to accept data for writing</td>
  </tr>
 </tbody>
</table><p>These are referred to as <strong>interest ops</strong> when registering the channel and as <strong>ready ops</strong> when the event has occurred.</p><h3 id="inspecting-and-handling-events">Inspecting and Handling Events</h3><p>Once the <code>Selector.select()</code> method is called and returns, the <code>selectedKeys()</code> method gives you the set of keys for channels that are ready.</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-Java">Set&lt;SelectionKey&gt; selectedKeys = selector.selectedKeys();
Iterator&lt;SelectionKey&gt; iterator = selectedKeys.iterator();</code></pre>
</div><p>You loop through this set to handle events:</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-Java">while (iterator.hasNext()) {
    SelectionKey key = iterator.next();

    if (key.isAcceptable()) {
        // Handle new connection
    } else if (key.isConnectable()) {
        // Handle client connection finish
    } else if (key.isReadable()) {
        // Handle read from client
    } else if (key.isWritable()) {
        // Handle write to client
    }

    iterator.remove(); // Important: remove the processed key
}</code></pre>
</div><h3 id="example-full-event-handling-logic">Example: Full Event Handling Logic</h3><p>Here’s a complete code example of a simple server handling accept and read events using <code>SelectionKey</code>.</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-java">import java.io.IOException;
import java.net.InetSocketAddress;
import java.nio.ByteBuffer;
import java.nio.channels.*;
import java.util.Iterator;
import java.util.Set;

public class SelectionKeyExample {
    public static void main(String[] args) throws IOException {
        Selector selector = Selector.open();

        // Create server channel and register for accept
        ServerSocketChannel serverChannel = ServerSocketChannel.open();
        serverChannel.bind(new InetSocketAddress(5000));
        serverChannel.configureBlocking(false);
        serverChannel.register(selector, SelectionKey.OP_ACCEPT);
        System.out.println("Server started on port 5000.");

        while (true) {
            selector.select(); // Wait for events
            Set&lt;SelectionKey&gt; selectedKeys = selector.selectedKeys();
            Iterator&lt;SelectionKey&gt; iter = selectedKeys.iterator();

            while (iter.hasNext()) {
                SelectionKey key = iter.next();

                if (key.isAcceptable()) {
                    ServerSocketChannel server = (ServerSocketChannel) key.channel();
                    SocketChannel client = server.accept();
                    client.configureBlocking(false);
                    client.register(selector, SelectionKey.OP_READ);
                    System.out.println("Accepted new client.");
                }

                else if (key.isReadable()) {
                    SocketChannel client = (SocketChannel) key.channel();
                    ByteBuffer buffer = ByteBuffer.allocate(256);
                    int bytesRead = client.read(buffer);

                    if (bytesRead == -1) {
                        client.close();
                        System.out.println("Client disconnected.");
                    } else {
                        buffer.flip();
                        byte[] data = new byte[buffer.remaining()];
                        buffer.get(data);
                        System.out.println("Received: " + new String(data));
                    }
                }

                iter.remove(); // Important to avoid reprocessing
            }
        }
    }
}</code></pre>
</div><h3 id="attaching-context-with-selectionkey">Attaching Context with <code>SelectionKey</code></h3><p>You can store additional context (such as a buffer or session object) using the <code>attach()</code> method when registering the channel:</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-Java">SelectionKey key = clientChannel.register(selector, SelectionKey.OP_READ);
key.attach(ByteBuffer.allocate(1024)); // Attach a buffer</code></pre>
</div><p>Later, you can retrieve it during event handling:</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-Java">ByteBuffer buffer = (ByteBuffer) key.attachment();</code></pre>
</div><p>This approach is useful when each client needs its own data buffer or state tracker.</p><h3 id="best-practices-for-using-selectionkey">Best Practices for Using <code>SelectionKey</code></h3><ul>
 <li><strong>Always remove keys after processing</strong> using <code>iterator.remove()</code> to avoid handling them again.</li>
 <li><strong>Use attachments</strong> to store per-channel data such as buffers or user sessions.</li>
 <li><strong>Check for multiple readiness states</strong>: A key may be ready for more than one operation at a time. Always use <code>if-else</code> or <code>switch</code> to check each.</li>
 <li><strong>Gracefully handle closed connections</strong>: When <code>read()</code> returns <code>-1</code>, it means the client has disconnected. Always close the channel.</li>
</ul><h3 id="summary">Summary</h3><ul>
 <li><code>SelectionKey</code> objects represent the link between a channel and a selector.</li>
 <li>They track what events the channel is interested in and what it is currently ready for.</li>
 <li>You retrieve and process these keys from the <code>Selector</code> using <code>selectedKeys()</code>.</li>
 <li>Events like <code>OP_ACCEPT</code>, <code>OP_READ</code>, and <code>OP_WRITE</code> allow efficient, event-driven IO.</li>
 <li>You can attach custom objects to a key to manage per-channel context.</li>
 <li>Proper handling of <code>SelectionKey</code> objects is essential for building scalable non-blocking servers.</li>
</ul><p>By mastering how to work with <code>SelectionKey</code>, you unlock the full power of Java NIO selectors and can build high-performance applications with minimal thread usage.</p><div class = "chapter-navi-section">
<a href="#top" class="nav-button prev">↑</a>
<a href='java-io-and-nio.htm#selectors-and-non-blocking-io' class="nav-button toc-link">Index</a>
<a href="#bottom" class="nav-button next">↓</a>
</div>
<h2 id='building-a-simple-non-blocking-server'>7.4 Building a Simple Non-blocking Server</h2><p>In this tutorial, we'll build a <strong>simple non-blocking TCP server</strong> that:</p><ul>
 <li>Listens for client connections</li>
 <li>Reads messages from connected clients</li>
 <li>Echoes messages back to them (echo server)</li>
 <li>Handles multiple clients using <strong>one thread</strong></li>
</ul><h3 id="step-1-imports-and-setup">Step 1: Imports and Setup</h3><p>We’ll begin by importing the necessary Java NIO classes:</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-Java">import java.io.IOException;
import java.net.InetSocketAddress;
import java.nio.ByteBuffer;
import java.nio.channels.*;
import java.util.Iterator;
import java.util.Set;</code></pre>
</div><h3 id="step-2-create-and-configure-the-server">Step 2: Create and Configure the Server</h3><p>We need a <code>ServerSocketChannel</code> and a <code>Selector</code>. The server channel must be non-blocking and registered with the selector to watch for <strong>OP_ACCEPT</strong> events (ready to accept new connections).</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-Java">public class NonBlockingTCPServer {
    public static void main(String[] args) {
        try {
            // 1. Open a selector
            Selector selector = Selector.open();

            // 2. Open a server socket channel
            ServerSocketChannel serverChannel = ServerSocketChannel.open();
            serverChannel.bind(new InetSocketAddress(5000));
            serverChannel.configureBlocking(false); // Non-blocking mode

            // 3. Register the server channel with selector for ACCEPT operations
            serverChannel.register(selector, SelectionKey.OP_ACCEPT);
            System.out.println("Server listening on port 5000...");

            // 4. Event loop
            while (true) {
                selector.select(); // Blocking call - waits for events

                // 5. Get the set of keys representing ready channels
                Set&lt;SelectionKey&gt; selectedKeys = selector.selectedKeys();
                Iterator&lt;SelectionKey&gt; iterator = selectedKeys.iterator();

                while (iterator.hasNext()) {
                    SelectionKey key = iterator.next();

                    // 6. Acceptable event (new client connection)
                    if (key.isAcceptable()) {
                        handleAccept(key, selector);
                    }

                    // 7. Readable event (client sent data)
                    else if (key.isReadable()) {
                        handleRead(key);
                    }

                    // Remove the key from the set to avoid processing again
                    iterator.remove();
                }
            }

        } catch (IOException e) {
            e.printStackTrace();
        }
    }</code></pre>
</div><h3 id="step-3-handle-new-client-connections">Step 3: Handle New Client Connections</h3><p>When a client attempts to connect, the server channel becomes “acceptable”. We then accept the connection and register the new client channel for <strong>OP_READ</strong> (read readiness).</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-Java">private static void handleAccept(SelectionKey key, Selector selector) throws IOException {
        ServerSocketChannel serverChannel = (ServerSocketChannel) key.channel();
        SocketChannel clientChannel = serverChannel.accept(); // Accept client
        clientChannel.configureBlocking(false);

        // Register client channel for READ events
        clientChannel.register(selector, SelectionKey.OP_READ);

        System.out.println("New client connected from " + clientChannel.getRemoteAddress());
    }</code></pre>
</div><h3 id="step-4-handle-incoming-data">Step 4: Handle Incoming Data</h3><p>When a client sends data, the channel becomes “readable”. We read the data from the channel using a <code>ByteBuffer</code>, and in this example, we <strong>echo</strong> the data back to the client.</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-Java">private static void handleRead(SelectionKey key) throws IOException {
        SocketChannel clientChannel = (SocketChannel) key.channel();
        ByteBuffer buffer = ByteBuffer.allocate(1024);
        int bytesRead = -1;

        try {
            bytesRead = clientChannel.read(buffer);
        } catch (IOException e) {
            System.out.println("Client forcibly closed the connection.");
            clientChannel.close();
            key.cancel();
            return;
        }

        if (bytesRead == -1) {
            // Client closed the connection cleanly
            System.out.println("Client disconnected.");
            clientChannel.close();
            key.cancel();
            return;
        }

        // Echo back the received message
        buffer.flip(); // Prepare buffer for reading
        String received = new String(buffer.array(), 0, buffer.limit());
        System.out.println("Received: " + received.trim());

        // Echo it back
        clientChannel.write(buffer); // Buffer still in read mode
    }
}</code></pre>
</div><div class="snippet-container" id="I5wI5">
 <div class="snippet-header" onclick="toggleSnippet('I5wI5')">
  Click to view full runnable Code
 </div>
 <div class="snippet-body">
  <div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
   <pre><code class="language-java">
import java.io.IOException;
import java.net.InetSocketAddress;
import java.nio.ByteBuffer;
import java.nio.channels.*;
import java.util.Iterator;
import java.util.Set;

public class NonBlockingTCPServer {
    public static void main(String[] args) {
        try {
            // 1. Open a selector
            Selector selector = Selector.open();

            // 2. Open a server socket channel
            ServerSocketChannel serverChannel = ServerSocketChannel.open();
            serverChannel.bind(new InetSocketAddress(5000));
            serverChannel.configureBlocking(false); // Non-blocking mode

            // 3. Register the server channel with selector for ACCEPT operations
            serverChannel.register(selector, SelectionKey.OP_ACCEPT);
            System.out.println("Server listening on port 5000...");

            // 4. Event loop
            while (true) {
                selector.select(); // Blocking call - waits for events

                Set&lt;SelectionKey&gt; selectedKeys = selector.selectedKeys();
                Iterator&lt;SelectionKey&gt; iterator = selectedKeys.iterator();

                while (iterator.hasNext()) {
                    SelectionKey key = iterator.next();

                    if (key.isAcceptable()) {
                        handleAccept(key, selector);
                    } else if (key.isReadable()) {
                        handleRead(key);
                    }

                    iterator.remove(); // Prevent processing the same key again
                }
            }

        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private static void handleAccept(SelectionKey key, Selector selector) throws IOException {
        ServerSocketChannel serverChannel = (ServerSocketChannel) key.channel();
        SocketChannel clientChannel = serverChannel.accept();
        clientChannel.configureBlocking(false);
        clientChannel.register(selector, SelectionKey.OP_READ);
        System.out.println("New client connected from " + clientChannel.getRemoteAddress());
    }

    private static void handleRead(SelectionKey key) throws IOException {
        SocketChannel clientChannel = (SocketChannel) key.channel();
        ByteBuffer buffer = ByteBuffer.allocate(1024);
        int bytesRead;

        try {
            bytesRead = clientChannel.read(buffer);
        } catch (IOException e) {
            System.out.println("Client forcibly closed the connection.");
            clientChannel.close();
            key.cancel();
            return;
        }

        if (bytesRead == -1) {
            System.out.println("Client disconnected.");
            clientChannel.close();
            key.cancel();
            return;
        }

        buffer.flip();
        String received = new String(buffer.array(), 0, buffer.limit());
        System.out.println("Received: " + received.trim());

        clientChannel.write(buffer); // Echo back
    }
} 
</code></pre>
  </div>
 </div>
</div><h3 id="how-it-works">How It Works</h3><ul>
 <li>The <strong>selector</strong> waits for channels to become ready.</li>
 <li>When a channel is <strong>ready to accept</strong>, we accept the connection and register the new socket.</li>
 <li>When a client sends data, the channel becomes <strong>readable</strong>, and we read the message.</li>
 <li>After reading, we <strong>write it back</strong>, effectively creating an echo server.</li>
</ul><h3 id="testing-the-server">Testing the Server</h3><p>You can test the server using multiple <code>telnet</code> sessions:</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-bash">telnet localhost 5000</code></pre>
</div><p>Type a message and press Enter. The server will echo the message back to you.</p><h3 id="benefits-of-non-blocking-nio">Benefits of Non-blocking NIO</h3><ul>
 <li><strong>Single thread handles many connections</strong>: Unlike traditional blocking IO, we don’t need one thread per connection.</li>
 <li><strong>Low memory and CPU usage</strong>: Threads are expensive. Fewer threads = less overhead.</li>
 <li><strong>Highly scalable</strong>: Ideal for chat servers, proxies, and real-time apps.</li>
</ul><h3 id="limitations-and-enhancements">Limitations and Enhancements</h3><p>This server is a good starting point, but there are areas for improvement:</p><ul>
 <li>Add write buffering and support for partial writes.</li>
 <li>Add a command protocol for structured communication.</li>
 <li>Use attachments (<code>SelectionKey.attach()</code>) to store session state.</li>
 <li>Support concurrent reads/writes using a thread pool for intensive tasks.</li>
</ul><h3 id="summary">Summary</h3><p>In this tutorial, you’ve learned how to:</p><ul>
 <li>Set up a <strong>non-blocking TCP server</strong> using Java NIO</li>
 <li>Use a <strong>Selector</strong> to handle multiple client connections in one thread</li>
 <li>Respond to <strong>OP_ACCEPT</strong> and <strong>OP_READ</strong> events</li>
 <li>Echo data back to clients efficiently</li>
</ul><p>Java NIO selectors are a powerful tool for building scalable network applications. With just a bit more work, this basic server can evolve into a production-grade framework.</p><div class = "chapter-navi-section">
<a href="#top" class="nav-button prev">↑</a>
<a href='java-io-and-nio.htm#selectors-and-non-blocking-io' class="nav-button toc-link">Index</a>
<a href="#bottom" class="nav-button next">↓</a>
</div>
<h2 id='performance-considerations'>7.5 Performance Considerations</h2><p>Java NIO's selector-based non-blocking IO model is designed for high performance and scalability. Unlike traditional IO, which dedicates a thread per connection, NIO allows a <strong>single thread</strong> to handle <strong>thousands of connections</strong> by multiplexing readiness events across channels. While this design provides significant performance benefits, achieving optimal efficiency requires careful attention to several areas: <strong>threading, resource management, event handling</strong>, and <strong>common pitfalls</strong>.</p><p>In this section, we’ll explore these performance considerations in depth and provide actionable best practices for optimizing selector-based applications.</p><h3 id="scalability-through-fewer-threads">Scalability Through Fewer Threads</h3><p>A primary advantage of non-blocking IO is the ability to support <strong>many concurrent connections</strong> using <strong>a small number of threads</strong>. Since a selector can monitor thousands of channels, the server can scale horizontally without spawning a thread per client.</p><p><strong>Why It Matters:</strong></p><ul>
 <li>Traditional blocking IO uses one thread per connection, which doesn’t scale well under heavy load.</li>
 <li>Each thread consumes memory (stack space) and CPU time for context switching.</li>
 <li>NIO avoids these costs by handling IO events only when data is ready.</li>
</ul><p><strong>Best Practice:</strong></p><ul>
 <li>Use a single <strong>Selector thread</strong> to handle network IO.</li>
 <li>Offload CPU-intensive or blocking operations (like database access) to a <strong>separate thread pool</strong>.</li>
</ul><h3 id="thread-management-and-design-patterns">Thread Management and Design Patterns</h3><p>To avoid performance bottlenecks, organize your application into logical thread roles:</p><ul>
 <li><strong>Selector Thread</strong>: Handles accept/read/write events and dispatches them.</li>
 <li><strong>Worker Threads</strong>: Process data, execute business logic, or perform blocking tasks.</li>
</ul><p>This pattern ensures the selector loop remains responsive and doesn't block on operations like disk IO or long-running tasks.</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-text">[Selector Thread] → [Worker Pool] → [Processing Logic]</code></pre>
</div><p><strong>Best Practice:</strong></p><ul>
 <li>Keep the selector thread fast and non-blocking.</li>
 <li>Use <code>ExecutorService</code> to manage a pool of workers for background processing.</li>
</ul><h3 id="minimizing-memory-allocation-and-garbage-collection">Minimizing Memory Allocation and Garbage Collection</h3><p>Non-blocking servers can experience <strong>frequent memory allocation</strong> from buffers and temporary objects, which leads to <strong>garbage collection (GC)</strong> pressure. GC pauses can introduce latency and jitter.</p><p><strong>Tips to reduce GC overhead:</strong></p><ul>
 <li><strong>Reuse <code>ByteBuffer</code> objects</strong>: Allocate buffers once and reuse them per connection.</li>
 <li><strong>Use attachments on <code>SelectionKey</code></strong> to store buffer and session objects.</li>
 <li>Avoid per-request object creation in the selector loop.</li>
</ul><p><strong>Example:</strong></p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-Java">ByteBuffer buffer = ByteBuffer.allocate(1024);
key.attach(buffer); // Reuse per client</code></pre>
</div><h3 id="efficient-buffer-and-channel-management">Efficient Buffer and Channel Management</h3><p>Efficient use of <code>ByteBuffer</code> is critical for performance. Understand buffer methods like <code>clear()</code>, <code>flip()</code>, <code>compact()</code> to avoid redundant copying or unnecessary allocations.</p><p><strong>Best Practice:</strong></p><ul>
 <li>Use <strong>direct buffers</strong> (<code>ByteBuffer.allocateDirect()</code>) for large or long-lived buffers.</li>
 <li>Use <strong>heap buffers</strong> (<code>ByteBuffer.allocate()</code>) for short-lived or small objects where GC is negligible.</li>
</ul><p><strong>Caution:</strong> Direct buffers avoid heap GC but are more expensive to allocate and harder to monitor. Use them judiciously.</p><h3 id="selector-wakeup-overhead">Selector Wakeup Overhead</h3><p>A common pitfall is <strong>unnecessary wakeups</strong> of the selector, which can degrade performance, especially under high load.</p><p><strong>Avoid:</strong></p><ul>
 <li>Calling <code>selector.wakeup()</code> too frequently.</li>
 <li>Waking the selector from multiple threads unless absolutely required.</li>
</ul><p><strong>Best Practice:</strong></p><ul>
 <li>Use a <strong>single-threaded event loop</strong> when possible.</li>
 <li>When you need to register channels from other threads, use a <strong>task queue</strong> and call <code>wakeup()</code> only when needed.</li>
</ul><h3 id="handling-write-readiness-properly">Handling Write Readiness Properly</h3><p>Another common pitfall is treating <code>OP_WRITE</code> like <code>OP_READ</code>. Unlike read events, <strong>write events are always ready</strong> unless the buffer is full. Constantly registering for write events can cause busy loops and CPU spikes.</p><p><strong>Best Practice:</strong></p><ul>
 <li>Only register <code>OP_WRITE</code> when you have actual data to write.</li>
 <li>Remove <code>OP_WRITE</code> interest once all data is written.</li>
</ul><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-Java">if (buffer.hasRemaining()) {
    key.interestOps(key.interestOps() | SelectionKey.OP_WRITE);
} else {
    key.interestOps(key.interestOps() &amp; ~SelectionKey.OP_WRITE);
}</code></pre>
</div><h3 id="avoid-blocking-operations-in-event-loop">Avoid Blocking Operations in Event Loop</h3><p>Blocking the selector thread (e.g., by reading from disk, calling <code>Thread.sleep()</code>, or synchronizing on shared objects) severely reduces responsiveness.</p><p><strong>Best Practice:</strong></p><ul>
 <li>Offload slow or blocking operations to a <strong>dedicated thread pool</strong>.</li>
 <li>Never call blocking methods like <code>readLine()</code> or database queries in the selector thread.</li>
</ul><h3 id="monitoring-and-profiling">Monitoring and Profiling</h3><p>To tune performance, you must <strong>observe your application</strong> under load:</p><ul>
 <li>Use profilers (VisualVM, JFR) to track GC, thread usage, and heap allocations.</li>
 <li>Log channel lifecycle events (connect, read, write, disconnect) for debugging.</li>
 <li>Instrument IO throughput and latency.</li>
</ul><h3 id="use-selectors-correctly">Use Selectors Correctly</h3><p>NIO selectors are powerful but fragile. Misuse can lead to <strong>stale keys</strong>, <strong>dropped connections</strong>, or <strong>busy spinning</strong>.</p><p><strong>Common Issues:</strong></p><ul>
 <li>Not calling <code>iterator.remove()</code> causes keys to be reprocessed.</li>
 <li>Not handling <code>IOException</code> can leave channels in an inconsistent state.</li>
 <li>Forgetting to close channels leads to resource leaks.</li>
</ul><p><strong>Best Practice:</strong></p><ul>
 <li>Always <code>remove()</code> keys after processing.</li>
 <li>Properly close and cancel keys on error.</li>
 <li>Use try-catch around all IO operations.</li>
</ul><h3 id="summary">Summary</h3><p>Using selectors and non-blocking IO in Java NIO can yield high-performance, scalable servers when used correctly. Key takeaways include:</p><ul>
 <li>Use minimal threads with clear roles.</li>
 <li>Reuse buffers and avoid memory churn.</li>
 <li>Register <code>OP_WRITE</code> only when needed.</li>
 <li>Keep selector threads free of blocking calls.</li>
 <li>Profile and monitor your server to find bottlenecks.</li>
</ul><p>By adhering to these practices, you can build NIO-based applications that serve thousands of clients efficiently while minimizing CPU, memory, and thread usage.</p><p>Below is a <strong>complete example of a multi-threaded non-blocking TCP server</strong> using Java NIO with:</p><ul>
 <li>A <strong>single selector thread</strong> (for accepting and reading client connections)</li>
 <li>A <strong>worker thread pool</strong> (for offloading business logic)</li>
 <li><strong>ByteBuffer reuse via SelectionKey attachments</strong></li>
 <li><strong>Proper handling of <code>OP_WRITE</code> readiness</strong></li>
 <li><strong>Thread-safe task submission using a queue</strong></li>
</ul><h3 id="features-demonstrated">Features Demonstrated</h3><ul>
 <li>Non-blocking server with <code>Selector</code></li>
 <li><code>ExecutorService</code> for background processing</li>
 <li>Channel registration from multiple threads using <code>Selector.wakeup()</code></li>
 <li>Efficient buffer reuse and write registration logic</li>
</ul><h3 id="full-java-example">Full Java Example</h3><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-java">import java.io.IOException;
import java.net.InetSocketAddress;
import java.nio.ByteBuffer;
import java.nio.channels.*;
import java.util.Iterator;
import java.util.Set;
import java.util.concurrent.*;

public class MultiThreadedNIOServer {
    private static final int PORT = 5000;
    private static final int BUFFER_SIZE = 1024;

    private final Selector selector;
    private final ServerSocketChannel serverChannel;
    private final ExecutorService workerPool;
    private final ConcurrentLinkedQueue&lt;Runnable&gt; pendingTasks;

    public MultiThreadedNIOServer() throws IOException {
        this.selector = Selector.open();
        this.serverChannel = ServerSocketChannel.open();
        this.workerPool = Executors.newFixedThreadPool(4); // Worker thread pool
        this.pendingTasks = new ConcurrentLinkedQueue&lt;&gt;();

        serverChannel.bind(new InetSocketAddress(PORT));
        serverChannel.configureBlocking(false);
        serverChannel.register(selector, SelectionKey.OP_ACCEPT);
    }

    public void start() throws IOException {
        System.out.println("Server started on port " + PORT);

        while (true) {
            // Execute any tasks added from other threads
            Runnable task;
            while ((task = pendingTasks.poll()) != null) {
                task.run();
            }

            selector.select();

            Set&lt;SelectionKey&gt; selectedKeys = selector.selectedKeys();
            Iterator&lt;SelectionKey&gt; iter = selectedKeys.iterator();

            while (iter.hasNext()) {
                SelectionKey key = iter.next();

                try {
                    if (key.isAcceptable()) {
                        handleAccept(key);
                    } else if (key.isReadable()) {
                        handleRead(key);
                    } else if (key.isWritable()) {
                        handleWrite(key);
                    }
                } catch (IOException e) {
                    System.err.println("Closing broken connection: " + e.getMessage());
                    closeKey(key);
                }

                iter.remove();
            }
        }
    }

    private void handleAccept(SelectionKey key) throws IOException {
        ServerSocketChannel server = (ServerSocketChannel) key.channel();
        SocketChannel client = server.accept();
        client.configureBlocking(false);

        // Attach a buffer for each client connection
        ByteBuffer buffer = ByteBuffer.allocate(BUFFER_SIZE);
        client.register(selector, SelectionKey.OP_READ, buffer);

        System.out.println("Accepted connection from " + client.getRemoteAddress());
    }

    private void handleRead(SelectionKey key) throws IOException {
        SocketChannel client = (SocketChannel) key.channel();
        ByteBuffer buffer = (ByteBuffer) key.attachment();

        int bytesRead = client.read(buffer);

        if (bytesRead == -1) {
            closeKey(key);
            return;
        }

        buffer.flip();
        byte[] data = new byte[buffer.limit()];
        buffer.get(data);
        buffer.clear(); // Ready for next read

        String message = new String(data).trim();
        System.out.println("Received: " + message);

        // Offload processing to worker pool
        workerPool.submit(() -&gt; {
            String response = "[Echo] " + message;
            ByteBuffer responseBuffer = ByteBuffer.wrap(response.getBytes());

            // Schedule write back in selector thread
            scheduleTask(() -&gt; {
                key.attach(responseBuffer);
                key.interestOps(SelectionKey.OP_WRITE);
                selector.wakeup(); // Ensure selector notices change
            });
        });
    }

    private void handleWrite(SelectionKey key) throws IOException {
        SocketChannel client = (SocketChannel) key.channel();
        ByteBuffer buffer = (ByteBuffer) key.attachment();

        client.write(buffer);
        if (!buffer.hasRemaining()) {
            // Done writing; switch back to read
            ByteBuffer readBuffer = ByteBuffer.allocate(BUFFER_SIZE);
            key.attach(readBuffer);
            key.interestOps(SelectionKey.OP_READ);
        }
    }

    private void scheduleTask(Runnable task) {
        pendingTasks.add(task);
        selector.wakeup(); // Wake up selector to execute task
    }

    private void closeKey(SelectionKey key) {
        try {
            key.channel().close();
        } catch (IOException ignored) {}
        key.cancel();
    }

    public static void main(String[] args) throws IOException {
        new MultiThreadedNIOServer().start();
    }
}</code></pre>
</div><h3 id="how-this-works">How This Works</h3><ul>
 <li><strong>Selector Thread</strong>: Accepts new clients and handles IO readiness events (<code>OP_READ</code>, <code>OP_WRITE</code>)</li>
 <li><strong>Worker Pool</strong>: Handles processing of messages outside the selector thread</li>
 <li><strong>Attachments</strong>: Each channel carries its own buffer, reused for read/write</li>
 <li><strong>Selector Wakeup</strong>: Ensures safe registration and state changes from other threads</li>
 <li><strong>Pending Task Queue</strong>: Thread-safe way to modify selector state from workers</li>
</ul><h3 id="test-the-server">Test the Server</h3><p>Open multiple terminal tabs and run:</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-bash">telnet localhost 5000</code></pre>
</div><p>Each message sent will be echoed back with <code>[Echo]</code> prefix.</p><h3 id="best-practices-applied">Best Practices Applied</h3><ul>
 <li>One thread handles thousands of connections (selector thread)</li>
 <li>Worker threads only process logic, keeping selector responsive</li>
 <li>Buffer reuse via attachments reduces GC pressure</li>
 <li>Selector wakeup ensures thread-safe channel updates</li>
</ul><div class = "chapter-navi-section">
<a href="java-io-and-nio-buffers-and-channels.htm" class="nav-button prev">←</a>
<a href='java-io-and-nio.htm#selectors-and-non-blocking-io' class="nav-button toc-link">Index</a>
<a href="java-io-and-nio-asynchronous-io.htm" class="nav-button next">→</a>
</div>
<section class="download-section">
  <div class="book-cover" style="background-color: #f9f6f1;border: 1px solid #ccc;"> 
    <div class="book-cover-title" style="font-size: 18px;color: #333;top: 20px;">Java IO and NIO</div>
    <div class="book-cover-author">readbytes</div>
    <div class="book-cover-bottom-stripe" style="background-color: #333;"></div>
    <img class="book-cover-icon" style="width: 80px;height: 90px;top: 60px;" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFoAAABaCAYAAAA4qEECAAADAElEQVR4Xu2Zu6oTURSGjze0UfANtLAUzgOI4DOItc+VKk1uJ12aadNa21vbCpYK4wQmcPiYzL5k7eXM2f8HP0JYa/3ZX2PEmxshxAPi7u6uLRH2VA3lWId9VdK27WOKsQ47q6RpmucUYx12VolEOyHRToyJ5mwI7ufeeZBItBMS7YREOyHRTki0ExLthEQ7IdFOSLQTEu2ERDsxJtoq7KwSiXZCop04Ho9PKcY67KwWirEO+6qGcqzCHhGBJDoh0U5ItAP7/f6bRDtAyV3+ckYYQNHr9fo1Z8SVtG37iKI5Mzv4IKuwJwXeuvbef4ePsQ77YuGdLp85MysGHmQa9sXAG7l3JgUfZB32heh+0t3yRvfZD87NDj7KOuwLwf2cG5OEj7IO+8bg7imr1eoV55Lh0VC4bwE7cru4n3Jns9l85d7YPmdCSV8oADtyu7gfe4fzMbucCyV9oQDsyO3i/tid7i+395xjuHMfzoaSvlAAduR2cf/+ne7PT/x8JL94mwzsjCZ5wTN8XAjuTynT/nKJcH9KmfaXS4T7U8q0v1wi3J9Skr8cH3cJ7l3I98Ph8HLg86SuM9zPvRMDO0JJXwjQ/Wx6yx3kI3cGZqK6CPdz78TAjlDSF0ZYLpcvOH9O0zQX/xnL2ZiuIbifeycGdoSSvjACZ2N2TnA+do9wP/dODOwIhfvZ8HCfn5wbYmDPNOybLXxYn9+cu8TArmnYN1v4sNTHcdc67JslfFTOw7hvHfbNEj6q+3n3gTMheMM67JsdfNA1j+Idq7BnlvBR2+32DWfElazX63cUzRlhACVLdCEk2QmJdmC3232RaAcoucsfzogAAxJNwp6qoRzrsK9aKMY6i8XiGTurhGKsc/ofGHZWCcVYR6J7KMY6Et1DMedwLgT3JRpQjEQXgmIkuhAUI9GFoBiJLgTFSHQhKEaiC0ExEl0IipHoQlCMRBeCYiS6EBQj0YWgGOtIdA/FWEeieyjGOhLdQzHW2e/3T9hZJRRjHfZVDeVYhT1CiDnzD27IzgFe/xOvAAAAAElFTkSuQmCC"/>
  </div>
  <div class="download-info">
    <h2 id='bottom'>Download This Ebook</h2>
    <p class="format-label">Available formats:</p>
    <div class="download-buttons">
      <a href="java-io-and-nio.pdf" class="download-button">📄 PDF</a>
      <a href="java-io-and-nio.epub" class="download-button">📘 EPUB</a>
    </div>
  </div>
</section><div class='related-books'>
<h2>Java In-Depth Books</h2>
<div class='related-book-list'>
<a href="java-io-and-nio.htm">
<div class="book-cover" style="background-color: #f9f6f1;border: 1px solid #ccc;"> 
    <div class="book-cover-title" style="font-size: 18px;color: #333;top: 20px;">Java IO and NIO</div>
    <div class="book-cover-author">readbytes</div>
    <div class="book-cover-bottom-stripe" style="background-color: #333;"></div>
    <img class="book-cover-icon" style="width: 80px;height: 90px;top: 60px;" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFoAAABaCAYAAAA4qEECAAADAElEQVR4Xu2Zu6oTURSGjze0UfANtLAUzgOI4DOItc+VKk1uJ12aadNa21vbCpYK4wQmcPiYzL5k7eXM2f8HP0JYa/3ZX2PEmxshxAPi7u6uLRH2VA3lWId9VdK27WOKsQ47q6RpmucUYx12VolEOyHRToyJ5mwI7ufeeZBItBMS7YREOyHRTki0ExLthEQ7IdFOSLQTEu2ERDsxJtoq7KwSiXZCop04Ho9PKcY67KwWirEO+6qGcqzCHhGBJDoh0U5ItAP7/f6bRDtAyV3+ckYYQNHr9fo1Z8SVtG37iKI5Mzv4IKuwJwXeuvbef4ePsQ77YuGdLp85MysGHmQa9sXAG7l3JgUfZB32heh+0t3yRvfZD87NDj7KOuwLwf2cG5OEj7IO+8bg7imr1eoV55Lh0VC4bwE7cru4n3Jns9l85d7YPmdCSV8oADtyu7gfe4fzMbucCyV9oQDsyO3i/tid7i+395xjuHMfzoaSvlAAduR2cf/+ne7PT/x8JL94mwzsjCZ5wTN8XAjuTynT/nKJcH9KmfaXS4T7U8q0v1wi3J9Skr8cH3cJ7l3I98Ph8HLg86SuM9zPvRMDO0JJXwjQ/Wx6yx3kI3cGZqK6CPdz78TAjlDSF0ZYLpcvOH9O0zQX/xnL2ZiuIbifeycGdoSSvjACZ2N2TnA+do9wP/dODOwIhfvZ8HCfn5wbYmDPNOybLXxYn9+cu8TArmnYN1v4sNTHcdc67JslfFTOw7hvHfbNEj6q+3n3gTMheMM67JsdfNA1j+Idq7BnlvBR2+32DWfElazX63cUzRlhACVLdCEk2QmJdmC3232RaAcoucsfzogAAxJNwp6qoRzrsK9aKMY6i8XiGTurhGKsc/ofGHZWCcVYR6J7KMY6Et1DMedwLgT3JRpQjEQXgmIkuhAUI9GFoBiJLgTFSHQhKEaiC0ExEl0IipHoQlCMRBeCYiS6EBQj0YWgGOtIdA/FWEeieyjGOhLdQzHW2e/3T9hZJRRjHfZVDeVYhT1CiDnzD27IzgFe/xOvAAAAAElFTkSuQmCC"/>
  </div>
</a>


<a href="java-collections.htm">
<div class="book-cover" style="background-color: #f9f6f1;border: 1px solid #ccc;"> 
    <div class="book-cover-title" style="font-size: 18px;color: #333;top: 20px;">Java Collections</div>
    <div class="book-cover-author">readbytes</div>
    <div class="book-cover-bottom-stripe" style="background-color: #333;"></div>
    <img class="book-cover-icon" style="width: 80px;height: 90px;top: 60px;" src='data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFoAAABaCAYAAAA4qEECAAADAElEQVR4Xu2dQYrUUBRFIw50JI7FrYgrcAPOXYPORHci7sah4EAQFyA6dNKosZK2Ee8/dOclP7/+i/fAmaR+Xr17KehJV2oYjDHGGGM6YRxzmgZdPKvdMt4vl03vLU15ZsYnsORB7Apd7mh2gS51VM/K+LVc6LA+0/QNKZax9RnvlG+C/tI7+6PYuYLV0MHoc72rX8ZvsP9Gq6BDyWzo/jXcjA4sfKN39E+RoYaf9F2CFAPFjGiG3b0Y5r9111LcJGZEM7QW0UNqRjTDWXwQXCojmoEk9MxmHwWGZ0QzkMT4ujy31b/D4UU8uITp/J4uRDOQxPiyPFfDy+HwQnFoCdPZFi5AM5BE/0VP51r5brgRzUASexU9/piG60VxEdO5lt6AZiCJ3Yoep+Fw8Z8DS5gHNfLncCOagSSWFE2M38tzanFBXcS9k/OwBi5AM5DE2qIn9JxaXFAXM33S5oE7+nFYhGYgiRxFX7FH4V+GEJqBJHIV3QGagSRcdBDNQBIuOohmIAkXHUQzkISLDqIZSMJFB9EMJOGig2gGknDRQTQDSbjoIJqBJHIUfffkPLCC74dNaAaSyFH0PKyiL4bVaAaS6L/oedAOrkQzkISLDqIZSMJFB9EMJNF/0bdPzsMquxLNQBL9Fz3x4eQ8sJIb0AwkkaPoK56efLvSV0MVNANJ5Cq6AzQDSbjoIJqBJFx0EM1AEi46iGYgCRcdRDOQhIsOohlIwkUH0Qwk4aKDaAaScNFBNANJuOggmoEkXHQQzUASLjqIZiAJFx1EM5CEiw6iGUjCRQfRDCSxtuh2X63oDM1AEkuKXmtxQc2IZiCJ3Yqu9vW3ztAMJLFX0ZfD4YXiUDI0A0m46CCagSTyfOm+EzQDSeiZzT4ODM+IZjiLD4NLZUQztBbRQ2pGNMPu1nh4lR/H9sfP+i5BioFgNnT/Gm5GB6Ib/im8Nf0+MtMPgb3Wquhwqw1Vwg/qbkix0EHtAl3qaHaDfx6kIf7Bm8YUyyY1Dbp4Fo0xxhhj/kd+A/PkOH57kF8HAAAAAElFTkSuQmCC'/>
  </div>
</a>


<a href="java-regex.htm">
<div class="book-cover" style="background-color: #f9f6f1;border: 1px solid #ccc;"> 
    <div class="book-cover-title" style="font-size: 18px;color: #333;top: 20px;">Java Regex</div>
    <div class="book-cover-author">readbytes</div>
    <div class="book-cover-bottom-stripe" style="background-color: #333;"></div>
    <img class="book-cover-icon" style="width: 80px;height: 90px;top: 60px;" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFoAAABaCAYAAAA4qEECAAAFo0lEQVR4Xu2d3WscVRiH+y/YXuuFkov6H9je2huvlAQvFalCEW8qiFRFQcGrmoJ4U5TSLWglFqRIlJqCH6XWalM/0lrT1O1ukt3sV5qPTZrP3XHfLTM983vPztc5s+zZPQ88N5l3Z9inwzA70Dl79iQks29oM7N3yBkoW98ZO6RC62ANdvDBtYF9lJEcxHNi+CWnOvmXs5rN9aX03eg74vcWxV6xObX3iUdxp2P7DzqDztiTB1lsaoX9InF631BJ3NH408N4vIFn/NCwL/aZVjPsGAj+a1mCwV7YUwqeyZZoxDqz8ZpsiYfY7mzQNdtGVkdsiH3b2Mj6CIztbrB3F+qMHxqRh84Iv/gsehDO6oe/IN0/ju0/gPOWhNAPO3ZW27M5HXyhTwtP4Sx68S4f9NRPuJbgnEURsa0Xmp5QWfQyMfLwqZ8XunrtT5yzKEKPWFnoem4O5xKxsVbS5vbmMu7eKOr5OUnovHro1ep0KppKPT+vP/TGWpkF0qWp2NBdwobuEjY0MnXbcb4cd5xCGbco0XOhb8wuOhdnGp4//7fl254ah9/urAZ6KrQYGL01V0sndLPJw8pUxJjQ5OXsBh5KjVZjFjRIBXoqdKWcZXHRK/kGHi45GDJMBXoqNFku3WVx0V9nNcTGiK7nLgRvT0jPhSZLacfGeK7Xb4bPJaQnQz+InWNx0USXEQzn+vsUTvKZfgxNFhfyLC4a68x+7QMejrwieVqJM+QX3+BUZHo6NDlfnGNx0auzdPsQAQxHXprEKT7jqkDPhyZni/MsLhopNoY7kcEJPuN6bBQnY2FEaDJXLLC4aGhsjIfgdtdX3sHJ2BgTmswVwmMHXrMxoBgb/+76snpkwqjQZKnusLhox7uRryd4yDA1YVxoYmG1yeKi0jP7nzs8ZJAaMTI0UVhJEPvN4zxmJzVjbGhidik8tu8ygjE7mQJGha7XZvBQTnYxPHb7zF6o8qAyU8KY0Gv37uJhPGZq4bEXpnI8KpoiRoTe3lzBQzCmq51j59aabSu/3OBxSU23cEH0fOgHT+ej8W+Fx3Yju9YuXO16ZCKV0DvVSWfrzlnm+tyP/pCVW2xGNAlibIzsunT+p65GJroamhRD4zbVyC7TFR4XXf7qIn4sVVIJ3bj9meNce0OqGLM5+Rbb7jMhePmQWXzqWWf15Of40dRIJfTmwmV2hiY1LhhUJkV2Xfn4FO4iFXo+NBkVDCpTjOzFPvEp7ko7RoQmw8CgMjGw6PJourGNCU12AoPKXHpvlMVFl4+fxF1rw6jQJIJBZbpgWJnLH34i7F0fxoamnzEYVKZI6ZkXWViZS+9+5PucDowNjUFlIlt/3GRRO7n4+vv4cSWMDI1BZcpYP/89Cxpk7cgx3EVijAuNQWV2AkOSbZpN9nfX6uHkP5xE+i50EBgRwe1e7BeO4mhs+ip0GBjw/nc/4AibCZqNQ9+EjgLGI50G/yzOeLMK9EXoqBQPPMfixYm9cek3HIuM8aHjgvFcmzs7OMpm2v8oCTE6dBJ2q/dYPC/29rZvFrcPZGgVdss1FtCLvX6/PVN5/lW2beBC62C3VGURw2z/D66EGBdaJ7vFMosZpAoDHZqIGluVgQ/dJuAnuI7IhA0NVEaOtOMuHrVP74zEhu4SNnSXkIdWfHnVbr3AAunSVOjkZaF1vI4NA+nQZKSvY7MvGNSP9AWDpEUvYlv7EtgU8UK7Sz/Z0Ongnc34/mi7apA+xNWHxND21fOa8S4buHiZu4GWJbKo8W2nxRTE0PasVkdsiZ3b2NjqhEYmaNkhGzs5Yrszjzz+GPb1QQtq2djxEZu17pvL2FWK70M2dijYC3sGgmc2LUtk8SPeXcQ6kxFcdo+kG/FBR+tSqCK4U1F6QlW7/rezms33pfTdxKdwMrGXMhm7XLWo/uWqZdgF2OPxPxXwJpKIkhiiAAAAAElFTkSuQmCC"/>
  </div>
</a>


<a href="java-functional-programming.htm">
<div class="book-cover" style="background-color: #f9f6f1;border: 1px solid #ccc;"> 
    <div class="book-cover-title" style="font-size: 18px;color: #333;top: 20px;">Java Functional Programming</div>
    <div class="book-cover-author">readbytes</div>
    <div class="book-cover-bottom-stripe" style="background-color: #333;"></div>
    <img class="book-cover-icon" style="width: 80px;height: 80px;top: 80px;" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFoAAABaCAYAAAA4qEECAAADzUlEQVR4Xu2bO4sUURCFlxVBzfwLJkb+A1MxEgMRDBQDRTBRwchARk00MRFBAwNBzEQwMBfEBz7wbWIkiIGJoInio9wZdmZ7T1V3V91bPVhaH3xJ973n3jk2vdO968JCkiRJkiRRIYphWOgI/zB/uyHBDxHFUODmIxkK3HwkQ4Gbj2QY6BDffCTDgBuPZhhw49EMA248miGgW3zj0QwBbjqiIcBNRzQEuOlohoA+8Y1HMgy4cauJEizO5EZMS0RoUSjPYKIEi7OaKMHirCZKsDiTi5iWiNAmoTyDiRIszmqiBIsz+QXTklZYeQYTJXSUl2cxUYLFWU2UYHEmb2Na0gorz2CihJ7w8iwmSrA4q4kSLM7kYUxLWmHlGUyU0C9ensVECRZnNQS4abPPMNEOy7S4BdN00L5GxmU8q4cuNXL24tll2KYrLIXW8yyLJdAJnkP3cFQ/9FzIGeEgHOBgCZhh1Qod5xkzH+PoduiVMH/qqDkQT3q4trGAEpZh1AId4/OZb3EWh14K89DRdDCecNIKzjdp+IelHcL8Nj/g7BU6r2R0+3gCHvRyN26tHdoszDdoAef2KpQt3pN7ZAc81YLzrFrAuSrfNOY/Es4rZAdcfbCywS7YPIvfMa0buiBkaFz6ATn+POy4xmvjhfGgsxpwjsUSigsr8el0UTzh7c9Vn5FBe4Q5BkuZXKFCnqsPmwviyQHsAsdarWF8tWGem/dxMRwwkG3gOJMvMM1O7S8aRJtX8hQ2aCDbwHEWvXAte3pPlmCDBxKhK3yMRU9cbiOKp0k+aQg3+K7pTdUPyHeYVgELL9At7/zqLA9KH0YmNh5qqqHPwgJWLzby8JxBb1y+Wxve+vXCwguc5Lzmxy164lLy1IL32SJ0Qwi3+k04ZtSLqttFm3dxlUJY8Lzdijsqo+QtnFqPK5u2CcFz1APT++RSPe7ZLHSO1qL6zYiXmu/WXdAaIXRO1lD8mnSpsOKHmpu4CyMscB5W/m8rlqex8TBS+lBTDQYObS2Y16vwxFfydbAaDBzaWmgXz2y14/46fg3Kxre5E2cXwoKH8geuXIb4hzNo11u4ZVRX9kmcVQELH0hP6BTPnym9T26h8559Gkc7wBYZQG/oLF+D/WZEgfht5AyOcoLeC4s5OwR0oLHGVTyrh643cvbjWWewGFc/4mr/MXRQKMjJBMCCvEwAWsdL8jARwJKqvYMrJDNYWRUmHWBZNSY9YGGlJj1gYUWew9REhBVnNFFCX3l5FhMDWJ7WpAAssc+kAiyzzcQJLHbibxyVJEmSJMk/xB+4wdarC+OVAQAAAABJRU5ErkJggg=="/>
  </div>
</a>


<a href="java-streams.htm">
<div class="book-cover" style="background-color: #f9f6f1;border: 1px solid #ccc;"> 
    <div class="book-cover-title" style="font-size: 18px;color: #333;top: 20px;">Java Streams</div>
    <div class="book-cover-author">readbytes</div>
    <div class="book-cover-bottom-stripe" style="background-color: #333;"></div>
    <img class="book-cover-icon" style="width: 80px;height: 80px;top: 60px;" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFoAAABaCAYAAAA4qEECAAACbklEQVR4Xu3cP4oUQRiG8S8xEzESDI1MPIRHEQQPYTK9iCyewMxrGIiCoaFnWFkMTIwUxD894KI8VbNdVdNfzdR87w+eRKa2ul+WVZM1G8+3ud+d+mhBvbZ0DO/uWEAcoVfhcIBehcQRvAvt1dz7gjjaVfxcrhcmxTiwvkudcGAN7YQDa2gnHFhDO+HAGtoJB24ZmmdzhcdBWobh2VzhcZCWYXg2V3gcpGUYns0VHgdpGYZnc4XHQVqG4dlc4XGQlmF4Nld4HKRlGJ7NFR4HaRmGZ3MN48Hcu7lLS19ihI7SPUsfdPSOCh/ulDoKfKhT7KC2P3P5QKfawfBBTr2D4ENEqDs+QJS64uWR6ubc0ssj1Q0vjlYXvLS1X3Mv5x7NPTyi+Jy5uuClNY2Az5zL3RtLLy1pJHz2XO544VLbHw+j4TvkcscLlxoR3yGXO154XaPie+Ry9djSC69rVHyPXK62/xTjhbu6+HtmRHyXXK6iDH1wGroTDd2Jhu5EQ3eioTvR0J1o6E40tAMOt1YCHGitBDjQWglwoLUS4EBrJcCB1kqAA62VwFOnREREROSIPbP7/CNZ28Y+2KT/hPjbjnyVOPl/ZA3tZLLzZGiN7YAD/+smPyqt0nH1Xe2Cw7LndpdHpBZH3ZXs4YndSAbdleyBYy4ljTjkUtKAI5a0sS/8MrKEI5YmFTZ2mQxYmlTgeDVt7DO/nOzC8WqTApPdSoarTQpM9ikZrjYpMNmPZLjapMDZ/JcZh6tNCkx2OxmuNinE4WraDPnbZw5ksp/JgKVJJQ5YmjTgiEvJHib7mgyaS1Yy2dtk3DP7zo9F9wfJyGVFhM8g5gAAAABJRU5ErkJggg=="/>
  </div>
</a>



<a href='java.htm'><div class='book-cover' style='background-color: #f9f6f1;color: #111111;border: 1px solid #ccc;display: flex;justify-content: center;align-items: center;text-align: center;'>More Java Books</div></a>
</div>
</div>
  </div>
  <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/prism.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script>
  function toggleSnippet(id) {
      const box = document.getElementById(id);
      box.classList.toggle("open");
  }  
  </script>
  <script>
    function copyCode(button) {
      const code = button.nextElementSibling.innerText;
      navigator.clipboard.writeText(code).then(() => {
        button.textContent = 'Copied!';
        setTimeout(() => { button.textContent = 'Copy'; }, 1500);
      });
    }
  </script>  
<div id="floatingLog" aria-live="polite" role="alert"></div>
<footer class="page-footer">
    <nav>
      <a href="https://readbytes.github.io">Home</a> | 
      Email:<script language="JavaScript" type="text/javascript">
var part1 = 'yinpeng';var part6 = '263';var part2 = Math.pow(2,6);var part3 = String.fromCharCode(part2);var part4 = 'hotmail dot com';var part5 = part1 + String.fromCharCode(part2) + part4;document.write(part1 + part6 + part3 + part4);
</script>
    </nav>
  <p>© 2025 — All rights reserved.</p>    
  </footer>

</body>
</html>