<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>JavaScript Algorithms Sorting and Order: Divide and Conquer</title>
<link rel='shortcut icon' href='https://java2s.com/style/favicon.ico'>
<link href="https://fonts.googleapis.com/css2?family=Merriweather&display=swap" rel="stylesheet" />
<link href="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet" />

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/codemirror.min.css" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/theme/material.css"> <!-- Dark theme -->
<script src="https://cdn.jsdelivr.net/npm/typescript@5/lib/typescript.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/codemirror.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/mode/htmlmixed/htmlmixed.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/mode/xml/xml.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/mode/css/css.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/mode/javascript/javascript.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/mode/javascript/typescript.min.js"></script>
<style>
    #floatingLog {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(20, 20, 20, 0.95);
      color: white;
      font-family: monospace;
      font-size: 14px;
      padding: 16px 20px;
      border-radius: 8px;
      box-shadow: 0 4px 16px rgba(0, 0, 0, 0.4);
      max-width: 80%;
      max-height: 200px;
      overflow-y: auto;
      display: none;
      z-index: 9999;
      pointer-events: none;
      white-space: pre-wrap;
      text-align: center;
    }
</style>
<script>
  const codeMirrorMap = new Map();
  const iframeMap = new Map();
  
 

  let dismissTimer;
  function showFloatingLog(message) {
	const floatingLog = document.getElementById('floatingLog');

    if (floatingLog.style.display !== 'block') {
      floatingLog.textContent = '';
      floatingLog.style.display = 'block'; 
    }

    floatingLog.textContent += message + '\n';
    floatingLog.scrollTop = floatingLog.scrollHeight; 
    clearTimeout(dismissTimer);
    dismissTimer = setTimeout(() => {
      floatingLog.style.display = 'none';
      floatingLog.textContent = '';
    }, 2000);
  }
  window.addEventListener('message', (event) => {
	    if (!iframeMap.has(event.source)) return;

	    if (event.data?.type === 'console-log') {
	      showFloatingLog(event.data.message);
	    }
  });  
  function renderIframe(button,textarea_id, iframe_id) {
      const html = codeMirrorMap.get(textarea_id).getValue();
      const iframe = document.getElementById(iframe_id);
  
      const oldIframe = iframe;
      const newIframe = document.createElement('iframe');
      newIframe.className ="result_iframe";
      
      newIframe.id = iframe_id;
      oldIframe.replaceWith(newIframe);
 

      // Track the iframe in the map
      iframeMap.set(newIframe.contentWindow, button);

      const overrideScript = `
        <script>
          (function() {
            const originalLog = console.log;
            console.log = function(...args) {
              originalLog.apply(console, args);
              window.parent.postMessage({
                type: 'console-log',
                message: args.map(a => {
                  try { return JSON.stringify(a); }
                  catch { return String(a); }
                }).join(' ')
              }, '*');
            };
          })();
        <\/script>
      `;

      const iframeHTML = `
        <!DOCTYPE html>
        <html>
        <body>
          ${overrideScript}
          ${html}
        </body>
        </html>
      `;
 
      const doc = newIframe.contentDocument || newIframe.contentWindow.document;
      doc.open();
      doc.write(iframeHTML);
      doc.close();

      
  }
  function renderIframeForClientTypescript(textarea_id, iframe_id) {
      let code = codeMirrorMap.get(textarea_id).getValue();
      code = ts.transpile(code);
      const iframe = document.getElementById(iframe_id);
      const doc = iframe.contentDocument || iframe.contentWindow.document;

const html = `
  <!DOCTYPE html>
  <html>
    <head>
      <title>Output</title>
      <style>
        body { font-family: monospace; padding: 1em; background: #f4f4f4; color: #222; }
        pre { white-space: pre-wrap; word-break: break-word; }
        .error { color: red; }
      </style>
    </head>
    <body>
      <pre id="log"></pre>
      <script>
        (function(){
          const logEl = document.getElementById('log');
          const origLog = console.log;
          const origError = console.error;

          console.log = (...args) => {
            logEl.textContent += args.join(' ') + '\\n';
            origLog.apply(console, args);
          };
          console.table = (...args) => {
            logEl.textContent += args.join(' ') + '\\n';
            origLog.apply(console, args);
          };

          console.error = (...args) => {
            logEl.innerHTML +='<span class="error">' + args.join(' ') + '</span>';
            origError.apply(console, args);
          };
          window.addEventListener("error", function (event) {
              console.error("Caught by event listener:", event.message);
          });    
          try {             
              ${code};
          } catch (err) {
            console.error(err.stack || err.message);
          }
        })();
      <\/script>
    </body>
  </html>
`;

      iframe.style.display = "block";
      iframe.srcdoc = html;  
  }

    function renderIframeForClientJavascript(textarea_id, iframe_id) {
        const code = codeMirrorMap.get(textarea_id).getValue();
        const iframe = document.getElementById(iframe_id);
        const doc = iframe.contentDocument || iframe.contentWindow.document;

  const html = `
    <!DOCTYPE html>
    <html>
      <head>
        <title>Output</title>
        <style>
          body { font-family: monospace; padding: 1em; background: #1e1e1e; color: #eee; }
          pre { white-space: pre-wrap; word-break: break-word; }
          .error { color: red; }
        </style>
      </head>
      <body>
        <pre id="log"></pre>
        <script>
          (function(){
            const logEl = document.getElementById('log');
            const origLog = console.log;
            const origError = console.error;

            console.log = (...args) => {
              logEl.textContent += args.join(' ') + '\\n';
              origLog.apply(console, args);
            };
            console.table = (...args) => {
              logEl.textContent += args.join(' ') + '\\n';
              origLog.apply(console, args);
            };

            console.error = (...args) => {
              logEl.innerHTML +='<span class="error">' + args.join(' ') + '</span>';
              origError.apply(console, args);
            };
            window.addEventListener("error", function (event) {
                console.error("Caught by event listener:", event.message);
            });    
            try {
             ${code}; 
            } catch (err) {
              console.error(err.stack || err.message);
            }
          })();
        <\/script>
      </body>
    </html>
  `;
        iframe.style.display = "block";
        iframe.srcdoc = html;  
    }
    function toggleSnippetAndRefresh(id, textarea_id) {
      const box = document.getElementById(id);
      box.classList.toggle("open");
      codeMirrorMap.get(textarea_id).refresh();
    }

  </script>
  <script>
  const mode = localStorage.getItem('mode') || 'light';
  document.documentElement.classList.add(`${mode}-mode`);
  </script>   
<style> 
html {
  scroll-behavior: smooth;
}

body {
  font-family: 'Merriweather', serif;
  margin: 0;
  padding: 2rem 1rem;
  font-size: 15px;
  line-height: 1.5;
  transition: background-color 0.3s, color 0.3s;
}

.container {
  max-width: 700px;
  margin: 0 auto;
  padding: 1rem 2rem;
  box-shadow: 0 0 15px rgba(0,0,0,0.1);
}

h1, h2, h3 {
  font-weight: 600;
  margin-top: 2.5rem;
  margin-bottom: 1rem;
  line-height: 1.2;
}

h1 { font-size: 1.8rem; }
h2 { font-size: 1.4rem; }
h3 { font-size: 1.2rem; }

table {
  width: 100%;
  border-collapse: collapse;
  font-family: sans-serif;
  font-size: 1em;
  margin: 1em 0;
}

th, td {
  padding: 0.6em 1em;
  text-align: left;
  border: 1px solid;
}

tr:nth-child(even) {
  background-color: inherit;
}

tr:hover {
  background-color: inherit;
}

a {
  text-decoration: none;
  transition: color 0.2s;
}

a:hover {
  text-decoration: underline;
}

code {
  color: #d35400;
}

.book-title-chapter {
  font-family: 'Merriweather', serif;
  font-size: 2rem;
  font-weight: bold;
  text-align: center;
  margin-bottom: 2rem;
  border-bottom: 2px solid;
  padding-bottom: 0.5rem;
}

.book-subtitle-chapter {
  text-align: center;
  font-size: 1rem;
  margin-top: -1rem;
  margin-bottom: 2rem;
}

.related-books {
  margin-top: 40px;
}

.related-book-list {
  display: flex;
  flex-wrap: wrap;
  gap: 20px;
}

    .book-cover {
      width: 130px;
      height: 180px;
      font-family: Arial, sans-serif;
      position: relative;
      overflow: hidden;      
      line-height: normal;
      box-shadow: 2px 2px 4px rgba(0,0,0,0.1);
    }
    .book-cover-bottom-stripe {
      position: absolute;
      bottom: 0;
      left: 0;
      height: 5px;
      width: 100%;
    }
    .book-cover-title {
      position: absolute;
      width: 100%;
      text-align: center;
      font-weight: bold;
    }
     
    .book-cover-icon {
      position: absolute;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      align-items: center;
      justify-content: center; 
    }

    .book-cover-author {
      position: absolute;
      bottom: 10px;
      width: 100%;
      text-align: center;
      font-size: 8px;
      color: #333;
    }

.page-footer {
  margin-top: 4rem;
  padding: 1rem 0;
  text-align: center;
  font-size: 0.85rem;
  border-top: 1px solid;
}

.chapter-navi-section {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding-bottom: 10px;
}

.nav-link {
  color: inherit;
  text-decoration: none;
  opacity: 0.5;
  transition: opacity 0.3s ease, text-decoration 0.3s ease;
}

.nav-link:hover {
  opacity: 0.9;
  text-decoration: underline;
}

.prev { text-align: left; }
.toc-link { text-align: center; }
.next { text-align: right; }

.download-section {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 2rem;
  padding: 2rem 1rem;
  max-width: 600px;
  margin: 3rem auto;
  border-radius: 12px;
  box-shadow: 0 4px 10px rgba(0,0,0,0.05);
}

.download-info h2 {
  margin: 0 0 0.5rem;
  font-size: 1.2rem;
}

.format-label {
  margin: 0 0 0.5rem;
  font-size: 0.95rem;
}

.download-buttons {
  display: flex;
  gap: 1rem;
}

.download-button {
  background-color: #4A90E2;
  color: white;
  padding: 0.5em 1.2em;
  border-radius: 25px;
  font-size: 0.95rem;
  text-decoration: none;
  transition: background-color 0.3s ease;
}

.download-button:hover {
  background-color: #357ABD;
}

.code-block {
  position: relative;
  margin-bottom: 1em;
}

.copy-button {
  background: transparent;
  color: white;
  position: absolute;
  top: 8px;
  right: 8px;
  border: none;
  padding: 4px 8px;
  font-size: 12px;
  border-radius: 4px;
  cursor: pointer;
  z-index: 1;
}

.copy-button:hover {
  background-color: #0056b3;
}

.snippet-container {
  overflow: hidden;
}

.snippet-header {
  padding: 0.75rem 1rem;
  cursor: pointer;
  font-size: 1rem;
    background-color: #eeeeee;
    color:  #111111; 
    border-radius: 8px;
    cursor: pointer;
    box-shadow: 0 4px 6px rgba(0,0,0,0.1);  
}

.snippet-body {
  display: none;
  font-family: monospace;
}

.snippet-container.open .snippet-body {
  display: block;
}

.CodeMirror {
  border: 2px solid #ccc;
  border-radius: 4px;
  resize: vertical;
}

/* === Light Mode === */
html.light-mode {
  background-color: #f8f7f5;
  color: #333;
}

html.light-mode .container {
  background: white;
}

html.light-mode .book-title-chapter {
  color: #2c3e50;
  border-color: #ccc;
}
html.light-mode .book-subtitle-chapter{
  color: #888;
}

html.light-mode .page-footer,
html.light-mode .series-name,
html.light-mode .book-subtitle,
html.light-mode .format-label {
  color: #888;
}

html.light-mode .related-books h2 {
  color: #333;
  border-bottom: 2px solid #eee;
}

html.light-mode .book-title {
  color: #fff;
}

html.light-mode .book-cover {
  border: 1px solid #ccc;
}

html.light-mode th {
  background-color: #f2f2f2;
}

html.light-mode tr:nth-child(even) {
  background-color: #fafafa;
}

html.light-mode tr:hover {
  background-color: #e6f7ff;
}

html.light-mode a,
html.light-mode .page-footer a {
  color: #000;
}

/* === Dark Mode === */
html.dark-mode {
  background-color: #181818;
  color: #e0e0e0;
}

html.dark-mode .container {
  background: #222;
}

html.dark-mode .book-title-chapter {
  color: #ddd;
  border-color: #444;
}

html.dark-mode .snippet-header {
    background-color: #333;
    color:  #ddd; 
}


html.dark-mode .book-subtitle-chapter,
html.dark-mode .page-footer,
html.dark-mode .series-name,
html.dark-mode .book-subtitle,
html.dark-mode .book-footer,
html.dark-mode .format-label {
  color: #aaa;
}

html.dark-mode .related-books h2 {
  color: #ddd;
  border-bottom: 2px solid #333;
}

html.dark-mode .book-title {
  color: #fff;
}

html.dark-mode .book-cover {
  border: 1px solid #555;
}

html.dark-mode th {
  background-color: #333;
  color: #fff;
}

html.dark-mode td {
  border-color: #444;
}

html.dark-mode tr:nth-child(even) {
  background-color: #2a2a2a;
}

html.dark-mode tr:hover {
  background-color: #2c3e50;
}

html.dark-mode a,
html.dark-mode .page-footer a {
  color: #eee;
}

    .dialog-backdrop {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: rgba(0,0,0,0.5);
      display: none;
      justify-content: center;
      align-items: center;
      z-index: 10;
    }

    .dialog {
      background: white;
      padding: 20px;
      width: 90vw;
      height: 80vh;
      border-radius: 8px;
      box-shadow: 0 0 20px rgba(0,0,0,0.3);
      display: flex;
      flex-direction: column;
    }
    .dialog-content {
      display: flex;
      flex: 1;
      gap: 20px;
      margin-top: 10px;
    }
    .dialog h2 {
      margin-top: 0;
    }

    .textarea_dialog {
      width: 50%;
      height: 100%;
      resize: none;
      font-family: monospace;
      font-size: 14px;
      padding: 10px;
      box-sizing: border-box;
      border: 1px solid #ccc;
    }

    .iframe_dialog {
      width: 50%;
      height: 100%;
      border: 1px solid #ccc;
    }
    .controls_dialog {
      display: flex;
      justify-content: space-between;
      margin-top: 10px;
    }    
    button { padding: 0.5em 1em; background: green; color: white; border: none; cursor: pointer; }
    button:hover { background: #1e7e34; }
    .result_iframe { width:99%; height:200px; margin-top: 1em;  resize: both;border:1px solid #ccc;}        
</style>
</head>
<body> 
  <div class="container">
    <div class = "chapter-navi-section">
<a href="javascript-algorithms-sorting-and-order-elementary-sorting-algorithms.htm" class="nav-button prev">←</a>
<a href='javascript-algorithms.htm#sorting-and-order-divide-and-conquer' class="nav-button toc-link">Index</a>
<a href="javascript-algorithms-sorting-and-order-linear-time-sorting.htm" class="nav-button next">→</a>
</div>

    <h1 class="book-title-chapter" id = 'top'>Sorting and Order: Divide and Conquer</h1>
    <h3 class="book-subtitle-chapter">JavaScript Algorithms</h3>   
    <!-- <h1 class ="chapter-title"></h1> -->
    <h2 id='merge-sort'>5.1 Merge Sort</h2><p>Merge sort is a classic example of a <strong>divide-and-conquer</strong> algorithm. It works by <strong>dividing</strong> the input array into smaller subarrays, <strong>conquering</strong> each by recursively sorting them, and finally <strong>combining</strong> (merging) the sorted subarrays back into a fully sorted array. It is one of the most efficient general-purpose sorting algorithms and is particularly useful for sorting large datasets.</p><h3 id="the-divide-and-conquer-paradigm">The Divide-and-Conquer Paradigm</h3><p>Divide-and-conquer is a powerful algorithm design technique that follows three main steps:</p><ol>
 <li><strong>Divide</strong>: Split the problem into smaller subproblems.</li>
 <li><strong>Conquer</strong>: Solve each subproblem recursively.</li>
 <li><strong>Combine</strong>: Merge the solutions of the subproblems into a final result.</li>
</ol><p>In merge sort:</p><ul>
 <li><strong>Divide</strong>: The array is split into two halves.</li>
 <li><strong>Conquer</strong>: Each half is sorted recursively using merge sort.</li>
 <li><strong>Combine</strong>: Two sorted halves are merged into one sorted array.</li>
</ul><h3 id="merge-sort-in-action">Merge Sort in Action</h3><p>Let’s say we want to sort the array <code>[4, 1, 7, 3]</code>.</p><ol>
 <li><p><strong>Divide</strong>:</p>
  <ul>
   <li><code>[4, 1]</code> and <code>[7, 3]</code></li>
   <li>Then further: <code>[4]</code>, <code>[1]</code>, <code>[7]</code>, <code>[3]</code></li>
  </ul></li>
 <li><p><strong>Conquer</strong> (Sort small arrays):</p>
  <ul>
   <li><code>[4]</code> and <code>[1]</code> → merge to <code>[1, 4]</code></li>
   <li><code>[7]</code> and <code>[3]</code> → merge to <code>[3, 7]</code></li>
  </ul></li>
 <li><p><strong>Combine</strong>:</p>
  <ul>
   <li><code>[1, 4]</code> and <code>[3, 7]</code> → merge to <code>[1, 3, 4, 7]</code></li>
  </ul></li>
</ol><p>The result is a fully sorted array.</p><div class="snippet-container" id="<!DOCTYPE html>
<html lang=&quot;en&quot;>
<head>
  <meta charset=&quot;UTF-8&quot;>
  <title>Merge Sort - Persistent Canvas Visualization</title>
  <style>
    canvas {
      display: block;
      margin: 20px auto;
      border: 1px solid #ccc;
      background-color: #fff;
    }
    button {
      display: block;
      margin: 10px auto;
      padding: 10px 20px;
      font-size: 18px;
    }
  </style>
</head>
<body>

<canvas id=&quot;canvas&quot; width=&quot;600&quot; height=&quot;700&quot;></canvas>
<button id=&quot;next&quot;>Next Step</button>

<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');

const array = [8, 7, 3, 4, 9, 2, 1, 6, 5, 0];
const boxWidth = 50;
const boxHeight = 30;
const spacing = 10;

let steps = [];
let currentStep = 0;

// Prepare all steps: each will be drawn at y = depth * levelHeight
const levelHeight = 70;
function mergeSortTrace(arr, depth = 0, offset = 0) {
  const n = arr.length;
  const start = offset;
  const end = offset + n - 1;

  const stepSplit = {
    type: 'split',
    array: [...arr],
    depth,
    offset,
    start,
    end,
  };
  steps.push(stepSplit);

  if (n <= 1) return arr;

  const mid = Math.floor(n / 2);
  const left = arr.slice(0, mid);
  const right = arr.slice(mid);

  const sortedLeft = mergeSortTrace(left, depth + 1, offset);
  const sortedRight = mergeSortTrace(right, depth + 1, offset + mid);

  // Merge step
  const merged = [];
  let i = 0, j = 0;
  while (i < sortedLeft.length &amp;&amp; j < sortedRight.length) {
    if (sortedLeft[i] < sortedRight[j]) {
      merged.push(sortedLeft[i++]);
    } else {
      merged.push(sortedRight[j++]);
    }
  }
  while (i < sortedLeft.length) merged.push(sortedLeft[i++]);
  while (j < sortedRight.length) merged.push(sortedRight[j++]);

  const stepMerge = {
    type: 'merge',
    array: [...merged],
    depth,
    offset,
    start,
    end,
  };
  steps.push(stepMerge);

  return merged;
}

// Draw a row of boxes representing the array at a given y offset
function drawArray(arr, startIndex, y, color = 'black') {
  ctx.font = '16px monospace';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';

  arr.forEach((val, i) => {
    const x = 50 + (startIndex + i) * (boxWidth + spacing);
    ctx.strokeStyle = '#000';
    ctx.fillStyle = '#fff';
    ctx.fillRect(x, y, boxWidth, boxHeight);
    ctx.strokeRect(x, y, boxWidth, boxHeight);

    ctx.fillStyle = color;
    ctx.fillText(val, x + boxWidth / 2, y + boxHeight / 2);
  });
}

// Show the original array once at the top
function drawOriginalArray() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  ctx.fillStyle = '#000';
  ctx.font = '18px sans-serif';
  ctx.fillText(&quot;Original Array:&quot;, 50, 20);
  drawArray(array, 0, 30, 'black');
}

// Draw all steps up to and including currentStep
function renderSteps() {
  drawOriginalArray();
  for (let s = 0; s <= currentStep; s++) {
    const step = steps[s];
    const y = 100 + step.depth * levelHeight;
    const color = step.type === 'split' ? '#666' : 'green';
    drawArray(step.array, step.offset, y, color);
  }
}

// Step forward
function nextStep() {
  if (currentStep < steps.length - 1) {
    currentStep++;
    renderSteps();
  } else {
    document.getElementById('next').disabled = true;
  }
}

// Initialize
mergeSortTrace(array);
renderSteps();
document.getElementById('next').addEventListener('click', nextStep);
</script>

</body>
</html>ID"><textarea id="uhunc" style="display: none;">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
  &lt;meta charset="UTF-8"&gt;
  &lt;title&gt;Merge Sort - Persistent Canvas Visualization&lt;/title&gt;
  &lt;style&gt;
    canvas {
      display: block;
      margin: 20px auto;
      border: 1px solid #ccc;
      background-color: #fff;
    }
    button {
      display: block;
      margin: 10px auto;
      padding: 10px 20px;
      font-size: 18px;
    }
  &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;canvas id="canvas" width="600" height="700"&gt;&lt;/canvas&gt;
&lt;button id="next"&gt;Next Step&lt;/button&gt;

&lt;script&gt;
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');

const array = [8, 7, 3, 4, 9, 2, 1, 6, 5, 0];
const boxWidth = 50;
const boxHeight = 30;
const spacing = 10;

let steps = [];
let currentStep = 0;

// Prepare all steps: each will be drawn at y = depth * levelHeight
const levelHeight = 70;
function mergeSortTrace(arr, depth = 0, offset = 0) {
  const n = arr.length;
  const start = offset;
  const end = offset + n - 1;

  const stepSplit = {
    type: 'split',
    array: [...arr],
    depth,
    offset,
    start,
    end,
  };
  steps.push(stepSplit);

  if (n &lt;= 1) return arr;

  const mid = Math.floor(n / 2);
  const left = arr.slice(0, mid);
  const right = arr.slice(mid);

  const sortedLeft = mergeSortTrace(left, depth + 1, offset);
  const sortedRight = mergeSortTrace(right, depth + 1, offset + mid);

  // Merge step
  const merged = [];
  let i = 0, j = 0;
  while (i &lt; sortedLeft.length &amp;&amp; j &lt; sortedRight.length) {
    if (sortedLeft[i] &lt; sortedRight[j]) {
      merged.push(sortedLeft[i++]);
    } else {
      merged.push(sortedRight[j++]);
    }
  }
  while (i &lt; sortedLeft.length) merged.push(sortedLeft[i++]);
  while (j &lt; sortedRight.length) merged.push(sortedRight[j++]);

  const stepMerge = {
    type: 'merge',
    array: [...merged],
    depth,
    offset,
    start,
    end,
  };
  steps.push(stepMerge);

  return merged;
}

// Draw a row of boxes representing the array at a given y offset
function drawArray(arr, startIndex, y, color = 'black') {
  ctx.font = '16px monospace';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';

  arr.forEach((val, i) =&gt; {
    const x = 50 + (startIndex + i) * (boxWidth + spacing);
    ctx.strokeStyle = '#000';
    ctx.fillStyle = '#fff';
    ctx.fillRect(x, y, boxWidth, boxHeight);
    ctx.strokeRect(x, y, boxWidth, boxHeight);

    ctx.fillStyle = color;
    ctx.fillText(val, x + boxWidth / 2, y + boxHeight / 2);
  });
}

// Show the original array once at the top
function drawOriginalArray() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  ctx.fillStyle = '#000';
  ctx.font = '18px sans-serif';
  ctx.fillText("Original Array:", 50, 20);
  drawArray(array, 0, 30, 'black');
}

// Draw all steps up to and including currentStep
function renderSteps() {
  drawOriginalArray();
  for (let s = 0; s &lt;= currentStep; s++) {
    const step = steps[s];
    const y = 100 + step.depth * levelHeight;
    const color = step.type === 'split' ? '#666' : 'green';
    drawArray(step.array, step.offset, y, color);
  }
}

// Step forward
function nextStep() {
  if (currentStep &lt; steps.length - 1) {
    currentStep++;
    renderSteps();
  } else {
    document.getElementById('next').disabled = true;
  }
}

// Initialize
mergeSortTrace(array);
renderSteps();
document.getElementById('next').addEventListener('click', nextStep);
&lt;/script&gt;

&lt;/body&gt;
&lt;/html&gt;</textarea> <iframe id="H8CL0" class="result_iframe" style="border:none;"></iframe>
 <script>{
const textarea = document.getElementById("uhunc");
const iframe = document.getElementById("H8CL0");
const html = textarea.value;
const iframeHTML = `${html}`;
const doc = iframe.contentDocument || iframe.contentWindow.document;
doc.open();
doc.write(iframeHTML);
doc.close();
setTimeout(() => {
iframe.style.height = '0px';
const contentHeight = Math.max(
  doc.body.scrollHeight,
  doc.documentElement.scrollHeight
);
iframe.style.height = contentHeight + 'px';
}, 50);
}
		</script>
</div><h3 id="javascript-implementation">JavaScript Implementation</h3><p>Here's a step-by-step merge sort implementation with comments:</p><div>
 <div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
  <pre><code class="language-js">function mergeSort(arr) {
  // Base case: arrays with 0 or 1 element are already sorted
  if (arr.length &lt;= 1) return arr;

  // Split array into two halves
  const mid = Math.floor(arr.length / 2);
  const left = arr.slice(0, mid);
  const right = arr.slice(mid);

  // Recursively sort both halves and merge them
  return merge(mergeSort(left), mergeSort(right));
}

function merge(left, right) {
  const result = [];
  let i = 0, j = 0;

  // Merge elements in sorted order
  while (i &lt; left.length &amp;&amp; j &lt; right.length) {
    if (left[i] &lt;= right[j]) {
      result.push(left[i++]);
    } else {
      result.push(right[j++]);
    }
  }

  // Add remaining elements (only one of these will run)
  return result.concat(left.slice(i)).concat(right.slice(j));
}

// Example
console.log(mergeSort([4, 1, 7, 3])); // Output: [1, 3, 4, 7]</code></pre>
 </div>
 <div class="snippet-container" id="INOke">
  <div class="snippet-header" onclick="toggleSnippetAndRefresh('INOke','cCg8C')">
   Try it in editor
  </div>
  <div class="snippet-body"><textarea id="cCg8C">function mergeSort(arr) {
  // Base case: arrays with 0 or 1 element are already sorted
  if (arr.length &lt;= 1) return arr;

  // Split array into two halves
  const mid = Math.floor(arr.length / 2);
  const left = arr.slice(0, mid);
  const right = arr.slice(mid);

  // Recursively sort both halves and merge them
  return merge(mergeSort(left), mergeSort(right));
}

function merge(left, right) {
  const result = [];
  let i = 0, j = 0;

  // Merge elements in sorted order
  while (i &lt; left.length &amp;&amp; j &lt; right.length) {
    if (left[i] &lt;= right[j]) {
      result.push(left[i++]);
    } else {
      result.push(right[j++]);
    }
  }

  // Add remaining elements (only one of these will run)
  return result.concat(left.slice(i)).concat(right.slice(j));
}

// Example
console.log(mergeSort([4, 1, 7, 3])); // Output: [1, 3, 4, 7]</textarea> <br> <button onclick="renderIframeForClientJavascript('cCg8C','o5lK8')">Run</button> <iframe id="o5lK8" class="result_iframe" style="display: none;"></iframe>
   <script>
  {let editor1 = CodeMirror.fromTextArea(document.getElementById("cCg8C"), {
    mode: "javascript",
    lineNumbers:false,
    tabSize: 2
    });
    const mode = localStorage.getItem("mode") || "light";  
    const newTheme = mode === "dark" ? "material" : "default";
    editor1.setOption("theme", newTheme);

   codeMirrorMap.set("cCg8C", editor1);}
  </script>
  </div>
 </div>
</div><h3 id="recursion-flow-and-merging-visualized">Recursion Flow and Merging (Visualized)</h3><p>To understand how the algorithm flows, here’s a diagram for sorting <code>[4, 1, 7, 3]</code>:</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-bash">mergeSort([4, 1, 7, 3])
├─ mergeSort([4, 1])
│  ├─ mergeSort([4]) → [4]
│  ├─ mergeSort([1]) → [1]
│  └─ merge([4], [1]) → [1, 4]
├─ mergeSort([7, 3])
│  ├─ mergeSort([7]) → [7]
│  ├─ mergeSort([3]) → [3]
│  └─ merge([7], [3]) → [3, 7]
└─ merge([1, 4], [3, 7]) → [1, 3, 4, 7]</code></pre>
</div><p>Each recursive call further splits the array until it reaches size 1. Then the merging phase begins, combining smaller sorted arrays into larger ones.</p><h3 id="why-merge-step-guarantees-sorted-output">Why Merge Step Guarantees Sorted Output</h3><p>The merge step always compares the <strong>smallest elements</strong> of the two subarrays and appends the smaller one to the result. Since each subarray is already sorted from previous recursive calls, the final merged array is guaranteed to be sorted.</p><h3 id="time-and-space-complexity">Time and Space Complexity</h3><table>
 <thead>
  <tr>
   <th>Aspect</th>
   <th>Value</th>
  </tr>
 </thead>
 <tbody>
  <tr>
   <td><strong>Time (All Cases)</strong></td>
   <td>O(n log n)</td>
  </tr>
  <tr>
   <td><strong>Space</strong></td>
   <td>O(n) (due to extra arrays)</td>
  </tr>
  <tr>
   <td><strong>Stable Sort</strong></td>
   <td>✔️ (preserves relative order)</td>
  </tr>
 </tbody>
</table><ul>
 <li><strong>O(n log n)</strong>: The array is split log₂(n) times, and merging takes O(n) time at each level.</li>
 <li><strong>Stable</strong>: If two elements are equal, merge sort preserves their original order.</li>
</ul><h3 id="when-to-use-merge-sort">When to Use Merge Sort</h3><p>Merge sort is ideal when:</p><ul>
 <li>You need a <strong>guaranteed O(n log n)</strong> sort time.</li>
 <li><strong>Stability</strong> is important (e.g., sorting objects by a secondary key).</li>
 <li>Working with <strong>linked lists</strong> (where merge can be done in-place).</li>
</ul><p>It's often used in hybrid sorting algorithms like <strong>Timsort</strong>, which powers the built-in <code>Array.prototype.sort()</code> in many JavaScript engines.</p><h3 id="conclusion">Conclusion</h3><p>Merge sort is a powerful, efficient, and elegant algorithm that exemplifies the divide-and-conquer paradigm. Its guaranteed performance, stability, and predictable recursion structure make it an essential tool in your algorithmic toolkit. By understanding how merge sort works—both conceptually and in code—you’ll be better equipped to tackle complex sorting problems and recursion-based algorithms.</p><div class = "chapter-navi-section">
<a href="#top" class="nav-button prev">↑</a>
<a href='javascript-algorithms.htm#sorting-and-order-divide-and-conquer' class="nav-button toc-link">Index</a>
<a href="#bottom" class="nav-button next">↓</a>
</div>
<h2 id='quick-sort'>5.2 Quick Sort</h2><p>Quick sort is one of the fastest and most commonly used sorting algorithms in practice. Like merge sort, it uses the <strong>divide-and-conquer</strong> strategy, but instead of merging sorted arrays, it focuses on <strong>partitioning</strong> the input array around a <strong>pivot</strong> element. Quick sort typically performs better than merge sort in real-world scenarios due to its in-place sorting and lower overhead.</p><h3 id="the-quick-sort-strategy">The Quick Sort Strategy</h3><p>Quick sort follows this approach:</p><ol>
 <li><p><strong>Choose a pivot</strong> element from the array.</p></li>
 <li><p><strong>Partition</strong> the array into two subarrays:</p>
  <ul>
   <li>Elements less than the pivot.</li>
   <li>Elements greater than or equal to the pivot.</li>
  </ul></li>
 <li><p><strong>Recursively apply quick sort</strong> to the left and right subarrays.</p></li>
 <li><p>Combine the results (though the combining is implicit, since sorting is done in-place).</p></li>
</ol><p>Unlike merge sort, quick sort doesn’t merge arrays—it simply ensures that the pivot ends up in its final sorted position, with smaller elements to the left and larger to the right.</p><h3 id="visual-example">Visual Example</h3><p>Let’s sort <code>[5, 3, 8, 4, 2, 7, 1]</code> with pivot <code>4</code>.</p><ol>
 <li><p>Pivot: <code>4</code></p></li>
 <li><p>Partition:</p>
  <ul>
   <li>Left: <code>[3, 2, 1]</code> (less than 4)</li>
   <li>Right: <code>[5, 8, 7]</code> (greater than 4)</li>
  </ul></li>
 <li><p>Recurse on <code>[3, 2, 1]</code> and <code>[5, 8, 7]</code></p></li>
 <li><p>Final sorted result: <code>[1, 2, 3, 4, 5, 7, 8]</code></p></li>
</ol><div class="snippet-container" id="<!DOCTYPE html>
<html lang=&quot;en&quot;>
<head>
  <meta charset=&quot;UTF-8&quot;>
  <title>Quick Sort Visualizer with Canvas</title>
  <style>
    body {
      font-family: sans-serif;
      text-align: center;
      margin-top: 20px;
    }
    canvas {
      border: 1px solid #ccc;
      background: #fff;
      display: block;
      margin: 20px auto;
    }
    button {
      padding: 10px 20px;
      font-size: 16px;
      margin: 10px;
    }
    #explanation {
      font-size: 18px;
      margin-top: 10px;
    }
  </style>
</head>
<body>

<canvas id=&quot;canvas&quot; width=&quot;600&quot; height=&quot;400&quot;></canvas>
<button id=&quot;next&quot;>Next Step</button>
<div id=&quot;explanation&quot;></div>

<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
const explanation = document.getElementById('explanation');

const barWidth = 50;
const spacing = 10;
const bottom = 300;

const originalArray = [33, 10, 55, 71, 29, 3, 42];
let array = [...originalArray];
let steps = [];
let currentStep = 0;

// Prepare Quick Sort trace steps
function traceQuickSort(arr, start = 0, end = arr.length - 1) {
  if (start >= end) return;

  const pivotIndex = end;
  const pivotValue = arr[pivotIndex];
  let i = start;

  steps.push({ type: 'pivot', array: [...arr], pivot: pivotIndex });

  for (let j = start; j < end; j++) {
    steps.push({
      type: 'compare',
      array: [...arr],
      pivot: pivotIndex,
      j,
      i
    });

    if (arr[j] < pivotValue) {
      [arr[i], arr[j]] = [arr[j], arr[i]];
      steps.push({
        type: 'swap',
        array: [...arr],
        i,
        j
      });
      i++;
    }
  }

  [arr[i], arr[pivotIndex]] = [arr[pivotIndex], arr[i]];
  steps.push({
    type: 'pivot-swap',
    array: [...arr],
    pivotFinal: i
  });

  traceQuickSort(arr, start, i - 1);
  traceQuickSort(arr, i + 1, end);
}

function drawArrow(x1, y1, x2, y2) {
  ctx.beginPath();
  ctx.moveTo(x1, y1);
  ctx.bezierCurveTo(x1, y1 - 40, x2, y2 - 40, x2, y2);
  ctx.strokeStyle = 'blue';
  ctx.lineWidth = 2;
  ctx.stroke();

  const headlen = 8;
  const angle = Math.atan2(y2 - y1, x2 - x1);
  ctx.beginPath();
  ctx.moveTo(x2, y2);
  ctx.lineTo(x2 - headlen * Math.cos(angle - Math.PI / 6), y2 - headlen * Math.sin(angle - Math.PI / 6));
  ctx.lineTo(x2 - headlen * Math.cos(angle + Math.PI / 6), y2 - headlen * Math.sin(angle + Math.PI / 6));
  ctx.lineTo(x2, y2);
  ctx.fillStyle = 'blue';
  ctx.fill();
}

function drawBars(arr, highlight = {}) {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  const maxVal = Math.max(...arr);

  arr.forEach((val, index) => {
    const height = (val / maxVal) * 200;
    const x = index * (barWidth + spacing) + 50;
    const y = bottom - height;

    // Bar color
    ctx.fillStyle = 'gray';
    if (highlight.pivot === index) ctx.fillStyle = 'red';
    else if (highlight.j === index) ctx.fillStyle = 'orange';
    else if (highlight.i === index) ctx.fillStyle = 'gold';

    ctx.fillRect(x, y, barWidth, height);
    ctx.strokeRect(x, y, barWidth, height);

    ctx.fillStyle = 'black';
    ctx.font = '14px monospace';
    ctx.fillText(val, x + barWidth / 2, bottom + 15);
  });

  // Draw arrow from j to pivot
  if ('j' in highlight &amp;&amp; 'pivot' in highlight) {
    const xj = highlight.j * (barWidth + spacing) + 50 + barWidth / 2;
    const xp = highlight.pivot * (barWidth + spacing) + 50 + barWidth / 2;
    drawArrow(xj, bottom + 5, xp, bottom + 5);
  }
}

// Animate a swap between bars
function animateSwap(arr, i, j, callback) {
  const frames = 10;
  let frame = 0;
  const fromX = i * (barWidth + spacing) + 50;
  const toX = j * (barWidth + spacing) + 50;
  const diff = (toX - fromX) / frames;

  function animate() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    const maxVal = Math.max(...arr);
    arr.forEach((val, index) => {
      let x = index * (barWidth + spacing) + 50;
      if (index === i) x += frame * diff;
      else if (index === j) x -= frame * diff;

      const height = (val / maxVal) * 200;
      const y = bottom - height;

      ctx.fillStyle = (index === i || index === j) ? 'purple' : 'gray';
      ctx.fillRect(x, y, barWidth, height);
      ctx.strokeRect(x, y, barWidth, height);

      ctx.fillStyle = 'black';
      ctx.fillText(val, x + barWidth / 2, bottom + 15);
    });

    frame++;
    if (frame <= frames) requestAnimationFrame(animate);
    else callback();
  }

  animate();
}

function renderStep() {
  if (currentStep >= steps.length) return;

  const step = steps[currentStep];
  explanation.textContent = '';

  if (step.type === 'pivot') {
    drawBars(step.array, { pivot: step.pivot });
    explanation.textContent = `Select pivot: ${step.array[step.pivot]}`;
  } else if (step.type === 'compare') {
    drawBars(step.array, { j: step.j, pivot: step.pivot });
    explanation.textContent = `Compare arr[${step.j}] = ${step.array[step.j]} with pivot = ${step.array[step.pivot]}`;
  } else if (step.type === 'swap') {
    animateSwap(step.array, step.i, step.j, () => {
      drawBars(step.array);
      explanation.textContent = `Swap arr[${step.i}] = ${step.array[step.i]} with arr[${step.j}] = ${step.array[step.j]}`;
    });
  } else if (step.type === 'pivot-swap') {
    drawBars(step.array, { pivot: step.pivotFinal });
    explanation.textContent = `Place pivot at index ${step.pivotFinal}`;
  }
}

// Prepare steps and render first
traceQuickSort([...array]);
renderStep();

document.getElementById('next').addEventListener('click', () => {
  if (currentStep < steps.length - 1) {
    currentStep++;
    renderStep();
  } else {
    explanation.textContent = &quot;Sorting complete.&quot;;
    document.getElementById('next').disabled = true;
  }
});
</script>

</body>
</html>ID"><textarea id="M3pRc" style="display: none;">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
  &lt;meta charset="UTF-8"&gt;
  &lt;title&gt;Quick Sort Visualizer with Canvas&lt;/title&gt;
  &lt;style&gt;
    body {
      font-family: sans-serif;
      text-align: center;
      margin-top: 20px;
    }
    canvas {
      border: 1px solid #ccc;
      background: #fff;
      display: block;
      margin: 20px auto;
    }
    button {
      padding: 10px 20px;
      font-size: 16px;
      margin: 10px;
    }
    #explanation {
      font-size: 18px;
      margin-top: 10px;
    }
  &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;canvas id="canvas" width="600" height="400"&gt;&lt;/canvas&gt;
&lt;button id="next"&gt;Next Step&lt;/button&gt;
&lt;div id="explanation"&gt;&lt;/div&gt;

&lt;script&gt;
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
const explanation = document.getElementById('explanation');

const barWidth = 50;
const spacing = 10;
const bottom = 300;

const originalArray = [33, 10, 55, 71, 29, 3, 42];
let array = [...originalArray];
let steps = [];
let currentStep = 0;

// Prepare Quick Sort trace steps
function traceQuickSort(arr, start = 0, end = arr.length - 1) {
  if (start &gt;= end) return;

  const pivotIndex = end;
  const pivotValue = arr[pivotIndex];
  let i = start;

  steps.push({ type: 'pivot', array: [...arr], pivot: pivotIndex });

  for (let j = start; j &lt; end; j++) {
    steps.push({
      type: 'compare',
      array: [...arr],
      pivot: pivotIndex,
      j,
      i
    });

    if (arr[j] &lt; pivotValue) {
      [arr[i], arr[j]] = [arr[j], arr[i]];
      steps.push({
        type: 'swap',
        array: [...arr],
        i,
        j
      });
      i++;
    }
  }

  [arr[i], arr[pivotIndex]] = [arr[pivotIndex], arr[i]];
  steps.push({
    type: 'pivot-swap',
    array: [...arr],
    pivotFinal: i
  });

  traceQuickSort(arr, start, i - 1);
  traceQuickSort(arr, i + 1, end);
}

function drawArrow(x1, y1, x2, y2) {
  ctx.beginPath();
  ctx.moveTo(x1, y1);
  ctx.bezierCurveTo(x1, y1 - 40, x2, y2 - 40, x2, y2);
  ctx.strokeStyle = 'blue';
  ctx.lineWidth = 2;
  ctx.stroke();

  const headlen = 8;
  const angle = Math.atan2(y2 - y1, x2 - x1);
  ctx.beginPath();
  ctx.moveTo(x2, y2);
  ctx.lineTo(x2 - headlen * Math.cos(angle - Math.PI / 6), y2 - headlen * Math.sin(angle - Math.PI / 6));
  ctx.lineTo(x2 - headlen * Math.cos(angle + Math.PI / 6), y2 - headlen * Math.sin(angle + Math.PI / 6));
  ctx.lineTo(x2, y2);
  ctx.fillStyle = 'blue';
  ctx.fill();
}

function drawBars(arr, highlight = {}) {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  const maxVal = Math.max(...arr);

  arr.forEach((val, index) =&gt; {
    const height = (val / maxVal) * 200;
    const x = index * (barWidth + spacing) + 50;
    const y = bottom - height;

    // Bar color
    ctx.fillStyle = 'gray';
    if (highlight.pivot === index) ctx.fillStyle = 'red';
    else if (highlight.j === index) ctx.fillStyle = 'orange';
    else if (highlight.i === index) ctx.fillStyle = 'gold';

    ctx.fillRect(x, y, barWidth, height);
    ctx.strokeRect(x, y, barWidth, height);

    ctx.fillStyle = 'black';
    ctx.font = '14px monospace';
    ctx.fillText(val, x + barWidth / 2, bottom + 15);
  });

  // Draw arrow from j to pivot
  if ('j' in highlight &amp;&amp; 'pivot' in highlight) {
    const xj = highlight.j * (barWidth + spacing) + 50 + barWidth / 2;
    const xp = highlight.pivot * (barWidth + spacing) + 50 + barWidth / 2;
    drawArrow(xj, bottom + 5, xp, bottom + 5);
  }
}

// Animate a swap between bars
function animateSwap(arr, i, j, callback) {
  const frames = 10;
  let frame = 0;
  const fromX = i * (barWidth + spacing) + 50;
  const toX = j * (barWidth + spacing) + 50;
  const diff = (toX - fromX) / frames;

  function animate() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    const maxVal = Math.max(...arr);
    arr.forEach((val, index) =&gt; {
      let x = index * (barWidth + spacing) + 50;
      if (index === i) x += frame * diff;
      else if (index === j) x -= frame * diff;

      const height = (val / maxVal) * 200;
      const y = bottom - height;

      ctx.fillStyle = (index === i || index === j) ? 'purple' : 'gray';
      ctx.fillRect(x, y, barWidth, height);
      ctx.strokeRect(x, y, barWidth, height);

      ctx.fillStyle = 'black';
      ctx.fillText(val, x + barWidth / 2, bottom + 15);
    });

    frame++;
    if (frame &lt;= frames) requestAnimationFrame(animate);
    else callback();
  }

  animate();
}

function renderStep() {
  if (currentStep &gt;= steps.length) return;

  const step = steps[currentStep];
  explanation.textContent = '';

  if (step.type === 'pivot') {
    drawBars(step.array, { pivot: step.pivot });
    explanation.textContent = `Select pivot: ${step.array[step.pivot]}`;
  } else if (step.type === 'compare') {
    drawBars(step.array, { j: step.j, pivot: step.pivot });
    explanation.textContent = `Compare arr[${step.j}] = ${step.array[step.j]} with pivot = ${step.array[step.pivot]}`;
  } else if (step.type === 'swap') {
    animateSwap(step.array, step.i, step.j, () =&gt; {
      drawBars(step.array);
      explanation.textContent = `Swap arr[${step.i}] = ${step.array[step.i]} with arr[${step.j}] = ${step.array[step.j]}`;
    });
  } else if (step.type === 'pivot-swap') {
    drawBars(step.array, { pivot: step.pivotFinal });
    explanation.textContent = `Place pivot at index ${step.pivotFinal}`;
  }
}

// Prepare steps and render first
traceQuickSort([...array]);
renderStep();

document.getElementById('next').addEventListener('click', () =&gt; {
  if (currentStep &lt; steps.length - 1) {
    currentStep++;
    renderStep();
  } else {
    explanation.textContent = "Sorting complete.";
    document.getElementById('next').disabled = true;
  }
});
&lt;/script&gt;

&lt;/body&gt;
&lt;/html&gt;</textarea> <iframe id="ynXv7" class="result_iframe" style="border:none;"></iframe>
 <script>{
const textarea = document.getElementById("M3pRc");
const iframe = document.getElementById("ynXv7");
const html = textarea.value;
const iframeHTML = `${html}`;
const doc = iframe.contentDocument || iframe.contentWindow.document;
doc.open();
doc.write(iframeHTML);
doc.close();
setTimeout(() => {
iframe.style.height = '0px';
const contentHeight = Math.max(
  doc.body.scrollHeight,
  doc.documentElement.scrollHeight
);
iframe.style.height = contentHeight + 'px';
}, 50);
}
		</script>
</div><h3 id="javascript-implementation">JavaScript Implementation</h3><p>Here’s a full quick sort implementation using the <strong>Lomuto partition scheme</strong> (simple and intuitive for beginners):</p><div>
 <div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
  <pre><code class="language-js">function quickSort(arr, left = 0, right = arr.length - 1) {
  if (left &lt; right) {
    const pivotIndex = partition(arr, left, right);
    // Recursively sort elements before and after partition
    quickSort(arr, left, pivotIndex - 1);
    quickSort(arr, pivotIndex + 1, right);
  }
  return arr;
}

function partition(arr, left, right) {
  const pivot = arr[right]; // Pivot is the last element
  let i = left - 1;

  for (let j = left; j &lt; right; j++) {
    if (arr[j] &lt; pivot) {
      i++;
      [arr[i], arr[j]] = [arr[j], arr[i]]; // Swap
    }
  }

  // Place pivot in its correct position
  [arr[i + 1], arr[right]] = [arr[right], arr[i + 1]];
  return i + 1; // Return pivot index
}

// Example usage
console.log(quickSort([5, 3, 8, 4, 2, 7, 1]));
// Output: [1, 2, 3, 4, 5, 7, 8]</code></pre>
 </div>
 <div class="snippet-container" id="pmTpL">
  <div class="snippet-header" onclick="toggleSnippetAndRefresh('pmTpL','cZxg1')">
   Try it in editor
  </div>
  <div class="snippet-body"><textarea id="cZxg1">function quickSort(arr, left = 0, right = arr.length - 1) {
  if (left &lt; right) {
    const pivotIndex = partition(arr, left, right);
    // Recursively sort elements before and after partition
    quickSort(arr, left, pivotIndex - 1);
    quickSort(arr, pivotIndex + 1, right);
  }
  return arr;
}

function partition(arr, left, right) {
  const pivot = arr[right]; // Pivot is the last element
  let i = left - 1;

  for (let j = left; j &lt; right; j++) {
    if (arr[j] &lt; pivot) {
      i++;
      [arr[i], arr[j]] = [arr[j], arr[i]]; // Swap
    }
  }

  // Place pivot in its correct position
  [arr[i + 1], arr[right]] = [arr[right], arr[i + 1]];
  return i + 1; // Return pivot index
}

// Example usage
console.log(quickSort([5, 3, 8, 4, 2, 7, 1]));
// Output: [1, 2, 3, 4, 5, 7, 8]</textarea> <br> <button onclick="renderIframeForClientJavascript('cZxg1','SvEWN')">Run</button> <iframe id="SvEWN" class="result_iframe" style="display: none;"></iframe>
   <script>
  {let editor1 = CodeMirror.fromTextArea(document.getElementById("cZxg1"), {
    mode: "javascript",
    lineNumbers:false,
    tabSize: 2
    });
    const mode = localStorage.getItem("mode") || "light";  
    const newTheme = mode === "dark" ? "material" : "default";
    editor1.setOption("theme", newTheme);

   codeMirrorMap.set("cZxg1", editor1);}
  </script>
  </div>
 </div>
</div><h3 id="recursion-flow-diagram">Recursion Flow Diagram</h3><p>Here’s a simplified call tree of how quick sort works on <code>[5, 3, 8, 4, 2]</code>:</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-bash">quickSort([5, 3, 8, 4, 2])
├─ pivot = 2 → [1st partition]
│  ├─ quickSort([...left of pivot]) → [3, 1]
│  └─ quickSort([...right of pivot]) → [8, 5, 4]
    ├─ Further recursive calls...</code></pre>
</div><p>At each level, the pivot reduces the unsorted region, shrinking the problem size.</p><h3 id="time-complexity">Time Complexity</h3><table>
 <thead>
  <tr>
   <th>Case</th>
   <th>Time Complexity</th>
   <th>Description</th>
  </tr>
 </thead>
 <tbody>
  <tr>
   <td>Best</td>
   <td>O(n log n)</td>
   <td>Balanced partitions</td>
  </tr>
  <tr>
   <td>Average</td>
   <td>O(n log n)</td>
   <td>Random data, good pivot</td>
  </tr>
  <tr>
   <td>Worst</td>
   <td>O(n²)</td>
   <td>Poor pivot (e.g., always smallest/largest)</td>
  </tr>
 </tbody>
</table><ul>
 <li>Worst-case arises when the pivot divides the array into very uneven parts (e.g., sorting a sorted array with last element as pivot).</li>
 <li><strong>Average case is very fast</strong>, and modern implementations use strategies to avoid worst-case behavior.</li>
</ul><h3 id="pivot-choice-matters">Pivot Choice Matters</h3><p>The efficiency of quick sort heavily depends on the choice of pivot. Here are some strategies:</p><ul>
 <li><strong>Last element</strong> (used above): simple but risky on sorted arrays.</li>
 <li><strong>Middle element</strong>: a reasonable default.</li>
 <li><strong>Random element</strong>: helps avoid worst-case.</li>
 <li><strong>Median-of-three</strong>: choose the median of first, middle, and last—reduces chance of imbalance.</li>
</ul><p>You can easily implement random pivoting in JavaScript by swapping a random index with the last one before partitioning:</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-js">function randomPartition(arr, left, right) {
  const randIndex = left + Math.floor(Math.random() * (right - left + 1));
  [arr[randIndex], arr[right]] = [arr[right], arr[randIndex]];
  return partition(arr, left, right);
}</code></pre>
</div><h3 id="practical-tips-for-js-developers">Practical Tips for JS Developers</h3><ul>
 <li><strong>Use in-place sorting</strong> when memory is limited.</li>
 <li>Avoid using quick sort on small arrays where insertion sort may be faster due to lower overhead.</li>
 <li>For large datasets or guaranteed performance, use merge sort or built-in methods like <code>Array.prototype.sort()</code> (which often use hybrid approaches).</li>
 <li>Be cautious of performance when sorting nearly sorted or reverse-sorted data with poor pivot selection.</li>
</ul><h3 id="conclusion">Conclusion</h3><p>Quick sort is a powerful and elegant algorithm that often outperforms merge sort in real-world use due to its in-place nature and average-case efficiency of O(n log n). Understanding how partitioning and pivot selection work gives you deeper control over its performance and applicability. As you continue learning sorting techniques, quick sort is a crucial algorithm to master, both in concept and implementation.</p><div class = "chapter-navi-section">
<a href="#top" class="nav-button prev">↑</a>
<a href='javascript-algorithms.htm#sorting-and-order-divide-and-conquer' class="nav-button toc-link">Index</a>
<a href="#bottom" class="nav-button next">↓</a>
</div>
<h2 id='time-complexity-and-recursion-trees'>5.3 Time Complexity and Recursion Trees</h2><p>Understanding the time complexity of recursive algorithms can be tricky at first, but recursion trees offer an intuitive and visual way to analyze how work is divided and accumulated in divide-and-conquer algorithms like <strong>merge sort</strong> and <strong>quick sort</strong>.</p><p>In this section, we’ll learn how to:</p><ul>
 <li>Use recursion trees to estimate time complexity,</li>
 <li>Apply this method to merge sort and quick sort,</li>
 <li>Connect the math to real code using JavaScript.</li>
</ul><h3 id="what-is-a-recursion-tree">What Is a Recursion Tree?</h3><p>A recursion tree is a diagram that maps out how a recursive algorithm breaks down a problem. Each node in the tree represents a recursive call, and the amount of <strong>work</strong> done at that level. By adding up the work across all levels, we can estimate the algorithm’s total time complexity.</p><h3 id="merge-sort-as-a-recursion-tree">Merge Sort as a Recursion Tree</h3><p>Merge sort splits the array into two halves at each step and does linear work (O(n)) during the merge step.</p><p>Let’s visualize the recursion tree for sorting an array of size <code>n = 8</code>:</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-bash">Level 0:           mergeSort(8)                → O(8)
Level 1:     mergeSort(4)   mergeSort(4)       → O(4) + O(4)
Level 2:   m(2) m(2)       m(2) m(2)           → 4 × O(2)
Level 3:  m(1)m(1)m(1)m(1) m(1)m(1)m(1)m(1)    → 8 × O(1)</code></pre>
</div><p>Each level does <strong>O(n)</strong> total work:</p><ul>
 <li>Level 0: 1 call × O(8)</li>
 <li>Level 1: 2 calls × O(4)</li>
 <li>Level 2: 4 calls × O(2)</li>
 <li>Level 3: 8 calls × O(1)</li>
</ul><p>Total number of levels: <code>log₂n</code> (splitting in half each time)</p><p><strong>Total time:</strong></p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-bash">O(n) work per level × log₂n levels → O(n log n)</code></pre>
</div><h3 id="javascript-code-for-merge-sort-breakdown">JavaScript Code for Merge Sort Breakdown</h3><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-js">function mergeSort(arr) {
  if (arr.length &lt;= 1) return arr;

  const mid = Math.floor(arr.length / 2);
  const left = mergeSort(arr.slice(0, mid));
  const right = mergeSort(arr.slice(mid));

  return merge(left, right); // O(n) merge step
}</code></pre>
</div><p>Each call to <code>mergeSort</code> divides the array in half and merges results. The recursion tree helps us track the depth and cost at each level.</p><h3 id="quick-sort-and-recursion-tree-variability">Quick Sort and Recursion Tree Variability</h3><p>Quick sort’s recursion tree <strong>depends on pivot choice</strong>.</p><h4 id="best-average-case">Best/Average Case</h4><p>Each partition splits the array roughly in half, like merge sort.</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-bash">Level 0:       quickSort(8)         → O(8)
Level 1:   qS(4)       qS(4)        → 2 × O(4)
Level 2: qS(2) qS(2) qS(2) qS(2)    → 4 × O(2)
...</code></pre>
</div><p>Same pattern: <code>log₂n</code> levels, O(n) per level → <strong>O(n log n)</strong> time.</p><h4 id="worst-case">Worst Case</h4><p>If the pivot is the smallest or largest element every time:</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-bash">quickSort(8)
 └─ quickSort(7)
     └─ quickSort(6)
         ...</code></pre>
</div><ul>
 <li>Tree depth: n</li>
 <li>Work per level: O(n), O(n–1), ..., O(1)</li>
</ul><p><strong>Total time:</strong></p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-bash">O(n²) (like a linked list of recursive calls)</code></pre>
</div><h3 id="javascript-code-for-recursive-depth">JavaScript Code for Recursive Depth</h3><p>Here's how you can trace recursive depth in quick sort:</p><div>
 <div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
  <pre><code class="language-js">function quickSort(arr, depth = 0) {
  if (arr.length &lt;= 1) return arr;

  const pivot = arr[arr.length - 1];
  const left = [], right = [];

  for (let i = 0; i &lt; arr.length - 1; i++) {
    if (arr[i] &lt; pivot) left.push(arr[i]);
    else right.push(arr[i]);
  }

  console.log(" ".repeat(depth * 2) + `quickSort: [${arr.join(", ")}]`);

  return [
    ...quickSort(left, depth + 1),
    pivot,
    ...quickSort(right, depth + 1)
  ];
}

quickSort([5, 3, 8, 1, 4]);</code></pre>
 </div>
 <div class="snippet-container" id="IGmhG">
  <div class="snippet-header" onclick="toggleSnippetAndRefresh('IGmhG','wiTES')">
   Try it in editor
  </div>
  <div class="snippet-body"><textarea id="wiTES">function quickSort(arr, depth = 0) {
  if (arr.length &lt;= 1) return arr;

  const pivot = arr[arr.length - 1];
  const left = [], right = [];

  for (let i = 0; i &lt; arr.length - 1; i++) {
    if (arr[i] &lt; pivot) left.push(arr[i]);
    else right.push(arr[i]);
  }

  console.log(" ".repeat(depth * 2) + `quickSort: [${arr.join(", ")}]`);

  return [
    ...quickSort(left, depth + 1),
    pivot,
    ...quickSort(right, depth + 1)
  ];
}

quickSort([5, 3, 8, 1, 4]);</textarea> <br> <button onclick="renderIframeForClientJavascript('wiTES','1AvCG')">Run</button> <iframe id="1AvCG" class="result_iframe" style="display: none;"></iframe>
   <script>
  {let editor1 = CodeMirror.fromTextArea(document.getElementById("wiTES"), {
    mode: "javascript",
    lineNumbers:false,
    tabSize: 2
    });
    const mode = localStorage.getItem("mode") || "light";  
    const newTheme = mode === "dark" ? "material" : "default";
    editor1.setOption("theme", newTheme);

   codeMirrorMap.set("wiTES", editor1);}
  </script>
  </div>
 </div>
</div><p>This logs recursive depth with indentation—mirroring the tree shape.</p><h3 id="intuition-behind-the-log-n-factor">Intuition Behind the <code>log n</code> Factor</h3><p>When an algorithm <strong>cuts the input size in half</strong> each time (like merge sort or best-case quick sort), it forms a <strong>binary tree</strong> of calls. A binary tree of depth <code>log₂n</code> means the recursion continues only about <code>log n</code> levels deep.</p><p>Combine this with <code>O(n)</code> work at each level, and you get the hallmark <strong>O(n log n)</strong> complexity of divide-and-conquer.</p><h3 id="summary">Summary</h3><p>Recursion trees help demystify the time complexity of recursive algorithms:</p><ul>
 <li><strong>Merge sort</strong> always has O(n log n) time due to balanced recursion and linear merging.</li>
 <li><strong>Quick sort</strong> is O(n log n) in the best case, but can degrade to O(n²) with poor pivot choices.</li>
 <li>The <code>log n</code> factor comes from the number of times you can divide the input in half.</li>
</ul><p>By connecting recursion trees to your JavaScript implementations, you'll build stronger intuition about how recursive algorithms scale—an essential skill in algorithm design.</p><p>The following animation shows the steps in quick sort.</p><div class="snippet-container" id="<!DOCTYPE html>
<html lang=&quot;en&quot;>
<head>
  <meta charset=&quot;UTF-8&quot;>
  <title>Quick Sort Visualizer</title>
  <style>
    body {
      font-family: sans-serif;
      display: flex;
      flex-direction: row;
      margin: 0;
      padding: 0;
    }
    canvas {
      background: #fff;
      border-right: 1px solid #ccc;
    }
    #controls {
      padding: 20px;
      width: 250px;
    }
    #controls button {
      padding: 10px 20px;
      font-size: 16px;
      margin-bottom: 10px;
    }
    #stack {
      font-family: monospace;
      white-space: pre;
      background: #f9f9f9;
      padding: 10px;
      border: 1px solid #ccc;
      max-height: 400px;
      overflow-y: auto;
    }
  </style>
</head>
<body>

<div id=&quot;controls&quot;>
  <button id=&quot;next&quot;>Next Step</button>
  <div>Comparisons: <span id=&quot;cmp&quot;>0</span></div>
  <div>Swaps: <span id=&quot;swp&quot;>0</span></div>
  <h3>Call Stack</h3>
  <div id=&quot;stack&quot;></div>
</div>
<canvas id=&quot;canvas&quot; width=&quot;700&quot; height=&quot;700&quot;></canvas>


<script>
const canvas = document.getElementById(&quot;canvas&quot;);
const ctx = canvas.getContext(&quot;2d&quot;);
const stackDisplay = document.getElementById(&quot;stack&quot;);
const cmpDisplay = document.getElementById(&quot;cmp&quot;);
const swpDisplay = document.getElementById(&quot;swp&quot;);

const boxSize = 40;
const spacing = 10;
const baseY = 40;
const levelHeight = 80;
const array = [33, 10, 55, 71, 29, 3, 42];

let comparisons = 0;
let swaps = 0;

let frames = [];
let currentFrame = 0;
let positions = []; // To track box positions

function generateQuickSortTrace(arr) {
  let steps = [];
  function recurse(start, end, depth, parentPos = null) {
    if (start > end) return;

    const pivot = end;
    steps.push({
      type: &quot;partition&quot;,
      start, end, pivot, depth, parentPos,
      snapshot: arr.slice()
    });

    let i = start;
    for (let j = start; j < end; j++) {
      steps.push({
        type: &quot;compare&quot;,
        i, j, pivot, array: arr.slice(), depth
      });
      comparisons++;
      if (arr[j] < arr[pivot]) {
        [arr[i], arr[j]] = [arr[j], arr[i]];
        steps.push({
          type: &quot;swap&quot;,
          i, j, array: arr.slice(), depth
        });
        swaps++;
        i++;
      }
    }

    [arr[i], arr[pivot]] = [arr[pivot], arr[i]];
    steps.push({
      type: &quot;pivotSwap&quot;,
      i, pivot, array: arr.slice(), depth
    });
    swaps++;

    // recurse left and right
    steps.push({ type: &quot;recurse&quot;, depth, start, end, mid: i });
    recurse(start, i - 1, depth + 1, { start, end, depth });
    recurse(i + 1, end, depth + 1, { start, end, depth });
  }
  recurse(0, arr.length - 1, 0);
  return steps;
}

const trace = generateQuickSortTrace([...array]);

function drawBox(x, y, value, color = &quot;lightgray&quot;) {
  ctx.fillStyle = color;
  ctx.fillRect(x, y, boxSize, boxSize);
  ctx.strokeStyle = &quot;black&quot;;
  ctx.strokeRect(x, y, boxSize, boxSize);
  ctx.fillStyle = &quot;black&quot;;
  ctx.textAlign = &quot;center&quot;;
  ctx.textBaseline = &quot;middle&quot;;
  ctx.fillText(value, x + boxSize / 2, y + boxSize / 2);
}

function drawArrow(x1, y1, x2, y2) {
  ctx.beginPath();
  ctx.moveTo(x1, y1);
  const cpX = (x1 + x2) / 2;
  ctx.bezierCurveTo(cpX, y1 - 40, cpX, y2 + 40, x2, y2);
  ctx.strokeStyle = &quot;blue&quot;;
  ctx.lineWidth = 2;
  ctx.stroke();
}

function drawFrame(step) {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  let depthMap = {};

  for (let i = 0; i <= currentFrame; i++) {
    const s = trace[i];
    if (s.snapshot) {
      const arr = s.snapshot;
      const y = baseY + s.depth * levelHeight;
      const offsetX = (canvas.width - arr.length * (boxSize + spacing)) / 2;
      depthMap[`${s.start}-${s.end}-${s.depth}`] = [];

      for (let j = s.start; j <= s.end; j++) {
        const x = j * (boxSize + spacing) + offsetX;
        drawBox(x, y, arr[j], j === s.pivot ? &quot;salmon&quot; : &quot;lightblue&quot;);
        depthMap[`${s.start}-${s.end}-${s.depth}`].push({ x, y });

        // track for arrow connection
        if (!positions[s.depth]) positions[s.depth] = {};
        positions[s.depth][j] = { x, y };
      }

      if (s.parentPos) {
        const key = `${s.parentPos.start}-${s.parentPos.end}-${s.parentPos.depth}`;
        const parentBoxes = depthMap[key];
        if (parentBoxes) {
          const childBoxes = depthMap[`${s.start}-${s.end}-${s.depth}`];
          if (childBoxes) {
            drawArrow(
              parentBoxes[Math.floor(parentBoxes.length / 2)].x + boxSize / 2,
              parentBoxes[0].y + boxSize,
              childBoxes[Math.floor(childBoxes.length / 2)].x + boxSize / 2,
              childBoxes[0].y
            );
          }
        }
      }
    }

    if (s.type === &quot;compare&quot;) {
      const y = baseY + s.depth * levelHeight;
      const offsetX = (canvas.width - s.array.length * (boxSize + spacing)) / 2;
      for (let j = 0; j < s.array.length; j++) {
        const x = j * (boxSize + spacing) + offsetX;
        let color = &quot;lightgray&quot;;
        if (j === s.pivot) color = &quot;salmon&quot;;
        else if (j === s.j) color = &quot;orange&quot;;
        drawBox(x, y, s.array[j], color);
      }
    }

    if (s.type === &quot;swap&quot; || s.type === &quot;pivotSwap&quot;) {
      const y = baseY + s.depth * levelHeight;
      const offsetX = (canvas.width - s.array.length * (boxSize + spacing)) / 2;
      for (let j = 0; j < s.array.length; j++) {
        const x = j * (boxSize + spacing) + offsetX;
        let color = &quot;lightgray&quot;;
        if (j === s.i || j === s.j || j === s.pivot) color = &quot;gold&quot;;
        drawBox(x, y, s.array[j], color);
      }
    }
  }

  cmpDisplay.textContent = comparisons;
  swpDisplay.textContent = swaps;

  // Show call stack
  const callStack = [];
  for (let i = 0; i <= currentFrame; i++) {
    const s = trace[i];
    if (s.type === &quot;recurse&quot;) {
      callStack.push(`quicksort(${s.start}, ${s.end})`);
    }
  }
  stackDisplay.textContent = callStack.reverse().join(&quot;\n&quot;);
}

// Init first frame
drawFrame(trace[0]);

document.getElementById(&quot;next&quot;).addEventListener(&quot;click&quot;, () => {
  if (currentFrame < trace.length - 1) {
    currentFrame++;
    drawFrame(trace[currentFrame]);
  }
});
</script>

</body>
</html>ID"><textarea id="GPri4" style="display: none;">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
  &lt;meta charset="UTF-8"&gt;
  &lt;title&gt;Quick Sort Visualizer&lt;/title&gt;
  &lt;style&gt;
    body {
      font-family: sans-serif;
      display: flex;
      flex-direction: row;
      margin: 0;
      padding: 0;
    }
    canvas {
      background: #fff;
      border-right: 1px solid #ccc;
    }
    #controls {
      padding: 20px;
      width: 250px;
    }
    #controls button {
      padding: 10px 20px;
      font-size: 16px;
      margin-bottom: 10px;
    }
    #stack {
      font-family: monospace;
      white-space: pre;
      background: #f9f9f9;
      padding: 10px;
      border: 1px solid #ccc;
      max-height: 400px;
      overflow-y: auto;
    }
  &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;div id="controls"&gt;
  &lt;button id="next"&gt;Next Step&lt;/button&gt;
  &lt;div&gt;Comparisons: &lt;span id="cmp"&gt;0&lt;/span&gt;&lt;/div&gt;
  &lt;div&gt;Swaps: &lt;span id="swp"&gt;0&lt;/span&gt;&lt;/div&gt;
  &lt;h3&gt;Call Stack&lt;/h3&gt;
  &lt;div id="stack"&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;canvas id="canvas" width="700" height="700"&gt;&lt;/canvas&gt;


&lt;script&gt;
const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");
const stackDisplay = document.getElementById("stack");
const cmpDisplay = document.getElementById("cmp");
const swpDisplay = document.getElementById("swp");

const boxSize = 40;
const spacing = 10;
const baseY = 40;
const levelHeight = 80;
const array = [33, 10, 55, 71, 29, 3, 42];

let comparisons = 0;
let swaps = 0;

let frames = [];
let currentFrame = 0;
let positions = []; // To track box positions

function generateQuickSortTrace(arr) {
  let steps = [];
  function recurse(start, end, depth, parentPos = null) {
    if (start &gt; end) return;

    const pivot = end;
    steps.push({
      type: "partition",
      start, end, pivot, depth, parentPos,
      snapshot: arr.slice()
    });

    let i = start;
    for (let j = start; j &lt; end; j++) {
      steps.push({
        type: "compare",
        i, j, pivot, array: arr.slice(), depth
      });
      comparisons++;
      if (arr[j] &lt; arr[pivot]) {
        [arr[i], arr[j]] = [arr[j], arr[i]];
        steps.push({
          type: "swap",
          i, j, array: arr.slice(), depth
        });
        swaps++;
        i++;
      }
    }

    [arr[i], arr[pivot]] = [arr[pivot], arr[i]];
    steps.push({
      type: "pivotSwap",
      i, pivot, array: arr.slice(), depth
    });
    swaps++;

    // recurse left and right
    steps.push({ type: "recurse", depth, start, end, mid: i });
    recurse(start, i - 1, depth + 1, { start, end, depth });
    recurse(i + 1, end, depth + 1, { start, end, depth });
  }
  recurse(0, arr.length - 1, 0);
  return steps;
}

const trace = generateQuickSortTrace([...array]);

function drawBox(x, y, value, color = "lightgray") {
  ctx.fillStyle = color;
  ctx.fillRect(x, y, boxSize, boxSize);
  ctx.strokeStyle = "black";
  ctx.strokeRect(x, y, boxSize, boxSize);
  ctx.fillStyle = "black";
  ctx.textAlign = "center";
  ctx.textBaseline = "middle";
  ctx.fillText(value, x + boxSize / 2, y + boxSize / 2);
}

function drawArrow(x1, y1, x2, y2) {
  ctx.beginPath();
  ctx.moveTo(x1, y1);
  const cpX = (x1 + x2) / 2;
  ctx.bezierCurveTo(cpX, y1 - 40, cpX, y2 + 40, x2, y2);
  ctx.strokeStyle = "blue";
  ctx.lineWidth = 2;
  ctx.stroke();
}

function drawFrame(step) {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  let depthMap = {};

  for (let i = 0; i &lt;= currentFrame; i++) {
    const s = trace[i];
    if (s.snapshot) {
      const arr = s.snapshot;
      const y = baseY + s.depth * levelHeight;
      const offsetX = (canvas.width - arr.length * (boxSize + spacing)) / 2;
      depthMap[`${s.start}-${s.end}-${s.depth}`] = [];

      for (let j = s.start; j &lt;= s.end; j++) {
        const x = j * (boxSize + spacing) + offsetX;
        drawBox(x, y, arr[j], j === s.pivot ? "salmon" : "lightblue");
        depthMap[`${s.start}-${s.end}-${s.depth}`].push({ x, y });

        // track for arrow connection
        if (!positions[s.depth]) positions[s.depth] = {};
        positions[s.depth][j] = { x, y };
      }

      if (s.parentPos) {
        const key = `${s.parentPos.start}-${s.parentPos.end}-${s.parentPos.depth}`;
        const parentBoxes = depthMap[key];
        if (parentBoxes) {
          const childBoxes = depthMap[`${s.start}-${s.end}-${s.depth}`];
          if (childBoxes) {
            drawArrow(
              parentBoxes[Math.floor(parentBoxes.length / 2)].x + boxSize / 2,
              parentBoxes[0].y + boxSize,
              childBoxes[Math.floor(childBoxes.length / 2)].x + boxSize / 2,
              childBoxes[0].y
            );
          }
        }
      }
    }

    if (s.type === "compare") {
      const y = baseY + s.depth * levelHeight;
      const offsetX = (canvas.width - s.array.length * (boxSize + spacing)) / 2;
      for (let j = 0; j &lt; s.array.length; j++) {
        const x = j * (boxSize + spacing) + offsetX;
        let color = "lightgray";
        if (j === s.pivot) color = "salmon";
        else if (j === s.j) color = "orange";
        drawBox(x, y, s.array[j], color);
      }
    }

    if (s.type === "swap" || s.type === "pivotSwap") {
      const y = baseY + s.depth * levelHeight;
      const offsetX = (canvas.width - s.array.length * (boxSize + spacing)) / 2;
      for (let j = 0; j &lt; s.array.length; j++) {
        const x = j * (boxSize + spacing) + offsetX;
        let color = "lightgray";
        if (j === s.i || j === s.j || j === s.pivot) color = "gold";
        drawBox(x, y, s.array[j], color);
      }
    }
  }

  cmpDisplay.textContent = comparisons;
  swpDisplay.textContent = swaps;

  // Show call stack
  const callStack = [];
  for (let i = 0; i &lt;= currentFrame; i++) {
    const s = trace[i];
    if (s.type === "recurse") {
      callStack.push(`quicksort(${s.start}, ${s.end})`);
    }
  }
  stackDisplay.textContent = callStack.reverse().join("\n");
}

// Init first frame
drawFrame(trace[0]);

document.getElementById("next").addEventListener("click", () =&gt; {
  if (currentFrame &lt; trace.length - 1) {
    currentFrame++;
    drawFrame(trace[currentFrame]);
  }
});
&lt;/script&gt;

&lt;/body&gt;
&lt;/html&gt;</textarea> <iframe id="pxq6I" class="result_iframe" style="border:none;"></iframe>
 <script>{
const textarea = document.getElementById("GPri4");
const iframe = document.getElementById("pxq6I");
const html = textarea.value;
const iframeHTML = `${html}`;
const doc = iframe.contentDocument || iframe.contentWindow.document;
doc.open();
doc.write(iframeHTML);
doc.close();
setTimeout(() => {
iframe.style.height = '0px';
const contentHeight = Math.max(
  doc.body.scrollHeight,
  doc.documentElement.scrollHeight
);
iframe.style.height = contentHeight + 'px';
}, 50);
}
		</script>
</div><div class = "chapter-navi-section">
<a href="javascript-algorithms-sorting-and-order-elementary-sorting-algorithms.htm" class="nav-button prev">←</a>
<a href='javascript-algorithms.htm#sorting-and-order-divide-and-conquer' class="nav-button toc-link">Index</a>
<a href="javascript-algorithms-sorting-and-order-linear-time-sorting.htm" class="nav-button next">→</a>
</div>
<section class="download-section">
  <div class="book-cover" style="background-color: #f9f6f1;border: 1px solid #ccc;"> 
    <div class="book-cover-title" style="font-size: 18px;color: #333;top: 20px;">JavaScript Algorithms</div>
    <div class="book-cover-author">readbytes</div>
    <div class="book-cover-bottom-stripe" style="background-color: #333;"></div>
    <img class="book-cover-icon" style="width: 80px;height: 80px;top: 70px;" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFoAAABaCAYAAAA4qEECAAAErElEQVR4Xu2dPWgUQRiGo6BB8I+AlV3w9gzptLBWsLQ89O7ARrDXSivTCTaCnWhn7pQTxOoInpjCeEQQLC2CjVqoVSwMFpp1Jtzo7Luzs/Nd7uZ29r4HPpDsu7vPvIl7+SGTmRmGYRiGYZjCEzVacdnn9NX7+3DdXkGhMg+u3Su6SNztzsZvevH/efED8zrJbM+6EGJ2K5Hv9w9gRpHnXMyik2VsYVaHWJx7tt/bTOQ3urOYUch3QJ5z0YtOCeuQiqNlvybyto/ktbVDcG2jc5GLNgoriMW5Z/svPyfy693DmFHE71ePwrUznQta9ISeyViyKBIziri/Mpe8tt25kEXjMR1ScbQsPC5W5jCjMJT8DTM6MuO6vrHjIkIszj2LL3y2ktOPiy+Y0VE5l/V5IU+EVBwtm/wUzva4SL/wOZUsJ2993rCJEIujZJMl2174Up/C5T8u9LGtzyu6SNkH1+6VhUargkJlHVy7f5aW9qJUqeZy5zguufToBeAxZoRw0Z7goj3BRXuCi/YEF+0BvWQue0xgwfrMiy+aMM8QEUW+w2IHb8fC/+C5jCOGMhOPiqi+vG47zjiABVbr7XOYUWC2Um+fxwwDiKJeYXGYMYHniNnGDDPAUJZTyYph30nTg+G7f5VLj89gzBW8lu2xMzWIIt5iMZgZBrzmqK4bJFhENOLnatRsfcR7YKb0YAELF5+cwsyowHudrLcvYKZ0iIV+wIVjZhzgPaMR/+8pFIbFeilZUWm2Vyd5/5GxWOvsx4VkTbXROovn+wJdMqfevoHnFoKUaMbgeZMAnbIGzysEKGmZiX4DKKo/um5wMg6eWwhsgtVm62cRFoEOJg/xtltZxwqBTV4inuEHcZHztc4RzI0LvLeY15iRBF+0wrDgsX6qZXpUYEanNEVLROY3ZfHDgvdwuU+pipYs1h7OpUqI4z2YGxa8dqXefooZE6UrWoGFiMn8nRIXoubyTbymeLPzO7C0RUuiRvuXoRwyeI1hrlPqoiUnap1jWNLilU7mr0sgeK746rOFGRdKX7QCC4tyHiXi+DU8BzMUpqZoiSzXpTzMZOUoTFXROxh+xKV/gYPHqvVlp88q8pi+ogdgoabBc3bD1BYtEdfcxnLHeK/pLVoiHxvJktsPMDMKpr5oX3DRnuCiPcFFe4KL9gQX7Qku2hNctCe4aE94K1puD6mXNsmpOv74KUTnxEdmEQb9TOA5kx70M6KfcO/u8/j2nWffxb+XskZm9MHjw2YjgrTKygnFeUaF5cSEjZ4c9kJyz/Z7mxTpEJ0T0nhMhyRBy+5sTuXioAjR2UmaKEHJ/tsBLM9BJ0TnXGmiBCWb2GbN5oCE6GyVJkq4Z3FXxo3ubJaDiRCdM6VJErSscTtik0MWITobpYkS7lncKVfblREdbITonJImSVCyKAz7i1KkQ3ROSJMkaNnc7Ygp0iE6Z0pjTockjC8iBmEJRTpEZ6M0ZnRIwrhTrmU7Yop0iM4paTyusyvhnO2IKdIhOqdeWLLYlbDtL0oM/jaKi4MiRGcnaZIwPt8c/zZKnoNOiM4J6SIM+pnAcyY96GekYJtvf0I/EyE6MwzDMAzDjI+/5MPGam/zucIAAAAASUVORK5CYII="/>
  </div>
  <div class="download-info">
    <h2 id='bottom'>Download This Ebook</h2>
    <p class="format-label">Available formats:</p>
    <div class="download-buttons">
      <a href="javascript-algorithms.pdf" class="download-button">📄 PDF</a>
      <a href="javascript-algorithms.epub" class="download-button">📘 EPUB</a>
    </div>
  </div>
</section><div class='related-books'>
<h2>Java Introduction Books</h2>
<div class='related-book-list'>
<a href="javascript-algorithms.htm">
<div class="book-cover" style="background-color: #f9f6f1;border: 1px solid #ccc;"> 
    <div class="book-cover-title" style="font-size: 18px;color: #333;top: 20px;">JavaScript Algorithms</div>
    <div class="book-cover-author">readbytes</div>
    <div class="book-cover-bottom-stripe" style="background-color: #333;"></div>
    <img class="book-cover-icon" style="width: 80px;height: 80px;top: 70px;" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFoAAABaCAYAAAA4qEECAAAErElEQVR4Xu2dPWgUQRiGo6BB8I+AlV3w9gzptLBWsLQ89O7ARrDXSivTCTaCnWhn7pQTxOoInpjCeEQQLC2CjVqoVSwMFpp1Jtzo7Luzs/Nd7uZ29r4HPpDsu7vPvIl7+SGTmRmGYRiGYZjCEzVacdnn9NX7+3DdXkGhMg+u3Su6SNztzsZvevH/efED8zrJbM+6EGJ2K5Hv9w9gRpHnXMyik2VsYVaHWJx7tt/bTOQ3urOYUch3QJ5z0YtOCeuQiqNlvybyto/ktbVDcG2jc5GLNgoriMW5Z/svPyfy693DmFHE71ePwrUznQta9ISeyViyKBIziri/Mpe8tt25kEXjMR1ScbQsPC5W5jCjMJT8DTM6MuO6vrHjIkIszj2LL3y2ktOPiy+Y0VE5l/V5IU+EVBwtm/wUzva4SL/wOZUsJ2993rCJEIujZJMl2174Up/C5T8u9LGtzyu6SNkH1+6VhUargkJlHVy7f5aW9qJUqeZy5zguufToBeAxZoRw0Z7goj3BRXuCi/YEF+0BvWQue0xgwfrMiy+aMM8QEUW+w2IHb8fC/+C5jCOGMhOPiqi+vG47zjiABVbr7XOYUWC2Um+fxwwDiKJeYXGYMYHniNnGDDPAUJZTyYph30nTg+G7f5VLj89gzBW8lu2xMzWIIt5iMZgZBrzmqK4bJFhENOLnatRsfcR7YKb0YAELF5+cwsyowHudrLcvYKZ0iIV+wIVjZhzgPaMR/+8pFIbFeilZUWm2Vyd5/5GxWOvsx4VkTbXROovn+wJdMqfevoHnFoKUaMbgeZMAnbIGzysEKGmZiX4DKKo/um5wMg6eWwhsgtVm62cRFoEOJg/xtltZxwqBTV4inuEHcZHztc4RzI0LvLeY15iRBF+0wrDgsX6qZXpUYEanNEVLROY3ZfHDgvdwuU+pipYs1h7OpUqI4z2YGxa8dqXefooZE6UrWoGFiMn8nRIXoubyTbymeLPzO7C0RUuiRvuXoRwyeI1hrlPqoiUnap1jWNLilU7mr0sgeK746rOFGRdKX7QCC4tyHiXi+DU8BzMUpqZoiSzXpTzMZOUoTFXROxh+xKV/gYPHqvVlp88q8pi+ogdgoabBc3bD1BYtEdfcxnLHeK/pLVoiHxvJktsPMDMKpr5oX3DRnuCiPcFFe4KL9gQX7Qku2hNctCe4aE94K1puD6mXNsmpOv74KUTnxEdmEQb9TOA5kx70M6KfcO/u8/j2nWffxb+XskZm9MHjw2YjgrTKygnFeUaF5cSEjZ4c9kJyz/Z7mxTpEJ0T0nhMhyRBy+5sTuXioAjR2UmaKEHJ/tsBLM9BJ0TnXGmiBCWb2GbN5oCE6GyVJkq4Z3FXxo3ubJaDiRCdM6VJErSscTtik0MWITobpYkS7lncKVfblREdbITonJImSVCyKAz7i1KkQ3ROSJMkaNnc7Ygp0iE6Z0pjTockjC8iBmEJRTpEZ6M0ZnRIwrhTrmU7Yop0iM4paTyusyvhnO2IKdIhOqdeWLLYlbDtL0oM/jaKi4MiRGcnaZIwPt8c/zZKnoNOiM4J6SIM+pnAcyY96GekYJtvf0I/EyE6MwzDMAzDjI+/5MPGam/zucIAAAAASUVORK5CYII="/>
  </div>
</a>



<a href='java.htm'><div class='book-cover' style='background-color: #f9f6f1;color: #111111;border: 1px solid #ccc;display: flex;justify-content: center;align-items: center;text-align: center;'>More Java Books</div></a>
</div>
</div>
  </div>
  <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/prism.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
  
  <script>
    function copyCode(button) {
      const code = button.nextElementSibling.innerText;
      navigator.clipboard.writeText(code).then(() => {
        button.textContent = 'Copied!';
        setTimeout(() => { button.textContent = 'Copy'; }, 1500);
      });
    }
  </script>  
<div id="floatingLog" aria-live="polite" role="alert"></div>
<footer class="page-footer">
    <nav>
      <a href="https://readbytes.github.io">Home</a> | 
      Email:<script language="JavaScript" type="text/javascript">
var part1 = 'yinpeng';var part6 = '263';var part2 = Math.pow(2,6);var part3 = String.fromCharCode(part2);var part4 = 'hotmail dot com';var part5 = part1 + String.fromCharCode(part2) + part4;document.write(part1 + part6 + part3 + part4);
</script>
    </nav>
  <p>© 2025 — All rights reserved.</p>    
  </footer>

</body>
</html>