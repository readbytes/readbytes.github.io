<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>JavaScript Algorithms Graph Representations</title>
<link rel='shortcut icon' href='https://java2s.com/style/favicon.ico'>
<link href="https://fonts.googleapis.com/css2?family=Merriweather&display=swap" rel="stylesheet" />
<link href="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet" />


  <script>
  const mode = localStorage.getItem('mode') || 'light';
  document.documentElement.classList.add(`${mode}-mode`);
  </script>   
<style> 
html {
  scroll-behavior: smooth;
}

body {
  font-family: 'Merriweather', serif;
  margin: 0;
  padding: 2rem 1rem;
  font-size: 15px;
  line-height: 1.5;
  transition: background-color 0.3s, color 0.3s;
}

.container {
  max-width: 700px;
  margin: 0 auto;
  padding: 1rem 2rem;
  box-shadow: 0 0 15px rgba(0,0,0,0.1);
}

h1, h2, h3 {
  font-weight: 600;
  margin-top: 2.5rem;
  margin-bottom: 1rem;
  line-height: 1.2;
}

h1 { font-size: 1.8rem; }
h2 { font-size: 1.4rem; }
h3 { font-size: 1.2rem; }

table {
  width: 100%;
  border-collapse: collapse;
  font-family: sans-serif;
  font-size: 1em;
  margin: 1em 0;
}

th, td {
  padding: 0.6em 1em;
  text-align: left;
  border: 1px solid;
}

tr:nth-child(even) {
  background-color: inherit;
}

tr:hover {
  background-color: inherit;
}

a {
  text-decoration: none;
  transition: color 0.2s;
}

a:hover {
  text-decoration: underline;
}

code {
  color: #d35400;
}

.book-title-chapter {
  font-family: 'Merriweather', serif;
  font-size: 2rem;
  font-weight: bold;
  text-align: center;
  margin-bottom: 2rem;
  border-bottom: 2px solid;
  padding-bottom: 0.5rem;
}

.book-subtitle-chapter {
  text-align: center;
  font-size: 1rem;
  margin-top: -1rem;
  margin-bottom: 2rem;
}

.related-books {
  margin-top: 40px;
}

.related-book-list {
  display: flex;
  flex-wrap: wrap;
  gap: 20px;
}

    .book-cover {
      width: 130px;
      height: 180px;
      font-family: Arial, sans-serif;
      position: relative;
      overflow: hidden;      
      line-height: normal;
      box-shadow: 2px 2px 4px rgba(0,0,0,0.1);
    }
    .book-cover-bottom-stripe {
      position: absolute;
      bottom: 0;
      left: 0;
      height: 5px;
      width: 100%;
    }
    .book-cover-title {
      position: absolute;
      width: 100%;
      text-align: center;
      font-weight: bold;
    }
     
    .book-cover-icon {
      position: absolute;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      align-items: center;
      justify-content: center; 
    }

    .book-cover-author {
      position: absolute;
      bottom: 10px;
      width: 100%;
      text-align: center;
      font-size: 8px;
      color: #333;
    }

.page-footer {
  margin-top: 4rem;
  padding: 1rem 0;
  text-align: center;
  font-size: 0.85rem;
  border-top: 1px solid;
}

.chapter-navi-section {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding-bottom: 10px;
}

.nav-link {
  color: inherit;
  text-decoration: none;
  opacity: 0.5;
  transition: opacity 0.3s ease, text-decoration 0.3s ease;
}

.nav-link:hover {
  opacity: 0.9;
  text-decoration: underline;
}

.prev { text-align: left; }
.toc-link { text-align: center; }
.next { text-align: right; }

.download-section {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 2rem;
  padding: 2rem 1rem;
  max-width: 600px;
  margin: 3rem auto;
  border-radius: 12px;
  box-shadow: 0 4px 10px rgba(0,0,0,0.05);
}

.download-info h2 {
  margin: 0 0 0.5rem;
  font-size: 1.2rem;
}

.format-label {
  margin: 0 0 0.5rem;
  font-size: 0.95rem;
}

.download-buttons {
  display: flex;
  gap: 1rem;
}

.download-button {
  background-color: #4A90E2;
  color: white;
  padding: 0.5em 1.2em;
  border-radius: 25px;
  font-size: 0.95rem;
  text-decoration: none;
  transition: background-color 0.3s ease;
}

.download-button:hover {
  background-color: #357ABD;
}

.code-block {
  position: relative;
  margin-bottom: 1em;
}

.copy-button {
  background: transparent;
  color: white;
  position: absolute;
  top: 8px;
  right: 8px;
  border: none;
  padding: 4px 8px;
  font-size: 12px;
  border-radius: 4px;
  cursor: pointer;
  z-index: 1;
}

.copy-button:hover {
  background-color: #0056b3;
}

.snippet-container {
  overflow: hidden;
}

.snippet-header {
  padding: 0.75rem 1rem;
  cursor: pointer;
  font-size: 1rem;
    background-color: #eeeeee;
    color:  #111111; 
    border-radius: 8px;
    cursor: pointer;
    box-shadow: 0 4px 6px rgba(0,0,0,0.1);  
}

.snippet-body {
  display: none;
  font-family: monospace;
}

.snippet-container.open .snippet-body {
  display: block;
}

.CodeMirror {
  border: 2px solid #ccc;
  border-radius: 4px;
  resize: vertical;
}

/* === Light Mode === */
html.light-mode {
  background-color: #f8f7f5;
  color: #333;
}

html.light-mode .container {
  background: white;
}

html.light-mode .book-title-chapter {
  color: #2c3e50;
  border-color: #ccc;
}
html.light-mode .book-subtitle-chapter{
  color: #888;
}

html.light-mode .page-footer,
html.light-mode .series-name,
html.light-mode .book-subtitle,
html.light-mode .format-label {
  color: #888;
}

html.light-mode .related-books h2 {
  color: #333;
  border-bottom: 2px solid #eee;
}

html.light-mode .book-title {
  color: #fff;
}

html.light-mode .book-cover {
  border: 1px solid #ccc;
}

html.light-mode th {
  background-color: #f2f2f2;
}

html.light-mode tr:nth-child(even) {
  background-color: #fafafa;
}

html.light-mode tr:hover {
  background-color: #e6f7ff;
}

html.light-mode a,
html.light-mode .page-footer a {
  color: #000;
}

/* === Dark Mode === */
html.dark-mode {
  background-color: #181818;
  color: #e0e0e0;
}

html.dark-mode .container {
  background: #222;
}

html.dark-mode .book-title-chapter {
  color: #ddd;
  border-color: #444;
}

html.dark-mode .snippet-header {
    background-color: #333;
    color:  #ddd; 
}


html.dark-mode .book-subtitle-chapter,
html.dark-mode .page-footer,
html.dark-mode .series-name,
html.dark-mode .book-subtitle,
html.dark-mode .book-footer,
html.dark-mode .format-label {
  color: #aaa;
}

html.dark-mode .related-books h2 {
  color: #ddd;
  border-bottom: 2px solid #333;
}

html.dark-mode .book-title {
  color: #fff;
}

html.dark-mode .book-cover {
  border: 1px solid #555;
}

html.dark-mode th {
  background-color: #333;
  color: #fff;
}

html.dark-mode td {
  border-color: #444;
}

html.dark-mode tr:nth-child(even) {
  background-color: #2a2a2a;
}

html.dark-mode tr:hover {
  background-color: #2c3e50;
}

html.dark-mode a,
html.dark-mode .page-footer a {
  color: #eee;
}

    .dialog-backdrop {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: rgba(0,0,0,0.5);
      display: none;
      justify-content: center;
      align-items: center;
      z-index: 10;
    }

    .dialog {
      background: white;
      padding: 20px;
      width: 90vw;
      height: 80vh;
      border-radius: 8px;
      box-shadow: 0 0 20px rgba(0,0,0,0.3);
      display: flex;
      flex-direction: column;
    }
    .dialog-content {
      display: flex;
      flex: 1;
      gap: 20px;
      margin-top: 10px;
    }
    .dialog h2 {
      margin-top: 0;
    }

    .textarea_dialog {
      width: 50%;
      height: 100%;
      resize: none;
      font-family: monospace;
      font-size: 14px;
      padding: 10px;
      box-sizing: border-box;
      border: 1px solid #ccc;
    }

    .iframe_dialog {
      width: 50%;
      height: 100%;
      border: 1px solid #ccc;
    }
    .controls_dialog {
      display: flex;
      justify-content: space-between;
      margin-top: 10px;
    }    
    button { padding: 0.5em 1em; background: green; color: white; border: none; cursor: pointer; }
    button:hover { background: #1e7e34; }
    .result_iframe { width:99%; height:200px; margin-top: 1em;  resize: both;border:1px solid #ccc;}        
</style>
</head>
<body> 
  <div class="container">
    <div class = "chapter-navi-section">
<a href="javascript-algorithms-balanced-search-trees.htm" class="nav-button prev">←</a>
<a href='javascript-algorithms.htm#graph-representations' class="nav-button toc-link">Index</a>
<a href="javascript-algorithms-graphs-traversals.htm" class="nav-button next">→</a>
</div>

    <h1 class="book-title-chapter" id = 'top'>Graph Representations</h1>
    <h3 class="book-subtitle-chapter">JavaScript Algorithms</h3>   
    <!-- <h1 class ="chapter-title"></h1> -->
    <h2 id='adjacency-lists-and-matrices-in-js'>13.1 Adjacency Lists and Matrices in JS</h2><p>Graphs are powerful data structures used to model relationships between entities—think social networks, maps, or dependency graphs. To work with graphs in JavaScript, we need a way to represent the nodes (vertices) and their connections (edges). The two most common representations are:</p><ul>
 <li><strong>Adjacency List</strong></li>
 <li><strong>Adjacency Matrix</strong></li>
</ul><p>Each has its own trade-offs in terms of memory usage and performance for different operations. Let’s explore both.</p><div class="snippet-container" id="<!DOCTYPE html>
<html lang=&quot;en&quot;>
<head>
  <meta charset=&quot;UTF-8&quot;>
  <title>Graph Visualizer</title>
  <style>
    body {
      font-family: sans-serif;
      text-align: center;
      padding: 20px;
    }
    canvas {
      border: 1px solid #ccc;
      background: #f9f9f9;
      cursor: pointer;
    }
    input, button {
      font-size: 16px;
      padding: 6px;
      margin: 5px;
    }
  </style>
</head>
<body>
<h2>Graph Visualizer</h2>
<p>Click on canvas to add nodes. Click two nodes to add an edge between them.</p>
<canvas id=&quot;canvas&quot; width=&quot;600&quot; height=&quot;600&quot;></canvas>
<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
let nodes = [];
let edges = [];
let selectedNode = null;

canvas.addEventListener('click', handleCanvasClick);

function handleCanvasClick(event) {
  const rect = canvas.getBoundingClientRect();
  const x = event.clientX - rect.left;
  const y = event.clientY - rect.top;
  const clickedNode = nodes.find(n => Math.hypot(n.x - x, n.y - y) < 20);
  if (clickedNode) {
    if (selectedNode &amp;&amp; selectedNode !== clickedNode) {
      edges.push({ from: selectedNode, to: clickedNode });
      selectedNode = null;
    } else {
      selectedNode = clickedNode;
    }
  } else {
    nodes.push({ x, y, label: String.fromCharCode(65 + nodes.length) });
  }
  drawGraph();
}

function drawGraph() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  // Draw edges
  ctx.strokeStyle = '#333';
  ctx.lineWidth = 2;
  for (const edge of edges) {
    ctx.beginPath();
    ctx.moveTo(edge.from.x, edge.from.y);
    ctx.lineTo(edge.to.x, edge.to.y);
    ctx.stroke();
  }

  // Draw nodes
  for (const node of nodes) {
    ctx.beginPath();
    ctx.arc(node.x, node.y, 20, 0, 2 * Math.PI);
    ctx.fillStyle = node === selectedNode ? '#f39c12' : '#3498db';
    ctx.fill();
    ctx.strokeStyle = '#2c3e50';
    ctx.stroke();

    ctx.fillStyle = '#fff';
    ctx.font = '16px Arial';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(node.label, node.x, node.y);
  }
}
</script>
</body>
</html>ID"><textarea id="UneGU" style="display: none;">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
  &lt;meta charset="UTF-8"&gt;
  &lt;title&gt;Graph Visualizer&lt;/title&gt;
  &lt;style&gt;
    body {
      font-family: sans-serif;
      text-align: center;
      padding: 20px;
    }
    canvas {
      border: 1px solid #ccc;
      background: #f9f9f9;
      cursor: pointer;
    }
    input, button {
      font-size: 16px;
      padding: 6px;
      margin: 5px;
    }
  &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;h2&gt;Graph Visualizer&lt;/h2&gt;
&lt;p&gt;Click on canvas to add nodes. Click two nodes to add an edge between them.&lt;/p&gt;
&lt;canvas id="canvas" width="600" height="600"&gt;&lt;/canvas&gt;
&lt;script&gt;
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
let nodes = [];
let edges = [];
let selectedNode = null;

canvas.addEventListener('click', handleCanvasClick);

function handleCanvasClick(event) {
  const rect = canvas.getBoundingClientRect();
  const x = event.clientX - rect.left;
  const y = event.clientY - rect.top;
  const clickedNode = nodes.find(n =&gt; Math.hypot(n.x - x, n.y - y) &lt; 20);
  if (clickedNode) {
    if (selectedNode &amp;&amp; selectedNode !== clickedNode) {
      edges.push({ from: selectedNode, to: clickedNode });
      selectedNode = null;
    } else {
      selectedNode = clickedNode;
    }
  } else {
    nodes.push({ x, y, label: String.fromCharCode(65 + nodes.length) });
  }
  drawGraph();
}

function drawGraph() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  // Draw edges
  ctx.strokeStyle = '#333';
  ctx.lineWidth = 2;
  for (const edge of edges) {
    ctx.beginPath();
    ctx.moveTo(edge.from.x, edge.from.y);
    ctx.lineTo(edge.to.x, edge.to.y);
    ctx.stroke();
  }

  // Draw nodes
  for (const node of nodes) {
    ctx.beginPath();
    ctx.arc(node.x, node.y, 20, 0, 2 * Math.PI);
    ctx.fillStyle = node === selectedNode ? '#f39c12' : '#3498db';
    ctx.fill();
    ctx.strokeStyle = '#2c3e50';
    ctx.stroke();

    ctx.fillStyle = '#fff';
    ctx.font = '16px Arial';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(node.label, node.x, node.y);
  }
}
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</textarea> <iframe id="2kbki" class="result_iframe" style="border:none;"></iframe>
 <script>{
const textarea = document.getElementById("UneGU");
const iframe = document.getElementById("2kbki");
const html = textarea.value;
const iframeHTML = `${html}`;
const doc = iframe.contentDocument || iframe.contentWindow.document;
doc.open();
doc.write(iframeHTML);
doc.close();
setTimeout(() => {
iframe.style.height = '0px';
const contentHeight = Math.max(
  doc.body.scrollHeight,
  doc.documentElement.scrollHeight
);
iframe.style.height = contentHeight + 'px';
}, 50);
}
		</script>
</div><h3 id="adjacency-list">Adjacency List</h3><p>An <strong>adjacency list</strong> stores each node along with a list (or set) of its neighbors. This is a memory-efficient way to represent <strong>sparse graphs</strong>, where most node pairs are not directly connected.</p><h4 id="javascript-example-directed-graph">JavaScript Example Directed Graph</h4><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-js">class GraphList {
  constructor() {
    this.adjList = new Map();
  }

  addVertex(vertex) {
    if (!this.adjList.has(vertex)) {
      this.adjList.set(vertex, []);
    }
  }

  addEdge(src, dest) {
    this.addVertex(src);
    this.addVertex(dest);
    this.adjList.get(src).push(dest);
  }

  getNeighbors(vertex) {
    return this.adjList.get(vertex) || [];
  }
}</code></pre>
</div><h4 id="undirected-graph">Undirected Graph</h4><p>To make it undirected, add both directions:</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-js">addEdge(src, dest) {
  this.addVertex(src);
  this.addVertex(dest);
  this.adjList.get(src).push(dest);
  this.adjList.get(dest).push(src);
}</code></pre>
</div><h3 id="adjacency-matrix">Adjacency Matrix</h3><p>An <strong>adjacency matrix</strong> uses a 2D array to represent connections. The cell at <code>matrix[i][j]</code> is <code>1</code> (or <code>true</code>) if there’s an edge from vertex <code>i</code> to vertex <code>j</code>, and <code>0</code> otherwise. This is great for <strong>dense graphs</strong> or when you need <strong>constant-time edge lookups</strong>.</p><h4 id="javascript-example-directed-graph">JavaScript Example Directed Graph</h4><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-js">class GraphMatrix {
  constructor(size) {
    this.size = size;
    this.matrix = Array.from({ length: size }, () =&gt; Array(size).fill(0));
  }

  addEdge(src, dest) {
    this.matrix[src][dest] = 1;
  }

  getNeighbors(vertex) {
    return this.matrix[vertex]
      .map((val, index) =&gt; (val ? index : -1))
      .filter(index =&gt; index !== -1);
  }
}</code></pre>
</div><h4 id="undirected-graph">Undirected Graph</h4><p>Make it symmetric:</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-js">addEdge(src, dest) {
  this.matrix[src][dest] = 1;
  this.matrix[dest][src] = 1;
}</code></pre>
</div><h3 id="comparison-list-vs-matrix">Comparison: List vs Matrix</h3><table>
 <thead>
  <tr>
   <th>Feature</th>
   <th>Adjacency List</th>
   <th>Adjacency Matrix</th>
  </tr>
 </thead>
 <tbody>
  <tr>
   <td><strong>Space Complexity</strong></td>
   <td>O(V + E)</td>
   <td>O(V²)</td>
  </tr>
  <tr>
   <td><strong>Edge Lookup</strong></td>
   <td>O(degree)</td>
   <td>O(1)</td>
  </tr>
  <tr>
   <td><strong>Add Edge</strong></td>
   <td>O(1)</td>
   <td>O(1)</td>
  </tr>
  <tr>
   <td><strong>Best For</strong></td>
   <td>Sparse graphs</td>
   <td>Dense graphs</td>
  </tr>
  <tr>
   <td><strong>Iterating Neighbors</strong></td>
   <td>Fast</td>
   <td>Requires filtering</td>
  </tr>
 </tbody>
</table><ul>
 <li><code>V</code> = number of vertices</li>
 <li><code>E</code> = number of edges</li>
</ul><p>An adjacency list scales better when graphs are large but sparsely connected. Conversely, adjacency matrices are useful when the number of edges is close to the number of vertex pairs (e.g., in fully connected graphs).</p><h3 id="performance-implications-for-algorithms">Performance Implications for Algorithms</h3><ul>
 <li><strong>Depth-First Search (DFS)</strong> and <strong>Breadth-First Search (BFS)</strong> typically use adjacency lists for efficiency.</li>
 <li><strong>Dijkstra’s algorithm</strong> benefits from adjacency lists with a priority queue, especially on sparse graphs.</li>
 <li><strong>Floyd-Warshall</strong>, a shortest-path algorithm for all-pairs, is easier to implement with an adjacency matrix.</li>
</ul><h3 id="summary">Summary</h3><p>Choosing between an <strong>adjacency list</strong> and an <strong>adjacency matrix</strong> depends on your use case. For most real-world applications (like social graphs or road maps), adjacency lists offer better memory efficiency and flexibility. However, for dense graphs or algorithms needing quick edge access, adjacency matrices shine. Understanding both allows you to tailor your implementation to the specific needs of your application or algorithm.</p><div class = "chapter-navi-section">
<a href="#top" class="nav-button prev">↑</a>
<a href='javascript-algorithms.htm#graph-representations' class="nav-button toc-link">Index</a>
<a href="#bottom" class="nav-button next">↓</a>
</div>
<h2 id='directed-vs-undirected-graphs'>13.2 Directed vs Undirected Graphs</h2><p>In graph theory, the direction of edges plays a crucial role in how relationships are represented and how algorithms behave. Graphs are broadly classified as <strong>directed</strong> or <strong>undirected</strong>, depending on whether their edges have a direction.</p><div class="snippet-container" id="<!DOCTYPE html>
<html lang=&quot;en&quot;>
<head>
  <meta charset=&quot;UTF-8&quot;>
  <title>Directed &amp; Undirected Graph Visualizer</title>
  <style>
    body { font-family: sans-serif; text-align: center; padding: 20px; }
    canvas { border: 1px solid #ccc; background: #f9f9f9; cursor: pointer; }
    input, button, select {
      font-size: 16px;
      padding: 6px;
      margin: 5px;
    }
  </style>
</head>
<body>
<h2>Directed vs Undirected Graph Visualizer</h2>
<p>Click to add nodes. Click two nodes to add an edge. Toggle graph type below.</p>
<select id=&quot;graphType&quot;>
  <option value=&quot;undirected&quot;>Undirected</option>
  <option value=&quot;directed&quot;>Directed</option>
</select>
<canvas id=&quot;canvas&quot; width=&quot;600&quot; height=&quot;600&quot;></canvas>
<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
const graphTypeSelector = document.getElementById('graphType');
let graphType = graphTypeSelector.value;

let nodes = [];
let edges = [];
let selectedNode = null;

graphTypeSelector.addEventListener('change', () => {
  graphType = graphTypeSelector.value;
  drawGraph();
});

canvas.addEventListener('click', handleCanvasClick);

function handleCanvasClick(event) {
  const rect = canvas.getBoundingClientRect();
  const x = event.clientX - rect.left;
  const y = event.clientY - rect.top;
  const clickedNode = nodes.find(n => Math.hypot(n.x - x, n.y - y) < 20);
  if (clickedNode) {
    if (selectedNode &amp;&amp; selectedNode !== clickedNode) {
      edges.push({ from: selectedNode, to: clickedNode });
      selectedNode = null;
    } else {
      selectedNode = clickedNode;
    }
  } else {
    nodes.push({ x, y, label: String.fromCharCode(65 + nodes.length) });
  }
  drawGraph();
}

function drawArrow(fromX, fromY, toX, toY, directed) {
  ctx.beginPath();
  ctx.moveTo(fromX, fromY);
  ctx.lineTo(toX, toY);
  ctx.stroke();

  if (directed) {
    const headlen = 10;
    const angle = Math.atan2(toY - fromY, toX - fromX);
    ctx.beginPath();
    ctx.moveTo(toX, toY);
    ctx.lineTo(toX - headlen * Math.cos(angle - Math.PI / 6), toY - headlen * Math.sin(angle - Math.PI / 6));
    ctx.lineTo(toX - headlen * Math.cos(angle + Math.PI / 6), toY - headlen * Math.sin(angle + Math.PI / 6));
    ctx.lineTo(toX, toY);
    ctx.fill();
  }
}

function drawGraph() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  ctx.strokeStyle = '#333';
  ctx.lineWidth = 2;
  ctx.fillStyle = '#333';

  for (const edge of edges) {
    const dx = edge.to.x - edge.from.x;
    const dy = edge.to.y - edge.from.y;
    const dist = Math.hypot(dx, dy);
    const unitX = dx / dist;
    const unitY = dy / dist;
    const fromX = edge.from.x + unitX * 20;
    const fromY = edge.from.y + unitY * 20;
    const toX = edge.to.x - unitX * 20;
    const toY = edge.to.y - unitY * 20;

    drawArrow(fromX, fromY, toX, toY, graphType === 'directed');
  }

  for (const node of nodes) {
    ctx.beginPath();
    ctx.arc(node.x, node.y, 20, 0, 2 * Math.PI);
    ctx.fillStyle = node === selectedNode ? '#f39c12' : '#3498db';
    ctx.fill();
    ctx.strokeStyle = '#2c3e50';
    ctx.stroke();

    ctx.fillStyle = '#fff';
    ctx.font = '16px Arial';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(node.label, node.x, node.y);
  }
}
</script>
</body>
</html>ID"><textarea id="9Ehn8" style="display: none;">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
  &lt;meta charset="UTF-8"&gt;
  &lt;title&gt;Directed &amp; Undirected Graph Visualizer&lt;/title&gt;
  &lt;style&gt;
    body { font-family: sans-serif; text-align: center; padding: 20px; }
    canvas { border: 1px solid #ccc; background: #f9f9f9; cursor: pointer; }
    input, button, select {
      font-size: 16px;
      padding: 6px;
      margin: 5px;
    }
  &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;h2&gt;Directed vs Undirected Graph Visualizer&lt;/h2&gt;
&lt;p&gt;Click to add nodes. Click two nodes to add an edge. Toggle graph type below.&lt;/p&gt;
&lt;select id="graphType"&gt;
  &lt;option value="undirected"&gt;Undirected&lt;/option&gt;
  &lt;option value="directed"&gt;Directed&lt;/option&gt;
&lt;/select&gt;
&lt;canvas id="canvas" width="600" height="600"&gt;&lt;/canvas&gt;
&lt;script&gt;
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
const graphTypeSelector = document.getElementById('graphType');
let graphType = graphTypeSelector.value;

let nodes = [];
let edges = [];
let selectedNode = null;

graphTypeSelector.addEventListener('change', () =&gt; {
  graphType = graphTypeSelector.value;
  drawGraph();
});

canvas.addEventListener('click', handleCanvasClick);

function handleCanvasClick(event) {
  const rect = canvas.getBoundingClientRect();
  const x = event.clientX - rect.left;
  const y = event.clientY - rect.top;
  const clickedNode = nodes.find(n =&gt; Math.hypot(n.x - x, n.y - y) &lt; 20);
  if (clickedNode) {
    if (selectedNode &amp;&amp; selectedNode !== clickedNode) {
      edges.push({ from: selectedNode, to: clickedNode });
      selectedNode = null;
    } else {
      selectedNode = clickedNode;
    }
  } else {
    nodes.push({ x, y, label: String.fromCharCode(65 + nodes.length) });
  }
  drawGraph();
}

function drawArrow(fromX, fromY, toX, toY, directed) {
  ctx.beginPath();
  ctx.moveTo(fromX, fromY);
  ctx.lineTo(toX, toY);
  ctx.stroke();

  if (directed) {
    const headlen = 10;
    const angle = Math.atan2(toY - fromY, toX - fromX);
    ctx.beginPath();
    ctx.moveTo(toX, toY);
    ctx.lineTo(toX - headlen * Math.cos(angle - Math.PI / 6), toY - headlen * Math.sin(angle - Math.PI / 6));
    ctx.lineTo(toX - headlen * Math.cos(angle + Math.PI / 6), toY - headlen * Math.sin(angle + Math.PI / 6));
    ctx.lineTo(toX, toY);
    ctx.fill();
  }
}

function drawGraph() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  ctx.strokeStyle = '#333';
  ctx.lineWidth = 2;
  ctx.fillStyle = '#333';

  for (const edge of edges) {
    const dx = edge.to.x - edge.from.x;
    const dy = edge.to.y - edge.from.y;
    const dist = Math.hypot(dx, dy);
    const unitX = dx / dist;
    const unitY = dy / dist;
    const fromX = edge.from.x + unitX * 20;
    const fromY = edge.from.y + unitY * 20;
    const toX = edge.to.x - unitX * 20;
    const toY = edge.to.y - unitY * 20;

    drawArrow(fromX, fromY, toX, toY, graphType === 'directed');
  }

  for (const node of nodes) {
    ctx.beginPath();
    ctx.arc(node.x, node.y, 20, 0, 2 * Math.PI);
    ctx.fillStyle = node === selectedNode ? '#f39c12' : '#3498db';
    ctx.fill();
    ctx.strokeStyle = '#2c3e50';
    ctx.stroke();

    ctx.fillStyle = '#fff';
    ctx.font = '16px Arial';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(node.label, node.x, node.y);
  }
}
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</textarea> <iframe id="qjxZD" class="result_iframe" style="border:none;"></iframe>
 <script>{
const textarea = document.getElementById("9Ehn8");
const iframe = document.getElementById("qjxZD");
const html = textarea.value;
const iframeHTML = `${html}`;
const doc = iframe.contentDocument || iframe.contentWindow.document;
doc.open();
doc.write(iframeHTML);
doc.close();
setTimeout(() => {
iframe.style.height = '0px';
const contentHeight = Math.max(
  doc.body.scrollHeight,
  doc.documentElement.scrollHeight
);
iframe.style.height = contentHeight + 'px';
}, 50);
}
		</script>
</div><h3 id="directed-graphs-digraphs">Directed Graphs (Digraphs)</h3><p>In a <strong>directed graph</strong>, each edge has a direction, pointing from one vertex to another. If there’s an edge from node <code>A</code> to <code>B</code>, it means <strong>A → B</strong>, but not necessarily <strong>B → A</strong>.</p><h4 id="javascript-representation">JavaScript Representation</h4><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-js">class DirectedGraph {
  constructor() {
    this.adjList = new Map();
  }

  addVertex(vertex) {
    if (!this.adjList.has(vertex)) {
      this.adjList.set(vertex, []);
    }
  }

  addEdge(from, to) {
    this.addVertex(from);
    this.addVertex(to);
    this.adjList.get(from).push(to);
  }
}</code></pre>
</div><h4 id="use-cases">Use Cases</h4><ul>
 <li><strong>Social media (e.g., Twitter)</strong>: A user can follow another without reciprocation.</li>
 <li><strong>Dependency graphs</strong>: Task A must be completed before Task B.</li>
 <li><strong>Web crawling</strong>: Links go one-way from one page to another.</li>
</ul><h4 id="implications-for-algorithms">Implications for Algorithms</h4><p>Traversal (DFS, BFS) must respect edge direction. For example, if <code>A → B</code> but not <code>B → A</code>, starting from <code>B</code> won’t reach <code>A</code>.</p><h3 id="undirected-graphs">Undirected Graphs</h3><p>In an <strong>undirected graph</strong>, edges have <strong>no direction</strong>. A connection between nodes <code>A</code> and <code>B</code> implies <strong>A ↔ B</strong>—the relationship is mutual.</p><h4 id="javascript-representation">JavaScript Representation</h4><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-js">class UndirectedGraph {
  constructor() {
    this.adjList = new Map();
  }

  addVertex(vertex) {
    if (!this.adjList.has(vertex)) {
      this.adjList.set(vertex, []);
    }
  }

  addEdge(v1, v2) {
    this.addVertex(v1);
    this.addVertex(v2);
    this.adjList.get(v1).push(v2);
    this.adjList.get(v2).push(v1); // Bidirectional
  }
}</code></pre>
</div><h4 id="use-cases">Use Cases</h4><ul>
 <li><strong>Road maps</strong>: You can typically drive both directions between cities.</li>
 <li><strong>Friend networks (e.g., Facebook)</strong>: A friendship goes both ways.</li>
 <li><strong>Network topologies</strong>: Wired connections are often bidirectional.</li>
</ul><h4 id="implications-for-algorithms">Implications for Algorithms</h4><p>Since edges are bidirectional, DFS and BFS can traverse in either direction, making connectivity checks (e.g., is everything connected?) straightforward.</p><h3 id="visual-example">Visual Example</h3><ul>
 <li><strong>Directed Graph</strong></li>
</ul><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-bash">A → B
B → C</code></pre>
</div><p>Traversal from <code>A</code> can reach <code>C</code>, but <code>C</code> cannot reach <code>A</code>.</p><ul>
 <li><strong>Undirected Graph</strong></li>
</ul><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-bash">A — B — C</code></pre>
</div><p>You can go from any node to any other in both directions.</p><h3 id="key-differences">Key Differences</h3><table>
 <thead>
  <tr>
   <th>Feature</th>
   <th>Directed Graph</th>
   <th>Undirected Graph</th>
  </tr>
 </thead>
 <tbody>
  <tr>
   <td>Edge Direction</td>
   <td>One-way (A → B)</td>
   <td>Two-way (A ↔ B)</td>
  </tr>
  <tr>
   <td>Representation</td>
   <td>Single edge per direction</td>
   <td>Two-way edge stored twice</td>
  </tr>
  <tr>
   <td>Use Case Examples</td>
   <td>Twitter, workflows</td>
   <td>Road maps, mutual networks</td>
  </tr>
  <tr>
   <td>Traversal Complexity</td>
   <td>Direction-sensitive</td>
   <td>Easier full traversal</td>
  </tr>
 </tbody>
</table><h3 id="summary">Summary</h3><p>Understanding the distinction between <strong>directed</strong> and <strong>undirected</strong> graphs is essential when designing algorithms or modeling data. Directed graphs are great for modeling <strong>asymmetric relationships</strong>, while undirected graphs fit <strong>mutual or symmetric</strong> interactions. Choosing the correct type of graph affects how you implement traversal, search, and even pathfinding algorithms in JavaScript.</p><div class = "chapter-navi-section">
<a href="#top" class="nav-button prev">↑</a>
<a href='javascript-algorithms.htm#graph-representations' class="nav-button toc-link">Index</a>
<a href="#bottom" class="nav-button next">↓</a>
</div>
<h2 id='weighted-vs-unweighted-graphs'>13.3 Weighted vs Unweighted Graphs</h2><p>Graphs can be <strong>weighted</strong> or <strong>unweighted</strong>, depending on whether their edges carry additional data, typically representing cost, distance, time, or capacity. Understanding the difference is essential for choosing the right algorithms and data structures when solving real-world problems.</p><h3 id="what-is-a-weighted-graph">What Is a Weighted Graph?</h3><p>In a <strong>weighted graph</strong>, each edge has a numerical value (called a <strong>weight</strong>) that represents some cost associated with moving between two vertices.</p><h4 id="examples-of-edge-weights">Examples of Edge Weights:</h4><ul>
 <li>Distance between cities (in kilometers)</li>
 <li>Time to transmit a message (in milliseconds)</li>
 <li>Cost to perform an operation (in dollars)</li>
</ul><p>In contrast, an <strong>unweighted graph</strong> treats all connections equally—each edge has the same cost (often implied to be 1).</p><h3 id="representation-in-javascript">Representation in JavaScript</h3><h4 id="adjacency-list-weighted">Adjacency List (Weighted)</h4><p>Instead of storing just a neighbor, we store both the neighbor and the weight:</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-js">class WeightedGraph {
  constructor() {
    this.adjList = new Map();
  }

  addVertex(vertex) {
    if (!this.adjList.has(vertex)) {
      this.adjList.set(vertex, []);
    }
  }

  addEdge(from, to, weight) {
    this.addVertex(from);
    this.addVertex(to);
    this.adjList.get(from).push({ node: to, weight });
  }
}</code></pre>
</div><h4 id="example">Example:</h4><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-js">const graph = new WeightedGraph();
graph.addEdge("A", "B", 5);
graph.addEdge("A", "C", 2);
// A → B (5), A → C (2)</code></pre>
</div><h4 id="adjacency-matrix-weighted">Adjacency Matrix (Weighted)</h4><p>A 2D matrix can store weights directly:</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-js">const size = 3;
const matrix = Array.from({ length: size }, () =&gt; Array(size).fill(Infinity));

matrix[0][1] = 4; // weight from node 0 to node 1
matrix[1][2] = 7; // weight from node 1 to node 2</code></pre>
</div><p>Using <code>Infinity</code> or <code>null</code> to indicate no connection helps differentiate between zero-weight edges and absent edges.</p><h3 id="unweighted-graphs">Unweighted Graphs</h3><p>In unweighted graphs, edge values are all uniform (typically assumed to be 1), so you don’t store weights:</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-js">adjList = {
  A: ["B", "C"],
  B: ["A", "D"]
};</code></pre>
</div><p>Traversals like <strong>Breadth-First Search (BFS)</strong> are commonly used in unweighted graphs to find the shortest path by hop count.</p><h3 id="key-differences">Key Differences</h3><table>
 <thead>
  <tr>
   <th>Feature</th>
   <th>Weighted Graph</th>
   <th>Unweighted Graph</th>
  </tr>
 </thead>
 <tbody>
  <tr>
   <td>Edge Data</td>
   <td>Includes cost/weight</td>
   <td>No extra data (uniform cost)</td>
  </tr>
  <tr>
   <td>Shortest Path</td>
   <td>Requires Dijkstra’s or A*</td>
   <td>Can use BFS</td>
  </tr>
  <tr>
   <td>Representation</td>
   <td>Needs weight field or matrix values</td>
   <td>Simple arrays or booleans</td>
  </tr>
  <tr>
   <td>Common Use Cases</td>
   <td>Routing, navigation, network cost</td>
   <td>Social networks, reachability</td>
  </tr>
 </tbody>
</table><h3 id="real-world-applications">Real-World Applications</h3><ul>
 <li><strong>Routing &amp; Navigation</strong>: Maps use edge weights to represent driving distance or time.</li>
 <li><strong>Network Optimization</strong>: Weights can represent bandwidth, latency, or transfer cost.</li>
 <li><strong>Game AI</strong>: Weighted graphs help find efficient paths through terrain.</li>
 <li><strong>Logistics</strong>: Route planning, delivery optimization, and scheduling.</li>
</ul><h3 id="algorithms-that-use-weights">Algorithms That Use Weights</h3><p>Weighted graphs change how you approach algorithms:</p><ul>
 <li><strong>Dijkstra’s Algorithm</strong>: Finds shortest path considering edge weights.</li>
 <li><strong>Bellman-Ford</strong>: Handles graphs with negative weights.</li>
 <li><strong>Prim’s and Kruskal’s Algorithms</strong>: Find minimum spanning trees.</li>
</ul><p>In contrast, <strong>BFS</strong> is sufficient for unweighted graphs when edge count is more important than total weight.</p><h3 id="summary">Summary</h3><p>Understanding the difference between <strong>weighted</strong> and <strong>unweighted</strong> graphs helps you model problems accurately and choose efficient algorithms. In JavaScript, you can adapt both adjacency lists and matrices to store weights easily. Weighted graphs unlock powerful real-world applications like routing, cost analysis, and decision-making across various domains.</p><div class = "chapter-navi-section">
<a href="javascript-algorithms-balanced-search-trees.htm" class="nav-button prev">←</a>
<a href='javascript-algorithms.htm#graph-representations' class="nav-button toc-link">Index</a>
<a href="javascript-algorithms-graphs-traversals.htm" class="nav-button next">→</a>
</div>
<section class="download-section">
  <div class="book-cover" style="background-color: #f9f6f1;border: 1px solid #ccc;"> 
    <div class="book-cover-title" style="font-size: 18px;color: #333;top: 20px;">JavaScript Algorithms</div>
    <div class="book-cover-author">readbytes</div>
    <div class="book-cover-bottom-stripe" style="background-color: #333;"></div>
    <img class="book-cover-icon" style="width: 80px;height: 80px;top: 70px;" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFoAAABaCAYAAAA4qEECAAAErElEQVR4Xu2dPWgUQRiGo6BB8I+AlV3w9gzptLBWsLQ89O7ARrDXSivTCTaCnWhn7pQTxOoInpjCeEQQLC2CjVqoVSwMFpp1Jtzo7Luzs/Nd7uZ29r4HPpDsu7vPvIl7+SGTmRmGYRiGYZjCEzVacdnn9NX7+3DdXkGhMg+u3Su6SNztzsZvevH/efED8zrJbM+6EGJ2K5Hv9w9gRpHnXMyik2VsYVaHWJx7tt/bTOQ3urOYUch3QJ5z0YtOCeuQiqNlvybyto/ktbVDcG2jc5GLNgoriMW5Z/svPyfy693DmFHE71ePwrUznQta9ISeyViyKBIziri/Mpe8tt25kEXjMR1ScbQsPC5W5jCjMJT8DTM6MuO6vrHjIkIszj2LL3y2ktOPiy+Y0VE5l/V5IU+EVBwtm/wUzva4SL/wOZUsJ2993rCJEIujZJMl2174Up/C5T8u9LGtzyu6SNkH1+6VhUargkJlHVy7f5aW9qJUqeZy5zguufToBeAxZoRw0Z7goj3BRXuCi/YEF+0BvWQue0xgwfrMiy+aMM8QEUW+w2IHb8fC/+C5jCOGMhOPiqi+vG47zjiABVbr7XOYUWC2Um+fxwwDiKJeYXGYMYHniNnGDDPAUJZTyYph30nTg+G7f5VLj89gzBW8lu2xMzWIIt5iMZgZBrzmqK4bJFhENOLnatRsfcR7YKb0YAELF5+cwsyowHudrLcvYKZ0iIV+wIVjZhzgPaMR/+8pFIbFeilZUWm2Vyd5/5GxWOvsx4VkTbXROovn+wJdMqfevoHnFoKUaMbgeZMAnbIGzysEKGmZiX4DKKo/um5wMg6eWwhsgtVm62cRFoEOJg/xtltZxwqBTV4inuEHcZHztc4RzI0LvLeY15iRBF+0wrDgsX6qZXpUYEanNEVLROY3ZfHDgvdwuU+pipYs1h7OpUqI4z2YGxa8dqXefooZE6UrWoGFiMn8nRIXoubyTbymeLPzO7C0RUuiRvuXoRwyeI1hrlPqoiUnap1jWNLilU7mr0sgeK746rOFGRdKX7QCC4tyHiXi+DU8BzMUpqZoiSzXpTzMZOUoTFXROxh+xKV/gYPHqvVlp88q8pi+ogdgoabBc3bD1BYtEdfcxnLHeK/pLVoiHxvJktsPMDMKpr5oX3DRnuCiPcFFe4KL9gQX7Qku2hNctCe4aE94K1puD6mXNsmpOv74KUTnxEdmEQb9TOA5kx70M6KfcO/u8/j2nWffxb+XskZm9MHjw2YjgrTKygnFeUaF5cSEjZ4c9kJyz/Z7mxTpEJ0T0nhMhyRBy+5sTuXioAjR2UmaKEHJ/tsBLM9BJ0TnXGmiBCWb2GbN5oCE6GyVJkq4Z3FXxo3ubJaDiRCdM6VJErSscTtik0MWITobpYkS7lncKVfblREdbITonJImSVCyKAz7i1KkQ3ROSJMkaNnc7Ygp0iE6Z0pjTockjC8iBmEJRTpEZ6M0ZnRIwrhTrmU7Yop0iM4paTyusyvhnO2IKdIhOqdeWLLYlbDtL0oM/jaKi4MiRGcnaZIwPt8c/zZKnoNOiM4J6SIM+pnAcyY96GekYJtvf0I/EyE6MwzDMAzDjI+/5MPGam/zucIAAAAASUVORK5CYII="/>
  </div>
  <div class="download-info">
    <h2 id='bottom'>Download This Ebook</h2>
    <p class="format-label">Available formats:</p>
    <div class="download-buttons">
      <a href="javascript-algorithms.pdf" class="download-button">📄 PDF</a>
      <a href="javascript-algorithms.epub" class="download-button">📘 EPUB</a>
    </div>
  </div>
</section><div class='related-books'>
<h2>Java Introduction Books</h2>
<div class='related-book-list'>
<a href="javascript-algorithms.htm">
<div class="book-cover" style="background-color: #f9f6f1;border: 1px solid #ccc;"> 
    <div class="book-cover-title" style="font-size: 18px;color: #333;top: 20px;">JavaScript Algorithms</div>
    <div class="book-cover-author">readbytes</div>
    <div class="book-cover-bottom-stripe" style="background-color: #333;"></div>
    <img class="book-cover-icon" style="width: 80px;height: 80px;top: 70px;" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFoAAABaCAYAAAA4qEECAAAErElEQVR4Xu2dPWgUQRiGo6BB8I+AlV3w9gzptLBWsLQ89O7ARrDXSivTCTaCnWhn7pQTxOoInpjCeEQQLC2CjVqoVSwMFpp1Jtzo7Luzs/Nd7uZ29r4HPpDsu7vPvIl7+SGTmRmGYRiGYZjCEzVacdnn9NX7+3DdXkGhMg+u3Su6SNztzsZvevH/efED8zrJbM+6EGJ2K5Hv9w9gRpHnXMyik2VsYVaHWJx7tt/bTOQ3urOYUch3QJ5z0YtOCeuQiqNlvybyto/ktbVDcG2jc5GLNgoriMW5Z/svPyfy693DmFHE71ePwrUznQta9ISeyViyKBIziri/Mpe8tt25kEXjMR1ScbQsPC5W5jCjMJT8DTM6MuO6vrHjIkIszj2LL3y2ktOPiy+Y0VE5l/V5IU+EVBwtm/wUzva4SL/wOZUsJ2993rCJEIujZJMl2174Up/C5T8u9LGtzyu6SNkH1+6VhUargkJlHVy7f5aW9qJUqeZy5zguufToBeAxZoRw0Z7goj3BRXuCi/YEF+0BvWQue0xgwfrMiy+aMM8QEUW+w2IHb8fC/+C5jCOGMhOPiqi+vG47zjiABVbr7XOYUWC2Um+fxwwDiKJeYXGYMYHniNnGDDPAUJZTyYph30nTg+G7f5VLj89gzBW8lu2xMzWIIt5iMZgZBrzmqK4bJFhENOLnatRsfcR7YKb0YAELF5+cwsyowHudrLcvYKZ0iIV+wIVjZhzgPaMR/+8pFIbFeilZUWm2Vyd5/5GxWOvsx4VkTbXROovn+wJdMqfevoHnFoKUaMbgeZMAnbIGzysEKGmZiX4DKKo/um5wMg6eWwhsgtVm62cRFoEOJg/xtltZxwqBTV4inuEHcZHztc4RzI0LvLeY15iRBF+0wrDgsX6qZXpUYEanNEVLROY3ZfHDgvdwuU+pipYs1h7OpUqI4z2YGxa8dqXefooZE6UrWoGFiMn8nRIXoubyTbymeLPzO7C0RUuiRvuXoRwyeI1hrlPqoiUnap1jWNLilU7mr0sgeK746rOFGRdKX7QCC4tyHiXi+DU8BzMUpqZoiSzXpTzMZOUoTFXROxh+xKV/gYPHqvVlp88q8pi+ogdgoabBc3bD1BYtEdfcxnLHeK/pLVoiHxvJktsPMDMKpr5oX3DRnuCiPcFFe4KL9gQX7Qku2hNctCe4aE94K1puD6mXNsmpOv74KUTnxEdmEQb9TOA5kx70M6KfcO/u8/j2nWffxb+XskZm9MHjw2YjgrTKygnFeUaF5cSEjZ4c9kJyz/Z7mxTpEJ0T0nhMhyRBy+5sTuXioAjR2UmaKEHJ/tsBLM9BJ0TnXGmiBCWb2GbN5oCE6GyVJkq4Z3FXxo3ubJaDiRCdM6VJErSscTtik0MWITobpYkS7lncKVfblREdbITonJImSVCyKAz7i1KkQ3ROSJMkaNnc7Ygp0iE6Z0pjTockjC8iBmEJRTpEZ6M0ZnRIwrhTrmU7Yop0iM4paTyusyvhnO2IKdIhOqdeWLLYlbDtL0oM/jaKi4MiRGcnaZIwPt8c/zZKnoNOiM4J6SIM+pnAcyY96GekYJtvf0I/EyE6MwzDMAzDjI+/5MPGam/zucIAAAAASUVORK5CYII="/>
  </div>
</a>



<a href='java.htm'><div class='book-cover' style='background-color: #f9f6f1;color: #111111;border: 1px solid #ccc;display: flex;justify-content: center;align-items: center;text-align: center;'>More Java Books</div></a>
</div>
</div>
  </div>
  <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/prism.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
  
  <script>
    function copyCode(button) {
      const code = button.nextElementSibling.innerText;
      navigator.clipboard.writeText(code).then(() => {
        button.textContent = 'Copied!';
        setTimeout(() => { button.textContent = 'Copy'; }, 1500);
      });
    }
  </script>  
<div id="floatingLog" aria-live="polite" role="alert"></div>
<footer class="page-footer">
    <nav>
      <a href="https://readbytes.github.io">Home</a> | 
      Email:<script language="JavaScript" type="text/javascript">
var part1 = 'yinpeng';var part6 = '263';var part2 = Math.pow(2,6);var part3 = String.fromCharCode(part2);var part4 = 'hotmail dot com';var part5 = part1 + String.fromCharCode(part2) + part4;document.write(part1 + part6 + part3 + part4);
</script>
    </nav>
  <p>© 2025 — All rights reserved.</p>    
  </footer>

</body>
</html>