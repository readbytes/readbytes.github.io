<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Java IO and NIO Working with Character Sets and Encodings</title>
<link rel='shortcut icon' href='https://java2s.com/style/favicon.ico'>
<link href="https://fonts.googleapis.com/css2?family=Merriweather&display=swap" rel="stylesheet" />
<link href="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet" />


  <script>
  const mode = localStorage.getItem('mode') || 'light';
  document.documentElement.classList.add(`${mode}-mode`);
  </script>   
<style> 
html {
  scroll-behavior: smooth;
}

body {
  font-family: 'Merriweather', serif;
  margin: 0;
  padding: 2rem 1rem;
  font-size: 15px;
  line-height: 1.5;
  transition: background-color 0.3s, color 0.3s;
}

.container {
  max-width: 700px;
  margin: 0 auto;
  padding: 1rem 2rem;
  box-shadow: 0 0 15px rgba(0,0,0,0.1);
}

h1, h2, h3 {
  font-weight: 600;
  margin-top: 2.5rem;
  margin-bottom: 1rem;
  line-height: 1.2;
}

h1 { font-size: 1.8rem; }
h2 { font-size: 1.4rem; }
h3 { font-size: 1.2rem; }

table {
  width: 100%;
  border-collapse: collapse;
  font-family: sans-serif;
  font-size: 1em;
  margin: 1em 0;
}

th, td {
  padding: 0.6em 1em;
  text-align: left;
  border: 1px solid;
}

tr:nth-child(even) {
  background-color: inherit;
}

tr:hover {
  background-color: inherit;
}

a {
  text-decoration: none;
  transition: color 0.2s;
}

a:hover {
  text-decoration: underline;
}

code {
  color: #d35400;
}

.book-title-chapter {
  font-family: 'Merriweather', serif;
  font-size: 2rem;
  font-weight: bold;
  text-align: center;
  margin-bottom: 2rem;
  border-bottom: 2px solid;
  padding-bottom: 0.5rem;
}

.book-subtitle-chapter {
  text-align: center;
  font-size: 1rem;
  margin-top: -1rem;
  margin-bottom: 2rem;
}

.related-books {
  margin-top: 40px;
}

.related-book-list {
  display: flex;
  flex-wrap: wrap;
  gap: 20px;
}

    .book-cover {
      width: 130px;
      height: 180px;
      font-family: Arial, sans-serif;
      position: relative;
      overflow: hidden;      
      line-height: normal;
      box-shadow: 2px 2px 4px rgba(0,0,0,0.1);
    }
    .book-cover-bottom-stripe {
      position: absolute;
      bottom: 0;
      left: 0;
      height: 5px;
      width: 100%;
    }
    .book-cover-title {
      position: absolute;
      width: 100%;
      text-align: center;
      font-weight: bold;
    }
     
    .book-cover-icon {
      position: absolute;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      align-items: center;
      justify-content: center; 
    }

    .book-cover-author {
      position: absolute;
      bottom: 10px;
      width: 100%;
      text-align: center;
      font-size: 8px;
      color: #333;
    }

.page-footer {
  margin-top: 4rem;
  padding: 1rem 0;
  text-align: center;
  font-size: 0.85rem;
  border-top: 1px solid;
}

.chapter-navi-section {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding-bottom: 10px;
}

.nav-link {
  color: inherit;
  text-decoration: none;
  opacity: 0.5;
  transition: opacity 0.3s ease, text-decoration 0.3s ease;
}

.nav-link:hover {
  opacity: 0.9;
  text-decoration: underline;
}

.prev { text-align: left; }
.toc-link { text-align: center; }
.next { text-align: right; }

.download-section {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 2rem;
  padding: 2rem 1rem;
  max-width: 600px;
  margin: 3rem auto;
  border-radius: 12px;
  box-shadow: 0 4px 10px rgba(0,0,0,0.05);
}

.download-info h2 {
  margin: 0 0 0.5rem;
  font-size: 1.2rem;
}

.format-label {
  margin: 0 0 0.5rem;
  font-size: 0.95rem;
}

.download-buttons {
  display: flex;
  gap: 1rem;
}

.download-button {
  background-color: #4A90E2;
  color: white;
  padding: 0.5em 1.2em;
  border-radius: 25px;
  font-size: 0.95rem;
  text-decoration: none;
  transition: background-color 0.3s ease;
}

.download-button:hover {
  background-color: #357ABD;
}

.code-block {
  position: relative;
  margin-bottom: 1em;
}

.copy-button {
  background: transparent;
  color: white;
  position: absolute;
  top: 8px;
  right: 8px;
  border: none;
  padding: 4px 8px;
  font-size: 12px;
  border-radius: 4px;
  cursor: pointer;
  z-index: 1;
}

.copy-button:hover {
  background-color: #0056b3;
}

.snippet-container {
  overflow: hidden;
}

.snippet-header {
  padding: 0.75rem 1rem;
  cursor: pointer;
  font-size: 1rem;
    background-color: #eeeeee;
    color:  #111111; 
    border-radius: 8px;
    cursor: pointer;
    box-shadow: 0 4px 6px rgba(0,0,0,0.1);  
}

.snippet-body {
  display: none;
  font-family: monospace;
}

.snippet-container.open .snippet-body {
  display: block;
}

.CodeMirror {
  border: 2px solid #ccc;
  border-radius: 4px;
  resize: vertical;
}

/* === Light Mode === */
html.light-mode {
  background-color: #f8f7f5;
  color: #333;
}

html.light-mode .container {
  background: white;
}

html.light-mode .book-title-chapter {
  color: #2c3e50;
  border-color: #ccc;
}
html.light-mode .book-subtitle-chapter{
  color: #888;
}

html.light-mode .page-footer,
html.light-mode .series-name,
html.light-mode .book-subtitle,
html.light-mode .format-label {
  color: #888;
}

html.light-mode .related-books h2 {
  color: #333;
  border-bottom: 2px solid #eee;
}

html.light-mode .book-title {
  color: #fff;
}

html.light-mode .book-cover {
  border: 1px solid #ccc;
}

html.light-mode th {
  background-color: #f2f2f2;
}

html.light-mode tr:nth-child(even) {
  background-color: #fafafa;
}

html.light-mode tr:hover {
  background-color: #e6f7ff;
}

html.light-mode a,
html.light-mode .page-footer a {
  color: #000;
}

/* === Dark Mode === */
html.dark-mode {
  background-color: #181818;
  color: #e0e0e0;
}

html.dark-mode .container {
  background: #222;
}

html.dark-mode .book-title-chapter {
  color: #ddd;
  border-color: #444;
}

html.dark-mode .snippet-header {
    background-color: #333;
    color:  #ddd; 
}


html.dark-mode .book-subtitle-chapter,
html.dark-mode .page-footer,
html.dark-mode .series-name,
html.dark-mode .book-subtitle,
html.dark-mode .book-footer,
html.dark-mode .format-label {
  color: #aaa;
}

html.dark-mode .related-books h2 {
  color: #ddd;
  border-bottom: 2px solid #333;
}

html.dark-mode .book-title {
  color: #fff;
}

html.dark-mode .book-cover {
  border: 1px solid #555;
}

html.dark-mode th {
  background-color: #333;
  color: #fff;
}

html.dark-mode td {
  border-color: #444;
}

html.dark-mode tr:nth-child(even) {
  background-color: #2a2a2a;
}

html.dark-mode tr:hover {
  background-color: #2c3e50;
}

html.dark-mode a,
html.dark-mode .page-footer a {
  color: #eee;
}

    .dialog-backdrop {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: rgba(0,0,0,0.5);
      display: none;
      justify-content: center;
      align-items: center;
      z-index: 10;
    }

    .dialog {
      background: white;
      padding: 20px;
      width: 90vw;
      height: 80vh;
      border-radius: 8px;
      box-shadow: 0 0 20px rgba(0,0,0,0.3);
      display: flex;
      flex-direction: column;
    }
    .dialog-content {
      display: flex;
      flex: 1;
      gap: 20px;
      margin-top: 10px;
    }
    .dialog h2 {
      margin-top: 0;
    }

    .textarea_dialog {
      width: 50%;
      height: 100%;
      resize: none;
      font-family: monospace;
      font-size: 14px;
      padding: 10px;
      box-sizing: border-box;
      border: 1px solid #ccc;
    }

    .iframe_dialog {
      width: 50%;
      height: 100%;
      border: 1px solid #ccc;
    }
    .controls_dialog {
      display: flex;
      justify-content: space-between;
      margin-top: 10px;
    }    
    button { padding: 0.5em 1em; background: green; color: white; border: none; cursor: pointer; }
    button:hover { background: #1e7e34; }
    .result_iframe { width:99%; height:200px; margin-top: 1em;  resize: both;border:1px solid #ccc;}        
</style>
</head>
<body> 
  <div class="container">
    <div class = "chapter-navi-section">
<a href="java-io-and-nio-asynchronous-io.htm" class="nav-button prev">←</a>
<a href='java-io-and-nio.htm#working-with-character-sets-and-encodings' class="nav-button toc-link">Index</a>
<a href="java-io-and-nio-practical-java-io-and-nio-examples.htm" class="nav-button next">→</a>
</div>

    <h1 class="book-title-chapter" id = 'top'>Working with Character Sets and Encodings</h1>
    <h3 class="book-subtitle-chapter">Java IO and NIO</h3>   
    <!-- <h1 class ="chapter-title"></h1> -->
    <h2 id='charset-and-charsetdecoder-charsetencoder'>9.1 Charset and CharsetDecoder/CharsetEncoder</h2><p>When working with text in Java, understanding how characters are represented and converted to bytes (and vice versa) is crucial. This is especially important for applications dealing with file IO, network communication, or interoperability with systems that may use different encodings. Java’s <code>Charset</code>, <code>CharsetEncoder</code>, and <code>CharsetDecoder</code> classes provide a robust framework to handle these conversions reliably and efficiently.</p><h3 id="what-is-a-character-set">What is a Character Set?</h3><p>A <strong>character set</strong> (or <strong>charset</strong>) defines a mapping between a collection of characters (letters, digits, symbols) and their corresponding numeric values (code points). These numeric values are then encoded into sequences of bytes to store or transmit text.</p><p>Common character sets include:</p><ul>
 <li><strong>ASCII:</strong> 7-bit, represents basic English letters and control characters.</li>
 <li><strong>ISO-8859-1:</strong> An 8-bit encoding covering Western European languages.</li>
 <li><strong>UTF-8:</strong> A variable-length Unicode encoding capable of representing any character.</li>
 <li><strong>UTF-16:</strong> A Unicode encoding using 2 or 4 bytes per character.</li>
</ul><p>Because different systems and protocols may use different charsets, <strong>converting between bytes and characters requires specifying which charset to use</strong>. Incorrect charset assumptions often lead to mojibake (garbled text).</p><h3 id="the-charset-class-in-java">The <code>Charset</code> Class in Java</h3><p>The <code>Charset</code> class (in <code>java.nio.charset</code>) represents a named mapping between sequences of 16-bit Unicode characters (<code>char</code>) and sequences of bytes. Java’s core platform includes support for many standard charsets, and you can obtain a <code>Charset</code> instance for any supported charset.</p><h3 id="how-to-obtain-a-charset">How to Obtain a Charset</h3><p>You can get a <code>Charset</code> instance via:</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-Java">Charset charset1 = Charset.forName("UTF-8");         // Standard charset by name
Charset charset2 = StandardCharsets.UTF_8;           // Preferred constant from Java 7+</code></pre>
</div><p>Java also provides constants for other popular charsets like <code>US_ASCII</code>, <code>ISO_8859_1</code>, and <code>UTF_16</code>.</p><h3 id="role-of-charset-in-java-text-encoding-and-decoding">Role of Charset in Java Text Encoding and Decoding</h3><ul>
 <li><strong>Encoding:</strong> Converting a <code>CharBuffer</code> (characters) into a <code>ByteBuffer</code> (bytes) using a <code>CharsetEncoder</code>.</li>
 <li><strong>Decoding:</strong> Converting a <code>ByteBuffer</code> back into a <code>CharBuffer</code> using a <code>CharsetDecoder</code>.</li>
</ul><p>This two-way transformation is essential because:</p><ul>
 <li>Internally, Java strings and characters use UTF-16.</li>
 <li>External data (files, network data) is often represented as bytes encoded in a specific charset.</li>
</ul><h3 id="charsetencoder-and-charsetdecoder-classes"><code>CharsetEncoder</code> and <code>CharsetDecoder</code> Classes</h3><p><strong>CharsetEncoder</strong></p><p><code>CharsetEncoder</code> converts characters into bytes according to a specific charset encoding scheme.</p><ul>
 <li>Created from a <code>Charset</code> by calling <code>.newEncoder()</code>.</li>
 <li>Provides methods to encode characters in bulk or incrementally.</li>
 <li>Handles character-to-byte conversion, including error handling for unmappable or malformed characters.</li>
</ul><p><strong>CharsetDecoder</strong></p><p><code>CharsetDecoder</code> converts bytes into characters.</p><ul>
 <li>Created from a <code>Charset</code> by calling <code>.newDecoder()</code>.</li>
 <li>Reads bytes from a <code>ByteBuffer</code> and outputs decoded characters into a <code>CharBuffer</code>.</li>
 <li>Handles invalid byte sequences gracefully.</li>
</ul><h3 id="why-use-charsetencoder-decoder-instead-of-convenience-methods">Why Use CharsetEncoder/Decoder Instead of Convenience Methods?</h3><p>While Java offers convenience methods like <code>String.getBytes(Charset)</code> and <code>new String(byte[], Charset)</code>, the encoder/decoder classes give:</p><ul>
 <li><strong>More control:</strong> You can manage incremental encoding/decoding (streaming).</li>
 <li><strong>Error handling:</strong> Configure how to respond to malformed or unmappable input.</li>
 <li><strong>Performance benefits:</strong> Avoid unnecessary intermediate objects in bulk operations.</li>
</ul><h3 id="example-using-charsetencoder-and-charsetdecoder">Example: Using CharsetEncoder and CharsetDecoder</h3><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-java">import java.nio.*;
import java.nio.charset.*;

public class CharsetExample {
    public static void main(String[] args) throws CharacterCodingException {
        // Obtain a Charset instance for UTF-8
        Charset charset = StandardCharsets.UTF_8;

        // Create encoder and decoder
        CharsetEncoder encoder = charset.newEncoder();
        CharsetDecoder decoder = charset.newDecoder();

        // The original string
        String original = "Hello, 世界";  // Includes Unicode characters

        // Encode: Convert characters to bytes
        CharBuffer charBuffer = CharBuffer.wrap(original);
        ByteBuffer byteBuffer = encoder.encode(charBuffer);

        System.out.println("Encoded bytes:");
        while (byteBuffer.hasRemaining()) {
            System.out.printf("%02X ", byteBuffer.get());
        }
        System.out.println();

        // Reset buffer position for reading
        byteBuffer.flip();

        // Decode: Convert bytes back to characters
        CharBuffer decodedCharBuffer = decoder.decode(byteBuffer);
        String decodedString = decodedCharBuffer.toString();

        System.out.println("Decoded string:");
        System.out.println(decodedString);
    }
}</code></pre>
</div><p><strong>Output:</strong></p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-bash">Encoded bytes:
48 65 6C 6C 6F 2C 20 E4 B8 96 E7 95 8C 
Decoded string:
Hello, 世界</code></pre>
</div><h3 id="handling-malformed-and-unmappable-characters">Handling Malformed and Unmappable Characters</h3><p><code>CharsetEncoder</code> and <code>CharsetDecoder</code> allow configuring actions on errors:</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-Java">encoder.onMalformedInput(CodingErrorAction.REPLACE);
encoder.onUnmappableCharacter(CodingErrorAction.IGNORE);
decoder.onMalformedInput(CodingErrorAction.REPORT);</code></pre>
</div><p>Options include:</p><ul>
 <li><code>REPORT</code>: Throw an exception on error.</li>
 <li><code>IGNORE</code>: Skip malformed/unmappable sequences.</li>
 <li><code>REPLACE</code>: Replace with a default character (e.g., <code>?</code>).</li>
</ul><h3 id="summary">Summary</h3><ul>
 <li>The <strong><code>Charset</code></strong> class models the concept of a named character encoding scheme and provides access to encoders and decoders.</li>
 <li>The <strong><code>CharsetEncoder</code></strong> converts characters (Java’s internal UTF-16) into bytes according to the charset.</li>
 <li>The <strong><code>CharsetDecoder</code></strong> converts bytes back into characters.</li>
 <li>These classes are essential for correctly reading and writing text data in different encodings, avoiding data corruption.</li>
 <li>They support fine-grained control over incremental encoding/decoding and error handling, making them suitable for performance-critical and robust applications.</li>
</ul><p>By mastering <code>Charset</code>, <code>CharsetEncoder</code>, and <code>CharsetDecoder</code>, Java developers can handle text data across diverse platforms and protocols with confidence and precision.</p><div class = "chapter-navi-section">
<a href="#top" class="nav-button prev">↑</a>
<a href='java-io-and-nio.htm#working-with-character-sets-and-encodings' class="nav-button toc-link">Index</a>
<a href="#bottom" class="nav-button next">↓</a>
</div>
<h2 id='reading-and-writing-text-with-charset-support'>9.2 Reading and Writing Text with Charset Support</h2><p>Handling text files correctly in Java requires careful attention to character encoding. A common source of bugs and data corruption arises when the character encoding used to read a file does not match the encoding in which the file was written. This mismatch can cause unreadable characters (mojibake), lost data, or exceptions. To avoid such problems, <strong>explicitly specifying the character set (charset) during text file IO is crucial</strong>.</p><h3 id="why-specifying-charset-matters">Why Specifying Charset Matters</h3><p>Every text file is essentially a sequence of bytes interpreted as characters according to an encoding scheme or charset. Examples of common charsets are UTF-8, ISO-8859-1, UTF-16, etc. Different charsets encode characters differently:</p><ul>
 <li>For example, the character 'é' in UTF-8 is two bytes (<code>0xC3 0xA9</code>), but in ISO-8859-1 it is one byte (<code>0xE9</code>).</li>
 <li>A file encoded in UTF-8 but read as ISO-8859-1 will produce corrupted characters or unexpected results.</li>
</ul><p>If you rely on Java's platform default charset implicitly (e.g., <code>FileReader</code> or <code>FileWriter</code>), your code becomes non-portable and fragile because default charset varies by platform, locale, and JVM settings.</p><p><strong>Explicit charset specification ensures that your program reads and writes text consistently, regardless of platform or environment.</strong></p><h3 id="java-classes-for-charset-aware-text-io">Java Classes for Charset-Aware Text IO</h3><p>The key classes to perform charset-aware reading and writing of text files are:</p><ul>
 <li><strong><code>InputStreamReader</code></strong>: Converts bytes from an input stream into characters using a specified charset.</li>
 <li><strong><code>OutputStreamWriter</code></strong>: Converts characters into bytes and writes them to an output stream using a specified charset.</li>
</ul><p>Both classes bridge between byte streams (<code>InputStream</code>/<code>OutputStream</code>) and character streams (<code>Reader</code>/<code>Writer</code>).</p><h3 id="reading-text-files-with-inputstreamreader">Reading Text Files with <code>InputStreamReader</code></h3><p>The typical pattern to read a text file with a specific charset is:</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-java">import java.io.*;
import java.nio.charset.Charset;

public class CharsetAwareFileRead {
    public static void main(String[] args) {
        File file = new File("example.txt");
        Charset charset = Charset.forName("UTF-8");

        try (InputStream inputStream = new FileInputStream(file);
             Reader reader = new InputStreamReader(inputStream, charset);
             BufferedReader bufferedReader = new BufferedReader(reader)) {

            String line;
            while ((line = bufferedReader.readLine()) != null) {
                System.out.println(line);
            }

        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}</code></pre>
</div><h3 id="explanation">Explanation:</h3><ul>
 <li><code>FileInputStream</code> reads raw bytes from the file.</li>
 <li><code>InputStreamReader</code> converts these bytes into characters using the specified charset (<code>UTF-8</code> in this example).</li>
 <li><code>BufferedReader</code> provides efficient buffered reading and convenient methods like <code>readLine()</code>.</li>
</ul><p>This method guarantees that bytes are interpreted according to the specified charset, avoiding platform default pitfalls.</p><h3 id="writing-text-files-with-outputstreamwriter">Writing Text Files with <code>OutputStreamWriter</code></h3><p>Similarly, to write text safely with explicit charset:</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-java">import java.io.*;
import java.nio.charset.Charset;

public class CharsetAwareFileWrite {
    public static void main(String[] args) {
        File file = new File("output.txt");
        Charset charset = Charset.forName("UTF-8");

        try (OutputStream outputStream = new FileOutputStream(file);
             Writer writer = new OutputStreamWriter(outputStream, charset);
             BufferedWriter bufferedWriter = new BufferedWriter(writer)) {

            bufferedWriter.write("Hello, 世界!");
            bufferedWriter.newLine();
            bufferedWriter.write("This file is written with UTF-8 charset.");

        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}</code></pre>
</div><h3 id="explanation">Explanation:</h3><ul>
 <li><code>FileOutputStream</code> writes raw bytes to the file.</li>
 <li><code>OutputStreamWriter</code> encodes characters into bytes using the specified charset.</li>
 <li><code>BufferedWriter</code> provides buffered writing with convenient methods such as <code>newLine()</code>.</li>
</ul><p>This ensures the written bytes accurately represent the characters in UTF-8 encoding.</p><h3 id="example-round-trip-reading-and-writing">Example: Round-Trip Reading and Writing</h3><p>To illustrate safe and portable IO, consider reading a file in UTF-8 and writing its contents to another file in UTF-8 explicitly:</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-java">import java.io.*;
import java.nio.charset.StandardCharsets;

public class RoundTripTextIO {
    public static void main(String[] args) {
        File inputFile = new File("input.txt");
        File outputFile = new File("output.txt");

        try (BufferedReader reader = new BufferedReader(
                new InputStreamReader(new FileInputStream(inputFile), StandardCharsets.UTF_8));
             BufferedWriter writer = new BufferedWriter(
                new OutputStreamWriter(new FileOutputStream(outputFile), StandardCharsets.UTF_8))) {

            String line;
            while ((line = reader.readLine()) != null) {
                writer.write(line);
                writer.newLine();
            }

            System.out.println("File copied successfully with UTF-8 charset.");

        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}</code></pre>
</div><p>This example:</p><ul>
 <li>Reads <code>input.txt</code> assuming it’s encoded in UTF-8.</li>
 <li>Writes its contents to <code>output.txt</code> in UTF-8.</li>
 <li>Avoids data corruption by explicitly specifying the charset for both reading and writing.</li>
 <li>Is portable and reliable across different platforms and JVM settings.</li>
</ul><h3 id="common-pitfalls-and-best-practices">Common Pitfalls and Best Practices</h3><ol>
 <li><p><strong>Never rely on default charset for file IO.</strong> Always specify charset explicitly unless you have very specific reasons and control over the environment.</p></li>
 <li><p><strong>Match the charset on both reading and writing.</strong> When reading files you wrote yourself, use the same charset consistently to avoid surprises.</p></li>
 <li><p><strong>Use <code>StandardCharsets</code> constants when possible.</strong> E.g., <code>StandardCharsets.UTF_8</code> is preferred over <code>Charset.forName("UTF-8")</code> to avoid typos and <code>UnsupportedCharsetException</code>.</p></li>
 <li><p><strong>Wrap streams in buffered readers/writers.</strong> For performance and convenient line-based operations.</p></li>
 <li><p><strong>Be cautious with legacy APIs like <code>FileReader</code> and <code>FileWriter</code>.</strong> They use platform default charset internally and are discouraged for portable code.</p></li>
</ol><h3 id="summary">Summary</h3><ul>
 <li>Text files are sequences of bytes interpreted as characters via a charset.</li>
 <li>Mismatched charset assumptions between reading and writing cause data corruption.</li>
 <li>Java’s <code>InputStreamReader</code> and <code>OutputStreamWriter</code> classes allow explicit charset specification bridging byte streams to character streams.</li>
 <li>Always specify charset explicitly for safe, portable, and correct text file IO.</li>
 <li>Use buffered wrappers for efficient and convenient reading/writing.</li>
</ul><p>By adhering to these principles and using the proper classes with explicit charset parameters, Java developers can avoid many common pitfalls and ensure their applications handle text files robustly across environments and locales.</p><div class = "chapter-navi-section">
<a href="#top" class="nav-button prev">↑</a>
<a href='java-io-and-nio.htm#working-with-character-sets-and-encodings' class="nav-button toc-link">Index</a>
<a href="#bottom" class="nav-button next">↓</a>
</div>
<h2 id='handling-unicode-and-utf-variants'>9.3 Handling Unicode and UTF Variants</h2><p>In today’s globalized digital world, software often needs to handle text from many languages and scripts. This requirement has made Unicode the fundamental standard for representing text characters consistently across platforms and systems. Understanding Unicode and its encoding schemes—UTF-8, UTF-16, and UTF-32—is critical for developers, including Java programmers, to ensure correct, efficient, and interoperable text processing.</p><h3 id="what-is-unicode">What Is Unicode?</h3><p>Unicode is a <strong>universal character set</strong> designed to encode all the characters used in writing systems worldwide—letters, digits, symbols, emoji, and control characters—into a single standard. Unlike older character encodings that supported only limited alphabets (like ASCII or ISO-8859-1), Unicode can represent <strong>over one million code points</strong>, though currently fewer than 150,000 are assigned.</p><ul>
 <li>Each character in Unicode is assigned a <strong>code point</strong>, a unique integer value typically written in hexadecimal, e.g., the Latin capital letter A is <code>U+0041</code>.</li>
 <li>Code points are organized in <strong>planes</strong> of 65,536 characters each; the <strong>Basic Multilingual Plane (BMP)</strong> is plane 0 and contains most commonly used characters.</li>
</ul><p>Unicode itself is an abstract mapping of characters to numbers. To store or transmit text, these numbers need to be encoded as bytes—this is where <strong>UTF encodings</strong> come in.</p><h3 id="why-different-utf-encodings-exist">Why Different UTF Encodings Exist</h3><p>Unicode code points are abstract; they do not specify how to represent characters as bytes. Different encoding schemes—UTF-8, UTF-16, and UTF-32—define how to convert these code points to byte sequences.</p><p>Each UTF encoding offers trade-offs in terms of:</p><ul>
 <li><strong>Storage size</strong></li>
 <li><strong>Compatibility with legacy encodings</strong></li>
 <li><strong>Processing complexity</strong></li>
 <li><strong>Ease of random access to characters</strong></li>
</ul><p>No single encoding fits all use cases perfectly, so the Unicode standard provides multiple UTF variants to meet diverse needs.</p><h3 id="the-utf-encodings-explained">The UTF Encodings Explained</h3><p>UTF-8</p><ul>
 <li><strong>Variable-length encoding:</strong> 1 to 4 bytes per character.</li>
 <li>Uses <strong>1 byte</strong> for ASCII characters (<code>U+0000</code> to <code>U+007F</code>), making it fully backward-compatible with ASCII.</li>
 <li>Non-ASCII characters use 2, 3, or 4 bytes.</li>
 <li>Widely used on the web and many modern applications due to its efficiency for texts dominated by ASCII characters.</li>
 <li>Byte order is unambiguous (no endianness issues).</li>
</ul><p><strong>Example:</strong></p><ul>
 <li>The character 'A' (<code>U+0041</code>) is encoded as <code>0x41</code> (1 byte).</li>
 <li>The character '世' (<code>U+4E16</code>) is encoded as <code>0xE4 0xB8 0x96</code> (3 bytes).</li>
</ul><h3 id="utf-16">UTF-16</h3><ul>
 <li><strong>Variable-length encoding:</strong> 2 or 4 bytes per character.</li>
 <li>Characters in the BMP (most common characters) are encoded as <strong>2 bytes</strong>.</li>
 <li>Characters outside the BMP (supplementary characters) use <strong>surrogate pairs</strong>—two 2-byte code units (total 4 bytes).</li>
 <li>Commonly used in Windows APIs and Java internally.</li>
 <li>Requires consideration of <strong>byte order (endianness)</strong> — UTF-16LE and UTF-16BE variants exist.</li>
</ul><h3 id="utf-32">UTF-32</h3><ul>
 <li><strong>Fixed-length encoding:</strong> 4 bytes per character.</li>
 <li>Each Unicode code point is stored as a 4-byte integer.</li>
 <li>Simple for indexing and processing since every character is a fixed size.</li>
 <li>Inefficient for storage compared to UTF-8 and UTF-16, used mostly in internal processing or environments where fixed-width encoding is beneficial.</li>
</ul><h3 id="how-java-supports-unicode-and-utf-encodings">How Java Supports Unicode and UTF Encodings</h3><p>Java’s native <code>char</code> type is a <strong>16-bit UTF-16 code unit</strong>, meaning Java strings are internally encoded as UTF-16 sequences. This design enables Java to handle all BMP characters in a single <code>char</code>, but supplementary characters (outside BMP) are represented using <strong>two <code>char</code> units called surrogate pairs</strong>.</p><p>Java provides rich support for encoding and decoding Unicode text:</p><ul>
 <li>Classes like <code>java.nio.charset.Charset</code>, <code>CharsetEncoder</code>, and <code>CharsetDecoder</code> support UTF-8, UTF-16 (both endian variants), and UTF-32 (less common).</li>
 <li>StandardCharsets class includes constants like <code>StandardCharsets.UTF_8</code>, <code>StandardCharsets.UTF_16</code>, and <code>StandardCharsets.UTF_16BE</code>.</li>
 <li>Input/output streams and readers/writers accept charset parameters for reading and writing Unicode data correctly.</li>
 <li>Unicode-aware APIs like <code>String</code>, <code>Character</code>, and <code>CodePoint</code> methods help manage surrogate pairs and supplementary characters.</li>
</ul><h3 id="practical-advice-on-choosing-the-right-encoding">Practical Advice on Choosing the Right Encoding</h3><ol>
 <li><p><strong>Default to UTF-8 when possible</strong> UTF-8 is the de facto standard on the internet and in most modern software because it is compact for ASCII-heavy text, compatible with ASCII, and byte-order safe. For new projects and cross-platform interoperability, UTF-8 is generally the best choice.</p></li>
 <li><p><strong>Use UTF-16 when interacting with systems or protocols that expect it</strong> For example, Windows and Java internally use UTF-16, and some APIs or file formats require UTF-16 encoded data. But be aware of byte order and surrogate pairs.</p></li>
 <li><p><strong>UTF-32 is rarely needed except for specialized processing</strong> Fixed-width UTF-32 simplifies character indexing but uses much more space. Use it only if the application demands fixed-width encoding for performance reasons.</p></li>
 <li><p><strong>Always specify the encoding explicitly</strong> Never rely on platform default charset when reading or writing text, as this can cause data corruption or incompatibility.</p></li>
</ol><h3 id="common-pitfalls-when-handling-unicode-data">Common Pitfalls When Handling Unicode Data</h3><ul>
 <li><p><strong>Assuming one <code>char</code> equals one character:</strong> In Java, <code>char</code> is a UTF-16 code unit, not a full Unicode character. Supplementary characters are represented by surrogate pairs (<code>char</code> pairs), so methods like <code>String.length()</code> may not correspond to the number of actual Unicode characters (code points). Use methods like <code>codePointCount()</code>, <code>codePointAt()</code>, and <code>offsetByCodePoints()</code> for proper handling.</p></li>
 <li><p><strong>Not specifying charset on IO:</strong> Reading a UTF-8 file as ISO-8859-1 will produce garbled output. Always specify charset explicitly, e.g., <code>new InputStreamReader(inputStream, StandardCharsets.UTF_8)</code>.</p></li>
 <li><p><strong>Ignoring byte order in UTF-16:</strong> UTF-16 encoded files can be little-endian or big-endian. The presence of a BOM (byte order mark) can help detect the order, but some files omit it. Make sure to use the correct variant or detect BOM properly.</p></li>
 <li><p><strong>Incorrectly handling surrogate pairs:</strong> String operations that manipulate characters by index can break surrogate pairs and corrupt text. Use Unicode-aware APIs.</p></li>
</ul><h3 id="summary">Summary</h3><p>Unicode is the universal standard for representing text from all languages, and UTF encodings specify how to serialize those characters into bytes:</p><ul>
 <li><strong>UTF-8</strong>: Compact, ASCII-compatible, variable length (1-4 bytes), widely used.</li>
 <li><strong>UTF-16</strong>: Variable length (2 or 4 bytes), used internally by Java and Windows, sensitive to byte order.</li>
 <li><strong>UTF-32</strong>: Fixed length (4 bytes), simple but space-inefficient.</li>
</ul><p>Java’s internal string representation uses UTF-16, and it offers comprehensive support for all UTF encodings through its <code>Charset</code> APIs. Choosing the right encoding involves balancing compatibility, efficiency, and application requirements, with UTF-8 being the safest default for most cases.</p><p>By understanding these fundamentals and pitfalls, developers can correctly handle Unicode text, ensuring applications are robust, internationalized, and interoperable in a multilingual world.</p><div class = "chapter-navi-section">
<a href="#top" class="nav-button prev">↑</a>
<a href='java-io-and-nio.htm#working-with-character-sets-and-encodings' class="nav-button toc-link">Index</a>
<a href="#bottom" class="nav-button next">↓</a>
</div>
<h2 id='charset-conversion-examples'>9.4 Charset Conversion Examples</h2><p>In many real-world Java applications, you often need to convert text data from one character encoding to another—for example, reading a file encoded in ISO-8859-1 and saving it as UTF-8, or processing data streams with mixed encodings. Java’s <code>CharsetDecoder</code> and <code>CharsetEncoder</code> classes, along with utility classes in <code>java.nio.charset</code>, provide robust tools to perform such conversions reliably.</p><p>This section explains how to convert text between different charsets in Java and demonstrates practical code examples.</p><h3 id="why-charset-conversion-is-important">Why Charset Conversion is Important</h3><p>Different systems and files may use different encodings, and misinterpreting bytes as the wrong charset can lead to corrupted text (mojibake) or exceptions. Charset conversion ensures that:</p><ul>
 <li>Text data can be interoperably exchanged between systems.</li>
 <li>Legacy data encoded with older encodings can be converted to modern Unicode-based formats like UTF-8.</li>
 <li>Your application can display or store text correctly according to user or system requirements.</li>
</ul><h3 id="core-classes-charsetdecoder-and-charsetencoder">Core Classes: CharsetDecoder and CharsetEncoder</h3><ul>
 <li><strong><code>CharsetDecoder</code></strong> converts bytes from a specific charset into Java characters (<code>char</code>), resulting in a <code>CharBuffer</code>.</li>
 <li><strong><code>CharsetEncoder</code></strong> converts Java characters (<code>char</code>) into bytes according to a target charset, resulting in a <code>ByteBuffer</code>.</li>
</ul><p>To convert text from one charset to another, you:</p><ol>
 <li><strong>Decode</strong> the original bytes using the source charset into characters.</li>
 <li><strong>Encode</strong> these characters using the target charset back into bytes.</li>
</ol><h3 id="example-1-basic-charset-conversion-using-charsetdecoder-and-charsetencoder">Example 1: Basic Charset Conversion Using CharsetDecoder and CharsetEncoder</h3><p>This example reads a byte array encoded in ISO-8859-1 and converts it to a UTF-8 encoded byte array.</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-java">import java.nio.ByteBuffer;
import java.nio.CharBuffer;
import java.nio.charset.*;

public class CharsetConversionExample {
    public static void main(String[] args) throws CharacterCodingException {
        // Original text encoded in ISO-8859-1 bytes (for demo)
        byte[] iso8859Bytes = {(byte)0xE9, (byte)0x20, (byte)0x6C, (byte)0xE0, (byte)0x20, (byte)0x63, (byte)0xE9, (byte)0x20, (byte)0x63, (byte)0x61, (byte)0x72};

        // Step 1: Decode ISO-8859-1 bytes to characters
        Charset sourceCharset = Charset.forName("ISO-8859-1");
        CharsetDecoder decoder = sourceCharset.newDecoder();
        ByteBuffer sourceBytes = ByteBuffer.wrap(iso8859Bytes);
        CharBuffer chars = decoder.decode(sourceBytes);

        System.out.println("Decoded characters:");
        System.out.println(chars.toString());  // prints: é là cé car

        // Step 2: Encode characters into UTF-8 bytes
        Charset targetCharset = StandardCharsets.UTF_8;
        CharsetEncoder encoder = targetCharset.newEncoder();
        ByteBuffer utf8Bytes = encoder.encode(chars);

        System.out.println("Re-encoded UTF-8 bytes:");
        while (utf8Bytes.hasRemaining()) {
            System.out.printf("%02X ", utf8Bytes.get());
        }
        // Output: C3 A9 20 6C C3 A0 20 63 C3 A9 20 63 61 72
    }
}</code></pre>
</div><h3 id="explanation">Explanation</h3><ul>
 <li>We start with a byte array <code>iso8859Bytes</code> containing text encoded in ISO-8859-1, including accented characters like <code>é</code> and <code>à</code>.</li>
 <li>Using <code>CharsetDecoder</code> for ISO-8859-1, we decode these bytes into Java characters (<code>CharBuffer</code>).</li>
 <li>Then, we encode these characters into UTF-8 bytes using <code>CharsetEncoder</code>.</li>
 <li>This two-step decode-encode approach converts text from one charset to another safely.</li>
</ul><h3 id="example-2-converting-text-file-encoding">Example 2: Converting Text File Encoding</h3><p>Suppose you have a file encoded in Windows-1252 and want to convert it to UTF-8.</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-java">import java.io.*;
import java.nio.ByteBuffer;
import java.nio.CharBuffer;
import java.nio.charset.*;

public class FileEncodingConverter {
    public static void main(String[] args) {
        File inputFile = new File("input-win1252.txt");
        File outputFile = new File("output-utf8.txt");

        Charset sourceCharset = Charset.forName("windows-1252");
        Charset targetCharset = StandardCharsets.UTF_8;

        try (InputStream inStream = new FileInputStream(inputFile);
             OutputStream outStream = new FileOutputStream(outputFile)) {

            // Decoder and encoder
            CharsetDecoder decoder = sourceCharset.newDecoder();
            CharsetEncoder encoder = targetCharset.newEncoder();

            // Read all bytes from source file
            byte[] inputBytes = inStream.readAllBytes();
            ByteBuffer sourceBuffer = ByteBuffer.wrap(inputBytes);

            // Decode bytes to chars
            CharBuffer charBuffer = decoder.decode(sourceBuffer);

            // Encode chars to target charset bytes
            ByteBuffer targetBuffer = encoder.encode(charBuffer);

            // Write bytes to output file
            outStream.write(targetBuffer.array(), 0, targetBuffer.limit());

            System.out.println("File encoding converted successfully.");

        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}</code></pre>
</div><h3 id="explanation">Explanation</h3><ul>
 <li>This program reads all bytes from a file encoded in Windows-1252.</li>
 <li>It uses <code>CharsetDecoder</code> to decode the bytes into characters.</li>
 <li>It then encodes the characters into UTF-8 bytes with <code>CharsetEncoder</code>.</li>
 <li>Finally, it writes the UTF-8 bytes to the output file.</li>
 <li>This approach preserves the text correctly, regardless of special characters present.</li>
</ul><h3 id="utility-approach-using-new-string-and-getbytes-for-quick-conversions">Utility Approach: Using <code>new String()</code> and <code>getBytes()</code> for Quick Conversions</h3><p>For simpler scenarios, Java’s <code>String</code> constructors and <code>getBytes()</code> methods can be used for conversion:</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-java">import java.io.UnsupportedEncodingException;

public class Test {

    public class SimpleConversion {
        public static void main(String[] args) throws UnsupportedEncodingException {
            byte[] windows1252Bytes = { (byte) 0xE9, (byte) 0x20, (byte) 0x6C, (byte) 0xE0 }; // é là

            // Decode bytes into String with Windows-1252
            String text = new String(windows1252Bytes, "windows-1252");
            System.out.println("Decoded text: " + text);

            // Encode String into UTF-8 bytes
            byte[] utf8Bytes = text.getBytes("UTF-8");

            System.out.println("UTF-8 bytes:");
            for (byte b : utf8Bytes) {
                System.out.printf("%02X ", b);
            }
        }
    }
}</code></pre>
</div><h3 id="note">Note</h3><p>While convenient, this approach doesn’t provide fine-grained control over error handling or streaming conversion and may be less efficient for large data.</p><h3 id="handling-malformed-and-unmappable-characters">Handling Malformed and Unmappable Characters</h3><p>When converting between charsets, you may encounter characters that cannot be mapped from source to target charset. Both <code>CharsetDecoder</code> and <code>CharsetEncoder</code> allow configuring error handling strategies:</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-Java">decoder.onMalformedInput(CodingErrorAction.REPLACE);
decoder.onUnmappableCharacter(CodingErrorAction.IGNORE);

encoder.onMalformedInput(CodingErrorAction.REPORT);
encoder.onUnmappableCharacter(CodingErrorAction.REPLACE);</code></pre>
</div><p>Options include:</p><ul>
 <li><code>REPORT</code>: Throw an exception on error (default).</li>
 <li><code>REPLACE</code>: Substitute with a replacement character (usually <code>?</code>).</li>
 <li><code>IGNORE</code>: Skip the problematic input.</li>
</ul><p>Use these settings depending on your tolerance for data loss or corruption.</p><h3 id="summary">Summary</h3><ul>
 <li>Charset conversion in Java involves <strong>decoding bytes to characters</strong> from the source charset and <strong>encoding characters to bytes</strong> in the target charset.</li>
 <li>Use <code>CharsetDecoder</code> and <code>CharsetEncoder</code> for controlled, streaming-capable, and robust conversions.</li>
 <li>For quick tasks, <code>new String(byte[], charset)</code> and <code>String.getBytes(charset)</code> may suffice.</li>
 <li>Always be mindful of error handling policies to deal with malformed or unmappable characters.</li>
 <li>Explicitly specifying charsets ensures your application correctly handles multilingual data and avoids text corruption.</li>
</ul><p>Mastering charset conversion techniques ensures your Java applications remain compatible with diverse data sources and produce reliably encoded output across environments.</p><div class = "chapter-navi-section">
<a href="java-io-and-nio-asynchronous-io.htm" class="nav-button prev">←</a>
<a href='java-io-and-nio.htm#working-with-character-sets-and-encodings' class="nav-button toc-link">Index</a>
<a href="java-io-and-nio-practical-java-io-and-nio-examples.htm" class="nav-button next">→</a>
</div>
<section class="download-section">
  <div class="book-cover" style="background-color: #f9f6f1;border: 1px solid #ccc;"> 
    <div class="book-cover-title" style="font-size: 18px;color: #333;top: 20px;">Java IO and NIO</div>
    <div class="book-cover-author">readbytes</div>
    <div class="book-cover-bottom-stripe" style="background-color: #333;"></div>
    <img class="book-cover-icon" style="width: 80px;height: 90px;top: 60px;" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFoAAABaCAYAAAA4qEECAAADAElEQVR4Xu2Zu6oTURSGjze0UfANtLAUzgOI4DOItc+VKk1uJ12aadNa21vbCpYK4wQmcPiYzL5k7eXM2f8HP0JYa/3ZX2PEmxshxAPi7u6uLRH2VA3lWId9VdK27WOKsQ47q6RpmucUYx12VolEOyHRToyJ5mwI7ufeeZBItBMS7YREOyHRTki0ExLthEQ7IdFOSLQTEu2ERDsxJtoq7KwSiXZCop04Ho9PKcY67KwWirEO+6qGcqzCHhGBJDoh0U5ItAP7/f6bRDtAyV3+ckYYQNHr9fo1Z8SVtG37iKI5Mzv4IKuwJwXeuvbef4ePsQ77YuGdLp85MysGHmQa9sXAG7l3JgUfZB32heh+0t3yRvfZD87NDj7KOuwLwf2cG5OEj7IO+8bg7imr1eoV55Lh0VC4bwE7cru4n3Jns9l85d7YPmdCSV8oADtyu7gfe4fzMbucCyV9oQDsyO3i/tid7i+395xjuHMfzoaSvlAAduR2cf/+ne7PT/x8JL94mwzsjCZ5wTN8XAjuTynT/nKJcH9KmfaXS4T7U8q0v1wi3J9Skr8cH3cJ7l3I98Ph8HLg86SuM9zPvRMDO0JJXwjQ/Wx6yx3kI3cGZqK6CPdz78TAjlDSF0ZYLpcvOH9O0zQX/xnL2ZiuIbifeycGdoSSvjACZ2N2TnA+do9wP/dODOwIhfvZ8HCfn5wbYmDPNOybLXxYn9+cu8TArmnYN1v4sNTHcdc67JslfFTOw7hvHfbNEj6q+3n3gTMheMM67JsdfNA1j+Idq7BnlvBR2+32DWfElazX63cUzRlhACVLdCEk2QmJdmC3232RaAcoucsfzogAAxJNwp6qoRzrsK9aKMY6i8XiGTurhGKsc/ofGHZWCcVYR6J7KMY6Et1DMedwLgT3JRpQjEQXgmIkuhAUI9GFoBiJLgTFSHQhKEaiC0ExEl0IipHoQlCMRBeCYiS6EBQj0YWgGOtIdA/FWEeieyjGOhLdQzHW2e/3T9hZJRRjHfZVDeVYhT1CiDnzD27IzgFe/xOvAAAAAElFTkSuQmCC"/>
  </div>
  <div class="download-info">
    <h2 id='bottom'>Download This Ebook</h2>
    <p class="format-label">Available formats:</p>
    <div class="download-buttons">
      <a href="java-io-and-nio.pdf" class="download-button">📄 PDF</a>
      <a href="java-io-and-nio.epub" class="download-button">📘 EPUB</a>
    </div>
  </div>
</section><div class='related-books'>
<h2>Java In-Depth Books</h2>
<div class='related-book-list'>
<a href="java-io-and-nio.htm">
<div class="book-cover" style="background-color: #f9f6f1;border: 1px solid #ccc;"> 
    <div class="book-cover-title" style="font-size: 18px;color: #333;top: 20px;">Java IO and NIO</div>
    <div class="book-cover-author">readbytes</div>
    <div class="book-cover-bottom-stripe" style="background-color: #333;"></div>
    <img class="book-cover-icon" style="width: 80px;height: 90px;top: 60px;" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFoAAABaCAYAAAA4qEECAAADAElEQVR4Xu2Zu6oTURSGjze0UfANtLAUzgOI4DOItc+VKk1uJ12aadNa21vbCpYK4wQmcPiYzL5k7eXM2f8HP0JYa/3ZX2PEmxshxAPi7u6uLRH2VA3lWId9VdK27WOKsQ47q6RpmucUYx12VolEOyHRToyJ5mwI7ufeeZBItBMS7YREOyHRTki0ExLthEQ7IdFOSLQTEu2ERDsxJtoq7KwSiXZCop04Ho9PKcY67KwWirEO+6qGcqzCHhGBJDoh0U5ItAP7/f6bRDtAyV3+ckYYQNHr9fo1Z8SVtG37iKI5Mzv4IKuwJwXeuvbef4ePsQ77YuGdLp85MysGHmQa9sXAG7l3JgUfZB32heh+0t3yRvfZD87NDj7KOuwLwf2cG5OEj7IO+8bg7imr1eoV55Lh0VC4bwE7cru4n3Jns9l85d7YPmdCSV8oADtyu7gfe4fzMbucCyV9oQDsyO3i/tid7i+395xjuHMfzoaSvlAAduR2cf/+ne7PT/x8JL94mwzsjCZ5wTN8XAjuTynT/nKJcH9KmfaXS4T7U8q0v1wi3J9Skr8cH3cJ7l3I98Ph8HLg86SuM9zPvRMDO0JJXwjQ/Wx6yx3kI3cGZqK6CPdz78TAjlDSF0ZYLpcvOH9O0zQX/xnL2ZiuIbifeycGdoSSvjACZ2N2TnA+do9wP/dODOwIhfvZ8HCfn5wbYmDPNOybLXxYn9+cu8TArmnYN1v4sNTHcdc67JslfFTOw7hvHfbNEj6q+3n3gTMheMM67JsdfNA1j+Idq7BnlvBR2+32DWfElazX63cUzRlhACVLdCEk2QmJdmC3232RaAcoucsfzogAAxJNwp6qoRzrsK9aKMY6i8XiGTurhGKsc/ofGHZWCcVYR6J7KMY6Et1DMedwLgT3JRpQjEQXgmIkuhAUI9GFoBiJLgTFSHQhKEaiC0ExEl0IipHoQlCMRBeCYiS6EBQj0YWgGOtIdA/FWEeieyjGOhLdQzHW2e/3T9hZJRRjHfZVDeVYhT1CiDnzD27IzgFe/xOvAAAAAElFTkSuQmCC"/>
  </div>
</a>


<a href="java-collections.htm">
<div class="book-cover" style="background-color: #f9f6f1;border: 1px solid #ccc;"> 
    <div class="book-cover-title" style="font-size: 18px;color: #333;top: 20px;">Java Collections</div>
    <div class="book-cover-author">readbytes</div>
    <div class="book-cover-bottom-stripe" style="background-color: #333;"></div>
    <img class="book-cover-icon" style="width: 80px;height: 90px;top: 60px;" src='data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFoAAABaCAYAAAA4qEECAAADAElEQVR4Xu2dQYrUUBRFIw50JI7FrYgrcAPOXYPORHci7sah4EAQFyA6dNKosZK2Ee8/dOclP7/+i/fAmaR+Xr17KehJV2oYjDHGGGM6YRxzmgZdPKvdMt4vl03vLU15ZsYnsORB7Apd7mh2gS51VM/K+LVc6LA+0/QNKZax9RnvlG+C/tI7+6PYuYLV0MHoc72rX8ZvsP9Gq6BDyWzo/jXcjA4sfKN39E+RoYaf9F2CFAPFjGiG3b0Y5r9111LcJGZEM7QW0UNqRjTDWXwQXCojmoEk9MxmHwWGZ0QzkMT4ujy31b/D4UU8uITp/J4uRDOQxPiyPFfDy+HwQnFoCdPZFi5AM5BE/0VP51r5brgRzUASexU9/piG60VxEdO5lt6AZiCJ3Yoep+Fw8Z8DS5gHNfLncCOagSSWFE2M38tzanFBXcS9k/OwBi5AM5DE2qIn9JxaXFAXM33S5oE7+nFYhGYgiRxFX7FH4V+GEJqBJHIV3QGagSRcdBDNQBIuOohmIAkXHUQzkISLDqIZSMJFB9EMJOGig2gGknDRQTQDSbjoIJqBJHIUfffkPLCC74dNaAaSyFH0PKyiL4bVaAaS6L/oedAOrkQzkISLDqIZSMJFB9EMJNF/0bdPzsMquxLNQBL9Fz3x4eQ8sJIb0AwkkaPoK56efLvSV0MVNANJ5Cq6AzQDSbjoIJqBJFx0EM1AEi46iGYgCRcdRDOQhIsOohlIwkUH0Qwk4aKDaAaScNFBNANJuOggmoEkXHQQzUASLjqIZiAJFx1EM5CEiw6iGUjCRQfRDCSxtuh2X63oDM1AEkuKXmtxQc2IZiCJ3Yqu9vW3ztAMJLFX0ZfD4YXiUDI0A0m46CCagSTyfOm+EzQDSeiZzT4ODM+IZjiLD4NLZUQztBbRQ2pGNMPu1nh4lR/H9sfP+i5BioFgNnT/Gm5GB6Ib/im8Nf0+MtMPgb3Wquhwqw1Vwg/qbkix0EHtAl3qaHaDfx6kIf7Bm8YUyyY1Dbp4Fo0xxhhj/kd+A/PkOH57kF8HAAAAAElFTkSuQmCC'/>
  </div>
</a>


<a href="java-regex.htm">
<div class="book-cover" style="background-color: #f9f6f1;border: 1px solid #ccc;"> 
    <div class="book-cover-title" style="font-size: 18px;color: #333;top: 20px;">Java Regex</div>
    <div class="book-cover-author">readbytes</div>
    <div class="book-cover-bottom-stripe" style="background-color: #333;"></div>
    <img class="book-cover-icon" style="width: 80px;height: 90px;top: 60px;" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFoAAABaCAYAAAA4qEECAAAFo0lEQVR4Xu2d3WscVRiH+y/YXuuFkov6H9je2huvlAQvFalCEW8qiFRFQcGrmoJ4U5TSLWglFqRIlJqCH6XWalM/0lrT1O1ukt3sV5qPTZrP3XHfLTM983vPztc5s+zZPQ88N5l3Z9inwzA70Dl79iQks29oM7N3yBkoW98ZO6RC62ANdvDBtYF9lJEcxHNi+CWnOvmXs5rN9aX03eg74vcWxV6xObX3iUdxp2P7DzqDztiTB1lsaoX9InF631BJ3NH408N4vIFn/NCwL/aZVjPsGAj+a1mCwV7YUwqeyZZoxDqz8ZpsiYfY7mzQNdtGVkdsiH3b2Mj6CIztbrB3F+qMHxqRh84Iv/gsehDO6oe/IN0/ju0/gPOWhNAPO3ZW27M5HXyhTwtP4Sx68S4f9NRPuJbgnEURsa0Xmp5QWfQyMfLwqZ8XunrtT5yzKEKPWFnoem4O5xKxsVbS5vbmMu7eKOr5OUnovHro1ep0KppKPT+vP/TGWpkF0qWp2NBdwobuEjY0MnXbcb4cd5xCGbco0XOhb8wuOhdnGp4//7fl254ah9/urAZ6KrQYGL01V0sndLPJw8pUxJjQ5OXsBh5KjVZjFjRIBXoqdKWcZXHRK/kGHi45GDJMBXoqNFku3WVx0V9nNcTGiK7nLgRvT0jPhSZLacfGeK7Xb4bPJaQnQz+InWNx0USXEQzn+vsUTvKZfgxNFhfyLC4a68x+7QMejrwieVqJM+QX3+BUZHo6NDlfnGNx0auzdPsQAQxHXprEKT7jqkDPhyZni/MsLhopNoY7kcEJPuN6bBQnY2FEaDJXLLC4aGhsjIfgdtdX3sHJ2BgTmswVwmMHXrMxoBgb/+76snpkwqjQZKnusLhox7uRryd4yDA1YVxoYmG1yeKi0jP7nzs8ZJAaMTI0UVhJEPvN4zxmJzVjbGhidik8tu8ygjE7mQJGha7XZvBQTnYxPHb7zF6o8qAyU8KY0Gv37uJhPGZq4bEXpnI8KpoiRoTe3lzBQzCmq51j59aabSu/3OBxSU23cEH0fOgHT+ej8W+Fx3Yju9YuXO16ZCKV0DvVSWfrzlnm+tyP/pCVW2xGNAlibIzsunT+p65GJroamhRD4zbVyC7TFR4XXf7qIn4sVVIJ3bj9meNce0OqGLM5+Rbb7jMhePmQWXzqWWf15Of40dRIJfTmwmV2hiY1LhhUJkV2Xfn4FO4iFXo+NBkVDCpTjOzFPvEp7ko7RoQmw8CgMjGw6PJourGNCU12AoPKXHpvlMVFl4+fxF1rw6jQJIJBZbpgWJnLH34i7F0fxoamnzEYVKZI6ZkXWViZS+9+5PucDowNjUFlIlt/3GRRO7n4+vv4cSWMDI1BZcpYP/89Cxpk7cgx3EVijAuNQWV2AkOSbZpN9nfX6uHkP5xE+i50EBgRwe1e7BeO4mhs+ip0GBjw/nc/4AibCZqNQ9+EjgLGI50G/yzOeLMK9EXoqBQPPMfixYm9cek3HIuM8aHjgvFcmzs7OMpm2v8oCTE6dBJ2q/dYPC/29rZvFrcPZGgVdss1FtCLvX6/PVN5/lW2beBC62C3VGURw2z/D66EGBdaJ7vFMosZpAoDHZqIGluVgQ/dJuAnuI7IhA0NVEaOtOMuHrVP74zEhu4SNnSXkIdWfHnVbr3AAunSVOjkZaF1vI4NA+nQZKSvY7MvGNSP9AWDpEUvYlv7EtgU8UK7Sz/Z0Ongnc34/mi7apA+xNWHxND21fOa8S4buHiZu4GWJbKo8W2nxRTE0PasVkdsiZ3b2NjqhEYmaNkhGzs5Yrszjzz+GPb1QQtq2djxEZu17pvL2FWK70M2dijYC3sGgmc2LUtk8SPeXcQ6kxFcdo+kG/FBR+tSqCK4U1F6QlW7/rezms33pfTdxKdwMrGXMhm7XLWo/uWqZdgF2OPxPxXwJpKIkhiiAAAAAElFTkSuQmCC"/>
  </div>
</a>


<a href="java-functional-programming.htm">
<div class="book-cover" style="background-color: #f9f6f1;border: 1px solid #ccc;"> 
    <div class="book-cover-title" style="font-size: 18px;color: #333;top: 20px;">Java Functional Programming</div>
    <div class="book-cover-author">readbytes</div>
    <div class="book-cover-bottom-stripe" style="background-color: #333;"></div>
    <img class="book-cover-icon" style="width: 80px;height: 80px;top: 80px;" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFoAAABaCAYAAAA4qEECAAADzUlEQVR4Xu2bO4sUURCFlxVBzfwLJkb+A1MxEgMRDBQDRTBRwchARk00MRFBAwNBzEQwMBfEBz7wbWIkiIGJoInio9wZdmZ7T1V3V91bPVhaH3xJ973n3jk2vdO968JCkiRJkiRRIYphWOgI/zB/uyHBDxHFUODmIxkK3HwkQ4Gbj2QY6BDffCTDgBuPZhhw49EMA248miGgW3zj0QwBbjqiIcBNRzQEuOlohoA+8Y1HMgy4cauJEizO5EZMS0RoUSjPYKIEi7OaKMHirCZKsDiTi5iWiNAmoTyDiRIszmqiBIsz+QXTklZYeQYTJXSUl2cxUYLFWU2UYHEmb2Na0gorz2CihJ7w8iwmSrA4q4kSLM7kYUxLWmHlGUyU0C9ensVECRZnNQS4abPPMNEOy7S4BdN00L5GxmU8q4cuNXL24tll2KYrLIXW8yyLJdAJnkP3cFQ/9FzIGeEgHOBgCZhh1Qod5xkzH+PoduiVMH/qqDkQT3q4trGAEpZh1AId4/OZb3EWh14K89DRdDCecNIKzjdp+IelHcL8Nj/g7BU6r2R0+3gCHvRyN26tHdoszDdoAef2KpQt3pN7ZAc81YLzrFrAuSrfNOY/Es4rZAdcfbCywS7YPIvfMa0buiBkaFz6ATn+POy4xmvjhfGgsxpwjsUSigsr8el0UTzh7c9Vn5FBe4Q5BkuZXKFCnqsPmwviyQHsAsdarWF8tWGem/dxMRwwkG3gOJMvMM1O7S8aRJtX8hQ2aCDbwHEWvXAte3pPlmCDBxKhK3yMRU9cbiOKp0k+aQg3+K7pTdUPyHeYVgELL9At7/zqLA9KH0YmNh5qqqHPwgJWLzby8JxBb1y+Wxve+vXCwguc5Lzmxy164lLy1IL32SJ0Qwi3+k04ZtSLqttFm3dxlUJY8Lzdijsqo+QtnFqPK5u2CcFz1APT++RSPe7ZLHSO1qL6zYiXmu/WXdAaIXRO1lD8mnSpsOKHmpu4CyMscB5W/m8rlqex8TBS+lBTDQYObS2Y16vwxFfydbAaDBzaWmgXz2y14/46fg3Kxre5E2cXwoKH8geuXIb4hzNo11u4ZVRX9kmcVQELH0hP6BTPnym9T26h8559Gkc7wBYZQG/oLF+D/WZEgfht5AyOcoLeC4s5OwR0oLHGVTyrh643cvbjWWewGFc/4mr/MXRQKMjJBMCCvEwAWsdL8jARwJKqvYMrJDNYWRUmHWBZNSY9YGGlJj1gYUWew9REhBVnNFFCX3l5FhMDWJ7WpAAssc+kAiyzzcQJLHbibxyVJEmSJMk/xB+4wdarC+OVAQAAAABJRU5ErkJggg=="/>
  </div>
</a>


<a href="java-streams.htm">
<div class="book-cover" style="background-color: #f9f6f1;border: 1px solid #ccc;"> 
    <div class="book-cover-title" style="font-size: 18px;color: #333;top: 20px;">Java Streams</div>
    <div class="book-cover-author">readbytes</div>
    <div class="book-cover-bottom-stripe" style="background-color: #333;"></div>
    <img class="book-cover-icon" style="width: 80px;height: 80px;top: 60px;" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFoAAABaCAYAAAA4qEECAAACbklEQVR4Xu3cP4oUQRiG8S8xEzESDI1MPIRHEQQPYTK9iCyewMxrGIiCoaFnWFkMTIwUxD894KI8VbNdVdNfzdR87w+eRKa2ul+WVZM1G8+3ud+d+mhBvbZ0DO/uWEAcoVfhcIBehcQRvAvt1dz7gjjaVfxcrhcmxTiwvkudcGAN7YQDa2gnHFhDO+HAGtoJB24ZmmdzhcdBWobh2VzhcZCWYXg2V3gcpGUYns0VHgdpGYZnc4XHQVqG4dlc4XGQlmF4Nld4HKRlGJ7NFR4HaRmGZ3MN48Hcu7lLS19ihI7SPUsfdPSOCh/ulDoKfKhT7KC2P3P5QKfawfBBTr2D4ENEqDs+QJS64uWR6ubc0ssj1Q0vjlYXvLS1X3Mv5x7NPTyi+Jy5uuClNY2Az5zL3RtLLy1pJHz2XO544VLbHw+j4TvkcscLlxoR3yGXO154XaPie+Ry9djSC69rVHyPXK62/xTjhbu6+HtmRHyXXK6iDH1wGroTDd2Jhu5EQ3eioTvR0J1o6E40tAMOt1YCHGitBDjQWglwoLUS4EBrJcCB1kqAA62VwFOnREREROSIPbP7/CNZ28Y+2KT/hPjbjnyVOPl/ZA3tZLLzZGiN7YAD/+smPyqt0nH1Xe2Cw7LndpdHpBZH3ZXs4YndSAbdleyBYy4ljTjkUtKAI5a0sS/8MrKEI5YmFTZ2mQxYmlTgeDVt7DO/nOzC8WqTApPdSoarTQpM9ikZrjYpMNmPZLjapMDZ/JcZh6tNCkx2OxmuNinE4WraDPnbZw5ksp/JgKVJJQ5YmjTgiEvJHib7mgyaS1Yy2dtk3DP7zo9F9wfJyGVFhM8g5gAAAABJRU5ErkJggg=="/>
  </div>
</a>



<a href='java.htm'><div class='book-cover' style='background-color: #f9f6f1;color: #111111;border: 1px solid #ccc;display: flex;justify-content: center;align-items: center;text-align: center;'>More Java Books</div></a>
</div>
</div>
  </div>
  <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/prism.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
  
  <script>
    function copyCode(button) {
      const code = button.nextElementSibling.innerText;
      navigator.clipboard.writeText(code).then(() => {
        button.textContent = 'Copied!';
        setTimeout(() => { button.textContent = 'Copy'; }, 1500);
      });
    }
  </script>  
<div id="floatingLog" aria-live="polite" role="alert"></div>
<footer class="page-footer">
    <nav>
      <a href="https://readbytes.github.io">Home</a> | 
      Email:<script language="JavaScript" type="text/javascript">
var part1 = 'yinpeng';var part6 = '263';var part2 = Math.pow(2,6);var part3 = String.fromCharCode(part2);var part4 = 'hotmail dot com';var part5 = part1 + String.fromCharCode(part2) + part4;document.write(part1 + part6 + part3 + part4);
</script>
    </nav>
  <p>© 2025 — All rights reserved.</p>    
  </footer>

</body>
</html>