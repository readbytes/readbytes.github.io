<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>C for Beginners Project: Building a Command-Line Calculator</title>
<link rel='shortcut icon' href='https://java2s.com/style/favicon.ico'>
<link href="https://fonts.googleapis.com/css2?family=Merriweather&display=swap" rel="stylesheet" />
<link href="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet" />


  <script>
  const mode = localStorage.getItem('mode') || 'light';
  document.documentElement.classList.add(`${mode}-mode`);
  </script>   
<style> 
html {
  scroll-behavior: smooth;
}

body {
  font-family: 'Merriweather', serif;
  margin: 0;
  padding: 2rem 1rem;
  font-size: 15px;
  line-height: 1.5;
  transition: background-color 0.3s, color 0.3s;
}

.container {
  max-width: 700px;
  margin: 0 auto;
  padding: 1rem 2rem;
  box-shadow: 0 0 15px rgba(0,0,0,0.1);
}

h1, h2, h3 {
  font-weight: 600;
  margin-top: 2.5rem;
  margin-bottom: 1rem;
  line-height: 1.2;
}

h1 { font-size: 1.8rem; }
h2 { font-size: 1.4rem; }
h3 { font-size: 1.2rem; }

table {
  width: 100%;
  border-collapse: collapse;
  font-family: sans-serif;
  font-size: 1em;
  margin: 1em 0;
}

th, td {
  padding: 0.6em 1em;
  text-align: left;
  border: 1px solid;
}

tr:nth-child(even) {
  background-color: inherit;
}

tr:hover {
  background-color: inherit;
}

a {
  text-decoration: none;
  transition: color 0.2s;
}

a:hover {
  text-decoration: underline;
}

code {
  color: #d35400;
}

.book-title-chapter {
  font-family: 'Merriweather', serif;
  font-size: 2rem;
  font-weight: bold;
  text-align: center;
  margin-bottom: 2rem;
  border-bottom: 2px solid;
  padding-bottom: 0.5rem;
}

.book-subtitle-chapter {
  text-align: center;
  font-size: 1rem;
  margin-top: -1rem;
  margin-bottom: 2rem;
}

.related-books {
  margin-top: 40px;
}

.related-book-list {
  display: flex;
  flex-wrap: wrap;
  gap: 20px;
}

    .book-cover {
      width: 130px;
      height: 180px;
      font-family: Arial, sans-serif;
      position: relative;
      overflow: hidden;      
      line-height: normal;
      box-shadow: 2px 2px 4px rgba(0,0,0,0.1);
    }
    .book-cover-bottom-stripe {
      position: absolute;
      bottom: 0;
      left: 0;
      height: 5px;
      width: 100%;
    }
    .book-cover-title {
      position: absolute;
      width: 100%;
      text-align: center;
      font-weight: bold;
    }
     
    .book-cover-icon {
      position: absolute;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      align-items: center;
      justify-content: center; 
    }

    .book-cover-author {
      position: absolute;
      bottom: 10px;
      width: 100%;
      text-align: center;
      font-size: 8px;
      color: #333;
    }

.page-footer {
  margin-top: 4rem;
  padding: 1rem 0;
  text-align: center;
  font-size: 0.85rem;
  border-top: 1px solid;
}

.chapter-navi-section {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding-bottom: 10px;
}

.nav-link {
  color: inherit;
  text-decoration: none;
  opacity: 0.5;
  transition: opacity 0.3s ease, text-decoration 0.3s ease;
}

.nav-link:hover {
  opacity: 0.9;
  text-decoration: underline;
}

.prev { text-align: left; }
.toc-link { text-align: center; }
.next { text-align: right; }

.download-section {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 2rem;
  padding: 2rem 1rem;
  max-width: 600px;
  margin: 3rem auto;
  border-radius: 12px;
  box-shadow: 0 4px 10px rgba(0,0,0,0.05);
}

.download-info h2 {
  margin: 0 0 0.5rem;
  font-size: 1.2rem;
}

.format-label {
  margin: 0 0 0.5rem;
  font-size: 0.95rem;
}

.download-buttons {
  display: flex;
  gap: 1rem;
}

.download-button {
  background-color: #4A90E2;
  color: white;
  padding: 0.5em 1.2em;
  border-radius: 25px;
  font-size: 0.95rem;
  text-decoration: none;
  transition: background-color 0.3s ease;
}

.download-button:hover {
  background-color: #357ABD;
}

.code-block {
  position: relative;
  margin-bottom: 1em;
}

.copy-button {
  background: transparent;
  color: white;
  position: absolute;
  top: 8px;
  right: 8px;
  border: none;
  padding: 4px 8px;
  font-size: 12px;
  border-radius: 4px;
  cursor: pointer;
  z-index: 1;
}

.copy-button:hover {
  background-color: #0056b3;
}

.snippet-container {
  overflow: hidden;
}

.snippet-header {
  padding: 0.75rem 1rem;
  cursor: pointer;
  font-size: 1rem;
    background-color: #eeeeee;
    color:  #111111; 
    border-radius: 8px;
    cursor: pointer;
    box-shadow: 0 4px 6px rgba(0,0,0,0.1);  
}

.snippet-body {
  display: none;
  font-family: monospace;
}

.snippet-container.open .snippet-body {
  display: block;
}

.CodeMirror {
  border: 2px solid #ccc;
  border-radius: 4px;
  resize: vertical;
}

/* === Light Mode === */
html.light-mode {
  background-color: #f8f7f5;
  color: #333;
}

html.light-mode .container {
  background: white;
}

html.light-mode .book-title-chapter {
  color: #2c3e50;
  border-color: #ccc;
}
html.light-mode .book-subtitle-chapter{
  color: #888;
}

html.light-mode .page-footer,
html.light-mode .series-name,
html.light-mode .book-subtitle,
html.light-mode .format-label {
  color: #888;
}

html.light-mode .related-books h2 {
  color: #333;
  border-bottom: 2px solid #eee;
}

html.light-mode .book-title {
  color: #fff;
}

html.light-mode .book-cover {
  border: 1px solid #ccc;
}

html.light-mode th {
  background-color: #f2f2f2;
}

html.light-mode tr:nth-child(even) {
  background-color: #fafafa;
}

html.light-mode tr:hover {
  background-color: #e6f7ff;
}

html.light-mode a,
html.light-mode .page-footer a {
  color: #000;
}

/* === Dark Mode === */
html.dark-mode {
  background-color: #181818;
  color: #e0e0e0;
}

html.dark-mode .container {
  background: #222;
}

html.dark-mode .book-title-chapter {
  color: #ddd;
  border-color: #444;
}

html.dark-mode .snippet-header {
    background-color: #333;
    color:  #ddd; 
}


html.dark-mode .book-subtitle-chapter,
html.dark-mode .page-footer,
html.dark-mode .series-name,
html.dark-mode .book-subtitle,
html.dark-mode .book-footer,
html.dark-mode .format-label {
  color: #aaa;
}

html.dark-mode .related-books h2 {
  color: #ddd;
  border-bottom: 2px solid #333;
}

html.dark-mode .book-title {
  color: #fff;
}

html.dark-mode .book-cover {
  border: 1px solid #555;
}

html.dark-mode th {
  background-color: #333;
  color: #fff;
}

html.dark-mode td {
  border-color: #444;
}

html.dark-mode tr:nth-child(even) {
  background-color: #2a2a2a;
}

html.dark-mode tr:hover {
  background-color: #2c3e50;
}

html.dark-mode a,
html.dark-mode .page-footer a {
  color: #eee;
}

    .dialog-backdrop {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: rgba(0,0,0,0.5);
      display: none;
      justify-content: center;
      align-items: center;
      z-index: 10;
    }

    .dialog {
      background: white;
      padding: 20px;
      width: 90vw;
      height: 80vh;
      border-radius: 8px;
      box-shadow: 0 0 20px rgba(0,0,0,0.3);
      display: flex;
      flex-direction: column;
    }
    .dialog-content {
      display: flex;
      flex: 1;
      gap: 20px;
      margin-top: 10px;
    }
    .dialog h2 {
      margin-top: 0;
    }

    .textarea_dialog {
      width: 50%;
      height: 100%;
      resize: none;
      font-family: monospace;
      font-size: 14px;
      padding: 10px;
      box-sizing: border-box;
      border: 1px solid #ccc;
    }

    .iframe_dialog {
      width: 50%;
      height: 100%;
      border: 1px solid #ccc;
    }
    .controls_dialog {
      display: flex;
      justify-content: space-between;
      margin-top: 10px;
    }    
    button { padding: 0.5em 1em; background: green; color: white; border: none; cursor: pointer; }
    button:hover { background: #1e7e34; }
    .result_iframe { width:99%; height:200px; margin-top: 1em;  resize: both;border:1px solid #ccc;}        
</style>
</head>
<body> 
  <div class="container">
    <div class = "chapter-navi-section">
<a href="c-for-beginners-memory-management-deep-dive.htm" class="nav-button prev">←</a>
<a href='c-for-beginners.htm#project-building-a-command-line-calculator' class="nav-button toc-link">Index</a>
<a href="c-for-beginners-project-simple-file-compression-utility.htm" class="nav-button next">→</a>
</div>

    <h1 class="book-title-chapter" id = 'top'>Project: Building a Command-Line Calculator</h1>
    <h3 class="book-subtitle-chapter">C for Beginners</h3>   
    <!-- <h1 class ="chapter-title"></h1> -->
    <h2 id='parsing-expressions'>20.1 Parsing Expressions</h2><p>Building a command-line calculator requires the ability to understand and process mathematical expressions entered by the user. This process is called <strong>parsing</strong>, and it involves reading an input string, breaking it down into meaningful components (tokens), and organizing those tokens so the program can evaluate the expression correctly.</p><p>In this section, we will explore how to parse simple arithmetic expressions from command-line input. We’ll discuss tokenization, handling operators and numbers, and respecting operator precedence. Finally, we’ll design a basic parser that breaks expressions into tokens such as numbers, operators, and parentheses, which is the first step toward evaluation.</p><h3 id="what-is-parsing">What Is Parsing?</h3><p>Parsing is the process of analyzing a string of symbols (characters) to determine its grammatical structure according to defined rules. For a calculator, the input expression like:</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-bash">3 + 4 * (2 - 1)</code></pre>
</div><p>needs to be decomposed into tokens:</p><ul>
 <li>Numbers: <code>3</code>, <code>4</code>, <code>2</code>, <code>1</code></li>
 <li>Operators: <code>+</code>, <code>*</code>, <code>-</code></li>
 <li>Parentheses: <code>(</code>, <code>)</code></li>
</ul><p>After tokenization, these tokens can be processed respecting mathematical rules, especially <strong>operator precedence</strong> (multiplication before addition) and <strong>associativity</strong>.</p><h3 id="step-1-tokenization">Step 1: Tokenization</h3><p><strong>Tokenization</strong> means scanning the input string and separating it into atomic units called <em>tokens</em>. Each token has a type, such as:</p><ul>
 <li><strong>NUMBER</strong>: Represents numeric values (integers or floating-point).</li>
 <li><strong>OPERATOR</strong>: Symbols like <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>.</li>
 <li><strong>PARENTHESIS</strong>: Left <code>(</code> or right <code>)</code> parentheses.</li>
 <li><strong>END</strong>: Special token indicating the end of input.</li>
</ul><p><strong>Why tokenize?</strong> Tokenization simplifies parsing because instead of dealing with raw characters, the program works with meaningful components.</p><h3 id="basic-tokenizer-design">Basic Tokenizer Design</h3><p>A tokenizer reads characters from the input string one by one and groups them as follows:</p><ul>
 <li><strong>Skip whitespace:</strong> Spaces and tabs separate tokens but don’t have meaning themselves.</li>
 <li><strong>Numbers:</strong> One or more digits possibly including a decimal point.</li>
 <li><strong>Operators and parentheses:</strong> Single characters representing math operations or grouping.</li>
</ul><h3 id="sample-code-tokenizer-implementation">Sample Code: Tokenizer Implementation</h3><p>Here’s a simplified tokenizer in C that reads an input string and extracts tokens.</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;ctype.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;

typedef enum {
    TOKEN_NUMBER,
    TOKEN_OPERATOR,
    TOKEN_PAREN_OPEN,
    TOKEN_PAREN_CLOSE,
    TOKEN_END,
    TOKEN_INVALID
} TokenType;

typedef struct {
    TokenType type;
    double value;      // valid if type == TOKEN_NUMBER
    char op;           // valid if type == TOKEN_OPERATOR
} Token;

typedef struct {
    const char *input;
    size_t pos;
    Token current_token;
} Tokenizer;

// Function to advance tokenizer to the next token
void next_token(Tokenizer *tz) {
    const char *str = tz-&gt;input;
    size_t i = tz-&gt;pos;

    // Skip whitespace
    while (isspace(str[i])) i++;

    char c = str[i];
    if (c == '\0') {
        tz-&gt;current_token.type = TOKEN_END;
        tz-&gt;pos = i;
        return;
    }

    if (isdigit(c) || c == '.') {
        // Parse number
        char buffer[64];
        size_t j = 0;
        while (isdigit(str[i]) || str[i] == '.') {
            if (j &lt; sizeof(buffer) - 1) {
                buffer[j++] = str[i];
            }
            i++;
        }
        buffer[j] = '\0';
        tz-&gt;current_token.type = TOKEN_NUMBER;
        tz-&gt;current_token.value = atof(buffer);
        tz-&gt;pos = i;
        return;
    }

    if (c == '+' || c == '-' || c == '*' || c == '/') {
        tz-&gt;current_token.type = TOKEN_OPERATOR;
        tz-&gt;current_token.op = c;
        tz-&gt;pos = i + 1;
        return;
    }

    if (c == '(') {
        tz-&gt;current_token.type = TOKEN_PAREN_OPEN;
        tz-&gt;pos = i + 1;
        return;
    }

    if (c == ')') {
        tz-&gt;current_token.type = TOKEN_PAREN_CLOSE;
        tz-&gt;pos = i + 1;
        return;
    }

    tz-&gt;current_token.type = TOKEN_INVALID;
    tz-&gt;pos = i + 1;
}</code></pre>
</div><p><strong>Explanation:</strong></p><ul>
 <li>The <code>Tokenizer</code> struct holds the input string and current position.</li>
 <li><code>next_token()</code> updates <code>current_token</code> by reading from <code>input</code>.</li>
 <li>Numbers are parsed using <code>atof()</code> after collecting all digit and decimal characters.</li>
 <li>Operators and parentheses are recognized as single characters.</li>
 <li>Whitespace is skipped.</li>
</ul><h3 id="step-2-handling-operators-and-precedence">Step 2: Handling Operators and Precedence</h3><p>Once tokenized, your parser needs to respect <strong>operator precedence</strong>:</p><ul>
 <li>Multiplication (<code>*</code>) and division (<code>/</code>) have higher precedence than addition (<code>+</code>) and subtraction (<code>-</code>).</li>
 <li>Parentheses override precedence and force evaluation order.</li>
</ul><p>Handling precedence usually involves parsing techniques such as <strong>recursive descent parsing</strong>, or converting expressions to <strong>Reverse Polish Notation (RPN)</strong> using the <strong>Shunting Yard algorithm</strong>.</p><p>For a simple calculator, you can:</p><ul>
 <li><p>Parse expressions by recursive functions where:</p>
  <ul>
   <li>One function handles addition and subtraction.</li>
   <li>Another handles multiplication and division.</li>
   <li>Another handles parentheses and numbers.</li>
  </ul></li>
</ul><p>This method respects precedence naturally.</p><h3 id="example-token-stream-walkthrough">Example: Token Stream Walkthrough</h3><p>For the input:</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-bash">3 + 4 * (2 - 1)</code></pre>
</div><p>The tokenizer produces:</p><table>
 <thead>
  <tr>
   <th>Token Type</th>
   <th>Value/Operator</th>
  </tr>
 </thead>
 <tbody>
  <tr>
   <td>NUMBER</td>
   <td>3</td>
  </tr>
  <tr>
   <td>OPERATOR</td>
   <td>+</td>
  </tr>
  <tr>
   <td>NUMBER</td>
   <td>4</td>
  </tr>
  <tr>
   <td>OPERATOR</td>
   <td>*</td>
  </tr>
  <tr>
   <td>PAREN_OPEN</td>
   <td>(</td>
  </tr>
  <tr>
   <td>NUMBER</td>
   <td>2</td>
  </tr>
  <tr>
   <td>OPERATOR</td>
   <td>-</td>
  </tr>
  <tr>
   <td>NUMBER</td>
   <td>1</td>
  </tr>
  <tr>
   <td>PAREN_CLOSE</td>
   <td>)</td>
  </tr>
  <tr>
   <td>END</td>
   <td></td>
  </tr>
 </tbody>
</table><p>The parser will recognize that multiplication occurs before addition, and the parentheses indicate that subtraction happens before multiplication.</p><h3 id="summary">Summary</h3><p>Parsing mathematical expressions from command-line input involves:</p><ul>
 <li><strong>Tokenization</strong>: Splitting the input into numbers, operators, and parentheses.</li>
 <li><strong>Operator Handling</strong>: Recognizing the role and precedence of operators.</li>
 <li><strong>Parsing Design</strong>: Structuring code (often with recursion) to process tokens respecting precedence and grouping.</li>
</ul><p>The tokenizer example shown here is a solid foundation. From here, you can extend your parser to build an <strong>abstract syntax tree (AST)</strong> or use a stack-based algorithm for expression evaluation, which we will cover in the next chapter.</p><div class = "chapter-navi-section">
<a href="#top" class="nav-button prev">↑</a>
<a href='c-for-beginners.htm#project-building-a-command-line-calculator' class="nav-button toc-link">Index</a>
<a href="#bottom" class="nav-button next">↓</a>
</div>
<h2 id='stack-based-evaluation'>20.2 Stack-Based Evaluation</h2><p>Once you have parsed an expression into tokens, the next step is <strong>evaluating</strong> it to produce a numeric result. One of the most powerful and elegant ways to evaluate arithmetic expressions is by using <strong>stack-based algorithms</strong>. In this section, we introduce key techniques such as the <strong>Shunting Yard algorithm</strong> and <strong>Reverse Polish Notation (RPN)</strong> evaluation, explain how stacks are used to handle operators and operands, and provide code examples.</p><h3 id="why-use-stack-based-evaluation">Why Use Stack-Based Evaluation?</h3><p>Mathematical expressions typically contain:</p><ul>
 <li><strong>Operands</strong> (numbers)</li>
 <li><strong>Operators</strong> (like +, -, *, /)</li>
 <li><strong>Parentheses</strong> to dictate grouping and precedence</li>
</ul><p>Handling operator precedence and parentheses correctly can be tricky with simple left-to-right evaluation. Stack-based evaluation provides a systematic way to:</p><ul>
 <li>Convert infix expressions (like <code>3 + 4 * 2</code>) to a form that’s easy to compute.</li>
 <li>Evaluate expressions without recursion.</li>
 <li>Detect invalid input or errors during evaluation.</li>
</ul><h3 id="the-shunting-yard-algorithm-converting-to-reverse-polish-notation">The Shunting Yard Algorithm: Converting to Reverse Polish Notation</h3><p>Invented by Edsger Dijkstra, the <strong>Shunting Yard algorithm</strong> converts infix expressions (human-readable) into <strong>Reverse Polish Notation (RPN)</strong> — a postfix form where operators follow their operands.</p><p><strong>Example:</strong></p><p>Infix:</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-bash">3 + 4 * 2 / (1 - 5)</code></pre>
</div><p>RPN:</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-bash">3 4 2 * 1 5 - / +</code></pre>
</div><p>RPN expressions are straightforward to evaluate with a simple stack.</p><h3 id="how-does-the-shunting-yard-algorithm-work">How Does the Shunting Yard Algorithm Work?</h3><p>The algorithm uses two stacks:</p><ul>
 <li><strong>Operator stack:</strong> Holds operators and parentheses.</li>
 <li><strong>Output queue (or list):</strong> Stores tokens in RPN order.</li>
</ul><p><strong>Basic steps:</strong></p><ol>
 <li><p>Read tokens left to right.</p></li>
 <li><p>When reading a <strong>number</strong>, add it directly to the output queue.</p></li>
 <li><p>When reading an <strong>operator</strong>:</p>
  <ul>
   <li>While there is an operator on the top of the operator stack with higher or equal precedence, pop it to the output queue.</li>
   <li>Push the current operator on the operator stack.</li>
  </ul></li>
 <li><p>When reading a <strong>left parenthesis</strong> <code>(</code>, push it onto the operator stack.</p></li>
 <li><p>When reading a <strong>right parenthesis</strong> <code>)</code>, pop operators to the output queue until a left parenthesis is found on the stack (discard both parentheses).</p></li>
 <li><p>After processing all tokens, pop any remaining operators to the output queue.</p></li>
</ol><h3 id="evaluating-the-rpn-expression">Evaluating the RPN Expression</h3><p>Evaluating RPN is simpler:</p><ul>
 <li>Use a stack to store operands.</li>
 <li>Read tokens from the RPN expression left to right.</li>
 <li>When a <strong>number</strong> is encountered, push it onto the stack.</li>
 <li>When an <strong>operator</strong> is encountered, pop the required number of operands (usually two), apply the operator, and push the result back onto the stack.</li>
 <li>After processing all tokens, the stack contains the final result.</li>
</ul><h3 id="example-rpn-evaluation-in-c">Example: RPN Evaluation in C</h3><p>Below is a simplified example of evaluating an RPN expression stored as tokens.</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

typedef enum { NUMBER, OPERATOR } TokenType;

typedef struct {
    TokenType type;
    double value;   // valid if NUMBER
    char op;        // valid if OPERATOR
} Token;

#define MAX_STACK_SIZE 100

typedef struct {
    double data[MAX_STACK_SIZE];
    int top;
} Stack;

void push(Stack *s, double val) {
    if (s-&gt;top &lt; MAX_STACK_SIZE - 1) {
        s-&gt;data[++(s-&gt;top)] = val;
    } else {
        printf("Stack overflow!\n");
        exit(EXIT_FAILURE);
    }
}

double pop(Stack *s) {
    if (s-&gt;top &gt;= 0) {
        return s-&gt;data[(s-&gt;top)--];
    } else {
        printf("Stack underflow!\n");
        exit(EXIT_FAILURE);
    }
}

double evaluate_rpn(Token tokens[], int length) {
    Stack stack = {.top = -1};

    for (int i = 0; i &lt; length; i++) {
        Token t = tokens[i];
        if (t.type == NUMBER) {
            push(&amp;stack, t.value);
        } else if (t.type == OPERATOR) {
            double b = pop(&amp;stack);
            double a = pop(&amp;stack);
            double res;

            switch (t.op) {
                case '+': res = a + b; break;
                case '-': res = a - b; break;
                case '*': res = a * b; break;
                case '/':
                    if (b == 0) {
                        printf("Error: Division by zero\n");
                        exit(EXIT_FAILURE);
                    }
                    res = a / b; break;
                default:
                    printf("Unknown operator: %c\n", t.op);
                    exit(EXIT_FAILURE);
            }
            push(&amp;stack, res);
        }
    }
    if (stack.top != 0) {
        printf("Invalid expression: stack contains extra values\n");
        exit(EXIT_FAILURE);
    }
    return pop(&amp;stack);
}

int main() {
    // Expression: 3 4 2 * 1 5 - / +
    Token expr[] = {
        {NUMBER, 3, 0},
        {NUMBER, 4, 0},
        {NUMBER, 2, 0},
        {OPERATOR, 0, '*'},
        {NUMBER, 1, 0},
        {NUMBER, 5, 0},
        {OPERATOR, 0, '-'},
        {OPERATOR, 0, '/'},
        {OPERATOR, 0, '+'},
    };
    int length = sizeof(expr) / sizeof(expr[0]);

    double result = evaluate_rpn(expr, length);
    printf("Result: %lf\n", result);  
    // Output: 3 + (4*2)/(1-5) = 3 + 8 / -4 = 3 - 2 = 1

    return 0;
}</code></pre>
</div><h3 id="error-handling">Error Handling</h3><p>Stack-based evaluation can detect errors like:</p><ul>
 <li><strong>Stack underflow</strong>: When an operator needs more operands than are available.</li>
 <li><strong>Division by zero</strong>: When dividing by zero, report and terminate safely.</li>
 <li><strong>Extra operands</strong>: After evaluation, if the stack has more than one value, the expression was invalid.</li>
</ul><p>Proper error messages and early exits help debug user input issues.</p><h3 id="benefits-of-stack-based-evaluation">Benefits of Stack-Based Evaluation</h3><ul>
 <li><strong>Simplicity</strong>: Evaluating RPN is straightforward with a stack.</li>
 <li><strong>Precedence Handling</strong>: The Shunting Yard algorithm cleanly converts infix to postfix while respecting precedence.</li>
 <li><strong>Extensibility</strong>: New operators can be added easily by extending operator handling code.</li>
 <li><strong>Efficiency</strong>: No recursion or complicated tree structures needed for basic arithmetic.</li>
</ul><h3 id="summary">Summary</h3><p>Stack-based evaluation breaks down expression computation into two phases:</p><ol>
 <li><strong>Parsing</strong> the infix expression into RPN using the Shunting Yard algorithm.</li>
 <li><strong>Evaluating</strong> the RPN expression using a simple operand stack.</li>
</ol><p>This approach ensures correct handling of operator precedence and parentheses, while providing clear, manageable code for expression evaluation. You can combine the tokenizer from the previous section with these stack algorithms to build a full-featured command-line calculator.</p><p>In the next section, we will explore how to organize this functionality into clean, modular code for easy maintenance and expansion.</p><div class = "chapter-navi-section">
<a href="#top" class="nav-button prev">↑</a>
<a href='c-for-beginners.htm#project-building-a-command-line-calculator' class="nav-button toc-link">Index</a>
<a href="#bottom" class="nav-button next">↓</a>
</div>
<h2 id='modular-design'>20.3 Modular Design</h2><p>Building a command-line calculator that handles expression parsing, evaluation, input/output, and error handling can quickly become complex if all the code is lumped together in a single file. To keep your code manageable, maintainable, and reusable, it is essential to organize the project into <strong>modular components</strong>. In this section, we discuss how to break down your calculator into logical modules, the benefits of modular design, and offer guidelines on structuring the codebase with clear interfaces and responsibilities.</p><h3 id="why-modular-design">Why Modular Design?</h3><p>Modular design is a software engineering practice that involves splitting a program into distinct sections or modules, each responsible for a specific aspect of the overall functionality. The benefits include:</p><ul>
 <li><strong>Maintainability:</strong> Smaller, focused modules are easier to understand, fix, and update without impacting unrelated code.</li>
 <li><strong>Testability:</strong> Modules can be tested independently, making it easier to isolate bugs and verify correctness.</li>
 <li><strong>Reusability:</strong> Modules can be reused in other projects or contexts with minimal changes.</li>
 <li><strong>Collaboration:</strong> Modular code allows multiple developers to work simultaneously on different parts without conflicts.</li>
</ul><p>For a calculator, typical concerns such as parsing expressions, evaluating them, managing input/output, and handling errors can be encapsulated in separate modules.</p><h3 id="suggested-module-breakdown">Suggested Module Breakdown</h3><ol>
 <li><p><strong>Parser Module</strong> Responsibility: Tokenize input strings and convert them into a structured form (e.g., tokens or an Abstract Syntax Tree). Key functions:</p>
  <ul>
   <li><code>tokenize()</code> — split input into numbers, operators, parentheses</li>
   <li><code>parse_expression()</code> — implement algorithms like Shunting Yard to order tokens correctly Example file: <code>parser.c</code> / <code>parser.h</code></li>
  </ul></li>
 <li><p><strong>Evaluator Module</strong> Responsibility: Evaluate the parsed expression, usually in RPN form, producing a numeric result. Key functions:</p>
  <ul>
   <li><code>evaluate_rpn()</code> — process postfix tokens with a stack</li>
   <li><code>evaluate_expression()</code> — interface that takes parsed input and returns result or error Example file: <code>evaluator.c</code> / <code>evaluator.h</code></li>
  </ul></li>
 <li><p><strong>Input/Output Module</strong> Responsibility: Handle reading user input and displaying output or error messages. Key functions:</p>
  <ul>
   <li><code>read_input()</code> — get input from the user or command line arguments</li>
   <li><code>print_result()</code> — display the final result or error info Example file: <code>io.c</code> / <code>io.h</code></li>
  </ul></li>
 <li><p><strong>Error Handling Module</strong> Responsibility: Define error codes, messages, and handling mechanisms used throughout the calculator. Key functions:</p>
  <ul>
   <li><code>set_error()</code> / <code>get_error()</code></li>
   <li><code>print_error_message()</code> Example file: <code>error.c</code> / <code>error.h</code></li>
  </ul></li>
</ol><h3 id="example-file-structure">Example File Structure</h3><p>Here’s how your project directory might look:</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-bash">calculator/
├── parser.c
├── parser.h
├── evaluator.c
├── evaluator.h
├── io.c
├── io.h
├── error.c
├── error.h
├── main.c
├── Makefile</code></pre>
</div><ul>
 <li><strong><code>main.c</code></strong> serves as the entry point that ties together all modules.</li>
 <li>Each <code>.h</code> file declares the interface (function prototypes, constants).</li>
 <li>Each <code>.c</code> file contains the implementation details.</li>
</ul><h3 id="module-interfaces-and-separation-of-concerns">Module Interfaces and Separation of Concerns</h3><p>By defining clear interfaces in header files, you ensure that each module’s internal workings are hidden from others, promoting encapsulation.</p><p>For example, <strong>parser.h</strong> might look like this:</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-c">#ifndef PARSER_H
#define PARSER_H

#include "token.h"  // Defines Token and token types

int tokenize(const char *input, Token tokens[], int max_tokens);
int parse_expression(Token tokens[], int token_count, Token output[], 
                     int max_output);

#endif</code></pre>
</div><p>The <strong>evaluator.h</strong> interface could be:</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-c">#ifndef EVALUATOR_H
#define EVALUATOR_H

#include "token.h"

int evaluate_rpn(const Token tokens[], int length, double *result);

#endif</code></pre>
</div><p>The <strong>io.h</strong> interface for input/output:</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-c">#ifndef IO_H
#define IO_H

int read_input(char *buffer, int max_length);
void print_result(double result);
void print_error(const char *message);

#endif</code></pre>
</div><p>And <strong>error.h</strong> could define error codes:</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-c">#ifndef ERROR_H
#define ERROR_H

typedef enum {
    ERR_NONE,
    ERR_SYNTAX,
    ERR_DIV_ZERO,
    ERR_MEMORY,
    // Add more as needed
} ErrorCode;

const char* get_error_message(ErrorCode code);

#endif</code></pre>
</div><h3 id="how-the-modules-interact">How the Modules Interact</h3><ul>
 <li><code>main.c</code> calls <code>read_input()</code> to get user input.</li>
 <li>Input is passed to <code>tokenize()</code>, which breaks the string into tokens.</li>
 <li>Tokens are processed by <code>parse_expression()</code> to reorder them respecting operator precedence.</li>
 <li>The ordered tokens are then evaluated by <code>evaluate_rpn()</code> to produce a result.</li>
 <li>Errors at any step are captured via error codes and reported using <code>print_error()</code>.</li>
 <li>Finally, <code>print_result()</code> displays the output to the user.</li>
</ul><p>This flow separates concerns clearly, so each module focuses on one task and can be modified or enhanced independently.</p><h3 id="best-practices-for-modular-design">Best Practices for Modular Design</h3><ul>
 <li><strong>Single Responsibility:</strong> Each module should do one thing well.</li>
 <li><strong>Minimal Dependencies:</strong> Avoid unnecessary inter-module coupling.</li>
 <li><strong>Consistent Naming:</strong> Use clear, descriptive function and variable names.</li>
 <li><strong>Documentation:</strong> Comment interfaces and modules to explain usage.</li>
 <li><strong>Error Propagation:</strong> Use error codes or mechanisms to communicate problems cleanly across modules.</li>
 <li><strong>Unit Testing:</strong> Write tests for each module independently.</li>
</ul><h3 id="summary">Summary</h3><p>Modular design is a cornerstone of good software development. For your calculator project, dividing the program into parsing, evaluation, I/O, and error handling modules improves readability, debugging, and future enhancements. You get cleaner code, easier testing, and a scalable architecture that can grow — for example, by adding support for variables or more operators — without becoming unwieldy.</p><p>By planning your project structure and interfaces upfront, you set a strong foundation for robust and maintainable code.</p><div class = "chapter-navi-section">
<a href="c-for-beginners-memory-management-deep-dive.htm" class="nav-button prev">←</a>
<a href='c-for-beginners.htm#project-building-a-command-line-calculator' class="nav-button toc-link">Index</a>
<a href="c-for-beginners-project-simple-file-compression-utility.htm" class="nav-button next">→</a>
</div>
<section class="download-section">
  <div class="book-cover" style="background-color: #f9f6f1;border: 1px solid #ccc;"> 
    <div class="book-cover-title" style="font-size: 18px;color: #333;top: 20px;">C for Beginners</div>
    <div class="book-cover-author">readbytes</div>
    <div class="book-cover-bottom-stripe" style="background-color: #333;"></div>
    <img class="book-cover-icon" style="width: 90px;height: 90px;top: 70px;" src="data:image/png;base64,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"/>
  </div>
  <div class="download-info">
    <h2 id='bottom'>Download This Ebook</h2>
    <p class="format-label">Available formats:</p>
    <div class="download-buttons">
      <a href="c-for-beginners.pdf" class="download-button">📄 PDF</a>
      <a href="c-for-beginners.epub" class="download-button">📘 EPUB</a>
    </div>
  </div>
</section><div class='related-books'>
<h2>C Introduction Books</h2>
<div class='related-book-list'>
<a href="c-for-beginners.htm">
<div class="book-cover" style="background-color: #f9f6f1;border: 1px solid #ccc;"> 
    <div class="book-cover-title" style="font-size: 18px;color: #333;top: 20px;">C for Beginners</div>
    <div class="book-cover-author">readbytes</div>
    <div class="book-cover-bottom-stripe" style="background-color: #333;"></div>
    <img class="book-cover-icon" style="width: 90px;height: 90px;top: 70px;" src="data:image/png;base64,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"/>
  </div>
</a>



<a href='c.htm'><div class='book-cover' style='background-color: #f9f6f1;color: #111111;border: 1px solid #ccc;display: flex;justify-content: center;align-items: center;text-align: center;'>More C Books</div></a>
</div>
</div>
  </div>
  <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/prism.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
  
  <script>
    function copyCode(button) {
      const code = button.nextElementSibling.innerText;
      navigator.clipboard.writeText(code).then(() => {
        button.textContent = 'Copied!';
        setTimeout(() => { button.textContent = 'Copy'; }, 1500);
      });
    }
  </script>  
<div id="floatingLog" aria-live="polite" role="alert"></div>
<footer class="page-footer">
    <nav>
      <a href="https://readbytes.github.io">Home</a> | 
      Email:<script language="JavaScript" type="text/javascript">
var part1 = 'yinpeng';var part6 = '263';var part2 = Math.pow(2,6);var part3 = String.fromCharCode(part2);var part4 = 'hotmail dot com';var part5 = part1 + String.fromCharCode(part2) + part4;document.write(part1 + part6 + part3 + part4);
</script>
    </nav>
  <p>© 2025 — All rights reserved.</p>    
  </footer>

</body>
</html>