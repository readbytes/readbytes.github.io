<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>JavaScript Algorithms Sorting and Order: Linear-Time Sorting</title>
<link rel='shortcut icon' href='https://java2s.com/style/favicon.ico'>
<link href="https://fonts.googleapis.com/css2?family=Merriweather&display=swap" rel="stylesheet" />
<link href="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet" />

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/codemirror.min.css" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/theme/material.css"> <!-- Dark theme -->
<script src="https://cdn.jsdelivr.net/npm/typescript@5/lib/typescript.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/codemirror.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/mode/htmlmixed/htmlmixed.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/mode/xml/xml.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/mode/css/css.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/mode/javascript/javascript.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/mode/javascript/typescript.min.js"></script>
<style>
    #floatingLog {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(20, 20, 20, 0.95);
      color: white;
      font-family: monospace;
      font-size: 14px;
      padding: 16px 20px;
      border-radius: 8px;
      box-shadow: 0 4px 16px rgba(0, 0, 0, 0.4);
      max-width: 80%;
      max-height: 200px;
      overflow-y: auto;
      display: none;
      z-index: 9999;
      pointer-events: none;
      white-space: pre-wrap;
      text-align: center;
    }
</style>
<script>
  const codeMirrorMap = new Map();
  const iframeMap = new Map();
  
 

  let dismissTimer;
  function showFloatingLog(message) {
	const floatingLog = document.getElementById('floatingLog');

    if (floatingLog.style.display !== 'block') {
      floatingLog.textContent = '';
      floatingLog.style.display = 'block'; 
    }

    floatingLog.textContent += message + '\n';
    floatingLog.scrollTop = floatingLog.scrollHeight; 
    clearTimeout(dismissTimer);
    dismissTimer = setTimeout(() => {
      floatingLog.style.display = 'none';
      floatingLog.textContent = '';
    }, 2000);
  }
  window.addEventListener('message', (event) => {
	    if (!iframeMap.has(event.source)) return;

	    if (event.data?.type === 'console-log') {
	      showFloatingLog(event.data.message);
	    }
  });  
  function renderIframe(button,textarea_id, iframe_id) {
      const html = codeMirrorMap.get(textarea_id).getValue();
      const iframe = document.getElementById(iframe_id);
  
      const oldIframe = iframe;
      const newIframe = document.createElement('iframe');
      newIframe.className ="result_iframe";
      
      newIframe.id = iframe_id;
      oldIframe.replaceWith(newIframe);
 

      // Track the iframe in the map
      iframeMap.set(newIframe.contentWindow, button);

      const overrideScript = `
        <script>
          (function() {
            const originalLog = console.log;
            console.log = function(...args) {
              originalLog.apply(console, args);
              window.parent.postMessage({
                type: 'console-log',
                message: args.map(a => {
                  try { return JSON.stringify(a); }
                  catch { return String(a); }
                }).join(' ')
              }, '*');
            };
          })();
        <\/script>
      `;

      const iframeHTML = `
        <!DOCTYPE html>
        <html>
        <body>
          ${overrideScript}
          ${html}
        </body>
        </html>
      `;
 
      const doc = newIframe.contentDocument || newIframe.contentWindow.document;
      doc.open();
      doc.write(iframeHTML);
      doc.close();

      
  }
  function renderIframeForClientTypescript(textarea_id, iframe_id) {
      let code = codeMirrorMap.get(textarea_id).getValue();
      code = ts.transpile(code);
      const iframe = document.getElementById(iframe_id);
      const doc = iframe.contentDocument || iframe.contentWindow.document;

const html = `
  <!DOCTYPE html>
  <html>
    <head>
      <title>Output</title>
      <style>
        body { font-family: monospace; padding: 1em; background: #f4f4f4; color: #222; }
        pre { white-space: pre-wrap; word-break: break-word; }
        .error { color: red; }
      </style>
    </head>
    <body>
      <pre id="log"></pre>
      <script>
        (function(){
          const logEl = document.getElementById('log');
          const origLog = console.log;
          const origError = console.error;

          console.log = (...args) => {
            logEl.textContent += args.join(' ') + '\\n';
            origLog.apply(console, args);
          };
          console.table = (...args) => {
            logEl.textContent += args.join(' ') + '\\n';
            origLog.apply(console, args);
          };

          console.error = (...args) => {
            logEl.innerHTML +='<span class="error">' + args.join(' ') + '</span>';
            origError.apply(console, args);
          };
          window.addEventListener("error", function (event) {
              console.error("Caught by event listener:", event.message);
          });    
          try {             
              ${code};
          } catch (err) {
            console.error(err.stack || err.message);
          }
        })();
      <\/script>
    </body>
  </html>
`;

      iframe.style.display = "block";
      iframe.srcdoc = html;  
  }

    function renderIframeForClientJavascript(textarea_id, iframe_id) {
        const code = codeMirrorMap.get(textarea_id).getValue();
        const iframe = document.getElementById(iframe_id);
        const doc = iframe.contentDocument || iframe.contentWindow.document;

  const html = `
    <!DOCTYPE html>
    <html>
      <head>
        <title>Output</title>
        <style>
          body { font-family: monospace; padding: 1em; background: #1e1e1e; color: #eee; }
          pre { white-space: pre-wrap; word-break: break-word; }
          .error { color: red; }
        </style>
      </head>
      <body>
        <pre id="log"></pre>
        <script>
          (function(){
            const logEl = document.getElementById('log');
            const origLog = console.log;
            const origError = console.error;

            console.log = (...args) => {
              logEl.textContent += args.join(' ') + '\\n';
              origLog.apply(console, args);
            };
            console.table = (...args) => {
              logEl.textContent += args.join(' ') + '\\n';
              origLog.apply(console, args);
            };

            console.error = (...args) => {
              logEl.innerHTML +='<span class="error">' + args.join(' ') + '</span>';
              origError.apply(console, args);
            };
            window.addEventListener("error", function (event) {
                console.error("Caught by event listener:", event.message);
            });    
            try {
             ${code}; 
            } catch (err) {
              console.error(err.stack || err.message);
            }
          })();
        <\/script>
      </body>
    </html>
  `;
        iframe.style.display = "block";
        iframe.srcdoc = html;  
    }
    function toggleSnippetAndRefresh(id, textarea_id) {
      const box = document.getElementById(id);
      box.classList.toggle("open");
      codeMirrorMap.get(textarea_id).refresh();
    }

  </script>
  <script>
  const mode = localStorage.getItem('mode') || 'light';
  document.documentElement.classList.add(`${mode}-mode`);
  </script>   
<style> 
html {
  scroll-behavior: smooth;
}

body {
  font-family: 'Merriweather', serif;
  margin: 0;
  padding: 2rem 1rem;
  font-size: 15px;
  line-height: 1.5;
  transition: background-color 0.3s, color 0.3s;
}

.container {
  max-width: 700px;
  margin: 0 auto;
  padding: 1rem 2rem;
  box-shadow: 0 0 15px rgba(0,0,0,0.1);
}

h1, h2, h3 {
  font-weight: 600;
  margin-top: 2.5rem;
  margin-bottom: 1rem;
  line-height: 1.2;
}

h1 { font-size: 1.8rem; }
h2 { font-size: 1.4rem; }
h3 { font-size: 1.2rem; }

table {
  width: 100%;
  border-collapse: collapse;
  font-family: sans-serif;
  font-size: 1em;
  margin: 1em 0;
}

th, td {
  padding: 0.6em 1em;
  text-align: left;
  border: 1px solid;
}

tr:nth-child(even) {
  background-color: inherit;
}

tr:hover {
  background-color: inherit;
}

a {
  text-decoration: none;
  transition: color 0.2s;
}

a:hover {
  text-decoration: underline;
}

code {
  color: #d35400;
}

.book-title-chapter {
  font-family: 'Merriweather', serif;
  font-size: 2rem;
  font-weight: bold;
  text-align: center;
  margin-bottom: 2rem;
  border-bottom: 2px solid;
  padding-bottom: 0.5rem;
}

.book-subtitle-chapter {
  text-align: center;
  font-size: 1rem;
  margin-top: -1rem;
  margin-bottom: 2rem;
}

.related-books {
  margin-top: 40px;
}

.related-book-list {
  display: flex;
  flex-wrap: wrap;
  gap: 20px;
}

    .book-cover {
      width: 130px;
      height: 180px;
      font-family: Arial, sans-serif;
      position: relative;
      overflow: hidden;      
      line-height: normal;
      box-shadow: 2px 2px 4px rgba(0,0,0,0.1);
    }
    .book-cover-bottom-stripe {
      position: absolute;
      bottom: 0;
      left: 0;
      height: 5px;
      width: 100%;
    }
    .book-cover-title {
      position: absolute;
      width: 100%;
      text-align: center;
      font-weight: bold;
    }
     
    .book-cover-icon {
      position: absolute;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      align-items: center;
      justify-content: center; 
    }

    .book-cover-author {
      position: absolute;
      bottom: 10px;
      width: 100%;
      text-align: center;
      font-size: 8px;
      color: #333;
    }

.page-footer {
  margin-top: 4rem;
  padding: 1rem 0;
  text-align: center;
  font-size: 0.85rem;
  border-top: 1px solid;
}

.chapter-navi-section {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding-bottom: 10px;
}

.nav-link {
  color: inherit;
  text-decoration: none;
  opacity: 0.5;
  transition: opacity 0.3s ease, text-decoration 0.3s ease;
}

.nav-link:hover {
  opacity: 0.9;
  text-decoration: underline;
}

.prev { text-align: left; }
.toc-link { text-align: center; }
.next { text-align: right; }

.download-section {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 2rem;
  padding: 2rem 1rem;
  max-width: 600px;
  margin: 3rem auto;
  border-radius: 12px;
  box-shadow: 0 4px 10px rgba(0,0,0,0.05);
}

.download-info h2 {
  margin: 0 0 0.5rem;
  font-size: 1.2rem;
}

.format-label {
  margin: 0 0 0.5rem;
  font-size: 0.95rem;
}

.download-buttons {
  display: flex;
  gap: 1rem;
}

.download-button {
  background-color: #4A90E2;
  color: white;
  padding: 0.5em 1.2em;
  border-radius: 25px;
  font-size: 0.95rem;
  text-decoration: none;
  transition: background-color 0.3s ease;
}

.download-button:hover {
  background-color: #357ABD;
}

.code-block {
  position: relative;
  margin-bottom: 1em;
}

.copy-button {
  background: transparent;
  color: white;
  position: absolute;
  top: 8px;
  right: 8px;
  border: none;
  padding: 4px 8px;
  font-size: 12px;
  border-radius: 4px;
  cursor: pointer;
  z-index: 1;
}

.copy-button:hover {
  background-color: #0056b3;
}

.snippet-container {
  overflow: hidden;
}

.snippet-header {
  padding: 0.75rem 1rem;
  cursor: pointer;
  font-size: 1rem;
    background-color: #eeeeee;
    color:  #111111; 
    border-radius: 8px;
    cursor: pointer;
    box-shadow: 0 4px 6px rgba(0,0,0,0.1);  
}

.snippet-body {
  display: none;
  font-family: monospace;
}

.snippet-container.open .snippet-body {
  display: block;
}

.CodeMirror {
  border: 2px solid #ccc;
  border-radius: 4px;
  resize: vertical;
}

/* === Light Mode === */
html.light-mode {
  background-color: #f8f7f5;
  color: #333;
}

html.light-mode .container {
  background: white;
}

html.light-mode .book-title-chapter {
  color: #2c3e50;
  border-color: #ccc;
}
html.light-mode .book-subtitle-chapter{
  color: #888;
}

html.light-mode .page-footer,
html.light-mode .series-name,
html.light-mode .book-subtitle,
html.light-mode .format-label {
  color: #888;
}

html.light-mode .related-books h2 {
  color: #333;
  border-bottom: 2px solid #eee;
}

html.light-mode .book-title {
  color: #fff;
}

html.light-mode .book-cover {
  border: 1px solid #ccc;
}

html.light-mode th {
  background-color: #f2f2f2;
}

html.light-mode tr:nth-child(even) {
  background-color: #fafafa;
}

html.light-mode tr:hover {
  background-color: #e6f7ff;
}

html.light-mode a,
html.light-mode .page-footer a {
  color: #000;
}

/* === Dark Mode === */
html.dark-mode {
  background-color: #181818;
  color: #e0e0e0;
}

html.dark-mode .container {
  background: #222;
}

html.dark-mode .book-title-chapter {
  color: #ddd;
  border-color: #444;
}

html.dark-mode .snippet-header {
    background-color: #333;
    color:  #ddd; 
}


html.dark-mode .book-subtitle-chapter,
html.dark-mode .page-footer,
html.dark-mode .series-name,
html.dark-mode .book-subtitle,
html.dark-mode .book-footer,
html.dark-mode .format-label {
  color: #aaa;
}

html.dark-mode .related-books h2 {
  color: #ddd;
  border-bottom: 2px solid #333;
}

html.dark-mode .book-title {
  color: #fff;
}

html.dark-mode .book-cover {
  border: 1px solid #555;
}

html.dark-mode th {
  background-color: #333;
  color: #fff;
}

html.dark-mode td {
  border-color: #444;
}

html.dark-mode tr:nth-child(even) {
  background-color: #2a2a2a;
}

html.dark-mode tr:hover {
  background-color: #2c3e50;
}

html.dark-mode a,
html.dark-mode .page-footer a {
  color: #eee;
}

    .dialog-backdrop {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: rgba(0,0,0,0.5);
      display: none;
      justify-content: center;
      align-items: center;
      z-index: 10;
    }

    .dialog {
      background: white;
      padding: 20px;
      width: 90vw;
      height: 80vh;
      border-radius: 8px;
      box-shadow: 0 0 20px rgba(0,0,0,0.3);
      display: flex;
      flex-direction: column;
    }
    .dialog-content {
      display: flex;
      flex: 1;
      gap: 20px;
      margin-top: 10px;
    }
    .dialog h2 {
      margin-top: 0;
    }

    .textarea_dialog {
      width: 50%;
      height: 100%;
      resize: none;
      font-family: monospace;
      font-size: 14px;
      padding: 10px;
      box-sizing: border-box;
      border: 1px solid #ccc;
    }

    .iframe_dialog {
      width: 50%;
      height: 100%;
      border: 1px solid #ccc;
    }
    .controls_dialog {
      display: flex;
      justify-content: space-between;
      margin-top: 10px;
    }    
    button { padding: 0.5em 1em; background: green; color: white; border: none; cursor: pointer; }
    button:hover { background: #1e7e34; }
    .result_iframe { width:99%; height:200px; margin-top: 1em;  resize: both;border:1px solid #ccc;}        
</style>
</head>
<body> 
  <div class="container">
    <div class = "chapter-navi-section">
<a href="javascript-algorithms-sorting-and-order-divide-and-conquer.htm" class="nav-button prev">‚Üê</a>
<a href='javascript-algorithms.htm#sorting-and-order-linear-time-sorting' class="nav-button toc-link">Index</a>
<a href="javascript-algorithms-arrays-and-linked-lists.htm" class="nav-button next">‚Üí</a>
</div>

    <h1 class="book-title-chapter" id = 'top'>Sorting and Order: Linear-Time Sorting</h1>
    <h3 class="book-subtitle-chapter">JavaScript Algorithms</h3>   
    <!-- <h1 class ="chapter-title"></h1> -->
    <h2 id='counting-sort'>6.1 Counting Sort</h2><p>Counting sort is a <strong>non-comparison-based</strong> sorting algorithm designed specifically for sorting integers within a <strong>limited range</strong>. Unlike comparison-based algorithms (like quick sort or merge sort), counting sort does not sort by comparing elements. Instead, it counts the occurrences of each value and uses that count to build the final sorted array.</p><p>Because it avoids element-to-element comparisons, counting sort can achieve <strong>linear time complexity</strong>, O(n), under the right conditions. However, it's not universally applicable‚Äîit only works well when sorting integers or values that can be mapped to a small set of non-negative integers.</p><h3 id="when-is-counting-sort-efficient">When Is Counting Sort Efficient?</h3><p>Counting sort shines when:</p><ul>
 <li>The input consists of <strong>non-negative integers</strong>.</li>
 <li>The <strong>range of values (k)</strong> is not significantly larger than the number of elements (n).</li>
</ul><p>For example, sorting 1,000 student test scores ranging from 0‚Äì100 is ideal for counting sort.</p><p>If the range of numbers is very large (e.g., 0‚Äì1,000,000), but you only have 1,000 elements, the space overhead becomes excessive, making counting sort impractical.</p><h3 id="how-counting-sort-works">How Counting Sort Works</h3><p>The algorithm follows these steps:</p><ol>
 <li><strong>Count the occurrences</strong> of each value in the input array.</li>
 <li><strong>Accumulate</strong> counts to determine the positions of elements.</li>
 <li><strong>Place</strong> each element in its sorted position using the count data.</li>
</ol><p>Let‚Äôs sort <code>[4, 2, 2, 8, 3, 3, 1]</code>:</p><ol>
 <li><p>Count each value (from 0 to 8): <code>counts = [0, 1, 2, 2, 1, 0, 0, 0, 1]</code></p></li>
 <li><p>Accumulate positions (optional for stable version).</p></li>
 <li><p>Use the count array to build the sorted result: <code>[1, 2, 2, 3, 3, 4, 8]</code></p></li>
</ol><h3 id="javascript-implementation">JavaScript Implementation</h3><p>Here‚Äôs a simple and clear implementation of counting sort in JavaScript:</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">‚ñØ</button>
 <pre><code class="language-js">function countingSort(arr, maxValue) {
  // Step 1: Initialize count array with zeros
  const count = new Array(maxValue + 1).fill(0);

  // Step 2: Count occurrences of each value
  for (let i = 0; i &lt; arr.length; i++) {
    count[arr[i]]++;
  }

  // Step 3: Build the sorted array
  const result = [];
  for (let i = 0; i &lt; count.length; i++) {
    while (count[i] &gt; 0) {
      result.push(i);
      count[i]--;
    }
  }

  return result;
}

// Example usage
const data = [4, 2, 2, 8, 3, 3, 1];
console.log(countingSort(data, 8)); // Output: [1, 2, 2, 3, 3, 4, 8]</code></pre>
</div><blockquote>
 <p>üí° Note: You must supply <code>maxValue</code> or compute it dynamically for this function to work.</p>
</blockquote><h3 id="time-and-space-complexity">Time and Space Complexity</h3><table>
 <thead>
  <tr>
   <th>Metric</th>
   <th>Complexity</th>
  </tr>
 </thead>
 <tbody>
  <tr>
   <td><strong>Time</strong></td>
   <td>O(n + k)</td>
  </tr>
  <tr>
   <td><strong>Space</strong></td>
   <td>O(k)</td>
  </tr>
  <tr>
   <td><strong>Stable</strong></td>
   <td>‚ùå (unless modified)</td>
  </tr>
  <tr>
   <td><strong>Comparison-based</strong></td>
   <td>‚ùå</td>
  </tr>
 </tbody>
</table><ul>
 <li><strong>n</strong> = number of elements</li>
 <li><strong>k</strong> = range of input values (max - min + 1)</li>
</ul><p>In the best scenarios, when <code>k</code> is small and close to <code>n</code>, the algorithm runs in linear time‚Äî<strong>faster than any comparison-based sort</strong>.</p><h3 id="limitations">Limitations</h3><ul>
 <li>Only works for <strong>integers or discrete values</strong>.</li>
 <li>Not efficient when the value range (<code>k</code>) is <strong>much larger than <code>n</code></strong>.</li>
 <li>Standard implementation is <strong>not stable</strong>, but can be modified to preserve order.</li>
</ul><p>Counting sort is <strong>not suitable</strong> for:</p><ul>
 <li>Floating-point numbers,</li>
 <li>Arbitrary objects,</li>
 <li>Large sparse value ranges.</li>
</ul><h3 id="when-counting-sort-outperforms">When Counting Sort Outperforms</h3><p>Let‚Äôs compare performance:</p><table>
 <thead>
  <tr>
   <th>Dataset</th>
   <th>Best Algorithm</th>
  </tr>
 </thead>
 <tbody>
  <tr>
   <td><code>[4, 2, 2, 8, 3, 3, 1]</code></td>
   <td>Counting Sort (small range)</td>
  </tr>
  <tr>
   <td>1,000 integers from 0‚Äì50</td>
   <td>Counting Sort</td>
  </tr>
  <tr>
   <td>1,000,000 integers from 0‚Äì1,000,000</td>
   <td>Quick Sort (range too large)</td>
  </tr>
 </tbody>
</table><p>When the range of values is small relative to the size of the input, counting sort can outperform even the fastest comparison-based sorts like quick sort and merge sort.</p><h3 id="conclusion">Conclusion</h3><p>Counting sort is a powerful, specialized algorithm that leverages <strong>frequency counting instead of comparison</strong> to sort data. It achieves <strong>linear time performance</strong> when used under the right conditions‚Äîparticularly when sorting a large number of small-range integers. While it‚Äôs not universally applicable, it‚Äôs an important tool to have when performance matters and the data fits its constraints.</p><div class = "chapter-navi-section">
<a href="#top" class="nav-button prev">‚Üë</a>
<a href='javascript-algorithms.htm#sorting-and-order-linear-time-sorting' class="nav-button toc-link">Index</a>
<a href="#bottom" class="nav-button next">‚Üì</a>
</div>
<h2 id='radix-sort'>6.2 Radix Sort</h2><p>Radix sort is a powerful <strong>non-comparison-based</strong> sorting algorithm that sorts numbers by processing individual digits. Instead of comparing whole numbers directly, radix sort breaks them down into digits and sorts the numbers <strong>digit-by-digit</strong>, starting either from the <strong>least significant digit (LSD)</strong> or the <strong>most significant digit (MSD)</strong>.</p><h3 id="how-radix-sort-works">How Radix Sort Works</h3><p>The core idea of radix sort is to sort numbers based on their digits, grouping and ordering elements repeatedly by each digit‚Äôs value until the entire list is sorted. Radix sort relies on a <strong>stable sorting algorithm</strong> (like counting sort) at each digit level to maintain relative order.</p><p>There are two main variants:</p><ul>
 <li><p><strong>LSD Radix Sort (Least Significant Digit first):</strong> Sorting begins with the rightmost digit and moves leftward. This variant is commonly used for sorting integers and works well with fixed-length numbers or zero-padded values.</p></li>
 <li><p><strong>MSD Radix Sort (Most Significant Digit first):</strong> Sorting begins with the leftmost digit and proceeds rightward. It‚Äôs more suited for variable-length keys, such as strings or numbers with different digit counts.</p></li>
</ul><h3 id="lsd-radix-sort-step-by-step">LSD Radix Sort Step-by-Step</h3><p>Suppose we want to sort <code>[170, 45, 75, 90, 802, 24, 2, 66]</code>:</p><ol>
 <li><p>Sort by the least significant digit (units place): <code>[170, 90, 802, 2, 24, 45, 75, 66]</code></p></li>
 <li><p>Sort by the next digit (tens place): <code>[802, 2, 24, 45, 66, 170, 75, 90]</code></p></li>
 <li><p>Sort by the most significant digit (hundreds place): <code>[2, 24, 45, 66, 75, 90, 170, 802]</code></p></li>
</ol><p>After processing all digits, the array is fully sorted.</p><h3 id="javascript-implementation-lsd-radix-sort">JavaScript Implementation (LSD Radix Sort)</h3><div>
 <div class="code-block"><button class="copy-button" onclick="copyCode(this)">‚ñØ</button>
  <pre><code class="language-js">function getDigit(num, place) {
  return Math.floor(Math.abs(num) / Math.pow(10, place)) % 10;
}

function digitCount(num) {
  if (num === 0) return 1;
  return Math.floor(Math.log10(Math.abs(num))) + 1;
}

function mostDigits(nums) {
  let maxDigits = 0;
  for (let num of nums) {
    maxDigits = Math.max(maxDigits, digitCount(num));
  }
  return maxDigits;
}

function radixSort(arr) {
  const maxDigitCount = mostDigits(arr);

  for (let k = 0; k &lt; maxDigitCount; k++) {
    // Create buckets for each digit (0 to 9)
    let buckets = Array.from({ length: 10 }, () =&gt; []);

    for (let num of arr) {
      const digit = getDigit(num, k);
      buckets[digit].push(num);
    }

    // Flatten buckets back into array
    arr = [].concat(...buckets);
  }
  return arr;
}

// Example usage
const nums = [170, 45, 75, 90, 802, 24, 2, 66];
console.log(radixSort(nums)); // Output: [2, 24, 45, 66, 75, 90, 170, 802]</code></pre>
 </div>
 <div class="snippet-container" id="LQV4J">
  <div class="snippet-header" onclick="toggleSnippetAndRefresh('LQV4J','eiiyp')">
   Try it in editor
  </div>
  <div class="snippet-body"><textarea id="eiiyp">function getDigit(num, place) {
  return Math.floor(Math.abs(num) / Math.pow(10, place)) % 10;
}

function digitCount(num) {
  if (num === 0) return 1;
  return Math.floor(Math.log10(Math.abs(num))) + 1;
}

function mostDigits(nums) {
  let maxDigits = 0;
  for (let num of nums) {
    maxDigits = Math.max(maxDigits, digitCount(num));
  }
  return maxDigits;
}

function radixSort(arr) {
  const maxDigitCount = mostDigits(arr);

  for (let k = 0; k &lt; maxDigitCount; k++) {
    // Create buckets for each digit (0 to 9)
    let buckets = Array.from({ length: 10 }, () =&gt; []);

    for (let num of arr) {
      const digit = getDigit(num, k);
      buckets[digit].push(num);
    }

    // Flatten buckets back into array
    arr = [].concat(...buckets);
  }
  return arr;
}

// Example usage
const nums = [170, 45, 75, 90, 802, 24, 2, 66];
console.log(radixSort(nums)); // Output: [2, 24, 45, 66, 75, 90, 170, 802]</textarea> <br> <button onclick="renderIframeForClientJavascript('eiiyp','iqqxp')">Run</button> <iframe id="iqqxp" class="result_iframe" style="display: none;"></iframe>
   <script>
  {let editor1 = CodeMirror.fromTextArea(document.getElementById("eiiyp"), {
    mode: "javascript",
    lineNumbers:false,
    tabSize: 2
    });
    const mode = localStorage.getItem("mode") || "light";  
    const newTheme = mode === "dark" ? "material" : "default";
    editor1.setOption("theme", newTheme);

   codeMirrorMap.set("eiiyp", editor1);}
  </script>
  </div>
 </div>
</div><h3 id="complexity-and-practical-considerations">Complexity and Practical Considerations</h3><ul>
 <li><p><strong>Time complexity:</strong> O(d √ó (n + k)) Where <code>d</code> = number of digits, <code>n</code> = number of elements, and <code>k</code> = digit range (usually 10 for base-10).</p></li>
 <li><p>Radix sort can outperform comparison-based sorts like quick sort when:</p>
  <ul>
   <li>Numbers have a <strong>fixed or small number of digits</strong>.</li>
   <li>The digit range (<code>k</code>) is small.</li>
  </ul></li>
 <li><p><strong>Space complexity:</strong> Requires extra space for buckets, generally O(n + k).</p></li>
 <li><p>Radix sort is <strong>stable</strong> because it uses a stable sort (like counting sort) at each digit level.</p></li>
</ul><h3 id="handling-strings-or-fixed-length-keys">Handling Strings or Fixed-Length Keys</h3><p>Radix sort can easily extend to sort <strong>strings</strong> or fixed-length keys by processing characters from either left to right (MSD) or right to left (LSD). This is especially useful in applications like sorting words, IP addresses, or dates.</p><h3 id="when-to-use-radix-sort-in-javascript">When to Use Radix Sort in JavaScript</h3><ul>
 <li>When sorting large arrays of <strong>fixed-length integers</strong> efficiently.</li>
 <li>Sorting strings of uniform length, like fixed-length identifiers.</li>
 <li>When guaranteed linear-time sorting outperforms comparison-based sorts.</li>
</ul><h3 id="summary">Summary</h3><p>Radix sort is a versatile and efficient sorting algorithm that processes elements digit-by-digit. Its stable, linear-time behavior makes it a valuable tool in specialized scenarios, especially with integer keys of limited digit length or fixed-length strings. Understanding how digit extraction and stable bucket sorting work will help you implement radix sort effectively in JavaScript and leverage its speed advantages where applicable.</p><div class = "chapter-navi-section">
<a href="#top" class="nav-button prev">‚Üë</a>
<a href='javascript-algorithms.htm#sorting-and-order-linear-time-sorting' class="nav-button toc-link">Index</a>
<a href="#bottom" class="nav-button next">‚Üì</a>
</div>
<h2 id='bucket-sort'>6.3 Bucket Sort</h2><p>Bucket Sort is a <em>distribution-based</em> sorting algorithm particularly effective for sorting numbers that are <strong>uniformly distributed</strong> over a range. Unlike comparison-based sorts like quicksort or mergesort, bucket sort leverages the distribution of the input values to achieve <strong>linear-time performance</strong> in the average case.</p><h3 id="how-bucket-sort-works">How Bucket Sort Works</h3><p>The core idea of bucket sort is to divide the input array into a number of "buckets," sort the contents of each bucket individually (often using another sorting algorithm like insertion sort), and then concatenate the sorted buckets to form the final sorted array.</p><p>Here‚Äôs the step-by-step breakdown:</p><ol>
 <li><strong>Create Buckets</strong>: Based on the range of input values, create an array of empty buckets.</li>
 <li><strong>Distribute Input Into Buckets</strong>: Place each element in the array into one of the buckets. This distribution typically uses a simple formula to determine the right bucket for a value.</li>
 <li><strong>Sort Each Bucket</strong>: Sort the contents of each bucket. If the number of elements in each bucket is small, a simple algorithm like insertion sort is very efficient.</li>
 <li><strong>Concatenate Buckets</strong>: Combine the buckets in order to get the final sorted output.</li>
</ol><h3 id="javascript-example">JavaScript Example</h3><p>Below is a basic implementation of bucket sort in JavaScript, suitable for sorting an array of floating-point numbers in the range [0, 1).</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">‚ñØ</button>
 <pre><code class="language-js">function bucketSort(arr, bucketCount = 10) {
  if (arr.length === 0) return [];

  // Step 1: Create buckets
  const buckets = Array.from({ length: bucketCount }, () =&gt; []);

  // Step 2: Distribute values into buckets
  for (const value of arr) {
    const index = Math.floor(value * bucketCount);
    buckets[index].push(value);
  }

  // Step 3: Sort individual buckets
  for (let i = 0; i &lt; bucketCount; i++) {
    buckets[i].sort((a, b) =&gt; a - b); // Using built-in sort
  }

  // Step 4: Concatenate all buckets
  return buckets.flat();
}

// Example usage:
const input = [0.78, 0.17, 0.39, 0.26, 0.94, 0.21, 0.12, 0.23, 0.68];
console.log(bucketSort(input));</code></pre>
</div><h3 id="visualizing-bucket-sort">Visualizing Bucket Sort</h3><p>Suppose you have the input array:</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">‚ñØ</button>
 <pre><code class="language-bash">[0.78, 0.17, 0.39, 0.26, 0.94, 0.21]</code></pre>
</div><p>You could divide this into 5 buckets:</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">‚ñØ</button>
 <pre><code class="language-bash">Bucket 0: [0.17]
Bucket 1: [0.21, 0.26]
Bucket 2: [0.39]
Bucket 3: [0.78]
Bucket 4: [0.94]</code></pre>
</div><p>Each bucket is sorted:</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">‚ñØ</button>
 <pre><code class="language-bash">Bucket 0: [0.17]
Bucket 1: [0.21, 0.26]
...</code></pre>
</div><p>Concatenated result:</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">‚ñØ</button>
 <pre><code class="language-bash">[0.17, 0.21, 0.26, 0.39, 0.78, 0.94]</code></pre>
</div><h3 id="when-to-use-bucket-sort">When to Use Bucket Sort</h3><p>Bucket sort performs exceptionally well when:</p><ul>
 <li>The data is <strong>uniformly distributed</strong> across a known range.</li>
 <li>You're dealing with <strong>floating-point values</strong> between 0 and 1, or normalized datasets.</li>
 <li>You want to achieve <strong>linear average-case performance</strong>, especially when other sorts may degrade.</li>
</ul><p>However, if the input is <em>skewed</em> or unevenly distributed, some buckets may end up with many elements while others are nearly empty, resulting in a performance closer to O(n log n) or worse.</p><h3 id="performance">Performance</h3><ul>
 <li><strong>Best/Average Case</strong>: O(n + k), where <em>n</em> is the number of elements and <em>k</em> is the number of buckets.</li>
 <li><strong>Worst Case</strong>: O(n¬≤), when all elements fall into a single bucket (and that bucket is sorted using a poor algorithm).</li>
 <li><strong>Space Complexity</strong>: O(n + k)</li>
</ul><p>In JavaScript, bucket sort is most beneficial when working with numeric datasets in analytics, simulations, or normalized measurements. Its simplicity, especially when combined with built-in sorts, makes it practical and efficient for these scenarios.</p><div class = "chapter-navi-section">
<a href="#top" class="nav-button prev">‚Üë</a>
<a href='javascript-algorithms.htm#sorting-and-order-linear-time-sorting' class="nav-button toc-link">Index</a>
<a href="#bottom" class="nav-button next">‚Üì</a>
</div>
<h2 id='when-these-work-in-js-contexts'>6.4 When These Work in JS Contexts</h2><p>Linear-time sorting algorithms like <strong>Counting Sort</strong>, <strong>Radix Sort</strong>, and <strong>Bucket Sort</strong> are powerful tools, but their effectiveness in JavaScript depends heavily on the context in which they're used. Unlike general-purpose comparison-based sorts like quicksort or mergesort (used under the hood by JavaScript‚Äôs native <code>.sort()</code>), linear-time sorts are specialized‚Äîthey can outperform <code>.sort()</code> but only under certain conditions.</p><h3 id="constraints-in-javascript-environments">Constraints in JavaScript Environments</h3><p>JavaScript is a high-level, dynamic language with some built-in flexibility‚Äîbut also some limitations that matter when implementing linear-time sorting:</p><h4 id="input-data-types">Input Data Types</h4><ul>
 <li>Linear-time sorts assume numeric input, and often <strong>non-negative integers</strong> or <strong>normalized floats</strong>.</li>
 <li>JavaScript arrays can contain mixed types (e.g., strings, numbers, <code>undefined</code>), but linear sorts <strong>do not handle mixed types well</strong>.</li>
 <li>If your data is not already numeric, you may need a pre-processing step to transform it into a usable format.</li>
</ul><h4 id="value-ranges">Value Ranges</h4><ul>
 <li>Counting sort requires that you know the <strong>maximum value</strong> in advance and that the range is not too large.</li>
 <li>Radix sort is ideal for <strong>fixed-length integers</strong> or strings with known character sets.</li>
 <li>Bucket sort works best when data is <strong>uniformly distributed</strong> across a known range.</li>
</ul><p>When these assumptions break down‚Äîsuch as sorting large sparse integers or skewed float distributions‚Äîperformance and memory efficiency can degrade significantly.</p><h4 id="memory-usage">Memory Usage</h4><ul>
 <li>These algorithms typically allocate additional arrays or objects (e.g., buckets, count arrays).</li>
 <li>In large-scale applications (e.g., sorting millions of items), this can result in high memory usage or even slowdowns due to JavaScript‚Äôs garbage collection.</li>
 <li>Counting sort is especially memory-sensitive when used on data with a large range.</li>
</ul><h3 id="comparing-to-sort">Comparing to <code>.sort()</code></h3><p>JavaScript‚Äôs native <code>.sort()</code> method is well-optimized and works well in general-purpose cases:</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">‚ñØ</button>
 <pre><code class="language-js">[5, 3, 8, 1].sort((a, b) =&gt; a - b);</code></pre>
</div><p>Internally, modern engines like V8 (used by Chrome and Node.js) implement hybrid algorithms‚Äîusually <strong>Timsort</strong>, a variant of merge and insertion sort that handles many real-world cases efficiently.</p><p>So why use a linear-time sort?</p><ul>
 <li><strong>Speed</strong>: If the input is large but falls into a constrained numeric range, linear-time sorts can be <strong>much faster</strong>.</li>
 <li><strong>Control</strong>: In environments like competitive programming or performance-critical backend systems, you may need tighter control over the sorting mechanism.</li>
 <li><strong>Stability</strong>: Counting sort and radix sort are naturally stable (preserve input order of equal elements), which <code>.sort()</code> doesn‚Äôt guarantee unless implemented explicitly.</li>
</ul><h3 id="example-benchmark-comparison">Example: Benchmark Comparison</h3><div class="code-block"><button class="copy-button" onclick="copyCode(this)">‚ñØ</button>
 <pre><code class="language-js">const data = Array.from({ length: 1e6 }, () =&gt; Math.floor(Math.random() * 1000)); // small range

console.time('Native sort');
data.slice().sort((a, b) =&gt; a - b);
console.timeEnd('Native sort');

console.time('Counting sort');
countingSort(data); // assume implementation from earlier section
console.timeEnd('Counting sort');</code></pre>
</div><p>With a small range (0‚Äì999), counting sort often outperforms native <code>.sort()</code> by a large margin.</p><h3 id="best-practices">Best Practices</h3><ul>
 <li>Use <strong>Counting Sort</strong> when data is dense in a small integer range.</li>
 <li>Use <strong>Radix Sort</strong> for large arrays of integers or fixed-length strings.</li>
 <li>Use <strong>Bucket Sort</strong> for normalized floats or uniformly distributed datasets.</li>
 <li>Use <strong><code>.sort()</code></strong> for general-purpose, mixed-type, or unknown-range data.</li>
</ul><p>In summary, linear-time sorting can provide <em>significant speedups</em> in the right context. But in JavaScript, it‚Äôs essential to weigh the <strong>performance gains</strong> against <strong>code complexity</strong>, <strong>memory overhead</strong>, and <strong>data preparation costs</strong>.</p><div class = "chapter-navi-section">
<a href="javascript-algorithms-sorting-and-order-divide-and-conquer.htm" class="nav-button prev">‚Üê</a>
<a href='javascript-algorithms.htm#sorting-and-order-linear-time-sorting' class="nav-button toc-link">Index</a>
<a href="javascript-algorithms-arrays-and-linked-lists.htm" class="nav-button next">‚Üí</a>
</div>
<section class="download-section">
  <div class="book-cover" style="background-color: #f9f6f1;border: 1px solid #ccc;"> 
    <div class="book-cover-title" style="font-size: 18px;color: #333;top: 20px;">JavaScript Algorithms</div>
    <div class="book-cover-author">readbytes</div>
    <div class="book-cover-bottom-stripe" style="background-color: #333;"></div>
    <img class="book-cover-icon" style="width: 80px;height: 80px;top: 70px;" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFoAAABaCAYAAAA4qEECAAAErElEQVR4Xu2dPWgUQRiGo6BB8I+AlV3w9gzptLBWsLQ89O7ARrDXSivTCTaCnWhn7pQTxOoInpjCeEQQLC2CjVqoVSwMFpp1Jtzo7Luzs/Nd7uZ29r4HPpDsu7vPvIl7+SGTmRmGYRiGYZjCEzVacdnn9NX7+3DdXkGhMg+u3Su6SNztzsZvevH/efED8zrJbM+6EGJ2K5Hv9w9gRpHnXMyik2VsYVaHWJx7tt/bTOQ3urOYUch3QJ5z0YtOCeuQiqNlvybyto/ktbVDcG2jc5GLNgoriMW5Z/svPyfy693DmFHE71ePwrUznQta9ISeyViyKBIziri/Mpe8tt25kEXjMR1ScbQsPC5W5jCjMJT8DTM6MuO6vrHjIkIszj2LL3y2ktOPiy+Y0VE5l/V5IU+EVBwtm/wUzva4SL/wOZUsJ2993rCJEIujZJMl2174Up/C5T8u9LGtzyu6SNkH1+6VhUargkJlHVy7f5aW9qJUqeZy5zguufToBeAxZoRw0Z7goj3BRXuCi/YEF+0BvWQue0xgwfrMiy+aMM8QEUW+w2IHb8fC/+C5jCOGMhOPiqi+vG47zjiABVbr7XOYUWC2Um+fxwwDiKJeYXGYMYHniNnGDDPAUJZTyYph30nTg+G7f5VLj89gzBW8lu2xMzWIIt5iMZgZBrzmqK4bJFhENOLnatRsfcR7YKb0YAELF5+cwsyowHudrLcvYKZ0iIV+wIVjZhzgPaMR/+8pFIbFeilZUWm2Vyd5/5GxWOvsx4VkTbXROovn+wJdMqfevoHnFoKUaMbgeZMAnbIGzysEKGmZiX4DKKo/um5wMg6eWwhsgtVm62cRFoEOJg/xtltZxwqBTV4inuEHcZHztc4RzI0LvLeY15iRBF+0wrDgsX6qZXpUYEanNEVLROY3ZfHDgvdwuU+pipYs1h7OpUqI4z2YGxa8dqXefooZE6UrWoGFiMn8nRIXoubyTbymeLPzO7C0RUuiRvuXoRwyeI1hrlPqoiUnap1jWNLilU7mr0sgeK746rOFGRdKX7QCC4tyHiXi+DU8BzMUpqZoiSzXpTzMZOUoTFXROxh+xKV/gYPHqvVlp88q8pi+ogdgoabBc3bD1BYtEdfcxnLHeK/pLVoiHxvJktsPMDMKpr5oX3DRnuCiPcFFe4KL9gQX7Qku2hNctCe4aE94K1puD6mXNsmpOv74KUTnxEdmEQb9TOA5kx70M6KfcO/u8/j2nWffxb+XskZm9MHjw2YjgrTKygnFeUaF5cSEjZ4c9kJyz/Z7mxTpEJ0T0nhMhyRBy+5sTuXioAjR2UmaKEHJ/tsBLM9BJ0TnXGmiBCWb2GbN5oCE6GyVJkq4Z3FXxo3ubJaDiRCdM6VJErSscTtik0MWITobpYkS7lncKVfblREdbITonJImSVCyKAz7i1KkQ3ROSJMkaNnc7Ygp0iE6Z0pjTockjC8iBmEJRTpEZ6M0ZnRIwrhTrmU7Yop0iM4paTyusyvhnO2IKdIhOqdeWLLYlbDtL0oM/jaKi4MiRGcnaZIwPt8c/zZKnoNOiM4J6SIM+pnAcyY96GekYJtvf0I/EyE6MwzDMAzDjI+/5MPGam/zucIAAAAASUVORK5CYII="/>
  </div>
  <div class="download-info">
    <h2 id='bottom'>Download This Ebook</h2>
    <p class="format-label">Available formats:</p>
    <div class="download-buttons">
      <a href="javascript-algorithms.pdf" class="download-button">üìÑ PDF</a>
      <a href="javascript-algorithms.epub" class="download-button">üìò EPUB</a>
    </div>
  </div>
</section><div class='related-books'>
<h2>Java Introduction Books</h2>
<div class='related-book-list'>
<a href="javascript-algorithms.htm">
<div class="book-cover" style="background-color: #f9f6f1;border: 1px solid #ccc;"> 
    <div class="book-cover-title" style="font-size: 18px;color: #333;top: 20px;">JavaScript Algorithms</div>
    <div class="book-cover-author">readbytes</div>
    <div class="book-cover-bottom-stripe" style="background-color: #333;"></div>
    <img class="book-cover-icon" style="width: 80px;height: 80px;top: 70px;" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFoAAABaCAYAAAA4qEECAAAErElEQVR4Xu2dPWgUQRiGo6BB8I+AlV3w9gzptLBWsLQ89O7ARrDXSivTCTaCnWhn7pQTxOoInpjCeEQQLC2CjVqoVSwMFpp1Jtzo7Luzs/Nd7uZ29r4HPpDsu7vPvIl7+SGTmRmGYRiGYZjCEzVacdnn9NX7+3DdXkGhMg+u3Su6SNztzsZvevH/efED8zrJbM+6EGJ2K5Hv9w9gRpHnXMyik2VsYVaHWJx7tt/bTOQ3urOYUch3QJ5z0YtOCeuQiqNlvybyto/ktbVDcG2jc5GLNgoriMW5Z/svPyfy693DmFHE71ePwrUznQta9ISeyViyKBIziri/Mpe8tt25kEXjMR1ScbQsPC5W5jCjMJT8DTM6MuO6vrHjIkIszj2LL3y2ktOPiy+Y0VE5l/V5IU+EVBwtm/wUzva4SL/wOZUsJ2993rCJEIujZJMl2174Up/C5T8u9LGtzyu6SNkH1+6VhUargkJlHVy7f5aW9qJUqeZy5zguufToBeAxZoRw0Z7goj3BRXuCi/YEF+0BvWQue0xgwfrMiy+aMM8QEUW+w2IHb8fC/+C5jCOGMhOPiqi+vG47zjiABVbr7XOYUWC2Um+fxwwDiKJeYXGYMYHniNnGDDPAUJZTyYph30nTg+G7f5VLj89gzBW8lu2xMzWIIt5iMZgZBrzmqK4bJFhENOLnatRsfcR7YKb0YAELF5+cwsyowHudrLcvYKZ0iIV+wIVjZhzgPaMR/+8pFIbFeilZUWm2Vyd5/5GxWOvsx4VkTbXROovn+wJdMqfevoHnFoKUaMbgeZMAnbIGzysEKGmZiX4DKKo/um5wMg6eWwhsgtVm62cRFoEOJg/xtltZxwqBTV4inuEHcZHztc4RzI0LvLeY15iRBF+0wrDgsX6qZXpUYEanNEVLROY3ZfHDgvdwuU+pipYs1h7OpUqI4z2YGxa8dqXefooZE6UrWoGFiMn8nRIXoubyTbymeLPzO7C0RUuiRvuXoRwyeI1hrlPqoiUnap1jWNLilU7mr0sgeK746rOFGRdKX7QCC4tyHiXi+DU8BzMUpqZoiSzXpTzMZOUoTFXROxh+xKV/gYPHqvVlp88q8pi+ogdgoabBc3bD1BYtEdfcxnLHeK/pLVoiHxvJktsPMDMKpr5oX3DRnuCiPcFFe4KL9gQX7Qku2hNctCe4aE94K1puD6mXNsmpOv74KUTnxEdmEQb9TOA5kx70M6KfcO/u8/j2nWffxb+XskZm9MHjw2YjgrTKygnFeUaF5cSEjZ4c9kJyz/Z7mxTpEJ0T0nhMhyRBy+5sTuXioAjR2UmaKEHJ/tsBLM9BJ0TnXGmiBCWb2GbN5oCE6GyVJkq4Z3FXxo3ubJaDiRCdM6VJErSscTtik0MWITobpYkS7lncKVfblREdbITonJImSVCyKAz7i1KkQ3ROSJMkaNnc7Ygp0iE6Z0pjTockjC8iBmEJRTpEZ6M0ZnRIwrhTrmU7Yop0iM4paTyusyvhnO2IKdIhOqdeWLLYlbDtL0oM/jaKi4MiRGcnaZIwPt8c/zZKnoNOiM4J6SIM+pnAcyY96GekYJtvf0I/EyE6MwzDMAzDjI+/5MPGam/zucIAAAAASUVORK5CYII="/>
  </div>
</a>



<a href='java.htm'><div class='book-cover' style='background-color: #f9f6f1;color: #111111;border: 1px solid #ccc;display: flex;justify-content: center;align-items: center;text-align: center;'>More Java Books</div></a>
</div>
</div>
  </div>
  <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/prism.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
  
  <script>
    function copyCode(button) {
      const code = button.nextElementSibling.innerText;
      navigator.clipboard.writeText(code).then(() => {
        button.textContent = 'Copied!';
        setTimeout(() => { button.textContent = 'Copy'; }, 1500);
      });
    }
  </script>  
<div id="floatingLog" aria-live="polite" role="alert"></div>
<footer class="page-footer">
    <nav>
      <a href="https://readbytes.github.io">Home</a> | 
      Email:<script language="JavaScript" type="text/javascript">
var part1 = 'yinpeng';var part6 = '263';var part2 = Math.pow(2,6);var part3 = String.fromCharCode(part2);var part4 = 'hotmail dot com';var part5 = part1 + String.fromCharCode(part2) + part4;document.write(part1 + part6 + part3 + part4);
</script>
    </nav>
  <p>¬© 2025 ‚Äî All rights reserved.</p>    
  </footer>

</body>
</html>