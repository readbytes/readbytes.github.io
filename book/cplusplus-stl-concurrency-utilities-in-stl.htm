<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>C++ STL Concurrency Utilities in STL</title>
<link rel='shortcut icon' href='https://readbytes.github.io/images/favicon.ico'>
<link href="https://fonts.googleapis.com/css2?family=Merriweather&display=swap" rel="stylesheet" />
<link href="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet" />
<script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/prism.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/codemirror.min.css" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/codemirror.min.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/theme/dracula.min.css"><style>
html {scroll-behavior: smooth;}  
body {font-family: 'Merriweather', serif;;margin: 0;padding: 2rem 1rem;font-size: 15px;line-height: 1.5;transition: background-color 0.3s, color 0.3s;}
.container {max-width: 750px;margin: 0 auto;padding: 1rem 2rem;}
.light-mode {background-color: #f8f7f5;color: #333;} 
.dark-mode {background-color: #121212;color: #e0e0e0;}
a { text-decoration: none;transition: color 0.2s;}
a:hover {text-decoration: underline;}
.light-mode a {color: #555;}
.dark-mode a {color: #aaa;}
</style><style>
.related-book-list {display: flex;flex-wrap: wrap;gap: 20px;}
.related-books {margin-top: 40px;}
.related-books h2 {font-size: 22px;margin-bottom: 20px;border-bottom: 2px solid #eee;padding-bottom: 8px;}
.light-mode .related-books h2 {color: #333;border-color: #eee;}
.dark-mode .related-books h2 {color: #ddd;border-color: #333;}
</style><style>
.book-cover {width: 130px;height: 180px;font-family: Arial, sans-serif;position: relative;overflow: hidden;box-shadow: 2px 2px 4px rgba(0,0,0,0.1);}
.book-cover-bottom-stripe {position: absolute;bottom: 0;left: 0;height: 5px;width: 100%;}
.book-cover-title {position: absolute;width: 100%;text-align: center;font-weight: bold;}
.book-cover-icon {position: absolute;left: 50%;transform: translateX(-50%);display: flex;align-items: center;justify-content: center;}
.book-cover-author {position: absolute;bottom: 10px;width: 100%;text-align: center;font-size: 8px;color: #333;}
</style><style>
.book-title-toc {font-size: 32px;font-weight: bold; }
.book-subtitle-toc {font-size: 18px;margin-top: 8px;font-style: italic;}
.book-header {text-align: center;margin-bottom: 40px;}

.toc-container {border-radius: 10px;padding: 30px;margin-bottom: 40px;box-shadow: 0 8px 20px rgba(0,0,0,0.05);}
h1 {font-size: 24px;text-align: center;margin-bottom: 30px;letter-spacing: 1px;padding-bottom: 10px;}
.toc-list,.toc-section-list {list-style: none;padding: 0;margin: 0;}
.toc-section-list {padding-left: 18px;margin-top: 6px;margin-bottom: 20px; }
.toc-chapter {padding: 20px 0;}
.chapter-title,.toc-section {display: flex;justify-content: space-between;padding-top: 4px;}
.chapter-title {font-size: 17px;font-weight: bold;}
.chapter-page,.section-page {font-style: italic;}
 
 
.light-mode .book-title-toc,.light-mode .chapter-title,.light-mode .book-name {color: #222;}
.light-mode .book-subtitle-toc,.light-mode .book-sub,.light-mode .chapter-page,.light-mode .section-page {color: #666;}
.light-mode .toc-container { background: #fff;border: 1px solid #ddd;}
.light-mode h1 {border-bottom: 2px solid #eee;color: #222;}
.light-mode .toc-section {  color: #444;}

.light-mode .book-cover { border: 1px solid #ccc;box-shadow: 0 6px 12px rgba(0, 0, 0, 0.15);}
.light-mode .book-title,.light-mode .series-name {color: #fff;}
.light-mode .book-subtitle,.light-mode .book-footer {color: #aaa;}

.dark-mode .book-title-toc,.dark-mode .chapter-title,.dark-mode .book-name {color: #f5f5f5;}
.dark-mode .book-subtitle-toc,.dark-mode .book-sub,.dark-mode .chapter-page,.dark-mode .section-page {color: #aaa;}
.dark-mode .toc-container {background: #1e1e1e;border: 1px solid #444;}

.dark-mode h1 {border-bottom: 2px solid #333;color: #eee;}
.dark-mode .toc-section {color: #bbb;}

.dark-mode .related-books h2 {color: #ddd;border-bottom: 2px solid #333;}
.dark-mode .book-title,.dark-mode .series-name {color: #fff;}
.dark-mode .book-subtitle,.dark-mode .book-footer {color: #bbb;}
.dark-mode .toc-section {color: #ddd;}

@media (max-width: 600px) {
  .chapter-title,
  .toc-section {
    flex-direction: column;
    align-items: flex-start;
  }

  .chapter-page,
  .section-page {
    margin-top: 4px;
  }
}

</style><style>
.light-mode .container {box-shadow: 0 0 15px rgba(0,0,0,0.1);}
.dark-mode .container {box-shadow: 0 0 15px rgba(255, 255, 255, 0.05);}

h1, h2, h3 {font-weight: 600;margin-top: 2.5rem;margin-bottom: 1rem;line-height: 1.2;}
h1 { font-size: 1.8rem; }
h2 { font-size: 1.4rem; }
h3 { font-size: 1.2rem; }

table {width: 100%;border-collapse: collapse;font-family: sans-serif;font-size: 1em;margin: 1em 0;}
th, td {padding: 0.6em 1em;text-align: left;border: 1px solid;}
tr:nth-child(even) {  background-color: inherit;}
tr:hover { background-color: inherit;}

code {color: #d35400;}

.chapter-navi-section {display: flex;justify-content: space-between;align-items: center;padding-bottom: 10px;padding-top: 10px;}
.nav-link {color: inherit;text-decoration: none;opacity: 0.5;transition: opacity 0.3s ease, text-decoration 0.3s ease;}
.nav-link:hover {opacity: 0.9;text-decoration: underline;}
.prev { text-align: left; }
.toc-link { text-align: center; }
.next { text-align: right; }

.download-section {display: flex;align-items: center;justify-content: center;gap: 2rem;padding: 2rem 1rem;max-width: 600px;margin: 3rem auto;border-radius: 12px;box-shadow: 0 4px 10px rgba(0,0,0,0.05);}
.download-info h2 {margin: 0 0 0.5rem;font-size: 1.2rem;}
.format-label {margin: 0 0 0.5rem;font-size: 0.95rem;}
.download-buttons {display: flex;gap: 1rem;}
.download-button {background-color: #4A90E2;color: white;padding: 0.5em 1.2em;border-radius: 25px;font-size: 0.95rem;text-decoration: none;transition: background-color 0.3s ease;}
.download-button:hover {background-color: #357ABD;}

.code-block {position: relative;margin-bottom: 1em;}
.copy-button {background: transparent;color: white;position: absolute;top: 8px;right: 8px;border: none;padding: 4px 8px;font-size: 12px;border-radius: 4px;cursor: pointer;z-index: 1;}
.copy-button:hover {background-color: #0056b3;}

.snippet-container {overflow: hidden;}
.snippet-header {padding: 0.75rem 1rem;cursor: pointer;font-size: 1rem;background-color: #eeeeee;color:  #111111; border-radius: 8px;cursor: pointer;box-shadow: 0 4px 6px rgba(0,0,0,0.1); }
.snippet-body {display: none;font-family: monospace;}
.snippet-container.open .snippet-body {display: block;}

.CodeMirror {border: 2px solid #ccc;border-radius: 4px;resize: vertical;}

.light-mode .format-label {color: #888;}
.light-mode th {background-color: #f2f2f2;}
.light-mode tr:nth-child(even) {background-color: #fafafa;}
.light-mode tr:hover {background-color: #e6f7ff;}

.dark-mode .snippet-header {background-color: #333;color:  #ddd; }
.dark-mode .format-label {color: #aaa;}
.dark-mode th {background-color: #333;color: #fff;}
.dark-mode td {border-color: #444;}
.dark-mode tr:nth-child(even) {background-color: #2a2a2a;}
.dark-mode tr:hover {background-color: #2c3e50;}


.button-group-run-edit {display: flex;width: 100%;gap: 1rem;}
.button-run-edit {flex: 1;padding: 1rem;font-size: 1rem;font-weight: 600;border: none;border-radius: 8px;cursor: pointer;transition: background 0.3s, color 0.3s;}

.light-mode .button-run-edit {background-color: #f0f0f0;color: #222;box-shadow: 0 0 10px rgba(0, 0, 0, 0.05);}
.light-mode .button-run-edit:hover {background-color: #e0e0e0;}

.dark-mode .button-run-edit {background-color: #2a2a2a;color: #f5f5f5;box-shadow: 0 0 10px rgba(255, 255, 255, 0.05);}
.dark-mode .button-run-edit:hover {background-color: #3a3a3a;}

button { padding: 0.5em 1em; background: green; color: white; border: none; cursor: pointer; }
button:hover { background: #1e7e34; }
.result_iframe { width:99%; margin-top: 1em;  resize: both;background-color: #515b63;border:1px solid #ccc;}   

.dialog-backdrop {position: fixed;top: 0;left: 0;width: 100vw;height: 100vh;background: rgba(0,0,0,0.5);display: none;justify-content: center;align-items: center;z-index: 10;}
.dialog {background: #90979e;padding: 20px;width: 90vw;height: 80vh;border-radius: 8px;box-shadow: 0 0 20px rgba(0,0,0,0.3);display: flex;flex-direction: column;}
.dialog-content {display: flex;gap: 20px;margin-top: 10px;height: calc(100% - 40px);}
.editor-container, .preview-container {flex: 1;height: 100%;max-height: 100%;overflow: hidden; }
.result_iframe_dialog {width: 100%;height: 100%;resize: both;border:1px solid #ccc;overflow: auto; }   
.CodeMirror {width: 100% !important;height: 100% !important;}
</style>
</head>
<body>
<script>const mode = localStorage.getItem('mode') || 'light';document.documentElement.classList.add(`${mode}-mode`);</script>  
<div class="container"><div class = "chapter-navi-section">
<a href="cplusplus-stl-smart-pointers-and-resource-management-in-stl.htm" class="nav-button prev">←</a>
<a href='cplusplus-stl.htm#concurrency-utilities-in-stl' class="nav-button toc-link">Index</a>
<a href="cplusplus-stl-stl-in-modern-c-c11-and-beyond.htm" class="nav-button next">→</a>
</div>
<div class='book-header'><h1 class='book-title-toc' id = 'top'>Concurrency Utilities in STL</h1><h3 class='book-subtitle-toc'>C++ STL</h3></div><h2 id='thread-support-library-basics'>13.1 Thread Support Library Basics</h2><p>With the rise of multicore processors, writing programs that perform multiple tasks concurrently has become essential for maximizing performance. C++11 introduced a standardized <strong>Thread Support Library</strong> as part of the STL to provide portable, efficient tools for multithreading.</p><h4 id="motivation-for-multithreading">Motivation for Multithreading</h4><p>Multithreading allows a program to execute multiple sequences of instructions (threads) <strong>in parallel</strong>, improving CPU utilization and responsiveness. Common uses include:</p><ul>
 <li>Performing background computations without blocking user interfaces.</li>
 <li>Parallelizing tasks to reduce total execution time.</li>
 <li>Handling asynchronous I/O and event-driven programming.</li>
</ul><h4 id="basic-terminology-and-thread-lifecycle">Basic Terminology and Thread Lifecycle</h4><ul>
 <li><p><strong>Thread</strong>: The smallest unit of execution, having its own call stack but sharing process memory.</p></li>
 <li><p><strong>Main thread</strong>: The thread where <code>main()</code> runs.</p></li>
 <li><p><strong>Spawned thread</strong>: Any additional thread created during execution.</p></li>
 <li><p><strong>Thread lifecycle states</strong>:</p>
  <ul>
   <li><strong>Not started</strong>: Thread object created but not running.</li>
   <li><strong>Running</strong>: Thread is executing its task.</li>
   <li><strong>Blocked</strong>: Thread is waiting (e.g., on I/O or synchronization).</li>
   <li><strong>Joined or Detached</strong>: Thread has finished execution or runs independently.</li>
  </ul></li>
</ul><h4 id="creating-and-managing-threads-in-stl">Creating and Managing Threads in STL</h4><p>C++ provides the <code>std::thread</code> class to manage threads. You can create a thread by passing a callable (function, lambda, or functor):</p><div class="code-block">
 <button class="copy-button" onclick="copyCode(this)">📋</button>
 <pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;thread&gt;

void task() {
    std::cout &lt;&lt; "Thread running\n";
}

int main() {
    std::thread t(task);  // Spawn new thread executing task()

    t.join();             // Wait for thread to finish before continuing
    std::cout &lt;&lt; "Thread joined\n";
}</code></pre>
</div><ul>
 <li><code>std::thread t(task);</code> starts a new thread.</li>
 <li><code>t.join();</code> blocks the main thread until <code>t</code> completes.</li>
 <li>Alternatively, you can call <code>t.detach()</code> to let the thread run independently.</li>
</ul><h4 id="concurrency-challenges">Concurrency Challenges</h4><p>Writing multithreaded programs introduces complexities such as:</p><ul>
 <li><strong>Data races</strong>: Concurrent access to shared data without synchronization leads to undefined behavior.</li>
 <li><strong>Deadlocks</strong>: Two or more threads wait indefinitely for resources held by each other.</li>
 <li><strong>Race conditions</strong>: The program outcome depends on unpredictable thread execution order.</li>
</ul><h4 id="how-stl-helps-address-these-issues">How STL Helps Address These Issues</h4><p>C++ STL concurrency utilities provide tools to safely manage threads and shared data:</p><ul>
 <li><strong>Mutexes (<code>std::mutex</code>)</strong> for exclusive access.</li>
 <li><strong>Locks (<code>std::lock_guard</code>, <code>std::unique_lock</code>)</strong> for safer mutex management.</li>
 <li><strong>Condition variables (<code>std::condition_variable</code>)</strong> for thread synchronization.</li>
 <li><strong>Atomic operations (<code>std::atomic</code>)</strong> for lock-free thread-safe operations.</li>
</ul><p>By combining these with <code>std::thread</code>, C++ programmers can build efficient, safe multithreaded applications without platform-specific code.</p><h3 id="summary">Summary</h3><p>C++11’s Thread Support Library offers a powerful, standardized way to create and manage threads, helping developers harness parallelism. Understanding thread lifecycles and common concurrency pitfalls sets the foundation for mastering advanced synchronization techniques covered in later sections.</p><div class = "chapter-navi-section">
<a href="#top" class="nav-button prev">↑</a>
<a href='cplusplus-stl.htm#concurrency-utilities-in-stl' class="nav-button toc-link">Index</a>
<a href="#bottom" class="nav-button next">↓</a>
</div>
<h2 id='std-thread-creating-and-managing-threads'>13.2 <code>std::thread</code>: Creating and Managing Threads</h2><p>The <code>std::thread</code> class in C++11 provides a simple and portable way to create and manage threads. Each <code>std::thread</code> object represents a single thread of execution. This section explains how to launch threads, synchronize them with <code>join()</code>, or detach them to run independently, with practical examples.</p><h4 id="creating-and-launching-threads">Creating and Launching Threads</h4><p>You create a thread by instantiating <code>std::thread</code> with a callable — this can be a function, lambda expression, or callable object (functor):</p><div class="code-block">
 <button class="copy-button" onclick="copyCode(this)">📋</button>
 <pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;thread&gt;

void printMessage(int id) {
    std::cout &lt;&lt; "Hello from thread " &lt;&lt; id &lt;&lt; "\n";
}

int main() {
    std::thread t1(printMessage, 1);  // Launch thread running printMessage(1)
    std::thread t2(printMessage, 2);  // Launch another thread

    // Wait for threads to complete
    t1.join();
    t2.join();

    return 0;
}</code></pre>
</div><ul>
 <li>The <code>std::thread</code> constructor starts the thread immediately.</li>
 <li>Arguments following the callable are passed to the thread function.</li>
 <li>Threads run concurrently with the main thread.</li>
</ul><h4 id="joining-threads-waiting-for-completion">Joining Threads: Waiting for Completion</h4><p>Calling <code>join()</code> on a thread blocks the calling thread until the spawned thread finishes execution. It is essential to call <code>join()</code> (or <code>detach()</code>) on every <code>std::thread</code> object before it is destroyed to avoid program termination.</p><div class="code-block">
 <button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-cpp">t1.join(); // Waits for thread t1 to finish</code></pre>
</div><p>If you forget to join or detach, the destructor of <code>std::thread</code> will call <code>std::terminate()</code>, ending the program abruptly.</p><h4 id="detaching-threads-running-independently">Detaching Threads: Running Independently</h4><p>Alternatively, you can call <code>detach()</code> to allow a thread to run independently in the background:</p><div class="code-block">
 <button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-cpp">t1.detach(); // Thread continues running after main thread exits</code></pre>
</div><ul>
 <li>Detached threads run freely and cannot be joined later.</li>
 <li>Use detach cautiously: since you lose control, the program may exit before detached threads finish.</li>
</ul><h4 id="launching-multiple-threads">Launching Multiple Threads</h4><p>You can spawn many threads to parallelize tasks:</p><div class="code-block">
 <button class="copy-button" onclick="copyCode(this)">📋</button>
 <pre><code class="language-cpp">#include &lt;vector&gt;
#include &lt;iostream&gt;
#include &lt;thread&gt;
void worker(int id) {
    std::cout &lt;&lt; "Worker " &lt;&lt; id &lt;&lt; " starting\n";
    std::this_thread::sleep_for(std::chrono::milliseconds(100));
    std::cout &lt;&lt; "Worker " &lt;&lt; id &lt;&lt; " finished\n";
}

int main() {
    std::vector&lt;std::thread&gt; threads;

    for (int i = 0; i &lt; 5; ++i) {
        threads.emplace_back(worker, i);
    }

    // Join all threads to ensure they finish before main exits
    for (auto&amp; t : threads) {
        t.join();
    }

    std::cout &lt;&lt; "All workers done\n";
}</code></pre>
</div><p>This example creates five worker threads that simulate work with sleep, then joins all to safely wait for their completion.</p><h4 id="summary">Summary</h4><ul>
 <li><code>std::thread</code> launches threads immediately upon construction.</li>
 <li>Always call <code>join()</code> to wait for thread completion or <code>detach()</code> to run threads independently.</li>
 <li>Joining prevents premature termination and ensures safe synchronization.</li>
 <li>Managing multiple threads with containers like <code>std::vector&lt;std::thread&gt;</code> enables scalable parallelism.</li>
</ul><p>By understanding and applying these fundamentals, you can safely create multithreaded programs leveraging C++ STL concurrency utilities.</p><div class = "chapter-navi-section">
<a href="#top" class="nav-button prev">↑</a>
<a href='cplusplus-stl.htm#concurrency-utilities-in-stl' class="nav-button toc-link">Index</a>
<a href="#bottom" class="nav-button next">↓</a>
</div>
<h2 id='mutexes-locks-and-condition-variables'>13.3 Mutexes, Locks, and Condition Variables</h2><p>In multithreaded programming, when multiple threads access shared data concurrently, race conditions can occur, causing unpredictable behavior and data corruption. To prevent this, <strong>synchronization primitives</strong> are used to control thread access to shared resources. The C++ STL provides several such primitives: <code>std::mutex</code>, <code>std::lock_guard</code>, <code>std::unique_lock</code>, and <code>std::condition_variable</code>. This section introduces these tools and demonstrates their usage.</p><h4 id="thread-safety-and-critical-sections">Thread Safety and Critical Sections</h4><p>A <strong>critical section</strong> is a part of code that accesses shared resources and must not be executed by more than one thread at a time. To enforce this, a <strong>mutex</strong> (mutual exclusion) is used.</p><ul>
 <li><strong><code>std::mutex</code></strong> is a simple synchronization primitive used to protect critical sections.</li>
 <li>Threads lock the mutex before accessing shared data and unlock it after finishing.</li>
 <li>If another thread tries to lock the mutex while it’s already locked, it blocks until the mutex is released.</li>
</ul><h4 id="std-mutex-and-std-lock-guard"><code>std::mutex</code> and <code>std::lock_guard</code></h4><p>Manual locking and unlocking of a mutex can lead to errors such as forgetting to unlock or exceptions causing premature exit. To manage this safely, <strong>RAII wrappers</strong> like <code>std::lock_guard</code> exist:</p><div class="code-block">
 <button class="copy-button" onclick="copyCode(this)">📋</button>
 <pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;thread&gt;
#include &lt;mutex&gt;

std::mutex mtx;
int shared_counter = 0;

void increment() {
    for (int i = 0; i &lt; 1000; ++i) {
        std::lock_guard&lt;std::mutex&gt; lock(mtx);  // Lock mutex on scope entry
        ++shared_counter;                        // Critical section
    }                                            // Mutex automatically released here
}

int main() {
    std::thread t1(increment);
    std::thread t2(increment);

    t1.join();
    t2.join();

    std::cout &lt;&lt; "Final counter value: " &lt;&lt; shared_counter &lt;&lt; "\n";
}</code></pre>
</div><p>Here, <code>std::lock_guard</code> ensures that the mutex is released even if an exception occurs, preventing deadlocks.</p><h4 id="std-unique-lock"><code>std::unique_lock</code></h4><p><code>std::unique_lock</code> is a more flexible locking mechanism than <code>lock_guard</code>. It allows deferred locking, unlocking, and re-locking within its lifetime, making it useful for advanced scenarios, including waiting on condition variables.</p><p>Example:</p><div class="code-block">
 <button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-cpp">std::unique_lock&lt;std::mutex&gt; lock(mtx, std::defer_lock); // Mutex not locked yet
lock.lock();    // Lock explicitly
// Critical section here
lock.unlock();  // Unlock explicitly</code></pre>
</div><h4 id="std-condition-variable"><code>std::condition_variable</code></h4><p>Sometimes, threads need to wait for certain conditions before continuing execution, e.g., waiting for data availability or a flag. <code>std::condition_variable</code> facilitates this by allowing threads to wait and be notified when a condition changes.</p><ul>
 <li>Threads wait on a condition variable, releasing the mutex while waiting.</li>
 <li>When notified (<code>notify_one</code> or <code>notify_all</code>), waiting threads wake up and re-acquire the mutex to check the condition.</li>
</ul><p>Example of a producer-consumer pattern using condition variables:</p><div class="code-block">
 <button class="copy-button" onclick="copyCode(this)">📋</button>
 <pre><code class="language-cpp">#include &lt;queue&gt;
#include &lt;iostream&gt;
#include &lt;condition_variable&gt;

std::queue&lt;int&gt; dataQueue;
std::mutex mtx;
std::condition_variable cv;
bool done = false;

void producer() {
    for (int i = 1; i &lt;= 5; ++i) {
        {
            std::lock_guard&lt;std::mutex&gt; lock(mtx);
            dataQueue.push(i);
            std::cout &lt;&lt; "Produced: " &lt;&lt; i &lt;&lt; "\n";
        }
        cv.notify_one();  // Notify consumer
        std::this_thread::sleep_for(std::chrono::milliseconds(100));
    }
    {
        std::lock_guard&lt;std::mutex&gt; lock(mtx);
        done = true;
    }
    cv.notify_all();  // Notify consumer to stop waiting
}

void consumer() {
    std::unique_lock&lt;std::mutex&gt; lock(mtx);
    while (!done || !dataQueue.empty()) {
        cv.wait(lock, [] { return done || !dataQueue.empty(); });
        while (!dataQueue.empty()) {
            int value = dataQueue.front();
            dataQueue.pop();
            std::cout &lt;&lt; "Consumed: " &lt;&lt; value &lt;&lt; "\n";
        }
    }
}

int main() {
    std::thread prod(producer);
    std::thread cons(consumer);

    prod.join();
    cons.join();
}</code></pre>
</div><h4 id="summary">Summary</h4><ul>
 <li>Use <code>std::mutex</code> to protect critical sections and prevent data races.</li>
 <li>Prefer <code>std::lock_guard</code> for simple, exception-safe locking.</li>
 <li>Use <code>std::unique_lock</code> for advanced locking scenarios, especially with condition variables.</li>
 <li>Use <code>std::condition_variable</code> to block threads until notified of a change, enabling thread communication and synchronization.</li>
</ul><p>Together, these primitives help write safe and efficient multithreaded programs by controlling access and coordinating thread execution.</p><div class = "chapter-navi-section">
<a href="#top" class="nav-button prev">↑</a>
<a href='cplusplus-stl.htm#concurrency-utilities-in-stl' class="nav-button toc-link">Index</a>
<a href="#bottom" class="nav-button next">↓</a>
</div>
<h2 id='atomic-operations'>13.4 Atomic Operations</h2><p>In multithreaded programming, <strong>atomic operations</strong> provide a way to perform certain operations on shared data without the overhead of locks or mutexes. The C++ Standard Library’s <code>&lt;atomic&gt;</code> header offers atomic types and operations that guarantee <strong>lock-free</strong>, thread-safe manipulation of variables, helping to avoid race conditions while maintaining high performance.</p><h4 id="what-are-atomic-types">What Are Atomic Types?</h4><p>An <strong>atomic type</strong> ensures that operations on its instances occur indivisibly, meaning no thread can observe the variable in a partially modified state. These operations are <strong>atomic</strong> with respect to other threads, so concurrent access is safe without explicit synchronization.</p><p>The STL provides <code>std::atomic&lt;T&gt;</code> for many fundamental types like <code>int</code>, <code>bool</code>, and pointers. For example:</p><div class="code-block">
 <button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-cpp">#include &lt;atomic&gt;

std::atomic&lt;int&gt; counter(0);</code></pre>
</div><p>Operations such as incrementing or comparing and exchanging values happen atomically, avoiding data races without locking.</p><h4 id="use-cases-for-atomic-operations">Use Cases for Atomic Operations</h4><p>Atomic operations are especially useful when:</p><ul>
 <li>You need <strong>simple shared state updates</strong> (like counters, flags).</li>
 <li>Lock contention must be minimized for performance reasons.</li>
 <li>You want to avoid the complexity and overhead of mutexes.</li>
 <li>You are implementing <strong>lock-free</strong> or <strong>wait-free</strong> algorithms.</li>
</ul><p>However, atomic operations work best for simple cases. Complex data structures or critical sections often still require mutexes.</p><h4 id="basic-example-atomic-integer">Basic Example: Atomic Integer</h4><p>Here's a simple example of incrementing a shared atomic counter from multiple threads:</p><div class="code-block">
 <button class="copy-button" onclick="copyCode(this)">📋</button>
 <pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;thread&gt;
#include &lt;atomic&gt;
#include &lt;vector&gt;

std::atomic&lt;int&gt; atomic_counter(0);

void increment() {
    for (int i = 0; i &lt; 1000; ++i) {
        atomic_counter.fetch_add(1, std::memory_order_relaxed);
    }
}

int main() {
    std::vector&lt;std::thread&gt; threads;

    for (int i = 0; i &lt; 4; ++i)
        threads.emplace_back(increment);

    for (auto&amp; t : threads)
        t.join();

    std::cout &lt;&lt; "Final counter: " &lt;&lt; atomic_counter.load() &lt;&lt; "\n"; // Expected 4000
}</code></pre>
</div><p>In this example, <code>fetch_add</code> atomically increments <code>atomic_counter</code> without race conditions or locks. The <code>memory_order_relaxed</code> argument specifies minimal synchronization to improve performance where ordering constraints are not critical.</p><h4 id="atomic-flags-lightweight-synchronization">Atomic Flags: Lightweight Synchronization</h4><p>Another useful atomic type is <code>std::atomic_flag</code>, designed for simple boolean flags:</p><div class="code-block">
 <button class="copy-button" onclick="copyCode(this)">📋</button>
 <pre><code class="language-cpp">#include &lt;atomic&gt;
#include &lt;iostream&gt;
#include &lt;thread&gt;

std::atomic_flag lock_flag = ATOMIC_FLAG_INIT;

void try_lock(int thread_id) {
    while (lock_flag.test_and_set(std::memory_order_acquire)) {
        // Spin-wait (busy-wait) until flag is cleared
    }
    std::cout &lt;&lt; "Thread " &lt;&lt; thread_id &lt;&lt; " acquired lock\n";

    // Critical section simulation
    std::this_thread::sleep_for(std::chrono::milliseconds(100));

    lock_flag.clear(std::memory_order_release);
    std::cout &lt;&lt; "Thread " &lt;&lt; thread_id &lt;&lt; " released lock\n";
}

int main() {
    std::thread t1(try_lock, 1);
    std::thread t2(try_lock, 2);

    t1.join();
    t2.join();
}</code></pre>
</div><p>Here, <code>atomic_flag</code> acts as a <strong>spinlock</strong> where threads repeatedly attempt to acquire the lock by setting the flag atomically.</p><h4 id="summary">Summary</h4><ul>
 <li><strong><code>std::atomic</code> types</strong> enable lock-free, thread-safe operations on fundamental data.</li>
 <li>Atomic operations minimize synchronization overhead in simple shared state scenarios.</li>
 <li>Use <strong><code>std::atomic&lt;int&gt;</code></strong> for counters and shared integers.</li>
 <li>Use <strong><code>std::atomic_flag</code></strong> for lightweight, low-level synchronization (spinlocks).</li>
 <li>For complex data or logic, prefer mutexes as atomics have limited use cases.</li>
</ul><p>Atomic operations are powerful tools in concurrent programming, enabling safe, efficient communication between threads while reducing the cost of locking mechanisms.</p><div class = "chapter-navi-section">
<a href="#top" class="nav-button prev">↑</a>
<a href='cplusplus-stl.htm#concurrency-utilities-in-stl' class="nav-button toc-link">Index</a>
<a href="#bottom" class="nav-button next">↓</a>
</div>
<h2 id='practical-examples-parallel-stl-algorithms-and-synchronization'>13.5 Practical Examples: Parallel STL Algorithms and Synchronization</h2><p>C++17 introduced <strong>parallel algorithms</strong> to the STL, allowing many standard algorithms to run concurrently on multiple threads, improving performance on large data sets with minimal programmer effort. This section demonstrates how to combine these parallel algorithms with thread synchronization to efficiently process data and manage output safely.</p><h4 id="parallel-stl-algorithms-overview">Parallel STL Algorithms: Overview</h4><p>Parallel STL algorithms are variants of existing algorithms that accept an execution policy parameter to specify parallel execution:</p><ul>
 <li><code>std::execution::seq</code> — sequential execution (default)</li>
 <li><code>std::execution::par</code> — parallel execution using multiple threads</li>
 <li><code>std::execution::par_unseq</code> — parallel and vectorized execution</li>
</ul><p>For example, you can parallelize <code>std::for_each</code>, <code>std::sort</code>, and <code>std::transform</code>.</p><h4 id="example-1-parallel-data-processing">Example 1: Parallel Data Processing</h4><div class="code-block">
 <button class="copy-button" onclick="copyCode(this)">📋</button>
 <pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;execution&gt;

int main() {
    std::vector&lt;int&gt; data(1'000'000);
    std::iota(data.begin(), data.end(), 1);

    // Parallel transform: square each element
    std::transform(std::execution::par, data.begin(), data.end(), data.begin(),
                   [](int x) { return x * x; });

    // Print first 5 squared values
    for (int i = 0; i &lt; 5; ++i)
        std::cout &lt;&lt; data[i] &lt;&lt; ' ';
    std::cout &lt;&lt; '\n';
}</code></pre>
</div><p>Here, <code>std::transform</code> runs concurrently across the large vector to square each element, significantly speeding up processing on multi-core CPUs.</p><h4 id="synchronizing-output-with-mutexes">Synchronizing Output with Mutexes</h4><p>When multiple threads write to shared resources like <code>std::cout</code>, race conditions can corrupt output. Use <code>std::mutex</code> or <code>std::lock_guard</code> to synchronize:</p><div class="code-block">
 <button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-cpp">#include &lt;mutex&gt;
std::mutex cout_mutex;

void print_element(int x) {
    std::lock_guard&lt;std::mutex&gt; lock(cout_mutex);
    std::cout &lt;&lt; x &lt;&lt; ' ';
}</code></pre>
</div><p>Combining this with parallel algorithms requires care, as parallel algorithms do not guarantee order and invoke the callable concurrently.</p><h4 id="example-2-parallel-for-each-with-synchronized-output">Example 2: Parallel <code>for_each</code> with Synchronized Output</h4><div class="code-block">
 <button class="copy-button" onclick="copyCode(this)">📋</button>
 <pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;execution&gt;
#include &lt;mutex&gt;

std::mutex cout_mutex;

int main() {
    std::vector&lt;int&gt; numbers = {10, 20, 30, 40, 50};

    std::for_each(std::execution::par, numbers.begin(), numbers.end(),
                  [](int n) {
                      std::lock_guard&lt;std::mutex&gt; lock(cout_mutex);
                      std::cout &lt;&lt; "Number: " &lt;&lt; n &lt;&lt; '\n';
                  });

    return 0;
}</code></pre>
</div><p>This ensures output from different threads does not interleave, maintaining readability.</p><h4 id="pitfalls-and-best-practices">Pitfalls and Best Practices</h4><ul>
 <li><strong>Avoid data races:</strong> Use synchronization primitives when accessing shared state.</li>
 <li><strong>Order not guaranteed:</strong> Parallel algorithms do not preserve the order of operations unless documented.</li>
 <li><strong>Performance trade-offs:</strong> For small data, overhead of parallelization may outweigh benefits.</li>
 <li><strong>Exceptions:</strong> Exception handling in parallel algorithms can be complex; prefer careful error management.</li>
</ul><h4 id="summary">Summary</h4><ul>
 <li>Parallel STL algorithms simplify concurrent data processing.</li>
 <li>Synchronization tools like mutexes are essential to protect shared resources during parallel execution.</li>
 <li>Using parallel algorithms can dramatically improve performance on large datasets.</li>
 <li>Careful design and testing are needed to avoid concurrency pitfalls.</li>
</ul><p>By combining parallel STL algorithms with synchronization primitives, modern C++ lets you write efficient, safe concurrent programs with clear and maintainable code.</p><div class = "chapter-navi-section">
<a href="cplusplus-stl-smart-pointers-and-resource-management-in-stl.htm" class="nav-button prev">←</a>
<a href='cplusplus-stl.htm#concurrency-utilities-in-stl' class="nav-button toc-link">Index</a>
<a href="cplusplus-stl-stl-in-modern-c-c11-and-beyond.htm" class="nav-button next">→</a>
</div>
<section class="download-section">
  <div class="book-cover" style="background-color: #f9f6f1;border: 1px solid #ccc;"> 
    <div class="book-cover-title" style="font-size: 20px;color: #333;top: 20px;">C++ STL</div>
    <div class="book-cover-author">readbytes</div>
    <div class="book-cover-bottom-stripe" style="background-color: #333;"></div>
    <img class="book-cover-icon" style="width: 90px;height: 90px;top: 70px;" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFoAAABaCAYAAAA4qEECAAADK0lEQVR4Xu2cvWsTcRjHo+DkIKiTjiJugqTJ0cG/QcRZ/wJXQTd3ByeHDiLJnS84dHMVBHUSRQUH90pNfmfb6CKi8fqSaj93ae4lzzV3+X7gS9vkeZ7f7/lwEDq0jYYQQgghxFzQ9t0wbTzf3WO/SAllpg3niAlQYJa0uu4W54kxeA96ZykwU4JwnTPFGGLyMqd3nTNFAnFx2cOZIiee//UK5TLsEQWg3D1ZHpxgvShATLCeajsoWKKNaAfuDyVvZuGhu8paURBK1lNtBAVLtBEULNFGULBEG0HBlRfNRUrMqwW/f473GZFQvxXWVQbPD5e4zEGlcXt4eHQvvrdbU2W4zEGn5Yd3+NoovHul4DKzHN69UnCZWQ7vXim8IHzJhWY1vLtIQSRujSInhTNEBppL345R6LiwV+SAUpPCHpETimVYLwpAuRJtBOVKtBHNR4OTFCzRRlCwRBtBwRJtBAVLtBEULNFGeN3wPiVvp/+OtVmJ5qzvmdl1z1kzV8Ql53+q0/6az765gBLyConqN9i/X9hfeyiAYX0S7cCtsi9NOKf2UADDesL6LOGsWsPlx+V8d/Vo3t5x4bzyGA4P8TK1TuBeU0FpxC5T83D/0uBF6h7uXxq8SN3D/Utj80OHl6ltgvAX9y+V2IUm53eUQZQvUT4nvJ8x/e/R14+RiBeeHz4bZfPn6PW3bT908Z7s4d6Vgwsxix13mj15iGb94Ows4bxKwWUY1heF89OGcyoHFypjOZ4zKV7gVjijUjSfrJ/hUqOwdtrwvH2yzN7KkbDUTsKfrLWgufTmSPzsf2F9ZeFitVtwVqBgiTaCgiXaCAqWaCMoWKKNoGCJNoKCJdoICpZoIyhYoo2gYIk2goIl2ggKlmgjKFiijaBgiTaCgiXagLbfu0jBW+m6NdaKAsQEj9Jxl1krChATvBPWiQJ4fviJgiV6yiw+3ThOuRI9ZbzA3aRYSZ4iFx73T1FqUtg3l1DKbrr9960gvBt9f207/Rst332I1U0Iz5tbKGaa4VlzTSQk8X84Fw3PEY3p/70KTxA7UFTeeB13ibPFf1BY1nCeEEIIIYQowl8t5mhjJHw+fQAAAABJRU5ErkJggg=="/>
  </div>
  <div class="download-info">
    <h2 id='bottom'>Download This Ebook</h2>
    <p class="format-label">Available formats:</p>
    <div class="download-buttons">
      <a href="cplusplus-stl.pdf" class="download-button">📄 PDF</a>
      <a href="cplusplus-stl.epub" class="download-button">📘 EPUB</a>
    </div>
  </div>
</section><div class='related-books'>
<h2>C++ Introduction Books</h2>
<div class='related-book-list'>
<a href="cplusplus-for-beginners.htm">
<div class="book-cover" style="background-color: #f9f6f1;border: 1px solid #ccc;"> 
    <div class="book-cover-title" style="font-size: 18px;color: #333;top: 20px;">C++ for Beginners</div>
    <div class="book-cover-author">readbytes</div>
    <div class="book-cover-bottom-stripe" style="background-color: #333;"></div>
    <img class="book-cover-icon" style="width: 90px;height: 90px;top: 70px;" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFoAAABaCAYAAAA4qEECAAAKvUlEQVR4Xu1de3BUVx2OOjqjo+Mo2ezmnc2DvNoGjBSKgAIm0EIKRShQaFINhaQ8QiFSsIhBKUlrqUKthNaURyUpj0yLLU3Fos447TiMCvIPVnnMdNpCYRApJGFIwnp/d++5nP3Ouffu3Wz2cZNv5hvY3/mdc77fd8+93NcuCQkxDq/b1a3QZ8Qsd9K72GcIQQLNLMxI8TWvr/W1Nq1W+XLDct/SOfcKpivswrGGIAFv2r5nfmiLW9csUvvtbVybjeMOQYNiUF+oBsvIxsr1eFw416BFOA3mOa98nN/wZNcEnHPQYaBMZqybP10zOzkT5x40GGiTGSunfUedB+cfFFAKPxYJkxnZRkUdjgcV/dKGpYIhA0nN7GrU4lgoxd6K5GpmnDVxzOBa1VRsm3LRgUb0h6sWzhBiMtLcDQkJn0VNjkOW21UX7tVMV43BjjlojtVUZE6yWzAgVM4r086VFU4bWyq0yzhojMbCzZifbrxap4weobZdunjRd8+IuwzzkENGA2nls9WKbSx+7dNPfQyyPBnVvkmuXajNMVAKfMqWGRo3LV2gx3duXKHHERQbU5wnjIXU+t9CfY6B0epE8kay/B3rH9PjdJiQYXfLb4IaP9uTpOahPseAihue6hEKNzKZwD4T8zPSOFvloDwyEsfl+dDU8c43etsTjwqFG5kcKmiMvY2rhPEZf7JknvON/u1muQHhMpnQ/Kvn1bFefVqch/iL+mrnGy27IgynyQxzZ96vjrmmapYw344f+4/3qM8x8K+yet1Y4tmTx3z/u3IFfQoLzp4+rc8z/Vul+t/rK2c632h+9dKf61avAntuY/XypRgyBF203LhxA8MqclM86lwtzdt9D33vAV0D6nMMeJOtgBvFDN3d3UHnEoaM5mDH6Mq5DwadS1g4Z/aQ0Qx5af57HHW1S7BJCjtjlwzPHTI6GIzIz8OQLTAdqM8xYAUWZKZj7bZAY3R3dWE4aAwKo/dsWhmwqjs7r3MWWOPq1au2DhMI1tfxRvMXKOzmjl08cO9UDJni5InjAQYzDVlu11zU6AiwIomPTJ/Ur5VpB2gyt7F7UWPcI9Pt9vKF8gX/6Z0/oDdhhWxex75U4zV4xWBUfk5Qq3pOxTQ1jy5OCDu0G0dWGFkwXGo028ioM+5BReUZ3IumthP/+Dt6JEDb3XX+dP2TmCKA8uhdapyTM/ozqDWuYbSqiJX3+XfjcINtEJyPN9pxq9qsYL7ocMHKZOKMCaOcZXROcmKpVdHhNHtx1cOWJvNzot64RTCriy+8P2bffWex2p8ujHBsGSk3NTV1GGqOS1AxhRmpQpFGZGZPGjsGfTQF69fWVC+MaUStTx9qjktQMbMnjxWKNGPFuNtPRKxWOJ+H41iR9UPNcQkqZPuPaoQizTi+pFA3+EjHW2CtHKEY7ah3PKiQ0YXWbxDxNFvJ/AomXvzkgh5vbRQf/prRaSt6q53VVv+w/+GpDFO+7X/55dYfa32zxhUIphNftPFNAseYzMBMwEJ5NtTM1806eeIEeqyC2grTParRLJfhxV+/IJhObDG5MnSc0QRWGL1ygMUy3pWXw9kqgnLIZGb0fy9fxhQd+1tbhfGJ9BKPY01mwKKJXR1vBHw2A7XzRtvB7w8fFubWzHbW/Q4CX+CNt98UiCYsrqrUjXpwRoVu9PPL+n9/5M9HjwrzEXM9Xy9G3XEDK4OR5w+0CQYQv5mXJj0+hwNHOjoC5sIaYh52DDYjjcEfNvBVMjbP1i3PBsRDQdwZTYLpKxJoWihEo3msXeV/6Cvj9m1bA3KtsE3ZUHFlNIml997QsFBYVeZ/xkgm71lXLhhNn4sy/Kd9jD3v1PiyJca3NDcH9EVoeTexnpgEKwoNC5U01j2FGYbHZ7YRzNh3tFbZu/yX3DwRFMN6YhIpKSlfCqfJRN5IdWx4czQYo5Fdby+Ob6NJ6N35uYJZ/SEazWPlYzUhGS1b0VuamrR44mWsK6ZQXFz8hXCv5uqpZbqRBxvuE8yhz3QXDo20IvWjc2kcixFriykwkWhWf0jjjc5P183JVs5i0Bw6/qKRVsQNxsbqfOt3sW92uE0m0phW5kws8QpGmvHia983HIufF+uLCXg9SaujYXRF2Xf1Fcg4aUS2YC5PlsejcWODYLTCHqwz6mDi0SjG52oeFWJWrCqfrBvdvlE8Psswe7o/j+f4OzIFow+1twf0Q/3n9u5WP2OdUQeJ6u54QzCL2KUd9zBuRepT4k3RzaGrTLuYPd3/OhkSQbErh9qF+bHOqMPKSKt2GamP2WEjFNxf7j/UIGT6KJbtcR3GWqOGLLerVyYURZ9RdkeMm3EgjJYBj8/8/DG1qpkgFCoTjXEZWS6SBx8/euRIQJtdGGk7G2vHaRJz/fAhQSjPC9o9Zozz5M3bsO4J3Yje3l7BaEJXV5ewMYjt+/dhqimozyft+wQ9TBPWGzVYGciLxhgjrZ5zZ86gByrKJ/iffluBvkGLphN3vrQDUwNgpitmjC52ub5sJhRFH/pZgzQuM5I3a7NyHLWLjz/6UDA9Pz01IGdL4+b4MFoR8p6ZUJ652u8k8bHTr+wUTH7z9dd1Y3avFe8/h4oL58/7bmjfGmBg86BWRrU9MTEf6444SAjd1EGBRsSi1FUGvy5ToHxmBjCGA7Ix6c+P9rcKOnl93iTXFaw74iAhy2dWCAKNKDNahkuXLvmKs7MCjKGvF4cK3tyD+14NGPcvv9wi6OT1EbHuiAONs8PnauU332V4/9SpALPswqhvhXYBY1RHkbZ3Yd0Rh5HAYEh9i7yZWLsKatu7exeG1XhPTw+GgwIzdMkjVdhkaHZL/ePOMNoIrHAZ7WBUcZHQn3H+rJkBuexHVGQ6se6IQybMjCXKCqY/L792IGjT+vr6dHNu3ryJzaagPv/59/u+l3c0C0YT6R9yzEfNcWc0K47/uwys7ZmnNgkxO6CNYrcP5Y8uyBN0Y90RBZ1fBmP0D6b4n/vxuWYGVC9coOcbMTc1GbtJwfLpQoUu5a2AOmPDaJdrPIpCMuF0YYKxYND2yh6h8C01/rMVnnSv+pZyiOFB8XGlI9Wb/JhPbHhyXUA+64Pz0WesPaJQBFSjKBQoa6fYmpV1WKOK2mr/8zwkjsGzaZG8D/Gfx4/jFKanihQbruwtqFcp93NYf8TgdScusjJBRqMiGaiNXa6PzPEK/a24sWqhYPiGtbfvBpqBcj8+0CbojerrvFkeV1UoRjPxsrt1H37wgdqG+f0hms6IuH7tmnRuimUlu6Zi/RFDbmLiN2TCguGzS/z/idhI7seo2PO9ny+uFvL7Q5mpq1csw5CaN/6OImn/LLdrBdYfUYRqNF8ET6sHCKGQjd3Z2Yneqvjre+/qOdiX9c9yu+uw9ojCSFysETco8nHlKhH78H2z3cMmY+0RRbwYzZNe+/rXrhbfudY9QpuMVGNCtL9URCIK0lIEcU6iZnR04U1KKovHVR0sh2s3mrDuqICEVE8tF0Ra8dgL24RYrJFqy8j46tew5qggNfUrw0hQsGcMf9vu/5WvaO0JNO/BhvVCHMk0Yr1RhSLoFIlaNsP8sRYT31C5QGiLFJkGRn7PovcH+TasMyaQlpb2RV4k/SM5seROoTAsHElnBbR3hEJ6UdGKzMDS0oTPo7aYNlgGr/ajgrFK1DvQ+D8MyloZgHbpRwAAAABJRU5ErkJggg=="/>
  </div>
</a>


<a href="cplusplus-syntax.htm">
<div class="book-cover" style="background-color: #f9f6f1;border: 1px solid #ccc;"> 
    <div class="book-cover-title" style="font-size: 20px;color: #333;top: 20px;">C++ Syntax</div>
    <div class="book-cover-author">readbytes</div>
    <div class="book-cover-bottom-stripe" style="background-color: #333;"></div>
    <img class="book-cover-icon" style="width: 90px;height: 90px;top: 70px;" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFoAAABaCAYAAAA4qEECAAAFZ0lEQVR4Xu2dy4scVRSH8ye0iYtkERcmzgjT2OYBuhNREMVXBh/TgsYQx5ULDYTgVl3EFyg6uFJBV76IEXdKXAVBJCgISSTRGRmZiZlADBo6M5kp+3ZbnXt/p7q6btWtc++pqQPfpu/p7vP7UnSqi+m6GzbkrMbYO50u0Tqjgx5Kqe4brSa8+XplFf0UroQ3GbDltqNRs70Y3Tw5G22//2SXU0Fyy5MXc6GyqYyYWwd9WdfGbW9uxRe9vvlBtOvZKLrpwTOiUDO7QjlALxu3zWxFf5mq++RF/YU27/40au39lwSQAspygXICwhfRY2rhv5Z6URxcEuoAQUkuQV/oM7HwSN45vUoGlwaKKQOrI1t9zuhPaD19mQwtEZRSFrq71M/sqh3JMSikTHSH6LdXeoN6Ag4rlV3Ta0RG2aTKjhfU/6Q4rGRQAgf62QhKHnzjk3wKlwRK4EI7qq99g4wf3NR8nwwqmfE9s0QAF8olOarjB1QDDisZDM+NIbqhXYXDQaWDwbnRPj46xtkGDiodDM6N7nYgWl2hwkEl09r7DwnOzZbbr131G4iemFokw0oGQ/ug2XVKRI9PzpJhJYOhfdB66m8qevsDp8iwksHQPqi8aAzsi1o0E7VoJioteuzh30lgX1RaNIb1SS2aiVo0E5UVPTH1Fwnrk8qKxqC+qUUzUYtmwovoL49dioYV9uZhx/4VEjRmWM2fp70uYRc9qrA/DxhSZ1RhvyuCEL1wfiU6PXulB/bnAUPqnJnv8+cSTtEv7HeFd9G4XpyzJGQaWLjuisqJxoCjeOVjc572y7THBayim4+cNUKdONkhPUXBgKO495AxUrTvVdrjAq+ij//k/i9UMeAo7jlojFSLzsLE4/ZfuyspuvXYb0Yo16IxXBZQ9DOv0x4XsIqeOjRvhPri20ukpwgYLgt3HTBGir75kfa4gFU01h373f5ZA4bLChauu4BNdPtF82hWhT1FuHVfh4TLCtbR47SnKKWKTqu5hWXSXwQMZsOBGZzOLOzPA7voNz66QPpcgMHy8Py7OG2/sC8P7KLjurK8RvqLgMFsmDmC05mF/XkoVbTOjinz1E4V9uSl6I+AsF6YoT1FYROtwLpzeo705AFD2YKF6y5gFf3oQfPM48h3w8+jD3+4ZIDrOnGYtz7vgyHTuBvOo7/+nva4gFW0zTdDLFyPGdN+BBQXhkyDfDN8jfa4gFW0zbWOH365bIDrMXqYE7/2wZBpoOhKXOuwEZ0VDGTLuhD98+kO6bEFA9lyXxWvRyuwcN0GdccFDGTLe1+Z87Rfoj0uEC0aw+QBC9dd4V10XMsraz2wPw0Mk4WVq33WcID/C/tdwS766uqwiP3C/jQwTBZGFfa7gl204rnDC5hvUNg7DAySlWH1yTHa6xIvol2AQUKnFs2ESNHjk3MkSOiIFI0hJFCLZqIWzYQ40c0nLpAQEhAnGgNIoRbNRC2aCVGid6b8CCh0RInG4SVRi2YiUXSIN68ae8juR0ChkSg6xNux4eDSSLwdW4g3GMTBpZF4g0EFBvUNDi4N3a0SHeRNYCfaS2RwaWii+1s/xQ+oRQzsCxxaIoOjGe8fHdKNunFoaWzSdh/SRQd363kcXBrax4a5eVm8EMJmCmn33pDA5t2f0aMZRStUM4bnBAeXhu4SPfdKb/C54Q0OLomRklWFsoUTDi8F3d11N759A/o1quF5UzIcXgq6sy7n0GtiwZN6L4RCygIDSAB9oc/UwiOba+NIDBEy+tmF1ZGMhZ/ZijK3Qh3f8wcJEyJOt0LVC19UR12harbPOdncFzfWDQGVTb8KlwT6KlyNertqHffbVSdVo96A3ar+A5kzbYSE7G+UAAAAAElFTkSuQmCC"/>
  </div>
</a>


<a href="cplusplus-stl.htm">
<div class="book-cover" style="background-color: #f9f6f1;border: 1px solid #ccc;"> 
    <div class="book-cover-title" style="font-size: 20px;color: #333;top: 20px;">C++ STL</div>
    <div class="book-cover-author">readbytes</div>
    <div class="book-cover-bottom-stripe" style="background-color: #333;"></div>
    <img class="book-cover-icon" style="width: 90px;height: 90px;top: 70px;" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFoAAABaCAYAAAA4qEECAAADK0lEQVR4Xu2cvWsTcRjHo+DkIKiTjiJugqTJ0cG/QcRZ/wJXQTd3ByeHDiLJnS84dHMVBHUSRQUH90pNfmfb6CKi8fqSaj93ae4lzzV3+X7gS9vkeZ7f7/lwEDq0jYYQQgghxFzQ9t0wbTzf3WO/SAllpg3niAlQYJa0uu4W54kxeA96ZykwU4JwnTPFGGLyMqd3nTNFAnFx2cOZIiee//UK5TLsEQWg3D1ZHpxgvShATLCeajsoWKKNaAfuDyVvZuGhu8paURBK1lNtBAVLtBEULNFGULBEG0HBlRfNRUrMqwW/f473GZFQvxXWVQbPD5e4zEGlcXt4eHQvvrdbU2W4zEGn5Yd3+NoovHul4DKzHN69UnCZWQ7vXim8IHzJhWY1vLtIQSRujSInhTNEBppL345R6LiwV+SAUpPCHpETimVYLwpAuRJtBOVKtBHNR4OTFCzRRlCwRBtBwRJtBAVLtBEULNFGeN3wPiVvp/+OtVmJ5qzvmdl1z1kzV8Ql53+q0/6az765gBLyConqN9i/X9hfeyiAYX0S7cCtsi9NOKf2UADDesL6LOGsWsPlx+V8d/Vo3t5x4bzyGA4P8TK1TuBeU0FpxC5T83D/0uBF6h7uXxq8SN3D/Utj80OHl6ltgvAX9y+V2IUm53eUQZQvUT4nvJ8x/e/R14+RiBeeHz4bZfPn6PW3bT908Z7s4d6Vgwsxix13mj15iGb94Ows4bxKwWUY1heF89OGcyoHFypjOZ4zKV7gVjijUjSfrJ/hUqOwdtrwvH2yzN7KkbDUTsKfrLWgufTmSPzsf2F9ZeFitVtwVqBgiTaCgiXaCAqWaCMoWKKNoGCJNoKCJdoICpZoIyhYoo2gYIk2goIl2ggKlmgjKFiijaBgiTaCgiXagLbfu0jBW+m6NdaKAsQEj9Jxl1krChATvBPWiQJ4fviJgiV6yiw+3ThOuRI9ZbzA3aRYSZ4iFx73T1FqUtg3l1DKbrr9960gvBt9f207/Rst332I1U0Iz5tbKGaa4VlzTSQk8X84Fw3PEY3p/70KTxA7UFTeeB13ibPFf1BY1nCeEEIIIYQowl8t5mhjJHw+fQAAAABJRU5ErkJggg=="/>
  </div>
</a>



<a href='cplusplus.htm'><div class='book-cover' style='background-color: #f9f6f1;color: #111111;border: 1px solid #ccc;display: flex;justify-content: center;align-items: center;text-align: center;'>More C++ Books</div></a>
</div>
</div><script>
function copyCode(button) {const code = button.nextElementSibling.innerText;navigator.clipboard.writeText(code).then(() => {button.textContent = 'Copied!';setTimeout(() => { button.textContent = 'Copy'; }, 1500);});}
</script></div>
<style>
.site-footer {margin-top: 60px;padding: 20px 0;border-top: 1px solid #eee;text-align: center;font-size: 14px;}
.site-footer a {text-decoration: none;}
.light-mode .site-footer {color: #777;border-color: #eee;}
.dark-mode .site-footer {color: #888;border-color: #333;}
.light-mode .site-footer a {color: #555;}
.dark-mode .site-footer a {color: #aaa;}
.site-footer a:hover {text-decoration: underline;}    
</style>
<footer class="site-footer">
<nav><a href="https://readbytes.github.io">Home</a> |Email:<script type="text/javascript">
var part1 = 'yinpeng';var part6 = '263';var part2 = Math.pow(2,6);var part3 = String.fromCharCode(part2);var part4 = 'hotmail dot com';var part5 = part1 + String.fromCharCode(part2) + part4;document.write(part1 + part6 + part3 + part4);
</script>
| <a id="mode-toggle" href="#">Toggle Dark Mode</a>
</nav><p>© 2025 — All rights reserved.</p></footer>
<script>
const toggleButton = document.getElementById('mode-toggle');
const body = document.body;
const savedMode = localStorage.getItem('mode') || 'light';
body.classList.add(savedMode + '-mode');
toggleButton.addEventListener('click', () => {
      const isDark = body.classList.contains('dark-mode');
      body.classList.toggle('dark-mode', !isDark);
      body.classList.toggle('light-mode', isDark);
      localStorage.setItem('mode', isDark ? 'light' : 'dark');
});
function copyCode(button) {const code = button.nextElementSibling.innerText;navigator.clipboard.writeText(code).then(() => {button.textContent = 'Copied!';setTimeout(() => { button.textContent = 'Copy'; }, 1500);});}
</script>
</body>
</html>