<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>JavaScript Algorithms Arrays and Linked Lists</title>
<link rel='shortcut icon' href='https://java2s.com/style/favicon.ico'>
<link href="https://fonts.googleapis.com/css2?family=Merriweather&display=swap" rel="stylesheet" />
<link href="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet" />


  <script>
  const mode = localStorage.getItem('mode') || 'light';
  document.documentElement.classList.add(`${mode}-mode`);
  </script>   
<style> 
html {
  scroll-behavior: smooth;
}

body {
  font-family: 'Merriweather', serif;
  margin: 0;
  padding: 2rem 1rem;
  font-size: 15px;
  line-height: 1.5;
  transition: background-color 0.3s, color 0.3s;
}

.container {
  max-width: 700px;
  margin: 0 auto;
  padding: 1rem 2rem;
  box-shadow: 0 0 15px rgba(0,0,0,0.1);
}

h1, h2, h3 {
  font-weight: 600;
  margin-top: 2.5rem;
  margin-bottom: 1rem;
  line-height: 1.2;
}

h1 { font-size: 1.8rem; }
h2 { font-size: 1.4rem; }
h3 { font-size: 1.2rem; }

table {
  width: 100%;
  border-collapse: collapse;
  font-family: sans-serif;
  font-size: 1em;
  margin: 1em 0;
}

th, td {
  padding: 0.6em 1em;
  text-align: left;
  border: 1px solid;
}

tr:nth-child(even) {
  background-color: inherit;
}

tr:hover {
  background-color: inherit;
}

a {
  text-decoration: none;
  transition: color 0.2s;
}

a:hover {
  text-decoration: underline;
}

code {
  color: #d35400;
}

.book-title-chapter {
  font-family: 'Merriweather', serif;
  font-size: 2rem;
  font-weight: bold;
  text-align: center;
  margin-bottom: 2rem;
  border-bottom: 2px solid;
  padding-bottom: 0.5rem;
}

.book-subtitle-chapter {
  text-align: center;
  font-size: 1rem;
  margin-top: -1rem;
  margin-bottom: 2rem;
}

.related-books {
  margin-top: 40px;
}

.related-book-list {
  display: flex;
  flex-wrap: wrap;
  gap: 20px;
}

    .book-cover {
      width: 130px;
      height: 180px;
      font-family: Arial, sans-serif;
      position: relative;
      overflow: hidden;      
      line-height: normal;
      box-shadow: 2px 2px 4px rgba(0,0,0,0.1);
    }
    .book-cover-bottom-stripe {
      position: absolute;
      bottom: 0;
      left: 0;
      height: 5px;
      width: 100%;
    }
    .book-cover-title {
      position: absolute;
      width: 100%;
      text-align: center;
      font-weight: bold;
    }
     
    .book-cover-icon {
      position: absolute;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      align-items: center;
      justify-content: center; 
    }

    .book-cover-author {
      position: absolute;
      bottom: 10px;
      width: 100%;
      text-align: center;
      font-size: 8px;
      color: #333;
    }

.page-footer {
  margin-top: 4rem;
  padding: 1rem 0;
  text-align: center;
  font-size: 0.85rem;
  border-top: 1px solid;
}

.chapter-navi-section {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding-bottom: 10px;
}

.nav-link {
  color: inherit;
  text-decoration: none;
  opacity: 0.5;
  transition: opacity 0.3s ease, text-decoration 0.3s ease;
}

.nav-link:hover {
  opacity: 0.9;
  text-decoration: underline;
}

.prev { text-align: left; }
.toc-link { text-align: center; }
.next { text-align: right; }

.download-section {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 2rem;
  padding: 2rem 1rem;
  max-width: 600px;
  margin: 3rem auto;
  border-radius: 12px;
  box-shadow: 0 4px 10px rgba(0,0,0,0.05);
}

.download-info h2 {
  margin: 0 0 0.5rem;
  font-size: 1.2rem;
}

.format-label {
  margin: 0 0 0.5rem;
  font-size: 0.95rem;
}

.download-buttons {
  display: flex;
  gap: 1rem;
}

.download-button {
  background-color: #4A90E2;
  color: white;
  padding: 0.5em 1.2em;
  border-radius: 25px;
  font-size: 0.95rem;
  text-decoration: none;
  transition: background-color 0.3s ease;
}

.download-button:hover {
  background-color: #357ABD;
}

.code-block {
  position: relative;
  margin-bottom: 1em;
}

.copy-button {
  background: transparent;
  color: white;
  position: absolute;
  top: 8px;
  right: 8px;
  border: none;
  padding: 4px 8px;
  font-size: 12px;
  border-radius: 4px;
  cursor: pointer;
  z-index: 1;
}

.copy-button:hover {
  background-color: #0056b3;
}

.snippet-container {
  overflow: hidden;
}

.snippet-header {
  padding: 0.75rem 1rem;
  cursor: pointer;
  font-size: 1rem;
    background-color: #eeeeee;
    color:  #111111; 
    border-radius: 8px;
    cursor: pointer;
    box-shadow: 0 4px 6px rgba(0,0,0,0.1);  
}

.snippet-body {
  display: none;
  font-family: monospace;
}

.snippet-container.open .snippet-body {
  display: block;
}

.CodeMirror {
  border: 2px solid #ccc;
  border-radius: 4px;
  resize: vertical;
}

/* === Light Mode === */
html.light-mode {
  background-color: #f8f7f5;
  color: #333;
}

html.light-mode .container {
  background: white;
}

html.light-mode .book-title-chapter {
  color: #2c3e50;
  border-color: #ccc;
}
html.light-mode .book-subtitle-chapter{
  color: #888;
}

html.light-mode .page-footer,
html.light-mode .series-name,
html.light-mode .book-subtitle,
html.light-mode .format-label {
  color: #888;
}

html.light-mode .related-books h2 {
  color: #333;
  border-bottom: 2px solid #eee;
}

html.light-mode .book-title {
  color: #fff;
}

html.light-mode .book-cover {
  border: 1px solid #ccc;
}

html.light-mode th {
  background-color: #f2f2f2;
}

html.light-mode tr:nth-child(even) {
  background-color: #fafafa;
}

html.light-mode tr:hover {
  background-color: #e6f7ff;
}

html.light-mode a,
html.light-mode .page-footer a {
  color: #000;
}

/* === Dark Mode === */
html.dark-mode {
  background-color: #181818;
  color: #e0e0e0;
}

html.dark-mode .container {
  background: #222;
}

html.dark-mode .book-title-chapter {
  color: #ddd;
  border-color: #444;
}

html.dark-mode .snippet-header {
    background-color: #333;
    color:  #ddd; 
}


html.dark-mode .book-subtitle-chapter,
html.dark-mode .page-footer,
html.dark-mode .series-name,
html.dark-mode .book-subtitle,
html.dark-mode .book-footer,
html.dark-mode .format-label {
  color: #aaa;
}

html.dark-mode .related-books h2 {
  color: #ddd;
  border-bottom: 2px solid #333;
}

html.dark-mode .book-title {
  color: #fff;
}

html.dark-mode .book-cover {
  border: 1px solid #555;
}

html.dark-mode th {
  background-color: #333;
  color: #fff;
}

html.dark-mode td {
  border-color: #444;
}

html.dark-mode tr:nth-child(even) {
  background-color: #2a2a2a;
}

html.dark-mode tr:hover {
  background-color: #2c3e50;
}

html.dark-mode a,
html.dark-mode .page-footer a {
  color: #eee;
}

    .dialog-backdrop {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: rgba(0,0,0,0.5);
      display: none;
      justify-content: center;
      align-items: center;
      z-index: 10;
    }

    .dialog {
      background: white;
      padding: 20px;
      width: 90vw;
      height: 80vh;
      border-radius: 8px;
      box-shadow: 0 0 20px rgba(0,0,0,0.3);
      display: flex;
      flex-direction: column;
    }
    .dialog-content {
      display: flex;
      flex: 1;
      gap: 20px;
      margin-top: 10px;
    }
    .dialog h2 {
      margin-top: 0;
    }

    .textarea_dialog {
      width: 50%;
      height: 100%;
      resize: none;
      font-family: monospace;
      font-size: 14px;
      padding: 10px;
      box-sizing: border-box;
      border: 1px solid #ccc;
    }

    .iframe_dialog {
      width: 50%;
      height: 100%;
      border: 1px solid #ccc;
    }
    .controls_dialog {
      display: flex;
      justify-content: space-between;
      margin-top: 10px;
    }    
    button { padding: 0.5em 1em; background: green; color: white; border: none; cursor: pointer; }
    button:hover { background: #1e7e34; }
    .result_iframe { width:99%; height:200px; margin-top: 1em;  resize: both;border:1px solid #ccc;}        
</style>
</head>
<body> 
  <div class="container">
    <div class = "chapter-navi-section">
<a href="javascript-algorithms-sorting-and-order-linear-time-sorting.htm" class="nav-button prev">←</a>
<a href='javascript-algorithms.htm#arrays-and-linked-lists' class="nav-button toc-link">Index</a>
<a href="javascript-algorithms-stacks-and-queues.htm" class="nav-button next">→</a>
</div>

    <h1 class="book-title-chapter" id = 'top'>Arrays and Linked Lists</h1>
    <h3 class="book-subtitle-chapter">JavaScript Algorithms</h3>   
    <!-- <h1 class ="chapter-title"></h1> -->
    <h2 id='native-arrays-and-their-limits'>7.1 Native Arrays and Their Limits</h2><p>JavaScript’s native <code>Array</code> is one of the most flexible and widely used data structures in the language. Unlike fixed-size arrays in lower-level languages like C or Java, JavaScript arrays are <em>dynamic</em>, allowing elements to be added, removed, or modified at any index. While this makes them extremely convenient for general-purpose programming, it also hides performance trade-offs that are important to understand when solving algorithmic problems or working with large datasets.</p><div class="snippet-container" id="<!DOCTYPE html>
<html lang=&quot;en&quot;>
<head>
<meta charset=&quot;UTF-8&quot; />
<title>Interactive Array Visualization</title>
<style>
  body {
    font-family: Arial, sans-serif;
    text-align: center;
  }
  canvas {
    border: 1px solid black;
    background: #fafafa;
    display: block;
    margin: 20px auto;
  }
  #controls {
    margin: 10px auto;
    max-width: 700px;
  }
  input, button {
    font-size: 16px;
    padding: 6px 8px;
    margin: 4px;
  }
  #message {
    height: 24px;
    margin-top: 8px;
    font-weight: bold;
  }
</style>
</head>
<body>

<h2>Interactive Array Visualization</h2>

<div id=&quot;controls&quot;>
  <input type=&quot;number&quot; id=&quot;indexInput&quot; placeholder=&quot;Index&quot; min=&quot;0&quot; />
  <input type=&quot;number&quot; id=&quot;valueInput&quot; placeholder=&quot;Value&quot; />
  <button id=&quot;accessBtn&quot;>Access</button>
  <button id=&quot;updateBtn&quot;>Update</button>
  <button id=&quot;insertBtn&quot;>Insert</button>
  <button id=&quot;deleteBtn&quot;>Delete</button>
</div>

<canvas id=&quot;canvas&quot; width=&quot;700&quot; height=&quot;150&quot;></canvas>
<div id=&quot;message&quot;></div>

<script>
  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d');
  const indexInput = document.getElementById('indexInput');
  const valueInput = document.getElementById('valueInput');
  const accessBtn = document.getElementById('accessBtn');
  const updateBtn = document.getElementById('updateBtn');
  const insertBtn = document.getElementById('insertBtn');
  const deleteBtn = document.getElementById('deleteBtn');
  const message = document.getElementById('message');

  let array = [10, 22, 35, 47, 59, 63, 78];
  const cellWidth = 80;
  const cellHeight = 60;
  const startY = 50;
  let scrollX = 0;
  const scrollStep = 40;

  // For animations
  let highlightIndex = -1;
  let animationFrames = [];

  // Calculate total width needed for array
  function totalWidth() {
    return array.length * cellWidth;
  }

  // Draw the array with scrolling offset and highlight
  function drawArray() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.font = &quot;18px Arial&quot;;
    ctx.textAlign = &quot;center&quot;;
    ctx.textBaseline = &quot;middle&quot;;

    const visibleCount = Math.floor(canvas.width / cellWidth);

    for (let i = 0; i < array.length; i++) {
      const x = i * cellWidth - scrollX;
      if (x + cellWidth < 0 || x > canvas.width) continue; // skip if out of visible area

      // Highlight box if needed
      if (i === highlightIndex) {
        ctx.fillStyle = 'orange';
        ctx.fillRect(x, startY, cellWidth, cellHeight);
      }

      // Draw box border
      ctx.strokeStyle = &quot;black&quot;;
      ctx.lineWidth = 2;
      ctx.strokeRect(x, startY, cellWidth, cellHeight);

      // Draw value
      ctx.fillStyle = i === highlightIndex ? &quot;black&quot; : &quot;black&quot;;
      ctx.fillText(array[i], x + cellWidth / 2, startY + cellHeight / 2);

      // Draw index below
      ctx.fillStyle = &quot;gray&quot;;
      ctx.font = &quot;14px Arial&quot;;
      ctx.fillText(i, x + cellWidth / 2, startY + cellHeight + 20);

      ctx.font = &quot;18px Arial&quot;;
    }
  }

  // Animate highlight for access/update
  function animateHighlight(index, duration = 1000) {
    highlightIndex = index;
    drawArray();
    setTimeout(() => {
      highlightIndex = -1;
      drawArray();
    }, duration);
  }

  // Animate insertion with sliding boxes to right
  function animateInsert(index, value) {
    // Insert a placeholder at the end
    array.push(value);
    let frame = 0;
    const totalFrames = 20;
    const startScroll = scrollX;

    function animate() {
      frame++;
      const progress = frame / totalFrames;

      // Scroll if needed to show inserted item
      const targetScroll = Math.max(0, (array.length - Math.floor(canvas.width / cellWidth)) * cellWidth);
      scrollX = startScroll + (targetScroll - startScroll) * progress;

      // Shift elements right starting from the inserted index
      // We'll redraw array offsetting the elements >= index by progress * cellWidth
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.font = &quot;18px Arial&quot;;
      ctx.textAlign = &quot;center&quot;;
      ctx.textBaseline = &quot;middle&quot;;

      for (let i = 0; i < array.length; i++) {
        let x = i * cellWidth - scrollX;
        if (x + cellWidth < 0 || x > canvas.width) continue;

        if (i === index) {
          // The new inserted box slides in from left (or opacity fade)
          const insertX = x - cellWidth * (1 - progress);
          ctx.fillStyle = 'lightgreen';
          ctx.fillRect(insertX, startY, cellWidth, cellHeight);
          ctx.strokeStyle = &quot;black&quot;;
          ctx.lineWidth = 2;
          ctx.strokeRect(insertX, startY, cellWidth, cellHeight);
          ctx.fillStyle = &quot;black&quot;;
          ctx.fillText(array[i], insertX + cellWidth / 2, startY + cellHeight / 2);
          ctx.fillStyle = &quot;gray&quot;;
          ctx.font = &quot;14px Arial&quot;;
          ctx.fillText(i, insertX + cellWidth / 2, startY + cellHeight + 20);
          ctx.font = &quot;18px Arial&quot;;
        } else if (i > index) {
          // Shift right by progress * cellWidth
          const shiftedX = x + cellWidth * progress;
          ctx.fillStyle = 'white';
          ctx.fillRect(shiftedX, startY, cellWidth, cellHeight);
          ctx.strokeStyle = &quot;black&quot;;
          ctx.lineWidth = 2;
          ctx.strokeRect(shiftedX, startY, cellWidth, cellHeight);
          ctx.fillStyle = &quot;black&quot;;
          ctx.fillText(array[i], shiftedX + cellWidth / 2, startY + cellHeight / 2);
          ctx.fillStyle = &quot;gray&quot;;
          ctx.font = &quot;14px Arial&quot;;
          ctx.fillText(i, shiftedX + cellWidth / 2, startY + cellHeight + 20);
          ctx.font = &quot;18px Arial&quot;;
        } else {
          // Normal boxes
          ctx.strokeStyle = &quot;black&quot;;
          ctx.lineWidth = 2;
          ctx.strokeRect(x, startY, cellWidth, cellHeight);
          ctx.fillStyle = &quot;black&quot;;
          ctx.fillText(array[i], x + cellWidth / 2, startY + cellHeight / 2);
          ctx.fillStyle = &quot;gray&quot;;
          ctx.font = &quot;14px Arial&quot;;
          ctx.fillText(i, x + cellWidth / 2, startY + cellHeight + 20);
          ctx.font = &quot;18px Arial&quot;;
        }
      }

      if (frame < totalFrames) {
        requestAnimationFrame(animate);
      } else {
        // Insert is done, no highlight
        drawArray();
      }
    }

    animate();
  }

  // Animate delete by sliding boxes left
  function animateDelete(index) {
    let frame = 0;
    const totalFrames = 20;
    const startScroll = scrollX;

    function animate() {
      frame++;
      const progress = frame / totalFrames;

      // Scroll if needed to keep array visible
      const maxScroll = Math.max(0, (array.length - 1 - Math.floor(canvas.width / cellWidth)) * cellWidth);
      scrollX = startScroll + (maxScroll - startScroll) * progress;

      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.font = &quot;18px Arial&quot;;
      ctx.textAlign = &quot;center&quot;;
      ctx.textBaseline = &quot;middle&quot;;

      for (let i = 0; i < array.length; i++) {
        if (i === index) continue; // this one is deleting, so skip drawing

        let x = i * cellWidth - scrollX;
        if (x + cellWidth < 0 || x > canvas.width) continue;

        if (i > index) {
          // Shift left by progress * cellWidth
          const shiftedX = x - cellWidth * progress;
          ctx.strokeStyle = &quot;black&quot;;
          ctx.lineWidth = 2;
          ctx.strokeRect(shiftedX, startY, cellWidth, cellHeight);
          ctx.fillStyle = &quot;black&quot;;
          ctx.fillText(array[i], shiftedX + cellWidth / 2, startY + cellHeight / 2);
          ctx.fillStyle = &quot;gray&quot;;
          ctx.font = &quot;14px Arial&quot;;
          ctx.fillText(i - 1, shiftedX + cellWidth / 2, startY + cellHeight + 20);
          ctx.font = &quot;18px Arial&quot;;
        } else {
          // Normal boxes
          ctx.strokeStyle = &quot;black&quot;;
          ctx.lineWidth = 2;
          ctx.strokeRect(x, startY, cellWidth, cellHeight);
          ctx.fillStyle = &quot;black&quot;;
          ctx.fillText(array[i], x + cellWidth / 2, startY + cellHeight / 2);
          ctx.fillStyle = &quot;gray&quot;;
          ctx.font = &quot;14px Arial&quot;;
          ctx.fillText(i, x + cellWidth / 2, startY + cellHeight + 20);
          ctx.font = &quot;18px Arial&quot;;
        }
      }

      if (frame < totalFrames) {
        requestAnimationFrame(animate);
      } else {
        // Actually remove the element now
        array.splice(index, 1);
        drawArray();
      }
    }

    animate();
  }

  // Animate update by flashing the box
  function animateUpdate(index, newValue) {
    let frame = 0;
    const totalFrames = 30;

    function animate() {
      frame++;
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.font = &quot;18px Arial&quot;;
      ctx.textAlign = &quot;center&quot;;
      ctx.textBaseline = &quot;middle&quot;;

      for (let i = 0; i < array.length; i++) {
        const x = i * cellWidth - scrollX;
        if (x + cellWidth < 0 || x > canvas.width) continue;

        if (i === index) {
          // Flashing effect by changing fillStyle
          const intensity = Math.abs(Math.sin(frame / 5));
          ctx.fillStyle = `rgba(255, 165, 0, ${intensity})`; // orange glow
          ctx.fillRect(x, startY, cellWidth, cellHeight);
        }
        ctx.strokeStyle = &quot;black&quot;;
        ctx.lineWidth = 2;
        ctx.strokeRect(x, startY, cellWidth, cellHeight);

        ctx.fillStyle = &quot;black&quot;;
        ctx.fillText(i === index ? newValue : array[i], x + cellWidth / 2, startY + cellHeight / 2);
        ctx.fillStyle = &quot;gray&quot;;
        ctx.font = &quot;14px Arial&quot;;
        ctx.fillText(i, x + cellWidth / 2, startY + cellHeight + 20);
        ctx.font = &quot;18px Arial&quot;;
      }

      if (frame < totalFrames) {
        requestAnimationFrame(animate);
      } else {
        // Finalize update
        array[index] = newValue;
        drawArray();
      }
    }

    animate();
  }

  // Scroll canvas horizontally (left/right buttons could be added)
  function scrollLeft() {
    scrollX = Math.max(0, scrollX - scrollStep);
    drawArray();
  }
  function scrollRight() {
    const maxScroll = Math.max(0, totalWidth() - canvas.width);
    scrollX = Math.min(maxScroll, scrollX + scrollStep);
    drawArray();
  }

  // Button event handlers
  accessBtn.onclick = () => {
    const idx = parseInt(indexInput.value);
    if (isNaN(idx) || idx < 0 || idx >= array.length) {
      message.textContent = &quot;Invalid index for access&quot;;
      return;
    }
    message.textContent = `Accessed element at index ${idx}: ${array[idx]}`;
    animateHighlight(idx);
  };

  updateBtn.onclick = () => {
    const idx = parseInt(indexInput.value);
    const val = parseInt(valueInput.value);
    if (isNaN(idx) || idx < 0 || idx >= array.length) {
      message.textContent = &quot;Invalid index for update&quot;;
      return;
    }
    if (isNaN(val)) {
      message.textContent = &quot;Invalid value for update&quot;;
      return;
    }
    message.textContent = `Updating element at index ${idx} to ${val}`;
    animateUpdate(idx, val);
  };

  insertBtn.onclick = () => {
    const idx = parseInt(indexInput.value);
    const val = parseInt(valueInput.value);
    if (isNaN(idx) || idx < 0 || idx > array.length) {
      message.textContent = &quot;Invalid index for insert&quot;;
      return;
    }
    if (isNaN(val)) {
      message.textContent = &quot;Invalid value for insert&quot;;
      return;
    }
    message.textContent = `Inserting ${val} at index ${idx}`;
    // Insert visually with animation
    // Actually splice after animation completes
    // We insert a temporary placeholder now and slide later
    array.splice(idx, 0, val); // Insert to array but animate sliding boxes

    // Animate sliding boxes to the right, then finalize
    let frame = 0;
    const totalFrames = 20;
    const startScroll = scrollX;

    function animate() {
      frame++;
      const progress = frame / totalFrames;

      // Scroll if needed to show inserted item
      const targetScroll = Math.max(0, (array.length - Math.floor(canvas.width / cellWidth)) * cellWidth);
      scrollX = startScroll + (targetScroll - startScroll) * progress;

      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.font = &quot;18px Arial&quot;;
      ctx.textAlign = &quot;center&quot;;
      ctx.textBaseline = &quot;middle&quot;;

      for (let i = 0; i < array.length; i++) {
        let x = i * cellWidth - scrollX;
        if (x + cellWidth < 0 || x > canvas.width) continue;

        if (i === idx) {
          const insertX = x - cellWidth * (1 - progress);
          ctx.fillStyle = 'lightgreen';
          ctx.fillRect(insertX, startY, cellWidth, cellHeight);
          ctx.strokeStyle = &quot;black&quot;;
          ctx.lineWidth = 2;
          ctx.strokeRect(insertX, startY, cellWidth, cellHeight);
          ctx.fillStyle = &quot;black&quot;;
          ctx.fillText(array[i], insertX + cellWidth / 2, startY + cellHeight / 2);
          ctx.fillStyle = &quot;gray&quot;;
          ctx.font = &quot;14px Arial&quot;;
          ctx.fillText(i, insertX + cellWidth / 2, startY + cellHeight + 20);
          ctx.font = &quot;18px Arial&quot;;
        } else if (i > idx) {
          const shiftedX = x + cellWidth * progress;
          ctx.strokeStyle = &quot;black&quot;;
          ctx.lineWidth = 2;
          ctx.strokeRect(shiftedX, startY, cellWidth, cellHeight);
          ctx.fillStyle = &quot;black&quot;;
          ctx.fillText(array[i], shiftedX + cellWidth / 2, startY + cellHeight / 2);
          ctx.fillStyle = &quot;gray&quot;;
          ctx.font = &quot;14px Arial&quot;;
          ctx.fillText(i, shiftedX + cellWidth / 2, startY + cellHeight + 20);
          ctx.font = &quot;18px Arial&quot;;
        } else {
          ctx.strokeStyle = &quot;black&quot;;
          ctx.lineWidth = 2;
          ctx.strokeRect(x, startY, cellWidth, cellHeight);
          ctx.fillStyle = &quot;black&quot;;
          ctx.fillText(array[i], x + cellWidth / 2, startY + cellHeight / 2);
          ctx.fillStyle = &quot;gray&quot;;
          ctx.font = &quot;14px Arial&quot;;
          ctx.fillText(i, x + cellWidth / 2, startY + cellHeight + 20);
          ctx.font = &quot;18px Arial&quot;;
        }
      }

      if (frame < totalFrames) {
        requestAnimationFrame(animate);
      } else {
        drawArray();
      }
    }

    animate();
  };

  deleteBtn.onclick = () => {
    const idx = parseInt(indexInput.value);
    if (isNaN(idx) || idx < 0 || idx >= array.length) {
      message.textContent = &quot;Invalid index for delete&quot;;
      return;
    }
    message.textContent = `Deleting element at index ${idx}`;
    animateDelete(idx);
  };

  // Scroll on mouse wheel horizontally
  canvas.addEventListener('wheel', (e) => {
    e.preventDefault();
    if (e.deltaY < 0) {
      scrollLeft();
    } else {
      scrollRight();
    }
  });

  drawArray();
</script>
</body>
</html>ID"><textarea id="iP5aW" style="display: none;">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
&lt;meta charset="UTF-8" /&gt;
&lt;title&gt;Interactive Array Visualization&lt;/title&gt;
&lt;style&gt;
  body {
    font-family: Arial, sans-serif;
    text-align: center;
  }
  canvas {
    border: 1px solid black;
    background: #fafafa;
    display: block;
    margin: 20px auto;
  }
  #controls {
    margin: 10px auto;
    max-width: 700px;
  }
  input, button {
    font-size: 16px;
    padding: 6px 8px;
    margin: 4px;
  }
  #message {
    height: 24px;
    margin-top: 8px;
    font-weight: bold;
  }
&lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;h2&gt;Interactive Array Visualization&lt;/h2&gt;

&lt;div id="controls"&gt;
  &lt;input type="number" id="indexInput" placeholder="Index" min="0" /&gt;
  &lt;input type="number" id="valueInput" placeholder="Value" /&gt;
  &lt;button id="accessBtn"&gt;Access&lt;/button&gt;
  &lt;button id="updateBtn"&gt;Update&lt;/button&gt;
  &lt;button id="insertBtn"&gt;Insert&lt;/button&gt;
  &lt;button id="deleteBtn"&gt;Delete&lt;/button&gt;
&lt;/div&gt;

&lt;canvas id="canvas" width="700" height="150"&gt;&lt;/canvas&gt;
&lt;div id="message"&gt;&lt;/div&gt;

&lt;script&gt;
  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d');
  const indexInput = document.getElementById('indexInput');
  const valueInput = document.getElementById('valueInput');
  const accessBtn = document.getElementById('accessBtn');
  const updateBtn = document.getElementById('updateBtn');
  const insertBtn = document.getElementById('insertBtn');
  const deleteBtn = document.getElementById('deleteBtn');
  const message = document.getElementById('message');

  let array = [10, 22, 35, 47, 59, 63, 78];
  const cellWidth = 80;
  const cellHeight = 60;
  const startY = 50;
  let scrollX = 0;
  const scrollStep = 40;

  // For animations
  let highlightIndex = -1;
  let animationFrames = [];

  // Calculate total width needed for array
  function totalWidth() {
    return array.length * cellWidth;
  }

  // Draw the array with scrolling offset and highlight
  function drawArray() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.font = "18px Arial";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";

    const visibleCount = Math.floor(canvas.width / cellWidth);

    for (let i = 0; i &lt; array.length; i++) {
      const x = i * cellWidth - scrollX;
      if (x + cellWidth &lt; 0 || x &gt; canvas.width) continue; // skip if out of visible area

      // Highlight box if needed
      if (i === highlightIndex) {
        ctx.fillStyle = 'orange';
        ctx.fillRect(x, startY, cellWidth, cellHeight);
      }

      // Draw box border
      ctx.strokeStyle = "black";
      ctx.lineWidth = 2;
      ctx.strokeRect(x, startY, cellWidth, cellHeight);

      // Draw value
      ctx.fillStyle = i === highlightIndex ? "black" : "black";
      ctx.fillText(array[i], x + cellWidth / 2, startY + cellHeight / 2);

      // Draw index below
      ctx.fillStyle = "gray";
      ctx.font = "14px Arial";
      ctx.fillText(i, x + cellWidth / 2, startY + cellHeight + 20);

      ctx.font = "18px Arial";
    }
  }

  // Animate highlight for access/update
  function animateHighlight(index, duration = 1000) {
    highlightIndex = index;
    drawArray();
    setTimeout(() =&gt; {
      highlightIndex = -1;
      drawArray();
    }, duration);
  }

  // Animate insertion with sliding boxes to right
  function animateInsert(index, value) {
    // Insert a placeholder at the end
    array.push(value);
    let frame = 0;
    const totalFrames = 20;
    const startScroll = scrollX;

    function animate() {
      frame++;
      const progress = frame / totalFrames;

      // Scroll if needed to show inserted item
      const targetScroll = Math.max(0, (array.length - Math.floor(canvas.width / cellWidth)) * cellWidth);
      scrollX = startScroll + (targetScroll - startScroll) * progress;

      // Shift elements right starting from the inserted index
      // We'll redraw array offsetting the elements &gt;= index by progress * cellWidth
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.font = "18px Arial";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";

      for (let i = 0; i &lt; array.length; i++) {
        let x = i * cellWidth - scrollX;
        if (x + cellWidth &lt; 0 || x &gt; canvas.width) continue;

        if (i === index) {
          // The new inserted box slides in from left (or opacity fade)
          const insertX = x - cellWidth * (1 - progress);
          ctx.fillStyle = 'lightgreen';
          ctx.fillRect(insertX, startY, cellWidth, cellHeight);
          ctx.strokeStyle = "black";
          ctx.lineWidth = 2;
          ctx.strokeRect(insertX, startY, cellWidth, cellHeight);
          ctx.fillStyle = "black";
          ctx.fillText(array[i], insertX + cellWidth / 2, startY + cellHeight / 2);
          ctx.fillStyle = "gray";
          ctx.font = "14px Arial";
          ctx.fillText(i, insertX + cellWidth / 2, startY + cellHeight + 20);
          ctx.font = "18px Arial";
        } else if (i &gt; index) {
          // Shift right by progress * cellWidth
          const shiftedX = x + cellWidth * progress;
          ctx.fillStyle = 'white';
          ctx.fillRect(shiftedX, startY, cellWidth, cellHeight);
          ctx.strokeStyle = "black";
          ctx.lineWidth = 2;
          ctx.strokeRect(shiftedX, startY, cellWidth, cellHeight);
          ctx.fillStyle = "black";
          ctx.fillText(array[i], shiftedX + cellWidth / 2, startY + cellHeight / 2);
          ctx.fillStyle = "gray";
          ctx.font = "14px Arial";
          ctx.fillText(i, shiftedX + cellWidth / 2, startY + cellHeight + 20);
          ctx.font = "18px Arial";
        } else {
          // Normal boxes
          ctx.strokeStyle = "black";
          ctx.lineWidth = 2;
          ctx.strokeRect(x, startY, cellWidth, cellHeight);
          ctx.fillStyle = "black";
          ctx.fillText(array[i], x + cellWidth / 2, startY + cellHeight / 2);
          ctx.fillStyle = "gray";
          ctx.font = "14px Arial";
          ctx.fillText(i, x + cellWidth / 2, startY + cellHeight + 20);
          ctx.font = "18px Arial";
        }
      }

      if (frame &lt; totalFrames) {
        requestAnimationFrame(animate);
      } else {
        // Insert is done, no highlight
        drawArray();
      }
    }

    animate();
  }

  // Animate delete by sliding boxes left
  function animateDelete(index) {
    let frame = 0;
    const totalFrames = 20;
    const startScroll = scrollX;

    function animate() {
      frame++;
      const progress = frame / totalFrames;

      // Scroll if needed to keep array visible
      const maxScroll = Math.max(0, (array.length - 1 - Math.floor(canvas.width / cellWidth)) * cellWidth);
      scrollX = startScroll + (maxScroll - startScroll) * progress;

      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.font = "18px Arial";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";

      for (let i = 0; i &lt; array.length; i++) {
        if (i === index) continue; // this one is deleting, so skip drawing

        let x = i * cellWidth - scrollX;
        if (x + cellWidth &lt; 0 || x &gt; canvas.width) continue;

        if (i &gt; index) {
          // Shift left by progress * cellWidth
          const shiftedX = x - cellWidth * progress;
          ctx.strokeStyle = "black";
          ctx.lineWidth = 2;
          ctx.strokeRect(shiftedX, startY, cellWidth, cellHeight);
          ctx.fillStyle = "black";
          ctx.fillText(array[i], shiftedX + cellWidth / 2, startY + cellHeight / 2);
          ctx.fillStyle = "gray";
          ctx.font = "14px Arial";
          ctx.fillText(i - 1, shiftedX + cellWidth / 2, startY + cellHeight + 20);
          ctx.font = "18px Arial";
        } else {
          // Normal boxes
          ctx.strokeStyle = "black";
          ctx.lineWidth = 2;
          ctx.strokeRect(x, startY, cellWidth, cellHeight);
          ctx.fillStyle = "black";
          ctx.fillText(array[i], x + cellWidth / 2, startY + cellHeight / 2);
          ctx.fillStyle = "gray";
          ctx.font = "14px Arial";
          ctx.fillText(i, x + cellWidth / 2, startY + cellHeight + 20);
          ctx.font = "18px Arial";
        }
      }

      if (frame &lt; totalFrames) {
        requestAnimationFrame(animate);
      } else {
        // Actually remove the element now
        array.splice(index, 1);
        drawArray();
      }
    }

    animate();
  }

  // Animate update by flashing the box
  function animateUpdate(index, newValue) {
    let frame = 0;
    const totalFrames = 30;

    function animate() {
      frame++;
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.font = "18px Arial";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";

      for (let i = 0; i &lt; array.length; i++) {
        const x = i * cellWidth - scrollX;
        if (x + cellWidth &lt; 0 || x &gt; canvas.width) continue;

        if (i === index) {
          // Flashing effect by changing fillStyle
          const intensity = Math.abs(Math.sin(frame / 5));
          ctx.fillStyle = `rgba(255, 165, 0, ${intensity})`; // orange glow
          ctx.fillRect(x, startY, cellWidth, cellHeight);
        }
        ctx.strokeStyle = "black";
        ctx.lineWidth = 2;
        ctx.strokeRect(x, startY, cellWidth, cellHeight);

        ctx.fillStyle = "black";
        ctx.fillText(i === index ? newValue : array[i], x + cellWidth / 2, startY + cellHeight / 2);
        ctx.fillStyle = "gray";
        ctx.font = "14px Arial";
        ctx.fillText(i, x + cellWidth / 2, startY + cellHeight + 20);
        ctx.font = "18px Arial";
      }

      if (frame &lt; totalFrames) {
        requestAnimationFrame(animate);
      } else {
        // Finalize update
        array[index] = newValue;
        drawArray();
      }
    }

    animate();
  }

  // Scroll canvas horizontally (left/right buttons could be added)
  function scrollLeft() {
    scrollX = Math.max(0, scrollX - scrollStep);
    drawArray();
  }
  function scrollRight() {
    const maxScroll = Math.max(0, totalWidth() - canvas.width);
    scrollX = Math.min(maxScroll, scrollX + scrollStep);
    drawArray();
  }

  // Button event handlers
  accessBtn.onclick = () =&gt; {
    const idx = parseInt(indexInput.value);
    if (isNaN(idx) || idx &lt; 0 || idx &gt;= array.length) {
      message.textContent = "Invalid index for access";
      return;
    }
    message.textContent = `Accessed element at index ${idx}: ${array[idx]}`;
    animateHighlight(idx);
  };

  updateBtn.onclick = () =&gt; {
    const idx = parseInt(indexInput.value);
    const val = parseInt(valueInput.value);
    if (isNaN(idx) || idx &lt; 0 || idx &gt;= array.length) {
      message.textContent = "Invalid index for update";
      return;
    }
    if (isNaN(val)) {
      message.textContent = "Invalid value for update";
      return;
    }
    message.textContent = `Updating element at index ${idx} to ${val}`;
    animateUpdate(idx, val);
  };

  insertBtn.onclick = () =&gt; {
    const idx = parseInt(indexInput.value);
    const val = parseInt(valueInput.value);
    if (isNaN(idx) || idx &lt; 0 || idx &gt; array.length) {
      message.textContent = "Invalid index for insert";
      return;
    }
    if (isNaN(val)) {
      message.textContent = "Invalid value for insert";
      return;
    }
    message.textContent = `Inserting ${val} at index ${idx}`;
    // Insert visually with animation
    // Actually splice after animation completes
    // We insert a temporary placeholder now and slide later
    array.splice(idx, 0, val); // Insert to array but animate sliding boxes

    // Animate sliding boxes to the right, then finalize
    let frame = 0;
    const totalFrames = 20;
    const startScroll = scrollX;

    function animate() {
      frame++;
      const progress = frame / totalFrames;

      // Scroll if needed to show inserted item
      const targetScroll = Math.max(0, (array.length - Math.floor(canvas.width / cellWidth)) * cellWidth);
      scrollX = startScroll + (targetScroll - startScroll) * progress;

      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.font = "18px Arial";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";

      for (let i = 0; i &lt; array.length; i++) {
        let x = i * cellWidth - scrollX;
        if (x + cellWidth &lt; 0 || x &gt; canvas.width) continue;

        if (i === idx) {
          const insertX = x - cellWidth * (1 - progress);
          ctx.fillStyle = 'lightgreen';
          ctx.fillRect(insertX, startY, cellWidth, cellHeight);
          ctx.strokeStyle = "black";
          ctx.lineWidth = 2;
          ctx.strokeRect(insertX, startY, cellWidth, cellHeight);
          ctx.fillStyle = "black";
          ctx.fillText(array[i], insertX + cellWidth / 2, startY + cellHeight / 2);
          ctx.fillStyle = "gray";
          ctx.font = "14px Arial";
          ctx.fillText(i, insertX + cellWidth / 2, startY + cellHeight + 20);
          ctx.font = "18px Arial";
        } else if (i &gt; idx) {
          const shiftedX = x + cellWidth * progress;
          ctx.strokeStyle = "black";
          ctx.lineWidth = 2;
          ctx.strokeRect(shiftedX, startY, cellWidth, cellHeight);
          ctx.fillStyle = "black";
          ctx.fillText(array[i], shiftedX + cellWidth / 2, startY + cellHeight / 2);
          ctx.fillStyle = "gray";
          ctx.font = "14px Arial";
          ctx.fillText(i, shiftedX + cellWidth / 2, startY + cellHeight + 20);
          ctx.font = "18px Arial";
        } else {
          ctx.strokeStyle = "black";
          ctx.lineWidth = 2;
          ctx.strokeRect(x, startY, cellWidth, cellHeight);
          ctx.fillStyle = "black";
          ctx.fillText(array[i], x + cellWidth / 2, startY + cellHeight / 2);
          ctx.fillStyle = "gray";
          ctx.font = "14px Arial";
          ctx.fillText(i, x + cellWidth / 2, startY + cellHeight + 20);
          ctx.font = "18px Arial";
        }
      }

      if (frame &lt; totalFrames) {
        requestAnimationFrame(animate);
      } else {
        drawArray();
      }
    }

    animate();
  };

  deleteBtn.onclick = () =&gt; {
    const idx = parseInt(indexInput.value);
    if (isNaN(idx) || idx &lt; 0 || idx &gt;= array.length) {
      message.textContent = "Invalid index for delete";
      return;
    }
    message.textContent = `Deleting element at index ${idx}`;
    animateDelete(idx);
  };

  // Scroll on mouse wheel horizontally
  canvas.addEventListener('wheel', (e) =&gt; {
    e.preventDefault();
    if (e.deltaY &lt; 0) {
      scrollLeft();
    } else {
      scrollRight();
    }
  });

  drawArray();
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</textarea> <iframe id="BdRfz" class="result_iframe" style="border:none;"></iframe>
 <script>{
const textarea = document.getElementById("iP5aW");
const iframe = document.getElementById("BdRfz");
const html = textarea.value;
const iframeHTML = `${html}`;
const doc = iframe.contentDocument || iframe.contentWindow.document;
doc.open();
doc.write(iframeHTML);
doc.close();
setTimeout(() => {
   iframe.style.height = '0px';
   let contentHeight = Math.max(doc.body.scrollHeight,doc.documentElement.scrollHeight);
   if(contentHeight < 10 || contentHeight > 800){
	   contentHeight = 800;
   } 
   iframe.style.height = contentHeight + 'px';
}, 50);
}
		</script>
</div><h3 id="key-features-of-native-arrays">Key Features of Native Arrays</h3><h4 id="dynamic-sizing">Dynamic Sizing</h4><p>JavaScript arrays grow and shrink as needed. You can push, pop, or even assign a value to a distant index, and the array adjusts automatically.</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-js">const arr = [];
arr[100] = 'hello';
console.log(arr.length); // 101</code></pre>
</div><p>Assigning a value to index 100 creates a sparse array with undefined values in the gaps (indices 0 through 99).</p><h4 id="sparse-arrays">Sparse Arrays</h4><p>JavaScript arrays can have missing indices. These are not the same as <code>undefined</code> values—they are actual <em>holes</em> in the array.</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-js">const sparse = [1];
sparse[5] = 10;
console.log(sparse);        // [1, &lt;4 empty items&gt;, 10]
console.log(sparse.length); // 6</code></pre>
</div><p>Sparse arrays can negatively impact performance because they prevent the JavaScript engine from optimizing the array as a dense, contiguous block in memory.</p><h4 id="flexible-indexing-and-types">Flexible Indexing and Types</h4><p>Unlike typed arrays in other languages, JavaScript arrays can contain mixed types:</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-js">const mix = [42, "text", { key: "value" }, [1, 2], null];</code></pre>
</div><p>While this is powerful, it adds overhead and weakens guarantees around performance and structure.</p><h3 id="performance-implications">Performance Implications</h3><h4 id="access-time">Access Time</h4><p>Accessing elements by index (e.g. <code>arr[i]</code>) is generally <strong>O(1)</strong>—constant time—even for sparse arrays.</p><h4 id="insertion-and-deletion">Insertion and Deletion</h4><ul>
 <li><strong>Push/Pop</strong>: Adding or removing from the end (<code>push</code>, <code>pop</code>) is typically <strong>O(1)</strong>.</li>
 <li><strong>Unshift/Shift</strong>: Adding or removing from the beginning (<code>unshift</code>, <code>shift</code>) is <strong>O(n)</strong> because all elements must be reindexed.</li>
 <li><strong>Splice/Delete</strong>: Deleting an element with <code>splice()</code> causes shifting, resulting in <strong>O(n)</strong> operations.</li>
</ul><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-js">const a = [1, 2, 3, 4, 5];
a.splice(2, 1); // Removes value at index 2
console.log(a); // [1, 2, 4, 5]</code></pre>
</div><p>This shifts all elements after index 2 left by one, which is costly for large arrays.</p><h4 id="hidden-costs">Hidden Costs</h4><p>Under the hood, JavaScript engines like V8 optimize arrays by categorizing them as <em>packed</em> (dense) or <em>holey</em> (sparse). Dense arrays are faster to process, but sparse or mixed-type arrays lose these optimizations, causing slower reads, writes, and iterations.</p><h3 id="when-native-arrays-become-inefficient">When Native Arrays Become Inefficient</h3><p>Native arrays can become inefficient in scenarios such as:</p><ul>
 <li><strong>Frequent Insertions/Deletions at the Start or Middle</strong>: Constant reindexing makes this costly.</li>
 <li><strong>Sparse Data Representation</strong>: Sparse arrays increase memory usage and slow down iteration.</li>
 <li><strong>Large Data Sets Requiring Consistent Performance</strong>: With millions of elements, small inefficiencies compound.</li>
</ul><h3 id="example-performance-difference">Example: Performance Difference</h3><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-js">// Inefficient for large arrays
const big = Array(1e6).fill(0);
console.time('shift');
big.shift(); // O(n) operation
console.timeEnd('shift');</code></pre>
</div><p>Even though it's just removing the first element, the time complexity is linear due to reindexing.</p><h3 id="conclusion">Conclusion</h3><p>JavaScript’s native arrays are powerful, flexible, and suitable for many everyday tasks. However, understanding their underlying mechanics and limitations is crucial for writing performant code. When you find yourself needing frequent insertions or deletions in the middle of a dataset—or when working with very large or sparse data—consider switching to a more appropriate structure like a linked list or a custom data structure tailored to your use case.</p><div class = "chapter-navi-section">
<a href="#top" class="nav-button prev">↑</a>
<a href='javascript-algorithms.htm#arrays-and-linked-lists' class="nav-button toc-link">Index</a>
<a href="#bottom" class="nav-button next">↓</a>
</div>
<h2 id='implementing-singly-doubly-linked-lists'>7.2 Implementing Singly/Doubly Linked Lists</h2><p>Linked lists are fundamental data structures that store elements in a <em>sequence of nodes</em>, where each node contains data and one or more references (or "pointers") to other nodes. Unlike arrays, linked lists do <strong>not require contiguous memory</strong> and allow for efficient insertions and deletions—especially in the middle or beginning of a list.</p><h3 id="concept-linked-lists-vs-arrays">Concept: Linked Lists vs Arrays</h3><table>
 <thead>
  <tr>
   <th>Feature</th>
   <th>Array</th>
   <th>Linked List</th>
  </tr>
 </thead>
 <tbody>
  <tr>
   <td>Memory layout</td>
   <td>Contiguous</td>
   <td>Non-contiguous (nodes linked)</td>
  </tr>
  <tr>
   <td>Access by index</td>
   <td>O(1)</td>
   <td>O(n)</td>
  </tr>
  <tr>
   <td>Insertion (start)</td>
   <td>O(n)</td>
   <td>O(1) (linked list)</td>
  </tr>
  <tr>
   <td>Deletion (middle)</td>
   <td>O(n)</td>
   <td>O(1) with reference</td>
  </tr>
 </tbody>
</table><p>There are two common types:</p><ul>
 <li><strong>Singly Linked List</strong>: Each node points only to the <em>next</em> node.</li>
 <li><strong>Doubly Linked List</strong>: Each node points to <em>both</em> the next and previous nodes.</li>
</ul><h3 id="singly-linked-list">Singly Linked List</h3><h4 id="structure">Structure</h4><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-bash">[HEAD] → [data|next] → [data|next] → null</code></pre>
</div><h4 id="node-class">Node Class</h4><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-js">class ListNode {
  constructor(value) {
    this.value = value;
    this.next = null;
  }
}</code></pre>
</div><h4 id="singlylinkedlist-class">SinglyLinkedList Class</h4><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-js">class SinglyLinkedList {
  constructor() {
    this.head = null;
  }

  insertAtHead(value) {
    const newNode = new ListNode(value);
    newNode.next = this.head;
    this.head = newNode;
  }

  insertAtEnd(value) {
    const newNode = new ListNode(value);
    if (!this.head) {
      this.head = newNode;
      return;
    }
    let current = this.head;
    while (current.next) {
      current = current.next;
    }
    current.next = newNode;
  }

  delete(value) {
    if (!this.head) return;

    if (this.head.value === value) {
      this.head = this.head.next;
      return;
    }

    let current = this.head;
    while (current.next &amp;&amp; current.next.value !== value) {
      current = current.next;
    }

    if (current.next) {
      current.next = current.next.next;
    }
  }

  search(value) {
    let current = this.head;
    while (current) {
      if (current.value === value) return true;
      current = current.next;
    }
    return false;
  }

  traverse() {
    let current = this.head;
    const values = [];
    while (current) {
      values.push(current.value);
      current = current.next;
    }
    return values;
  }
}</code></pre>
</div><div class="snippet-container" id="<!DOCTYPE html>
<html lang=&quot;en&quot;>
<head>
<meta charset=&quot;UTF-8&quot; />
<title>Singly Linked List Visualization</title>
<style>
  body {
    font-family: Arial, sans-serif;
    text-align: center;
  }
  canvas {
    border: 1px solid black;
    background: #fafafa;
    display: block;
    margin: 20px auto;
  }
  #controls {
    margin: 10px auto;
    max-width: 700px;
  }
  input, button {
    font-size: 16px;
    padding: 6px 8px;
    margin: 4px;
  }
  #message {
    height: 24px;
    margin-top: 8px;
    font-weight: bold;
  }
</style>
</head>
<body>

<h2>Singly Linked List Visualization</h2>

<div id=&quot;controls&quot;>
  <input type=&quot;number&quot; id=&quot;valueInput&quot; placeholder=&quot;Value&quot; />
  <input type=&quot;number&quot; id=&quot;posInput&quot; placeholder=&quot;Position (0-based)&quot; />
  <button id=&quot;insertBtn&quot;>Insert</button>
  <button id=&quot;deleteBtn&quot;>Delete</button>
  <button id=&quot;highlightBtn&quot;>Highlight Node</button>
</div>

<canvas id=&quot;canvas&quot; width=&quot;900&quot; height=&quot;200&quot;></canvas>
<div id=&quot;message&quot;></div>

<script>
  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d');

  const valueInput = document.getElementById('valueInput');
  const posInput = document.getElementById('posInput');
  const insertBtn = document.getElementById('insertBtn');
  const deleteBtn = document.getElementById('deleteBtn');
  const highlightBtn = document.getElementById('highlightBtn');
  const message = document.getElementById('message');

  const nodeWidth = 70;
  const nodeHeight = 40;
  const nodeSpacing = 50;
  const startX = 50;
  const startY = 100;

  // Linked list nodes stored as objects {value, next}
  let head = null;

  // Highlight node index (-1 = none)
  let highlightIndex = -1;

  // Build linked list from array for easy initialization
  function buildListFromArray(arr) {
    head = null;
    let prev = null;
    for (let val of arr) {
      const node = { value: val, next: null };
      if (!head) head = node;
      else prev.next = node;
      prev = node;
    }
  }

  // Convert linked list to array for easy iteration
  function listToArray() {
    const arr = [];
    let current = head;
    while (current) {
      arr.push(current);
      current = current.next;
    }
    return arr;
  }

  // Draw a single node box at (x,y)
  function drawNode(x, y, node, isHighlighted = false) {
    ctx.fillStyle = isHighlighted ? '#f9d342' : 'lightblue';
    ctx.strokeStyle = 'black';
    ctx.lineWidth = 2;
    ctx.fillRect(x, y, nodeWidth, nodeHeight);
    ctx.strokeRect(x, y, nodeWidth, nodeHeight);

    ctx.fillStyle = 'black';
    ctx.font = '18px Arial';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(node.value, x + nodeWidth / 2, y + nodeHeight / 2);

    // Draw &quot;next&quot; box on right side of node
    const nextX = x + nodeWidth;
    const nextY = y;
    ctx.fillStyle = 'white';
    ctx.fillRect(nextX, nextY, 20, nodeHeight);
    ctx.strokeRect(nextX, nextY, 20, nodeHeight);

    // Draw arrow from next box to next node (if any)
    if (node.next) {
      const arrowStartX = nextX + 20;
      const arrowStartY = nextY + nodeHeight / 2;
      const arrowEndX = nextX + nodeSpacing;
      const arrowEndY = arrowStartY;

      // Line
      ctx.beginPath();
      ctx.moveTo(arrowStartX, arrowStartY);
      ctx.lineTo(arrowEndX, arrowEndY);
      ctx.stroke();

      // Arrowhead
      ctx.beginPath();
      ctx.moveTo(arrowEndX - 10, arrowEndY - 7);
      ctx.lineTo(arrowEndX, arrowEndY);
      ctx.lineTo(arrowEndX - 10, arrowEndY + 7);
      ctx.fillStyle = 'black';
      ctx.fill();
    }
  }

  // Draw head pointer label
  function drawHeadPointer(x, y) {
    ctx.fillStyle = 'black';
    ctx.font = '16px Arial';
    ctx.textAlign = 'center';
    ctx.fillText('head', x + nodeWidth / 2, y - 20);

    // Arrow down
    ctx.beginPath();
    ctx.moveTo(x + nodeWidth / 2, y - 10);
    ctx.lineTo(x + nodeWidth / 2, y);
    ctx.stroke();
  }

  // Draw the whole linked list
  function drawList() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    const nodes = listToArray();
    if (nodes.length === 0) {
      ctx.fillStyle = 'black';
      ctx.font = '20px Arial';
      ctx.fillText('List is empty', canvas.width / 2, canvas.height / 2);
      return;
    }

    // Draw nodes horizontally spaced
    nodes.forEach((node, idx) => {
      const x = startX + idx * (nodeWidth + nodeSpacing);
      drawNode(x, startY, node, idx === highlightIndex);
      if (idx === 0) drawHeadPointer(x, startY);
    });
  }

  // Insert node at position with animation
  function insertNode(value, position) {
    if (position < 0) {
      message.textContent = &quot;Invalid position&quot;;
      return;
    }
    const newNode = { value, next: null };

    if (!head || position === 0) {
      // Insert at head
      newNode.next = head;
      head = newNode;
      highlightIndex = 0;
      drawList();
      message.textContent = `Inserted ${value} at position 0`;
      return;
    }

    let prev = head;
    let idx = 0;
    while (prev &amp;&amp; idx < position - 1) {
      prev = prev.next;
      idx++;
    }
    if (!prev) {
      message.textContent = &quot;Position out of bounds&quot;;
      return;
    }
    newNode.next = prev.next;
    prev.next = newNode;

    highlightIndex = position;
    drawList();
    message.textContent = `Inserted ${value} at position ${position}`;
  }

  // Delete node at position with animation
  function deleteNode(position) {
    if (!head || position < 0) {
      message.textContent = &quot;Invalid position&quot;;
      return;
    }
    if (position === 0) {
      const deletedVal = head.value;
      head = head.next;
      highlightIndex = -1;
      drawList();
      message.textContent = `Deleted node at position 0 (value ${deletedVal})`;
      return;
    }

    let prev = head;
    let idx = 0;
    while (prev.next &amp;&amp; idx < position - 1) {
      prev = prev.next;
      idx++;
    }
    if (!prev.next) {
      message.textContent = &quot;Position out of bounds&quot;;
      return;
    }
    const deletedVal = prev.next.value;
    prev.next = prev.next.next;
    highlightIndex = -1;
    drawList();
    message.textContent = `Deleted node at position ${position} (value ${deletedVal})`;
  }

  // Highlight node at position
  function highlightNode(position) {
    const nodes = listToArray();
    if (position < 0 || position >= nodes.length) {
      message.textContent = &quot;Invalid position to highlight&quot;;
      return;
    }
    highlightIndex = position;
    drawList();
    message.textContent = `Highlighted node at position ${position} (value ${nodes[position].value})`;
  }

  insertBtn.onclick = () => {
    const val = parseInt(valueInput.value);
    const pos = parseInt(posInput.value);
    if (isNaN(val)) {
      message.textContent = &quot;Enter a valid value to insert&quot;;
      return;
    }
    if (isNaN(pos) || pos < 0) {
      message.textContent = &quot;Enter a valid position to insert&quot;;
      return;
    }
    insertNode(val, pos);
  };

  deleteBtn.onclick = () => {
    const pos = parseInt(posInput.value);
    if (isNaN(pos) || pos < 0) {
      message.textContent = &quot;Enter a valid position to delete&quot;;
      return;
    }
    deleteNode(pos);
  };

  highlightBtn.onclick = () => {
    const pos = parseInt(posInput.value);
    if (isNaN(pos) || pos < 0) {
      message.textContent = &quot;Enter a valid position to highlight&quot;;
      return;
    }
    highlightNode(pos);
  };

  // Initialize list with some values
  buildListFromArray([10, 20, 30, 40, 50]);
  drawList();
</script>

</body>
</html>ID"><textarea id="BnF9V" style="display: none;">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
&lt;meta charset="UTF-8" /&gt;
&lt;title&gt;Singly Linked List Visualization&lt;/title&gt;
&lt;style&gt;
  body {
    font-family: Arial, sans-serif;
    text-align: center;
  }
  canvas {
    border: 1px solid black;
    background: #fafafa;
    display: block;
    margin: 20px auto;
  }
  #controls {
    margin: 10px auto;
    max-width: 700px;
  }
  input, button {
    font-size: 16px;
    padding: 6px 8px;
    margin: 4px;
  }
  #message {
    height: 24px;
    margin-top: 8px;
    font-weight: bold;
  }
&lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;h2&gt;Singly Linked List Visualization&lt;/h2&gt;

&lt;div id="controls"&gt;
  &lt;input type="number" id="valueInput" placeholder="Value" /&gt;
  &lt;input type="number" id="posInput" placeholder="Position (0-based)" /&gt;
  &lt;button id="insertBtn"&gt;Insert&lt;/button&gt;
  &lt;button id="deleteBtn"&gt;Delete&lt;/button&gt;
  &lt;button id="highlightBtn"&gt;Highlight Node&lt;/button&gt;
&lt;/div&gt;

&lt;canvas id="canvas" width="900" height="200"&gt;&lt;/canvas&gt;
&lt;div id="message"&gt;&lt;/div&gt;

&lt;script&gt;
  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d');

  const valueInput = document.getElementById('valueInput');
  const posInput = document.getElementById('posInput');
  const insertBtn = document.getElementById('insertBtn');
  const deleteBtn = document.getElementById('deleteBtn');
  const highlightBtn = document.getElementById('highlightBtn');
  const message = document.getElementById('message');

  const nodeWidth = 70;
  const nodeHeight = 40;
  const nodeSpacing = 50;
  const startX = 50;
  const startY = 100;

  // Linked list nodes stored as objects {value, next}
  let head = null;

  // Highlight node index (-1 = none)
  let highlightIndex = -1;

  // Build linked list from array for easy initialization
  function buildListFromArray(arr) {
    head = null;
    let prev = null;
    for (let val of arr) {
      const node = { value: val, next: null };
      if (!head) head = node;
      else prev.next = node;
      prev = node;
    }
  }

  // Convert linked list to array for easy iteration
  function listToArray() {
    const arr = [];
    let current = head;
    while (current) {
      arr.push(current);
      current = current.next;
    }
    return arr;
  }

  // Draw a single node box at (x,y)
  function drawNode(x, y, node, isHighlighted = false) {
    ctx.fillStyle = isHighlighted ? '#f9d342' : 'lightblue';
    ctx.strokeStyle = 'black';
    ctx.lineWidth = 2;
    ctx.fillRect(x, y, nodeWidth, nodeHeight);
    ctx.strokeRect(x, y, nodeWidth, nodeHeight);

    ctx.fillStyle = 'black';
    ctx.font = '18px Arial';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(node.value, x + nodeWidth / 2, y + nodeHeight / 2);

    // Draw "next" box on right side of node
    const nextX = x + nodeWidth;
    const nextY = y;
    ctx.fillStyle = 'white';
    ctx.fillRect(nextX, nextY, 20, nodeHeight);
    ctx.strokeRect(nextX, nextY, 20, nodeHeight);

    // Draw arrow from next box to next node (if any)
    if (node.next) {
      const arrowStartX = nextX + 20;
      const arrowStartY = nextY + nodeHeight / 2;
      const arrowEndX = nextX + nodeSpacing;
      const arrowEndY = arrowStartY;

      // Line
      ctx.beginPath();
      ctx.moveTo(arrowStartX, arrowStartY);
      ctx.lineTo(arrowEndX, arrowEndY);
      ctx.stroke();

      // Arrowhead
      ctx.beginPath();
      ctx.moveTo(arrowEndX - 10, arrowEndY - 7);
      ctx.lineTo(arrowEndX, arrowEndY);
      ctx.lineTo(arrowEndX - 10, arrowEndY + 7);
      ctx.fillStyle = 'black';
      ctx.fill();
    }
  }

  // Draw head pointer label
  function drawHeadPointer(x, y) {
    ctx.fillStyle = 'black';
    ctx.font = '16px Arial';
    ctx.textAlign = 'center';
    ctx.fillText('head', x + nodeWidth / 2, y - 20);

    // Arrow down
    ctx.beginPath();
    ctx.moveTo(x + nodeWidth / 2, y - 10);
    ctx.lineTo(x + nodeWidth / 2, y);
    ctx.stroke();
  }

  // Draw the whole linked list
  function drawList() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    const nodes = listToArray();
    if (nodes.length === 0) {
      ctx.fillStyle = 'black';
      ctx.font = '20px Arial';
      ctx.fillText('List is empty', canvas.width / 2, canvas.height / 2);
      return;
    }

    // Draw nodes horizontally spaced
    nodes.forEach((node, idx) =&gt; {
      const x = startX + idx * (nodeWidth + nodeSpacing);
      drawNode(x, startY, node, idx === highlightIndex);
      if (idx === 0) drawHeadPointer(x, startY);
    });
  }

  // Insert node at position with animation
  function insertNode(value, position) {
    if (position &lt; 0) {
      message.textContent = "Invalid position";
      return;
    }
    const newNode = { value, next: null };

    if (!head || position === 0) {
      // Insert at head
      newNode.next = head;
      head = newNode;
      highlightIndex = 0;
      drawList();
      message.textContent = `Inserted ${value} at position 0`;
      return;
    }

    let prev = head;
    let idx = 0;
    while (prev &amp;&amp; idx &lt; position - 1) {
      prev = prev.next;
      idx++;
    }
    if (!prev) {
      message.textContent = "Position out of bounds";
      return;
    }
    newNode.next = prev.next;
    prev.next = newNode;

    highlightIndex = position;
    drawList();
    message.textContent = `Inserted ${value} at position ${position}`;
  }

  // Delete node at position with animation
  function deleteNode(position) {
    if (!head || position &lt; 0) {
      message.textContent = "Invalid position";
      return;
    }
    if (position === 0) {
      const deletedVal = head.value;
      head = head.next;
      highlightIndex = -1;
      drawList();
      message.textContent = `Deleted node at position 0 (value ${deletedVal})`;
      return;
    }

    let prev = head;
    let idx = 0;
    while (prev.next &amp;&amp; idx &lt; position - 1) {
      prev = prev.next;
      idx++;
    }
    if (!prev.next) {
      message.textContent = "Position out of bounds";
      return;
    }
    const deletedVal = prev.next.value;
    prev.next = prev.next.next;
    highlightIndex = -1;
    drawList();
    message.textContent = `Deleted node at position ${position} (value ${deletedVal})`;
  }

  // Highlight node at position
  function highlightNode(position) {
    const nodes = listToArray();
    if (position &lt; 0 || position &gt;= nodes.length) {
      message.textContent = "Invalid position to highlight";
      return;
    }
    highlightIndex = position;
    drawList();
    message.textContent = `Highlighted node at position ${position} (value ${nodes[position].value})`;
  }

  insertBtn.onclick = () =&gt; {
    const val = parseInt(valueInput.value);
    const pos = parseInt(posInput.value);
    if (isNaN(val)) {
      message.textContent = "Enter a valid value to insert";
      return;
    }
    if (isNaN(pos) || pos &lt; 0) {
      message.textContent = "Enter a valid position to insert";
      return;
    }
    insertNode(val, pos);
  };

  deleteBtn.onclick = () =&gt; {
    const pos = parseInt(posInput.value);
    if (isNaN(pos) || pos &lt; 0) {
      message.textContent = "Enter a valid position to delete";
      return;
    }
    deleteNode(pos);
  };

  highlightBtn.onclick = () =&gt; {
    const pos = parseInt(posInput.value);
    if (isNaN(pos) || pos &lt; 0) {
      message.textContent = "Enter a valid position to highlight";
      return;
    }
    highlightNode(pos);
  };

  // Initialize list with some values
  buildListFromArray([10, 20, 30, 40, 50]);
  drawList();
&lt;/script&gt;

&lt;/body&gt;
&lt;/html&gt;</textarea> <iframe id="idHBO" class="result_iframe" style="border:none;"></iframe>
 <script>{
const textarea = document.getElementById("BnF9V");
const iframe = document.getElementById("idHBO");
const html = textarea.value;
const iframeHTML = `${html}`;
const doc = iframe.contentDocument || iframe.contentWindow.document;
doc.open();
doc.write(iframeHTML);
doc.close();
setTimeout(() => {
   iframe.style.height = '0px';
   let contentHeight = Math.max(doc.body.scrollHeight,doc.documentElement.scrollHeight);
   if(contentHeight < 10 || contentHeight > 800){
	   contentHeight = 800;
   } 
   iframe.style.height = contentHeight + 'px';
}, 50);
}
		</script>
</div><h3 id="doubly-linked-list">Doubly Linked List</h3><h4 id="structure">Structure</h4><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-bash">null ← [prev|data|next] ⇄ [prev|data|next] ⇄ [prev|data|next] → null</code></pre>
</div><div class="snippet-container" id="<!DOCTYPE html>
<html lang=&quot;en&quot;>
<head>
  <meta charset=&quot;UTF-8&quot; />
  <title>Doubly Linked List - Canvas</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      text-align: center;
      padding: 20px;
    }
    canvas {
      border: 1px solid #aaa;
      margin-top: 20px;
      background: #fafafa;
    }
    .controls {
      margin-bottom: 10px;
    }
    input, button {
      font-size: 16px;
      padding: 5px;
      margin: 4px;
    }
  </style>
</head>
<body>

<h2>Doubly Linked List (Canvas)</h2>

<div class=&quot;controls&quot;>
  <input type=&quot;number&quot; id=&quot;valueInput&quot; placeholder=&quot;Value&quot; />
  <input type=&quot;number&quot; id=&quot;posInput&quot; placeholder=&quot;Position&quot; />
  <button onclick=&quot;insertNode()&quot;>Insert</button>
  <button onclick=&quot;deleteNode()&quot;>Delete</button>
  <button onclick=&quot;highlightNode()&quot;>Highlight</button>
</div>

<canvas id=&quot;canvas&quot; width=&quot;1000&quot; height=&quot;200&quot;></canvas>

<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');

const NODE_WIDTH = 90;
const NODE_HEIGHT = 60;
const FIELD_WIDTH = NODE_WIDTH / 3;
const SPACING = 50;
const START_X = 50;
const START_Y = 80;

let list = [10, 20, 30, 40];
let highlightIndex = -1;

function drawNode(x, y, value, highlight = false) {
  // Box
  ctx.fillStyle = highlight ? '#f5a623' : '#4a90e2';
  ctx.strokeStyle = 'black';
  ctx.lineWidth = 2;
  ctx.fillRect(x, y, NODE_WIDTH, NODE_HEIGHT);
  ctx.strokeRect(x, y, NODE_WIDTH, NODE_HEIGHT);

  // Partition fields
  ctx.beginPath();
  ctx.moveTo(x + FIELD_WIDTH, y);
  ctx.lineTo(x + FIELD_WIDTH, y + NODE_HEIGHT);
  ctx.moveTo(x + 2 * FIELD_WIDTH, y);
  ctx.lineTo(x + 2 * FIELD_WIDTH, y + NODE_HEIGHT);
  ctx.stroke();

  // Labels
  ctx.fillStyle = 'white';
  ctx.font = '12px Arial';
  ctx.textAlign = 'center';
  ctx.fillText('.prev', x + FIELD_WIDTH / 2, y + 15);
  ctx.fillText(value, x + NODE_WIDTH / 2, y + NODE_HEIGHT / 2 + 5);
  ctx.fillText('.next', x + FIELD_WIDTH * 2.5, y + 15);
}

function drawArrow(fromX, fromY, toX, toY, color = 'black') {
  const headlen = 8;
  const angle = Math.atan2(toY - fromY, toX - fromX);

  ctx.strokeStyle = color;
  ctx.fillStyle = color;
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(fromX, fromY);
  ctx.lineTo(toX, toY);
  ctx.stroke();

  // Arrowhead
  ctx.beginPath();
  ctx.moveTo(toX, toY);
  ctx.lineTo(toX - headlen * Math.cos(angle - Math.PI / 6), toY - headlen * Math.sin(angle - Math.PI / 6));
  ctx.lineTo(toX - headlen * Math.cos(angle + Math.PI / 6), toY - headlen * Math.sin(angle + Math.PI / 6));
  ctx.lineTo(toX, toY);
  ctx.fill();
}

function drawList() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  let x = START_X;
  const y = START_Y;

  for (let i = 0; i < list.length; i++) {
    drawNode(x, y, list[i], i === highlightIndex);

    // Connect .next to next node
    if (i < list.length - 1) {
      const fromX = x + FIELD_WIDTH * 2.5;
      const fromY = y + NODE_HEIGHT / 2;
      const toX = x + NODE_WIDTH + SPACING - FIELD_WIDTH / 2;
      const toY = fromY;
      drawArrow(fromX, fromY, toX, toY, '#000');
    }

    // Connect .prev from next node
    if (i > 0) {
      const fromX = x + FIELD_WIDTH / 2;
      const fromY = y + NODE_HEIGHT / 2;
      const toX = x - SPACING + NODE_WIDTH - FIELD_WIDTH * 2.5;
      const toY = fromY;
      drawArrow(fromX, fromY, toX, toY, 'gray');
    }

    x += NODE_WIDTH + SPACING;
  }

  // Head label
  if (list.length > 0) {
    ctx.fillStyle = 'black';
    ctx.font = '14px Arial';
    ctx.textAlign = 'center';
    ctx.fillText('head', START_X + NODE_WIDTH / 2, START_Y - 20);
    drawArrow(START_X + NODE_WIDTH / 2, START_Y - 10, START_X + NODE_WIDTH / 2, START_Y, 'black');
  }
}

function insertNode() {
  const val = parseInt(document.getElementById(&quot;valueInput&quot;).value);
  const pos = parseInt(document.getElementById(&quot;posInput&quot;).value);
  if (isNaN(val) || isNaN(pos) || pos < 0 || pos > list.length) {
    alert(&quot;Enter valid value and position.&quot;);
    return;
  }
  list.splice(pos, 0, val);
  highlightIndex = pos;
  drawList();
}

function deleteNode() {
  const pos = parseInt(document.getElementById(&quot;posInput&quot;).value);
  if (isNaN(pos) || pos < 0 || pos >= list.length) {
    alert(&quot;Invalid position.&quot;);
    return;
  }
  list.splice(pos, 1);
  highlightIndex = -1;
  drawList();
}

function highlightNode() {
  const pos = parseInt(document.getElementById(&quot;posInput&quot;).value);
  if (isNaN(pos) || pos < 0 || pos >= list.length) {
    alert(&quot;Invalid position to highlight.&quot;);
    return;
  }
  highlightIndex = pos;
  drawList();
}

// Initial render
drawList();
</script>

</body>
</html>ID"><textarea id="EM5kk" style="display: none;">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
  &lt;meta charset="UTF-8" /&gt;
  &lt;title&gt;Doubly Linked List - Canvas&lt;/title&gt;
  &lt;style&gt;
    body {
      font-family: Arial, sans-serif;
      text-align: center;
      padding: 20px;
    }
    canvas {
      border: 1px solid #aaa;
      margin-top: 20px;
      background: #fafafa;
    }
    .controls {
      margin-bottom: 10px;
    }
    input, button {
      font-size: 16px;
      padding: 5px;
      margin: 4px;
    }
  &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;h2&gt;Doubly Linked List (Canvas)&lt;/h2&gt;

&lt;div class="controls"&gt;
  &lt;input type="number" id="valueInput" placeholder="Value" /&gt;
  &lt;input type="number" id="posInput" placeholder="Position" /&gt;
  &lt;button onclick="insertNode()"&gt;Insert&lt;/button&gt;
  &lt;button onclick="deleteNode()"&gt;Delete&lt;/button&gt;
  &lt;button onclick="highlightNode()"&gt;Highlight&lt;/button&gt;
&lt;/div&gt;

&lt;canvas id="canvas" width="1000" height="200"&gt;&lt;/canvas&gt;

&lt;script&gt;
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');

const NODE_WIDTH = 90;
const NODE_HEIGHT = 60;
const FIELD_WIDTH = NODE_WIDTH / 3;
const SPACING = 50;
const START_X = 50;
const START_Y = 80;

let list = [10, 20, 30, 40];
let highlightIndex = -1;

function drawNode(x, y, value, highlight = false) {
  // Box
  ctx.fillStyle = highlight ? '#f5a623' : '#4a90e2';
  ctx.strokeStyle = 'black';
  ctx.lineWidth = 2;
  ctx.fillRect(x, y, NODE_WIDTH, NODE_HEIGHT);
  ctx.strokeRect(x, y, NODE_WIDTH, NODE_HEIGHT);

  // Partition fields
  ctx.beginPath();
  ctx.moveTo(x + FIELD_WIDTH, y);
  ctx.lineTo(x + FIELD_WIDTH, y + NODE_HEIGHT);
  ctx.moveTo(x + 2 * FIELD_WIDTH, y);
  ctx.lineTo(x + 2 * FIELD_WIDTH, y + NODE_HEIGHT);
  ctx.stroke();

  // Labels
  ctx.fillStyle = 'white';
  ctx.font = '12px Arial';
  ctx.textAlign = 'center';
  ctx.fillText('.prev', x + FIELD_WIDTH / 2, y + 15);
  ctx.fillText(value, x + NODE_WIDTH / 2, y + NODE_HEIGHT / 2 + 5);
  ctx.fillText('.next', x + FIELD_WIDTH * 2.5, y + 15);
}

function drawArrow(fromX, fromY, toX, toY, color = 'black') {
  const headlen = 8;
  const angle = Math.atan2(toY - fromY, toX - fromX);

  ctx.strokeStyle = color;
  ctx.fillStyle = color;
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(fromX, fromY);
  ctx.lineTo(toX, toY);
  ctx.stroke();

  // Arrowhead
  ctx.beginPath();
  ctx.moveTo(toX, toY);
  ctx.lineTo(toX - headlen * Math.cos(angle - Math.PI / 6), toY - headlen * Math.sin(angle - Math.PI / 6));
  ctx.lineTo(toX - headlen * Math.cos(angle + Math.PI / 6), toY - headlen * Math.sin(angle + Math.PI / 6));
  ctx.lineTo(toX, toY);
  ctx.fill();
}

function drawList() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  let x = START_X;
  const y = START_Y;

  for (let i = 0; i &lt; list.length; i++) {
    drawNode(x, y, list[i], i === highlightIndex);

    // Connect .next to next node
    if (i &lt; list.length - 1) {
      const fromX = x + FIELD_WIDTH * 2.5;
      const fromY = y + NODE_HEIGHT / 2;
      const toX = x + NODE_WIDTH + SPACING - FIELD_WIDTH / 2;
      const toY = fromY;
      drawArrow(fromX, fromY, toX, toY, '#000');
    }

    // Connect .prev from next node
    if (i &gt; 0) {
      const fromX = x + FIELD_WIDTH / 2;
      const fromY = y + NODE_HEIGHT / 2;
      const toX = x - SPACING + NODE_WIDTH - FIELD_WIDTH * 2.5;
      const toY = fromY;
      drawArrow(fromX, fromY, toX, toY, 'gray');
    }

    x += NODE_WIDTH + SPACING;
  }

  // Head label
  if (list.length &gt; 0) {
    ctx.fillStyle = 'black';
    ctx.font = '14px Arial';
    ctx.textAlign = 'center';
    ctx.fillText('head', START_X + NODE_WIDTH / 2, START_Y - 20);
    drawArrow(START_X + NODE_WIDTH / 2, START_Y - 10, START_X + NODE_WIDTH / 2, START_Y, 'black');
  }
}

function insertNode() {
  const val = parseInt(document.getElementById("valueInput").value);
  const pos = parseInt(document.getElementById("posInput").value);
  if (isNaN(val) || isNaN(pos) || pos &lt; 0 || pos &gt; list.length) {
    alert("Enter valid value and position.");
    return;
  }
  list.splice(pos, 0, val);
  highlightIndex = pos;
  drawList();
}

function deleteNode() {
  const pos = parseInt(document.getElementById("posInput").value);
  if (isNaN(pos) || pos &lt; 0 || pos &gt;= list.length) {
    alert("Invalid position.");
    return;
  }
  list.splice(pos, 1);
  highlightIndex = -1;
  drawList();
}

function highlightNode() {
  const pos = parseInt(document.getElementById("posInput").value);
  if (isNaN(pos) || pos &lt; 0 || pos &gt;= list.length) {
    alert("Invalid position to highlight.");
    return;
  }
  highlightIndex = pos;
  drawList();
}

// Initial render
drawList();
&lt;/script&gt;

&lt;/body&gt;
&lt;/html&gt;</textarea> <iframe id="lLGV9" class="result_iframe" style="border:none;"></iframe>
 <script>{
const textarea = document.getElementById("EM5kk");
const iframe = document.getElementById("lLGV9");
const html = textarea.value;
const iframeHTML = `${html}`;
const doc = iframe.contentDocument || iframe.contentWindow.document;
doc.open();
doc.write(iframeHTML);
doc.close();
setTimeout(() => {
   iframe.style.height = '0px';
   let contentHeight = Math.max(doc.body.scrollHeight,doc.documentElement.scrollHeight);
   if(contentHeight < 10 || contentHeight > 800){
	   contentHeight = 800;
   } 
   iframe.style.height = contentHeight + 'px';
}, 50);
}
		</script>
</div><h4 id="node-class">Node Class</h4><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-js">class DoublyListNode {
  constructor(value) {
    this.value = value;
    this.next = null;
    this.prev = null;
  }
}</code></pre>
</div><h4 id="doublylinkedlist-class">DoublyLinkedList Class</h4><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-js">class DoublyLinkedList {
  constructor() {
    this.head = null;
    this.tail = null;
  }

  insertAtEnd(value) {
    const newNode = new DoublyListNode(value);
    if (!this.tail) {
      this.head = this.tail = newNode;
    } else {
      this.tail.next = newNode;
      newNode.prev = this.tail;
      this.tail = newNode;
    }
  }

  delete(value) {
    let current = this.head;
    while (current &amp;&amp; current.value !== value) {
      current = current.next;
    }

    if (!current) return;

    if (current.prev) current.prev.next = current.next;
    else this.head = current.next;

    if (current.next) current.next.prev = current.prev;
    else this.tail = current.prev;
  }

  traverseForward() {
    let current = this.head;
    const values = [];
    while (current) {
      values.push(current.value);
      current = current.next;
    }
    return values;
  }

  traverseBackward() {
    let current = this.tail;
    const values = [];
    while (current) {
      values.push(current.value);
      current = current.prev;
    }
    return values;
  }
}</code></pre>
</div><h3 id="when-to-use-linked-lists">When to Use Linked Lists</h3><p>Use linked lists when:</p><ul>
 <li>You need <strong>frequent insertions/deletions</strong> (especially not at the end).</li>
 <li>You don’t need <strong>random access</strong> (which arrays handle better).</li>
 <li>You want to avoid shifting elements when modifying the list.</li>
</ul><h4 id="example">Example:</h4><ul>
 <li>Implementing a browser history (back/forward): doubly linked list.</li>
 <li>Building a queue or stack from scratch: singly linked list.</li>
</ul><h3 id="summary">Summary</h3><table>
 <thead>
  <tr>
   <th>Operation</th>
   <th>Array (Dynamic)</th>
   <th>Singly LL</th>
   <th>Doubly LL</th>
  </tr>
 </thead>
 <tbody>
  <tr>
   <td>Access by Index</td>
   <td>O(1)</td>
   <td>O(n)</td>
   <td>O(n)</td>
  </tr>
  <tr>
   <td>Insert at Head</td>
   <td>O(n)</td>
   <td>O(1)</td>
   <td>O(1)</td>
  </tr>
  <tr>
   <td>Insert at Tail</td>
   <td>O(1)</td>
   <td>O(n)</td>
   <td>O(1)</td>
  </tr>
  <tr>
   <td>Delete Node</td>
   <td>O(n)</td>
   <td>O(n)</td>
   <td>O(n)</td>
  </tr>
  <tr>
   <td>Traverse</td>
   <td>O(n)</td>
   <td>O(n)</td>
   <td>O(n)</td>
  </tr>
 </tbody>
</table><p>While arrays are often the default structure in JavaScript, linked lists offer critical advantages in certain situations. By understanding how they work and when to use them, you’ll gain more control over performance and algorithmic efficiency.</p><div class = "chapter-navi-section">
<a href="javascript-algorithms-sorting-and-order-linear-time-sorting.htm" class="nav-button prev">←</a>
<a href='javascript-algorithms.htm#arrays-and-linked-lists' class="nav-button toc-link">Index</a>
<a href="javascript-algorithms-stacks-and-queues.htm" class="nav-button next">→</a>
</div>
<section class="download-section">
  <div class="book-cover" style="background-color: #f9f6f1;border: 1px solid #ccc;"> 
    <div class="book-cover-title" style="font-size: 18px;color: #333;top: 20px;">JavaScript Algorithms</div>
    <div class="book-cover-author">readbytes</div>
    <div class="book-cover-bottom-stripe" style="background-color: #333;"></div>
    <img class="book-cover-icon" style="width: 80px;height: 80px;top: 70px;" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFoAAABaCAYAAAA4qEECAAAErElEQVR4Xu2dPWgUQRiGo6BB8I+AlV3w9gzptLBWsLQ89O7ARrDXSivTCTaCnWhn7pQTxOoInpjCeEQQLC2CjVqoVSwMFpp1Jtzo7Luzs/Nd7uZ29r4HPpDsu7vPvIl7+SGTmRmGYRiGYZjCEzVacdnn9NX7+3DdXkGhMg+u3Su6SNztzsZvevH/efED8zrJbM+6EGJ2K5Hv9w9gRpHnXMyik2VsYVaHWJx7tt/bTOQ3urOYUch3QJ5z0YtOCeuQiqNlvybyto/ktbVDcG2jc5GLNgoriMW5Z/svPyfy693DmFHE71ePwrUznQta9ISeyViyKBIziri/Mpe8tt25kEXjMR1ScbQsPC5W5jCjMJT8DTM6MuO6vrHjIkIszj2LL3y2ktOPiy+Y0VE5l/V5IU+EVBwtm/wUzva4SL/wOZUsJ2993rCJEIujZJMl2174Up/C5T8u9LGtzyu6SNkH1+6VhUargkJlHVy7f5aW9qJUqeZy5zguufToBeAxZoRw0Z7goj3BRXuCi/YEF+0BvWQue0xgwfrMiy+aMM8QEUW+w2IHb8fC/+C5jCOGMhOPiqi+vG47zjiABVbr7XOYUWC2Um+fxwwDiKJeYXGYMYHniNnGDDPAUJZTyYph30nTg+G7f5VLj89gzBW8lu2xMzWIIt5iMZgZBrzmqK4bJFhENOLnatRsfcR7YKb0YAELF5+cwsyowHudrLcvYKZ0iIV+wIVjZhzgPaMR/+8pFIbFeilZUWm2Vyd5/5GxWOvsx4VkTbXROovn+wJdMqfevoHnFoKUaMbgeZMAnbIGzysEKGmZiX4DKKo/um5wMg6eWwhsgtVm62cRFoEOJg/xtltZxwqBTV4inuEHcZHztc4RzI0LvLeY15iRBF+0wrDgsX6qZXpUYEanNEVLROY3ZfHDgvdwuU+pipYs1h7OpUqI4z2YGxa8dqXefooZE6UrWoGFiMn8nRIXoubyTbymeLPzO7C0RUuiRvuXoRwyeI1hrlPqoiUnap1jWNLilU7mr0sgeK746rOFGRdKX7QCC4tyHiXi+DU8BzMUpqZoiSzXpTzMZOUoTFXROxh+xKV/gYPHqvVlp88q8pi+ogdgoabBc3bD1BYtEdfcxnLHeK/pLVoiHxvJktsPMDMKpr5oX3DRnuCiPcFFe4KL9gQX7Qku2hNctCe4aE94K1puD6mXNsmpOv74KUTnxEdmEQb9TOA5kx70M6KfcO/u8/j2nWffxb+XskZm9MHjw2YjgrTKygnFeUaF5cSEjZ4c9kJyz/Z7mxTpEJ0T0nhMhyRBy+5sTuXioAjR2UmaKEHJ/tsBLM9BJ0TnXGmiBCWb2GbN5oCE6GyVJkq4Z3FXxo3ubJaDiRCdM6VJErSscTtik0MWITobpYkS7lncKVfblREdbITonJImSVCyKAz7i1KkQ3ROSJMkaNnc7Ygp0iE6Z0pjTockjC8iBmEJRTpEZ6M0ZnRIwrhTrmU7Yop0iM4paTyusyvhnO2IKdIhOqdeWLLYlbDtL0oM/jaKi4MiRGcnaZIwPt8c/zZKnoNOiM4J6SIM+pnAcyY96GekYJtvf0I/EyE6MwzDMAzDjI+/5MPGam/zucIAAAAASUVORK5CYII="/>
  </div>
  <div class="download-info">
    <h2 id='bottom'>Download This Ebook</h2>
    <p class="format-label">Available formats:</p>
    <div class="download-buttons">
      <a href="javascript-algorithms.pdf" class="download-button">📄 PDF</a>
      <a href="javascript-algorithms.epub" class="download-button">📘 EPUB</a>
    </div>
  </div>
</section><div class='related-books'>
<h2>Javascript In-Depth Books</h2>
<div class='related-book-list'>
<a href="javascript-clean-code.htm">
<div class="book-cover" style="background-color: #f9f6f1;border: 1px solid #ccc;"> 
    <div class="book-cover-title" style="font-size: 18px;color: #333;top: 20px;">JavaScript Clean Code</div>
    <div class="book-cover-author">readbytes</div>
    <div class="book-cover-bottom-stripe" style="background-color: #333;"></div>
    <img class="book-cover-icon" style="width: 90px;height: 90px;top: 65px;" src='data:image/png;base64,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'/>
  </div>
</a>


<a href="javascript-coding-best-practices.htm">
<div class="book-cover" style="background-color: #f9f6f1;border: 1px solid #ccc;"> 
    <div class="book-cover-title" style="font-size: 16px;color: #333;top: 20px;">JavaScript Coding Best Practices</div>
    <div class="book-cover-author">readbytes</div>
    <div class="book-cover-bottom-stripe" style="background-color: #333;"></div>
    <img class="book-cover-icon" style="width: 80px;height: 80px;top: 80px;" src='data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFoAAABaCAYAAAA4qEECAAADdklEQVR4Xu2dPW/UMBjHH0QRlRA7MDDBgBAbH4ABNsRCQXwHFpAQQwVKws1IwMaXYO/M1I0VWEC8bIgy81LO53sS54l9OSe2G7f/n/S/c2zXefpT4g6nXIkAAADkQUFvqKR9JECUyw4lbXYmIqGyaYpWHXtNBwhCST8XbpcH2jyIQ+1XvRS0VQ+8opPzvrfLvDfayLpRDpmKbpMh+lw90N1jkCFhlNvFsXqxieb2Np2tx0A/EJ0IiE6Et2iOKVqOmQEa6aNXNLdxRfsB0YmA6ER4i+bYRMs5MoqK7nf6x6ai76KS6cG1Mr2iuW0TDdxAdCIgOhHeojku0XJejMQ41x063rvmGOQaa4jeXry7Rd+a/9yLqGFk/5g09T/vjKmUdK2eMwRv0dx2iQZ2IDoR3qI5q0Tv07HO/IPIlJA1BRGt/rDI+QeRKSFr6hXN7VWiQReIToS36JLOrxT9mk7QjK63YiLHQiQHBojWcYmW88wTyL5QyQFZa69obrtEAzsQnQiIToS3aI5LtJw3NGPX8//Zm/U5Y2DWpegVzW2XaGAHohMB0YnwFs2xiZZzYkSf50un35YpIWvqFc1tm+jHdDpqfM71iE615h80QUUDNxCdCG/RHJdoOW9IFPpzuu7YmHRrfFn3xUbWsIbob4t3t+hd0g/DDEtF75brbHTGxqap8ceyb6Pui423aG67RAM7EJ0Ib9ElfXSKruirV44SA0Tr2ETLOX05SsjfuVc0t22igRuITgREJ8JbNMcULcfMAI300Sua27ii/YDoREB0IrxFI+PSKxqEBaITAdGJaIlG4mfxUtA9qugGEiHKrSEaW0csstyjO7djBmQnWn9GqZ98bR5S2pXTJkeGopXYX/VxRXtZXNUt0TO6KMcnh9wu5PFUKehCI7qkv3J8krDcXCQrKvpjis6jaEVBVxfJhdpv+yo5I+eBgSiXrbuvOfgtpCPj0zgl/pJu9QA9CEvzpQTLL+uu6F9jHgSBfSq3LWa0Zbn0kTEp6G5b8lRQxYXYwviWBQ5Cygm51qGipJ2gcvTtuyO7Ae9roQi93qFBSXlKV2T3YJ7RZYi2EUNKjDWz5gldiiJFrTmbrw2WxNpPY62bLVrIZ9k9mpI+QbRJTBkx186OmDJirp0FJT2o99BUqeihLOPwo//hWVdGzBT0QZYBAAAA/AcQ1vXmtMbyGwAAAABJRU5ErkJggg=='/>
  </div>
</a>


<a href="javascript-asynchronous-programming.htm">
<div class="book-cover" style="background-color: #f9f6f1;border: 1px solid #ccc;"> 
    <div class="book-cover-title" style="font-size: 18px;color: #333;top: 20px;">JavaScript Asynchronous Programming</div>
    <div class="book-cover-author">readbytes</div>
    <div class="book-cover-bottom-stripe" style="background-color: #333;"></div>
    <img class="book-cover-icon" style="width: 80px;height: 80px;top: 80px;" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFoAAABaCAYAAAA4qEECAAADU0lEQVR4Xu2cvW7UQBRGkwKJV0CipqJbG9pIFLGXRyD2IgpeghegQ9DRUNHQUdLQUVFAC0h0tFEKkMJPCEykRHKObzZrr6/t8X5H+qrMN3PvUbQpEmVra8NI8vLfWWazh1f4ddEBVcmVPOA5sQZB6DND8mkWj3hetCQI/VAXXE3xhB3RkrrcWl6wI1qQZuUrQ+75ZOVr9kQL0mxxpya3nnfsiRbs7Ny/ashFiq/siZbU5Z7PLC9/sCNaQrlGfrIjWmLIxXd28Z0d0QKKvSCSvQ5pXr41pF6QxT77vRF+Or+vDzTdhJW36cAdDrEpoQdX+PgmhS482ebjmxTKcIMPb1roww0+vGmhDzf4MMPzY4fzL8tsd+8a+27w8Wp4Nga4w7Kw6wofr+Qzz8aAsYcZ9tzhAIMN0gFh7l/cwwp7vcAhBh1mDcLMf7iDFfZ6g4MMPlALwrzHnN/IMXu9YgwUlehktY+LI/Z6xxgqGtFhzgPObeQve4NgDBaF6Nl88YUzGxn246KKMVwUojlvPYtx/dqqPuD4RSeX/aXSvDxgZ3BqQ0YhunjOec+SzstvPD8KOGgMok/gvKf5xHOjwRg2CtEnVOdNs+Ipvz4qKDgm0VFBwRLtBAVLtBMULNFOULBEO0HBEu0EBUu0ExQs0U5QsEQ7QcES7QQFS7QTFCzRTlCwRDtBwRLtBAVLtBMULNFOULBEO0HBEu0EBUu0ExQs0U5QsEQ7QcES7QQFS7QTFCzRTlBw16LDXb897o0OCu5SSLjniPd2dXd0UEKXMnhn1/dHBQV0KYJ3Mjw/abh8lxJ4pxV2JgsX71oA77XCziTh0h7L824r7EwOLuy1OO+3ws6k4LKeSydZech3GHYmAxf1XniWl2/4FsPOJOCSfSyb5sVLvsewEz1csK9l+ZYVdqKGyzFpXj5O7hY3u0q6u5fxjWXhvNHCxcYYzhwlXGqM4cxRwqXGmPDxdci5o4SLjTGcOVq42JgSvqOH+8+4HtzO713nkmMI5xQrQpGXhX3RAMq8KOyJBtyalzco1Ap7ohkr/RtllkRDKNQKO6IhFGqFHdEQCrXCjmgIhVphRzSEQq2wIxpCoVbYES2gVIbnRUsoVpKdCEL3KViSnUjm5cepSf4Pt8Ix0I7hKy8AAAAASUVORK5CYII="/>
  </div>
</a>


<a href="javascript-pragmatic-developer.htm">
<div class="book-cover" style="background-color: #f9f6f1;border: 1px solid #ccc;"> 
    <div class="book-cover-title" style="font-size: 18px;color: #333;top: 20px;">JavaScript Pragmatic Developer</div>
    <div class="book-cover-author">readbytes</div>
    <div class="book-cover-bottom-stripe" style="background-color: #333;"></div>
    <img class="book-cover-icon" style="width: 80px;height: 70px;top: 85px;" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFoAAABaCAYAAAA4qEECAAAGkUlEQVR4Xu2de4hUVRzHlR5UYGm+epgkamahRGUgYkUkKFlIcmdnTFdNW52ZO491y1dp619ZaZpg+oeUYBgoWREZ1H9hkNJjBU0qaq1W21iNkqTWdG/zm+aMZ753zn2f253r+cDvn3vP+T0+np29Mwxrv34KhcIjmaacUYqf8LpTKvt/w+tuWJrMLajkqQm9SddwbcNRGuQCPxTed0qNmHn6KLzvBLb/kQceq4bfviIBG4LwOxDLk03mPeeiPXNnzjcGDBxSjXRC95QrEmiadhkvOUjRxLnec57y0XpeMsXwG0a6zhMV+lPjhXnLqmIIL2J4eNFec9YTTeEmR2SgpvU5BXTiWgpSTzThNG+6KVe0Ep1O5lbgnsjChq6HUyEiRHmJsqjZ6Ym4h4fVR8lMtJ/eQiXTpH9nJ8PPMFa52xYut81N9xc9vsR4ePIMU/jtLVSo0aMdX6ODKn6HsRJNVPKfx30MVt8qcE/kKJ3m8w5FeB7GLv/pntOW+eled/dJYVjtjQzUZNePJ3D2GmSLJio1/sC9BKuPgin0VMFXb6FQnFUc6EKC52Gc1Ni6fpuwRqvWerVItGhPpGAC7QhDNGFVo96p9ttXaFCTv5zoxnlN+B3IjehsIj8f9xOle531RJeesd/BtZHDjYCwRIvqZBL6rnqiS9dfxrWRIwgBTnBax+oXW8OKbmlpucapgOeya4UCnOC0TtfxLmGdhhXdlmob4lQAUTnVzZjHDtpX7/OTevT+3Rs/0W5ONFERXVeCCD2p3+SmxpnfzwhrNKxowo0EwqXs8keuBz85hGmErF/5kjD/JSWaYLIzTYVJmI+RTeR+pjWvvbgdt1ti9Q/Z8KK7u+yfo5GLssXR19eH22wp703mnsI+iYYXTeGV17fsrJGbn9uKS1xBObBHRkOLXv7k8gF+RAdJ57ed8RVNULM93T04d+hUfirOYn+MOIi2/Tw6DKxOM9Hwoglq+PtvfsDZQ6NymvuwL564iO78v071B3v3255mIhaiicqpQg/SoZp6Qp+C/SCxEU1Q4/kn/D2iucHJSwYjVqIJar7Y3IZOAof9BGF9EbETTch+GXErmYilaILJ6Lvg/q20CPbBfin+wnp2xFY0kU7ofUGc7o5DHdVT3P5g++VYxwmxFk1MmzK9Koliw5pN6FEIv2/x7BbXLxc8sRc94/5Hq18oTHPinMbIW8YG8hXb2IumYYgjR47WfIvz+iE3GtOnzjSJHT92Ys26awcNrTndmN8pl4xoZNnTK0xfoaUYOHi4ceDAp7hcibZDJNotSrQNdqKZQIr33nofb1dRom0QieYFY9R79laibagnenV6TXnIYcNHmF6jmVAkKNGmWnEWTdfuuvM+k2Qr2U5E05sZti6IWKq13ow1Igs1zHPs8LHyECiXj6mTHiqv4WHDY34e9qWe/fpW4wWtzbh7wuSaoOsYojWUJ5sqTMMakQWFbV63xVY0O9U8bkSfevZdY4e20pSTrmOI1jS86FfaX1WiZYDClGhJoDAlWhIoLAzRXyzbaWzWnjFGj7qjJug6hmiNEm1B+4L2q9i6IGLJnPxYrBFZqGEemaI5yl/5vW7QUFNeqxg3ZkK5RkErjMOEkQeFhSS6XNdJHazppkakQGFKtCRQWEiiKy8dw0x5rWL0qPHlGuqlw0Z00L8MM1pmDNaILNQwj0zR7PHu88rj3ZjS4xofdB1DtIbyqMc7AeoNC4cSLQkUpkRLAoUp0ZJAYUq0JFCYEi0JFKZESwKFKdGSQGFKtCRQmBItCRSmREsChSnRkkBhSrQkUJgSLQkUpkRLAoUp0ZJAYUq0JFCYEi0JFBaWaCuJSnTAoseNuK2ar3v1PpNkio8WbayuSd07Iz6i9+36bwgUi4H7nIhmf5AbZXoJyqOn9NuxRmShhvFv2NmJZlJxj51oIkjRmDvSWElDwbzonl9PmfZomnYl5keCEH185Z7GE60n9FkomolD2QtnLa57mjsOHnY8ONuP8twEy4G5Iw81veeNvTXyCDYQH19+9hUuK19PN+V6Ma8IP6JPrnqbSe6PeSNPOlWYiKfUKV5Ol59T7aVepCg1/49b2X6G9iLbT71IURriTxqkMLf2v+FD2B/c9js0y/FxfptJKh8bFz4fSL1I0XJPyxVsqHIkc8ab23cbG9duungtwKEzidyHfM51zauM3Us3GK2pItTL78C9saE04FmUm0nmd+G6ICgmi7eaapUi25wdjGsVCoWIfwEHsnr03kJ4IwAAAABJRU5ErkJggg=="/>
  </div>
</a>


<a href="javascript-algorithms.htm">
<div class="book-cover" style="background-color: #f9f6f1;border: 1px solid #ccc;"> 
    <div class="book-cover-title" style="font-size: 18px;color: #333;top: 20px;">JavaScript Algorithms</div>
    <div class="book-cover-author">readbytes</div>
    <div class="book-cover-bottom-stripe" style="background-color: #333;"></div>
    <img class="book-cover-icon" style="width: 80px;height: 80px;top: 70px;" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFoAAABaCAYAAAA4qEECAAAErElEQVR4Xu2dPWgUQRiGo6BB8I+AlV3w9gzptLBWsLQ89O7ARrDXSivTCTaCnWhn7pQTxOoInpjCeEQQLC2CjVqoVSwMFpp1Jtzo7Luzs/Nd7uZ29r4HPpDsu7vPvIl7+SGTmRmGYRiGYZjCEzVacdnn9NX7+3DdXkGhMg+u3Su6SNztzsZvevH/efED8zrJbM+6EGJ2K5Hv9w9gRpHnXMyik2VsYVaHWJx7tt/bTOQ3urOYUch3QJ5z0YtOCeuQiqNlvybyto/ktbVDcG2jc5GLNgoriMW5Z/svPyfy693DmFHE71ePwrUznQta9ISeyViyKBIziri/Mpe8tt25kEXjMR1ScbQsPC5W5jCjMJT8DTM6MuO6vrHjIkIszj2LL3y2ktOPiy+Y0VE5l/V5IU+EVBwtm/wUzva4SL/wOZUsJ2993rCJEIujZJMl2174Up/C5T8u9LGtzyu6SNkH1+6VhUargkJlHVy7f5aW9qJUqeZy5zguufToBeAxZoRw0Z7goj3BRXuCi/YEF+0BvWQue0xgwfrMiy+aMM8QEUW+w2IHb8fC/+C5jCOGMhOPiqi+vG47zjiABVbr7XOYUWC2Um+fxwwDiKJeYXGYMYHniNnGDDPAUJZTyYph30nTg+G7f5VLj89gzBW8lu2xMzWIIt5iMZgZBrzmqK4bJFhENOLnatRsfcR7YKb0YAELF5+cwsyowHudrLcvYKZ0iIV+wIVjZhzgPaMR/+8pFIbFeilZUWm2Vyd5/5GxWOvsx4VkTbXROovn+wJdMqfevoHnFoKUaMbgeZMAnbIGzysEKGmZiX4DKKo/um5wMg6eWwhsgtVm62cRFoEOJg/xtltZxwqBTV4inuEHcZHztc4RzI0LvLeY15iRBF+0wrDgsX6qZXpUYEanNEVLROY3ZfHDgvdwuU+pipYs1h7OpUqI4z2YGxa8dqXefooZE6UrWoGFiMn8nRIXoubyTbymeLPzO7C0RUuiRvuXoRwyeI1hrlPqoiUnap1jWNLilU7mr0sgeK746rOFGRdKX7QCC4tyHiXi+DU8BzMUpqZoiSzXpTzMZOUoTFXROxh+xKV/gYPHqvVlp88q8pi+ogdgoabBc3bD1BYtEdfcxnLHeK/pLVoiHxvJktsPMDMKpr5oX3DRnuCiPcFFe4KL9gQX7Qku2hNctCe4aE94K1puD6mXNsmpOv74KUTnxEdmEQb9TOA5kx70M6KfcO/u8/j2nWffxb+XskZm9MHjw2YjgrTKygnFeUaF5cSEjZ4c9kJyz/Z7mxTpEJ0T0nhMhyRBy+5sTuXioAjR2UmaKEHJ/tsBLM9BJ0TnXGmiBCWb2GbN5oCE6GyVJkq4Z3FXxo3ubJaDiRCdM6VJErSscTtik0MWITobpYkS7lncKVfblREdbITonJImSVCyKAz7i1KkQ3ROSJMkaNnc7Ygp0iE6Z0pjTockjC8iBmEJRTpEZ6M0ZnRIwrhTrmU7Yop0iM4paTyusyvhnO2IKdIhOqdeWLLYlbDtL0oM/jaKi4MiRGcnaZIwPt8c/zZKnoNOiM4J6SIM+pnAcyY96GekYJtvf0I/EyE6MwzDMAzDjI+/5MPGam/zucIAAAAASUVORK5CYII="/>
  </div>
</a>



<a href='javascript.htm'><div class='book-cover' style='background-color: #f9f6f1;color: #111111;border: 1px solid #ccc;display: flex;justify-content: center;align-items: center;text-align: center;'>More Javascript Books</div></a>
</div>
</div>
  </div>
  <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/prism.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
  
  <script>
    function copyCode(button) {
      const code = button.nextElementSibling.innerText;
      navigator.clipboard.writeText(code).then(() => {
        button.textContent = 'Copied!';
        setTimeout(() => { button.textContent = 'Copy'; }, 1500);
      });
    }
  </script>  
<div id="floatingLog" aria-live="polite" role="alert"></div>
<footer class="page-footer">
    <nav>
      <a href="https://readbytes.github.io">Home</a> | 
      Email:<script language="JavaScript" type="text/javascript">
var part1 = 'yinpeng';var part6 = '263';var part2 = Math.pow(2,6);var part3 = String.fromCharCode(part2);var part4 = 'hotmail dot com';var part5 = part1 + String.fromCharCode(part2) + part4;document.write(part1 + part6 + part3 + part4);
</script>
    </nav>
  <p>© 2025 — All rights reserved.</p>    
  </footer>

</body>
</html>