<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Java IO and NIO Java IO Fundamentals</title>
<link rel='shortcut icon' href='https://java2s.com/style/favicon.ico'>
<link href="https://fonts.googleapis.com/css2?family=Merriweather&display=swap" rel="stylesheet" />
<link href="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet" />


  <script>
  const mode = localStorage.getItem('mode') || 'light';
  document.documentElement.classList.add(`${mode}-mode`);
  </script>   
<style> 
html {
  scroll-behavior: smooth;
}

body {
  font-family: 'Merriweather', serif;
  margin: 0;
  padding: 2rem 1rem;
  font-size: 15px;
  line-height: 1.5;
  transition: background-color 0.3s, color 0.3s;
}

.container {
  max-width: 700px;
  margin: 0 auto;
  padding: 1rem 2rem;
  box-shadow: 0 0 15px rgba(0,0,0,0.1);
}

h1, h2, h3 {
  font-weight: 600;
  margin-top: 2.5rem;
  margin-bottom: 1rem;
  line-height: 1.2;
}

h1 { font-size: 1.8rem; }
h2 { font-size: 1.4rem; }
h3 { font-size: 1.2rem; }

table {
  width: 100%;
  border-collapse: collapse;
  font-family: sans-serif;
  font-size: 1em;
  margin: 1em 0;
}

th, td {
  padding: 0.6em 1em;
  text-align: left;
  border: 1px solid;
}

tr:nth-child(even) {
  background-color: inherit;
}

tr:hover {
  background-color: inherit;
}

a {
  text-decoration: none;
  transition: color 0.2s;
}

a:hover {
  text-decoration: underline;
}

code {
  color: #d35400;
}

.book-title-chapter {
  font-family: 'Merriweather', serif;
  font-size: 2rem;
  font-weight: bold;
  text-align: center;
  margin-bottom: 2rem;
  border-bottom: 2px solid;
  padding-bottom: 0.5rem;
}

.book-subtitle-chapter {
  text-align: center;
  font-size: 1rem;
  margin-top: -1rem;
  margin-bottom: 2rem;
}

.related-books {
  margin-top: 40px;
}

.related-book-list {
  display: flex;
  flex-wrap: wrap;
  gap: 20px;
}

    .book-cover {
      width: 130px;
      height: 180px;
      font-family: Arial, sans-serif;
      position: relative;
      overflow: hidden;      
      line-height: normal;
      box-shadow: 2px 2px 4px rgba(0,0,0,0.1);
    }
    .book-cover-bottom-stripe {
      position: absolute;
      bottom: 0;
      left: 0;
      height: 5px;
      width: 100%;
    }
    .book-cover-title {
      position: absolute;
      width: 100%;
      text-align: center;
      font-weight: bold;
    }
     
    .book-cover-icon {
      position: absolute;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      align-items: center;
      justify-content: center; 
    }

    .book-cover-author {
      position: absolute;
      bottom: 10px;
      width: 100%;
      text-align: center;
      font-size: 8px;
      color: #333;
    }

.page-footer {
  margin-top: 4rem;
  padding: 1rem 0;
  text-align: center;
  font-size: 0.85rem;
  border-top: 1px solid;
}

.chapter-navi-section {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding-bottom: 10px;
}

.nav-link {
  color: inherit;
  text-decoration: none;
  opacity: 0.5;
  transition: opacity 0.3s ease, text-decoration 0.3s ease;
}

.nav-link:hover {
  opacity: 0.9;
  text-decoration: underline;
}

.prev { text-align: left; }
.toc-link { text-align: center; }
.next { text-align: right; }

.download-section {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 2rem;
  padding: 2rem 1rem;
  max-width: 600px;
  margin: 3rem auto;
  border-radius: 12px;
  box-shadow: 0 4px 10px rgba(0,0,0,0.05);
}

.download-info h2 {
  margin: 0 0 0.5rem;
  font-size: 1.2rem;
}

.format-label {
  margin: 0 0 0.5rem;
  font-size: 0.95rem;
}

.download-buttons {
  display: flex;
  gap: 1rem;
}

.download-button {
  background-color: #4A90E2;
  color: white;
  padding: 0.5em 1.2em;
  border-radius: 25px;
  font-size: 0.95rem;
  text-decoration: none;
  transition: background-color 0.3s ease;
}

.download-button:hover {
  background-color: #357ABD;
}

.code-block {
  position: relative;
  margin-bottom: 1em;
}

.copy-button {
  background: transparent;
  color: white;
  position: absolute;
  top: 8px;
  right: 8px;
  border: none;
  padding: 4px 8px;
  font-size: 12px;
  border-radius: 4px;
  cursor: pointer;
  z-index: 1;
}

.copy-button:hover {
  background-color: #0056b3;
}

.snippet-container {
  overflow: hidden;
}

.snippet-header {
  padding: 0.75rem 1rem;
  cursor: pointer;
  font-size: 1rem;
    background-color: #eeeeee;
    color:  #111111; 
    border-radius: 8px;
    cursor: pointer;
    box-shadow: 0 4px 6px rgba(0,0,0,0.1);  
}

.snippet-body {
  display: none;
  font-family: monospace;
}

.snippet-container.open .snippet-body {
  display: block;
}

.CodeMirror {
  border: 2px solid #ccc;
  border-radius: 4px;
  resize: vertical;
}

/* === Light Mode === */
html.light-mode {
  background-color: #f8f7f5;
  color: #333;
}

html.light-mode .container {
  background: white;
}

html.light-mode .book-title-chapter {
  color: #2c3e50;
  border-color: #ccc;
}
html.light-mode .book-subtitle-chapter{
  color: #888;
}

html.light-mode .page-footer,
html.light-mode .series-name,
html.light-mode .book-subtitle,
html.light-mode .format-label {
  color: #888;
}

html.light-mode .related-books h2 {
  color: #333;
  border-bottom: 2px solid #eee;
}

html.light-mode .book-title {
  color: #fff;
}

html.light-mode .book-cover {
  border: 1px solid #ccc;
}

html.light-mode th {
  background-color: #f2f2f2;
}

html.light-mode tr:nth-child(even) {
  background-color: #fafafa;
}

html.light-mode tr:hover {
  background-color: #e6f7ff;
}

html.light-mode a,
html.light-mode .page-footer a {
  color: #000;
}

/* === Dark Mode === */
html.dark-mode {
  background-color: #181818;
  color: #e0e0e0;
}

html.dark-mode .container {
  background: #222;
}

html.dark-mode .book-title-chapter {
  color: #ddd;
  border-color: #444;
}

html.dark-mode .snippet-header {
    background-color: #333;
    color:  #ddd; 
}


html.dark-mode .book-subtitle-chapter,
html.dark-mode .page-footer,
html.dark-mode .series-name,
html.dark-mode .book-subtitle,
html.dark-mode .book-footer,
html.dark-mode .format-label {
  color: #aaa;
}

html.dark-mode .related-books h2 {
  color: #ddd;
  border-bottom: 2px solid #333;
}

html.dark-mode .book-title {
  color: #fff;
}

html.dark-mode .book-cover {
  border: 1px solid #555;
}

html.dark-mode th {
  background-color: #333;
  color: #fff;
}

html.dark-mode td {
  border-color: #444;
}

html.dark-mode tr:nth-child(even) {
  background-color: #2a2a2a;
}

html.dark-mode tr:hover {
  background-color: #2c3e50;
}

html.dark-mode a,
html.dark-mode .page-footer a {
  color: #eee;
}

    .dialog-backdrop {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: rgba(0,0,0,0.5);
      display: none;
      justify-content: center;
      align-items: center;
      z-index: 10;
    }

    .dialog {
      background: white;
      padding: 20px;
      width: 90vw;
      height: 80vh;
      border-radius: 8px;
      box-shadow: 0 0 20px rgba(0,0,0,0.3);
      display: flex;
      flex-direction: column;
    }
    .dialog-content {
      display: flex;
      flex: 1;
      gap: 20px;
      margin-top: 10px;
    }
    .dialog h2 {
      margin-top: 0;
    }

    .textarea_dialog {
      width: 50%;
      height: 100%;
      resize: none;
      font-family: monospace;
      font-size: 14px;
      padding: 10px;
      box-sizing: border-box;
      border: 1px solid #ccc;
    }

    .iframe_dialog {
      width: 50%;
      height: 100%;
      border: 1px solid #ccc;
    }
    .controls_dialog {
      display: flex;
      justify-content: space-between;
      margin-top: 10px;
    }    
    button { padding: 0.5em 1em; background: green; color: white; border: none; cursor: pointer; }
    button:hover { background: #1e7e34; }
    .result_iframe { width:99%; height:200px; margin-top: 1em;  resize: both;border:1px solid #ccc;}        
</style>
</head>
<body> 
  <div class="container">
    <div class = "chapter-navi-section">
<a href="java-io-and-nio-introduction-to-java-io-and-nio.htm" class="nav-button prev">‚Üê</a>
<a href='java-io-and-nio.htm#java-io-fundamentals' class="nav-button toc-link">Index</a>
<a href="java-io-and-nio-file-and-directory-operations.htm" class="nav-button next">‚Üí</a>
</div>

    <h1 class="book-title-chapter" id = 'top'>Java IO Fundamentals</h1>
    <h3 class="book-subtitle-chapter">Java IO and NIO</h3>   
    <!-- <h1 class ="chapter-title"></h1> -->
    <h2 id='byte-streams-vs-character-streams'>2.1 Byte Streams vs Character Streams</h2><p>Java IO provides two primary types of streams to handle input and output operations: <strong>byte streams</strong> and <strong>character streams</strong>. Understanding the distinction between these two is crucial for selecting the right tools when reading or writing data in a Java program.</p><h3 id="byte-streams">Byte Streams</h3><h4 id="definition">Definition</h4><p><strong>Byte streams</strong> are designed to handle <strong>raw binary data</strong> ‚Äî such as images, audio files, or serialized objects. These streams read and write <strong>8-bit bytes</strong>, making them suitable for any kind of binary input or output.</p><p>Java provides the following abstract base classes for byte streams:</p><ul>
 <li><code>InputStream</code> (for reading)</li>
 <li><code>OutputStream</code> (for writing)</li>
</ul><p>All byte stream classes in Java are derived from these.</p><h4 id="typical-use-cases">Typical Use Cases</h4><ul>
 <li>Reading and writing image files (e.g., <code>.jpg</code>, <code>.png</code>)</li>
 <li>Handling binary data from sockets or files</li>
 <li>Copying files regardless of their format</li>
</ul><h4 id="example-copying-a-binary-file-using-byte-streams">Example: Copying a Binary File Using Byte Streams</h4><div class="code-block"><button class="copy-button" onclick="copyCode(this)">üìã</button>
 <pre><code class="language-java">import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;

public class ByteStreamExample {
    public static void main(String[] args) {
        try (
            // Open input and output streams for binary file
            FileInputStream input = new FileInputStream("input.jpg");
            FileOutputStream output = new FileOutputStream("output.jpg");
        ) {
            int data;
            // Read and write one byte at a time
            while ((data = input.read()) != -1) {
                output.write(data);
            }
            System.out.println("File copied successfully using byte streams.");
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}</code></pre>
</div><p><strong>Explanation</strong>:</p><ul>
 <li>This example reads a <code>.jpg</code> file byte-by-byte and writes it to another file.</li>
 <li>It does not interpret the content ‚Äî just moves raw bytes.</li>
</ul><h3 id="character-streams">Character Streams</h3><h4 id="definition">Definition</h4><p><strong>Character streams</strong> are designed to handle <strong>text data</strong>, dealing with <strong>16-bit Unicode characters</strong>. These streams automatically handle character encoding and decoding, making them ideal for reading and writing text files.</p><p>Java provides the following abstract base classes for character streams:</p><ul>
 <li><code>Reader</code> (for reading characters)</li>
 <li><code>Writer</code> (for writing characters)</li>
</ul><p>These streams are encoding-aware and useful when working with text in any language.</p><h4 id="typical-use-cases">Typical Use Cases</h4><ul>
 <li>Reading and writing <code>.txt</code>, <code>.csv</code>, <code>.xml</code>, and other plain-text files</li>
 <li>Processing user input or log files</li>
 <li>Outputting human-readable reports</li>
</ul><h4 id="example-copying-a-text-file-using-character-streams">Example: Copying a Text File Using Character Streams</h4><div class="code-block"><button class="copy-button" onclick="copyCode(this)">üìã</button>
 <pre><code class="language-java">import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;

public class CharacterStreamExample {
    public static void main(String[] args) {
        try (
            // Open character streams for text file
            FileReader reader = new FileReader("input.txt");
            FileWriter writer = new FileWriter("output.txt");
        ) {
            int ch;
            // Read and write one character at a time
            while ((ch = reader.read()) != -1) {
                writer.write(ch);
            }
            System.out.println("File copied successfully using character streams.");
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}</code></pre>
</div><p><strong>Explanation</strong>:</p><ul>
 <li>This program copies text from <code>input.txt</code> to <code>output.txt</code> using character streams.</li>
 <li>It understands character encoding (e.g., UTF-8, UTF-16) and works well with international text.</li>
</ul><h3 id="key-differences-between-byte-streams-and-character-streams">Key Differences Between Byte Streams and Character Streams</h3><table>
 <thead>
  <tr>
   <th>Feature</th>
   <th>Byte Streams</th>
   <th>Character Streams</th>
  </tr>
 </thead>
 <tbody>
  <tr>
   <td>Base Classes</td>
   <td><code>InputStream</code> / <code>OutputStream</code></td>
   <td><code>Reader</code> / <code>Writer</code></td>
  </tr>
  <tr>
   <td>Data Type</td>
   <td>Bytes (8-bit)</td>
   <td>Characters (16-bit Unicode)</td>
  </tr>
  <tr>
   <td>Suitable For</td>
   <td>Binary data (images, files)</td>
   <td>Text data (logs, documents)</td>
  </tr>
  <tr>
   <td>Encoding Awareness</td>
   <td>Not aware of encoding</td>
   <td>Automatically handles encoding</td>
  </tr>
  <tr>
   <td>Performance (text)</td>
   <td>May corrupt text without encoding</td>
   <td>Ideal for reading/writing text</td>
  </tr>
  <tr>
   <td>Common Subclasses</td>
   <td><code>FileInputStream</code>, <code>BufferedInputStream</code></td>
   <td><code>FileReader</code>, <code>BufferedReader</code></td>
  </tr>
 </tbody>
</table><h3 id="when-to-use-which">When to Use Which</h3><ul>
 <li>Use <strong>byte streams</strong> when working with <strong>non-text data</strong> (e.g., media files, PDFs, serialized objects).</li>
 <li>Use <strong>character streams</strong> for <strong>text files</strong> or any situation where character encoding matters.</li>
</ul><p>For example:</p><ul>
 <li>Use <code>FileInputStream</code> to copy a binary <code>.pdf</code> file.</li>
 <li>Use <code>FileReader</code> to read a <code>.txt</code> file containing human-readable content.</li>
</ul><h3 id="recap">Recap</h3><p>Java‚Äôs stream architecture cleanly separates IO into <strong>byte streams</strong> and <strong>character streams</strong>, each tailored to specific types of data. Byte streams provide raw access to data, making them perfect for binary files, while character streams add encoding support, making them safer and more efficient for text.</p><p>By choosing the appropriate stream type, developers can avoid common bugs such as text corruption and improve the performance and maintainability of their applications. Understanding this distinction is a foundational skill for mastering Java IO.</p><div class = "chapter-navi-section">
<a href="#top" class="nav-button prev">‚Üë</a>
<a href='java-io-and-nio.htm#java-io-fundamentals' class="nav-button toc-link">Index</a>
<a href="#bottom" class="nav-button next">‚Üì</a>
</div>
<h2 id='inputstream-and-outputstream-classes'>2.2 InputStream and OutputStream Classes</h2><p>In Java‚Äôs IO system, the <code>InputStream</code> and <code>OutputStream</code> classes form the foundation for all <strong>byte stream</strong> input and output operations. They enable reading and writing of binary data, such as images, audio files, PDF documents, or raw network data.</p><p>These two abstract classes reside in the <code>java.io</code> package and define the core API for handling <strong>low-level byte IO</strong>. All other byte-based stream classes in Java either extend or decorate these two base classes.</p><h3 id="inputstream-reading-bytes-from-a-source">InputStream: Reading Bytes from a Source</h3><p><code>InputStream</code> is an <strong>abstract class</strong> that provides methods to read <strong>one byte at a time</strong>, or an array of bytes, from a source such as a file, socket, or byte array.</p><h4 id="key-methods">Key Methods</h4><table>
 <thead>
  <tr>
   <th>Method</th>
   <th>Description</th>
  </tr>
 </thead>
 <tbody>
  <tr>
   <td><code>int read()</code></td>
   <td>Reads one byte of data and returns it as an int (0‚Äì255), or <code>-1</code> if end of stream is reached.</td>
  </tr>
  <tr>
   <td><code>int read(byte[] b)</code></td>
   <td>Reads bytes into the provided array.</td>
  </tr>
  <tr>
   <td><code>int read(byte[] b, int off, int len)</code></td>
   <td>Reads up to <code>len</code> bytes into array <code>b</code>, starting at offset <code>off</code>.</td>
  </tr>
  <tr>
   <td><code>void close()</code></td>
   <td>Closes the stream and releases any resources.</td>
  </tr>
  <tr>
   <td><code>int available()</code></td>
   <td>Returns the number of bytes that can be read without blocking.</td>
  </tr>
 </tbody>
</table><h4 id="common-subclasses">Common Subclasses</h4><ul>
 <li><code>FileInputStream</code> ‚Äì Reads from a file.</li>
 <li><code>BufferedInputStream</code> ‚Äì Adds buffering to reduce IO calls.</li>
 <li><code>ByteArrayInputStream</code> ‚Äì Reads from a byte array.</li>
 <li><code>ObjectInputStream</code> ‚Äì Reads serialized Java objects.</li>
 <li><code>PipedInputStream</code> ‚Äì Reads from a connected PipedOutputStream (used in thread communication).</li>
</ul><h4 id="example-reading-bytes-from-a-file">Example: Reading Bytes from a File</h4><div class="code-block"><button class="copy-button" onclick="copyCode(this)">üìã</button>
 <pre><code class="language-java">import java.io.FileInputStream;
import java.io.IOException;

public class InputStreamExample {
    public static void main(String[] args) {
        try (FileInputStream fis = new FileInputStream("input.dat")) {
            int byteData;
            // Read one byte at a time until end of file
            while ((byteData = fis.read()) != -1) {
                System.out.print((char) byteData); // Print byte as character (for demo)
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}</code></pre>
</div><p><strong>Note</strong>: This approach works best for small files. For larger files, use buffered streams.</p><h3 id="outputstream-writing-bytes-to-a-destination">OutputStream: Writing Bytes to a Destination</h3><p><code>OutputStream</code> is the abstract superclass for all classes that <strong>write raw bytes</strong> to an output destination, such as a file, byte array, or network socket.</p><h4 id="key-methods">Key Methods</h4><table>
 <thead>
  <tr>
   <th>Method</th>
   <th>Description</th>
  </tr>
 </thead>
 <tbody>
  <tr>
   <td><code>void write(int b)</code></td>
   <td>Writes the specified byte (lower 8 bits of int).</td>
  </tr>
  <tr>
   <td><code>void write(byte[] b)</code></td>
   <td>Writes all bytes from the given array.</td>
  </tr>
  <tr>
   <td><code>void write(byte[] b, int off, int len)</code></td>
   <td>Writes <code>len</code> bytes from the array starting at offset <code>off</code>.</td>
  </tr>
  <tr>
   <td><code>void flush()</code></td>
   <td>Forces any buffered output bytes to be written out.</td>
  </tr>
  <tr>
   <td><code>void close()</code></td>
   <td>Closes the stream and releases resources.</td>
  </tr>
 </tbody>
</table><h3 id="common-subclasses">Common Subclasses</h3><ul>
 <li><code>FileOutputStream</code> ‚Äì Writes to a file.</li>
 <li><code>BufferedOutputStream</code> ‚Äì Adds buffering to improve performance.</li>
 <li><code>ByteArrayOutputStream</code> ‚Äì Writes to an internal byte array.</li>
 <li><code>ObjectOutputStream</code> ‚Äì Writes serialized objects.</li>
 <li><code>PipedOutputStream</code> ‚Äì Connects to a <code>PipedInputStream</code>.</li>
</ul><h3 id="example-writing-bytes-to-a-file">Example: Writing Bytes to a File</h3><div class="code-block"><button class="copy-button" onclick="copyCode(this)">üìã</button>
 <pre><code class="language-java">import java.io.FileOutputStream;
import java.io.IOException;

public class OutputStreamExample {
    public static void main(String[] args) {
        String message = "Hello, this is a test message!";
        try (FileOutputStream fos = new FileOutputStream("output.dat")) {
            // Convert the string to bytes and write to file
            fos.write(message.getBytes());
            System.out.println("Message written to file.");
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}</code></pre>
</div><p><strong>Explanation</strong>: <code>getBytes()</code> converts the string to a byte array, which is then written to the file.</p><h3 id="combining-inputstream-and-outputstream-file-copy-example">Combining InputStream and OutputStream: File Copy Example</h3><p>Here‚Äôs a practical example that demonstrates using both <code>InputStream</code> and <code>OutputStream</code> to <strong>copy the contents of a binary file</strong>.</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">üìã</button>
 <pre><code class="language-java">import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;

public class FileCopyExample {
    public static void main(String[] args) {
        try (
            FileInputStream input = new FileInputStream("source.dat");
            FileOutputStream output = new FileOutputStream("copy.dat");
        ) {
            byte[] buffer = new byte[1024]; // 1KB buffer
            int bytesRead;
            // Read from source and write to destination
            while ((bytesRead = input.read(buffer)) != -1) {
                output.write(buffer, 0, bytesRead);
            }
            System.out.println("File copied successfully.");
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}</code></pre>
</div><p><strong>Explanation</strong>:</p><ul>
 <li>The file is read in chunks (1KB at a time).</li>
 <li>Reduces the number of IO calls for better performance.</li>
 <li>The use of try-with-resources ensures streams are closed automatically.</li>
</ul><h3 id="best-practices-when-using-streams">Best Practices When Using Streams</h3><ul>
 <li><strong>Always close streams</strong>: Use try-with-resources to ensure automatic closing.</li>
 <li><strong>Buffer your streams</strong>: Use <code>BufferedInputStream</code> and <code>BufferedOutputStream</code> to reduce disk access.</li>
 <li><strong>Check for available bytes</strong>: Use <code>available()</code> carefully; it provides an estimate, not a guarantee.</li>
 <li><strong>Handle exceptions properly</strong>: Always catch <code>IOException</code> or let it propagate.</li>
</ul><h3 id="recap">Recap</h3><p><code>InputStream</code> and <code>OutputStream</code> are the backbone of Java‚Äôs byte stream IO system. They provide a flexible, low-level interface for reading and writing binary data across a variety of sources and destinations. By understanding these classes and their common subclasses, you gain the tools necessary to handle a wide range of IO tasks ‚Äî from simple file operations to complex network data processing. Mastering them sets the foundation for efficient, reliable IO handling in any Java application.</p><div class = "chapter-navi-section">
<a href="#top" class="nav-button prev">‚Üë</a>
<a href='java-io-and-nio.htm#java-io-fundamentals' class="nav-button toc-link">Index</a>
<a href="#bottom" class="nav-button next">‚Üì</a>
</div>
<h2 id='reader-and-writer-classes'>2.3 Reader and Writer Classes</h2><p>Java provides a distinct set of stream classes for <strong>character-based input and output</strong>, built around the <code>Reader</code> and <code>Writer</code> abstract classes. These classes were introduced to support <strong>Unicode</strong> and allow seamless handling of text data in a platform- and encoding-independent manner.</p><p>While <code>InputStream</code> and <code>OutputStream</code> are designed for <strong>byte-level</strong> operations, <code>Reader</code> and <code>Writer</code> operate at the <strong>character level</strong>, abstracting away byte-to-character conversions and making it easier to work with textual content.</p><h3 id="why-character-streams">Why Character Streams?</h3><p>Early Java IO relied solely on byte streams (<code>InputStream</code> and <code>OutputStream</code>). However, byte streams aren‚Äôt encoding-aware ‚Äî they deal with raw bytes, so developers had to manually convert bytes to characters, which led to common bugs and encoding issues.</p><p>To resolve this, the Java platform introduced <code>Reader</code> and <code>Writer</code>, which:</p><ul>
 <li>Automatically handle character encoding and decoding</li>
 <li>Simplify reading and writing Unicode-compliant text</li>
 <li>Improve code clarity when dealing with textual data</li>
</ul><h3 id="reader-class">Reader Class</h3><p><code>Reader</code> is an <strong>abstract base class</strong> for reading character streams. It reads <strong>16-bit Unicode characters</strong> from text sources such as files, memory, or network streams.</p><h4 id="key-methods">Key Methods</h4><table>
 <thead>
  <tr>
   <th>Method</th>
   <th>Description</th>
  </tr>
 </thead>
 <tbody>
  <tr>
   <td><code>int read()</code></td>
   <td>Reads a single character, returns -1 if end of stream.</td>
  </tr>
  <tr>
   <td><code>int read(char[] cbuf)</code></td>
   <td>Reads characters into an array.</td>
  </tr>
  <tr>
   <td><code>int read(char[] cbuf, int off, int len)</code></td>
   <td>Reads up to <code>len</code> characters into <code>cbuf</code> starting at <code>off</code>.</td>
  </tr>
  <tr>
   <td><code>void close()</code></td>
   <td>Closes the stream.</td>
  </tr>
  <tr>
   <td><code>boolean ready()</code></td>
   <td>Checks if the stream is ready to be read.</td>
  </tr>
 </tbody>
</table><h4 id="common-subclasses">Common Subclasses</h4><ul>
 <li><code>FileReader</code> ‚Äì Reads characters from a file.</li>
 <li><code>BufferedReader</code> ‚Äì Adds buffering and line-based reading.</li>
 <li><code>InputStreamReader</code> ‚Äì Bridges byte streams to character streams with encoding support.</li>
 <li><code>CharArrayReader</code> ‚Äì Reads from a character array.</li>
 <li><code>StringReader</code> ‚Äì Reads from a string.</li>
</ul><h3 id="writer-class">Writer Class</h3><p><code>Writer</code> is the <strong>abstract superclass</strong> for writing character streams. It writes characters, arrays, or strings to text destinations.</p><h4 id="key-methods">Key Methods</h4><table>
 <thead>
  <tr>
   <th>Method</th>
   <th>Description</th>
  </tr>
 </thead>
 <tbody>
  <tr>
   <td><code>void write(int c)</code></td>
   <td>Writes a single character.</td>
  </tr>
  <tr>
   <td><code>void write(char[] cbuf)</code></td>
   <td>Writes an array of characters.</td>
  </tr>
  <tr>
   <td><code>void write(String str)</code></td>
   <td>Writes a string.</td>
  </tr>
  <tr>
   <td><code>void flush()</code></td>
   <td>Flushes the stream (forces buffered data to be written).</td>
  </tr>
  <tr>
   <td><code>void close()</code></td>
   <td>Closes the stream.</td>
  </tr>
 </tbody>
</table><h4 id="common-subclasses">Common Subclasses</h4><ul>
 <li><code>FileWriter</code> ‚Äì Writes characters to a file.</li>
 <li><code>BufferedWriter</code> ‚Äì Buffers characters to improve performance.</li>
 <li><code>OutputStreamWriter</code> ‚Äì Converts characters into bytes using specified encoding.</li>
 <li><code>CharArrayWriter</code> ‚Äì Writes to a character array in memory.</li>
 <li><code>StringWriter</code> ‚Äì Writes to a string buffer.</li>
</ul><h3 id="example-1-reading-text-with-filereader-and-bufferedreader">Example 1: Reading Text with FileReader and BufferedReader</h3><div class="code-block"><button class="copy-button" onclick="copyCode(this)">üìã</button>
 <pre><code class="language-java">import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;

public class ReaderExample {
    public static void main(String[] args) {
        try (BufferedReader reader = new BufferedReader(new FileReader("example.txt"))) {
            String line;
            // Read line by line until end of file
            while ((line = reader.readLine()) != null) {
                System.out.println(line);
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}</code></pre>
</div><p><strong>Explanation</strong>:</p><ul>
 <li><code>BufferedReader</code> wraps <code>FileReader</code> to provide efficient, line-based reading.</li>
 <li>Ideal for reading text files in a readable and memory-efficient manner.</li>
</ul><h3 id="example-2-writing-text-with-filewriter-and-bufferedwriter">Example 2: Writing Text with FileWriter and BufferedWriter</h3><div class="code-block"><button class="copy-button" onclick="copyCode(this)">üìã</button>
 <pre><code class="language-java">import java.io.BufferedWriter;
import java.io.FileWriter;
import java.io.IOException;

public class WriterExample {
    public static void main(String[] args) {
        try (BufferedWriter writer = new BufferedWriter(new FileWriter("output.txt"))) {
            writer.write("Hello, world!");
            writer.newLine();
            writer.write("This was written using character streams.");
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}</code></pre>
</div><p><strong>Explanation</strong>:</p><ul>
 <li><code>BufferedWriter</code> improves performance by reducing direct disk writes.</li>
 <li><code>newLine()</code> writes the system-dependent line separator.</li>
</ul><h3 id="handling-character-encoding">Handling Character Encoding</h3><p>Character streams like <code>FileReader</code> and <code>FileWriter</code> use the platform's default encoding, which can vary. To specify an encoding (e.g., UTF-8), use <strong>bridging streams</strong> like <code>InputStreamReader</code> and <code>OutputStreamWriter</code>.</p><h4 id="example-reading-with-utf-8-encoding">Example: Reading with UTF-8 Encoding</h4><div class="code-block"><button class="copy-button" onclick="copyCode(this)">üìã</button>
 <pre><code class="language-java">import java.io.*;

public class UTF8ReadExample {
    public static void main(String[] args) {
        try (
            InputStreamReader isr = new InputStreamReader(new FileInputStream("utf8.txt"), "UTF-8");
            BufferedReader reader = new BufferedReader(isr)
        ) {
            String line;
            while ((line = reader.readLine()) != null) {
                System.out.println(line);
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}</code></pre>
</div><h4 id="example-writing-with-utf-8-encoding">Example: Writing with UTF-8 Encoding</h4><div class="code-block"><button class="copy-button" onclick="copyCode(this)">üìã</button>
 <pre><code class="language-java">import java.io.*;

public class UTF8WriteExample {
    public static void main(String[] args) {
        try (
            OutputStreamWriter osw = new OutputStreamWriter(new FileOutputStream("utf8-output.txt"), "UTF-8");
            BufferedWriter writer = new BufferedWriter(osw)
        ) {
            writer.write("„Åì„Çì„Å´„Å°„ÅØ„ÄÅ‰∏ñÁïåÔºÅ"); // Japanese: "Hello, World!"
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}</code></pre>
</div><p><strong>Note</strong>: Always specify character encoding explicitly for portable, correct international text handling.</p><h3 id="key-differences-between-byte-and-character-streams">Key Differences Between Byte and Character Streams</h3><table>
 <thead>
  <tr>
   <th>Feature</th>
   <th>Byte Streams (<code>InputStream</code>/<code>OutputStream</code>)</th>
   <th>Character Streams (<code>Reader</code>/<code>Writer</code>)</th>
  </tr>
 </thead>
 <tbody>
  <tr>
   <td>Data Type</td>
   <td>Bytes (8-bit)</td>
   <td>Characters (16-bit Unicode)</td>
  </tr>
  <tr>
   <td>Encoding Awareness</td>
   <td>Not aware</td>
   <td>Handles character encoding/decoding</td>
  </tr>
  <tr>
   <td>Best For</td>
   <td>Binary files (images, audio, PDFs)</td>
   <td>Text files, source code, logs, CSVs</td>
  </tr>
  <tr>
   <td>Example Classes</td>
   <td><code>FileInputStream</code>, <code>BufferedOutputStream</code></td>
   <td><code>BufferedReader</code>, <code>FileWriter</code>, <code>PrintWriter</code></td>
  </tr>
 </tbody>
</table><h3 id="recap">Recap</h3><p>The <code>Reader</code> and <code>Writer</code> classes bring structure and clarity to handling character data in Java. They solve the encoding challenges present in byte streams and allow developers to work naturally with Unicode and multi-language text. By choosing character streams over byte streams for text-based operations, Java developers can write more robust, maintainable, and internationalization-friendly code.</p><div class = "chapter-navi-section">
<a href="#top" class="nav-button prev">‚Üë</a>
<a href='java-io-and-nio.htm#java-io-fundamentals' class="nav-button toc-link">Index</a>
<a href="#bottom" class="nav-button next">‚Üì</a>
</div>
<h2 id='file-handling-basics'>2.4 File Handling Basics</h2><p>When working with files and directories in Java, the primary tool is the <code>java.io.File</code> class. Unlike input/output stream classes, <code>File</code> does not handle reading or writing the contents of a file‚Äîit <strong>represents the abstract path</strong> of a file or directory in the file system and allows you to <strong>manipulate metadata and perform file-level operations</strong> such as creating, deleting, renaming, or checking properties.</p><h3 id="understanding-the-file-class">Understanding the <code>File</code> Class</h3><p>The <code>File</code> class represents both files and directories. It is used to:</p><ul>
 <li>Check if a file or directory exists</li>
 <li>Create new files or directories</li>
 <li>Delete or rename files/directories</li>
 <li>Get file metadata (e.g., size, path, permissions)</li>
</ul><p>To use it, you simply create an instance of <code>File</code> by passing a pathname (as a <code>String</code> or <code>Path</code>):</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">‚ñØ</button>
 <pre><code class="language-Java">import java.io.File;

File myFile = new File("example.txt");</code></pre>
</div><p>This line does <strong>not</strong> create a physical file. It only creates a representation of the path. The actual file operations require calling methods on the <code>File</code> object.</p><h3 id="creating-files-and-directories">Creating Files and Directories</h3><p>To create a <strong>new empty file</strong>, use the <code>createNewFile()</code> method:</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">üìã</button>
 <pre><code class="language-java">import java.io.File;
import java.io.IOException;

public class CreateFileExample {
    public static void main(String[] args) {
        File file = new File("sample.txt");
        try {
            if (file.createNewFile()) {
                System.out.println("File created: " + file.getName());
            } else {
                System.out.println("File already exists.");
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}</code></pre>
</div><ul>
 <li><code>createNewFile()</code> returns <code>true</code> if the file was created, <code>false</code> if it already exists.</li>
 <li>It throws an <code>IOException</code> if an error occurs (e.g., permissions issue).</li>
</ul><p>To create a <strong>directory</strong>, use <code>mkdir()</code>:</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">‚ñØ</button>
 <pre><code class="language-Java">File dir = new File("myFolder");
if (dir.mkdir()) {
    System.out.println("Directory created.");
} else {
    System.out.println("Failed to create directory.");
}</code></pre>
</div><p>To create <strong>nested directories</strong>, use <code>mkdirs()</code>:</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">‚ñØ</button>
 <pre><code class="language-Java">File nestedDir = new File("parent/child/grandchild");
nestedDir.mkdirs();  // creates all intermediate directories if needed</code></pre>
</div><h3 id="deleting-files-and-directories">Deleting Files and Directories</h3><p>To delete a file or empty directory, use the <code>delete()</code> method:</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">‚ñØ</button>
 <pre><code class="language-Java">File file = new File("sample.txt");
if (file.delete()) {
    System.out.println("Deleted the file: " + file.getName());
} else {
    System.out.println("Failed to delete the file.");
}</code></pre>
</div><p><strong>Important</strong>:</p><ul>
 <li><code>delete()</code> does <strong>not</strong> delete non-empty directories.</li>
 <li>There‚Äôs no built-in Java method to recursively delete directories in the <code>File</code> class; this must be implemented manually or by using <code>java.nio.file.Files</code>.</li>
</ul><h3 id="renaming-and-moving-files">Renaming and Moving Files</h3><p>To rename or move a file, use <code>renameTo()</code>:</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">‚ñØ</button>
 <pre><code class="language-Java">File oldFile = new File("sample.txt");
File newFile = new File("renamed.txt");

if (oldFile.renameTo(newFile)) {
    System.out.println("File renamed successfully.");
} else {
    System.out.println("Rename failed.");
}</code></pre>
</div><p><strong>Note</strong>: This method can also move a file to a different directory.</p><h3 id="checking-file-properties">Checking File Properties</h3><p>The <code>File</code> class provides several methods to inspect the file or directory:</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">üìã</button>
 <pre><code class="language-java">import java.io.File;

public class Test {

    public static void main(String[] argv) throws Exception {
        File file = new File("example.txt");

        System.out.println("File name: " + file.getName());
        System.out.println("Absolute path: " + file.getAbsolutePath());
        System.out.println("Parent: " + file.getParent());

        System.out.println("Exists: " + file.exists());
        System.out.println("Is directory: " + file.isDirectory());
        System.out.println("Is file: " + file.isFile());
        System.out.println("Readable: " + file.canRead());
        System.out.println("Writable: " + file.canWrite());
        System.out.println("Executable: " + file.canExecute());
        System.out.println("File size (bytes): " + file.length());
    }
}</code></pre>
</div><p>These methods allow you to verify if a file exists, distinguish between files and directories, and check permissions.</p><h3 id="listing-files-and-directories">Listing Files and Directories</h3><p>To list files inside a directory, use <code>list()</code> or <code>listFiles()</code>:</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">üìã</button>
 <pre><code class="language-java">import java.io.File;

public class Test {

    public static void main(String[] argv) throws Exception {
        File directory = new File("myFolder");

        if (directory.isDirectory()) {
            String[] fileNames = directory.list();
            for (String name : fileNames) {
                System.out.println(name);
            }
        }
    }
}</code></pre>
</div><p>Or get <code>File</code> objects:</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">üìã</button>
 <pre><code class="language-java">import java.io.File;

public class Test {

    public static void main(String[] argv) throws Exception {
        File directory = new File("myFolder");
        File[] files = directory.listFiles();
        for (File f : files) {
            System.out.println(f.getName() + (f.isDirectory() ? " (dir)" : " (file)"));
        }
    }
}</code></pre>
</div><h3 id="working-with-absolute-and-relative-paths">Working with Absolute and Relative Paths</h3><ul>
 <li>A <strong>relative path</strong> is relative to the program's working directory.</li>
 <li>An <strong>absolute path</strong> provides the full file location in the file system.</li>
</ul><div class="code-block"><button class="copy-button" onclick="copyCode(this)">üìã</button>
 <pre><code class="language-java">import java.io.File;

public class Test {

    public static void main(String[] argv) throws Exception {
        File relative = new File("sample.txt");
        File absolute = new File("/home/user/docs/sample.txt");

        System.out.println("Relative path: " + relative.getPath());
        System.out.println("Absolute path: " + absolute.getAbsolutePath());
    }
}</code></pre>
</div><h3 id="summary-of-common-file-methods">Summary of Common <code>File</code> Methods</h3><table>
 <thead>
  <tr>
   <th>Method</th>
   <th>Purpose</th>
  </tr>
 </thead>
 <tbody>
  <tr>
   <td><code>createNewFile()</code></td>
   <td>Creates a new file</td>
  </tr>
  <tr>
   <td><code>mkdir()</code> / <code>mkdirs()</code></td>
   <td>Creates directories</td>
  </tr>
  <tr>
   <td><code>delete()</code></td>
   <td>Deletes a file or empty directory</td>
  </tr>
  <tr>
   <td><code>renameTo(File)</code></td>
   <td>Renames or moves a file</td>
  </tr>
  <tr>
   <td><code>exists()</code></td>
   <td>Checks existence</td>
  </tr>
  <tr>
   <td><code>isFile()</code> / <code>isDirectory()</code></td>
   <td>Checks file type</td>
  </tr>
  <tr>
   <td><code>canRead()</code> / <code>canWrite()</code> / <code>canExecute()</code></td>
   <td>Checks permissions</td>
  </tr>
  <tr>
   <td><code>length()</code></td>
   <td>Gets file size in bytes</td>
  </tr>
  <tr>
   <td><code>list()</code> / <code>listFiles()</code></td>
   <td>Lists files in a directory</td>
  </tr>
 </tbody>
</table><h3 id="recap">Recap</h3><p>The <code>File</code> class in Java IO provides powerful tools to interact with the file system, enabling developers to create, delete, inspect, and manipulate files and directories. Although it doesn't handle file content, it is essential for managing file paths and metadata. For actual content processing, <code>Reader</code>/<code>Writer</code> or <code>InputStream</code>/<code>OutputStream</code> classes are used in conjunction. Mastering the <code>File</code> class sets the foundation for reliable and efficient file handling in Java applications.</p><div class = "chapter-navi-section">
<a href="#top" class="nav-button prev">‚Üë</a>
<a href='java-io-and-nio.htm#java-io-fundamentals' class="nav-button toc-link">Index</a>
<a href="#bottom" class="nav-button next">‚Üì</a>
</div>
<h2 id='buffered-streams-and-their-importance'>2.5 Buffered Streams and Their Importance</h2><p>In Java IO, reading and writing data directly to and from a source (like a file or socket) using unbuffered streams (e.g., <code>FileInputStream</code>, <code>FileOutputStream</code>) can be inefficient, especially when data is processed byte-by-byte or character-by-character. Buffered streams were introduced to solve this performance issue by <strong>minimizing the number of expensive disk or network access operations</strong> through the use of an in-memory buffer.</p><h3 id="what-is-buffering-in-io">What is Buffering in IO?</h3><p><strong>Buffering</strong> refers to the technique of using a temporary memory area‚Äîa buffer‚Äîto store data before it's read or written. Instead of performing a system-level read/write operation for every byte or character, a buffered stream:</p><ul>
 <li>Reads larger blocks of data into memory at once (for input)</li>
 <li>Writes larger blocks of data to the destination in one go (for output)</li>
</ul><p>This <strong>reduces the number of IO operations</strong>, improving performance dramatically.</p><h3 id="buffered-streams-in-java">Buffered Streams in Java</h3><p>Java provides four main buffered stream classes:</p><table>
 <thead>
  <tr>
   <th>Buffered Stream Class</th>
   <th>Base Class</th>
   <th>Type</th>
  </tr>
 </thead>
 <tbody>
  <tr>
   <td><code>BufferedInputStream</code></td>
   <td><code>InputStream</code></td>
   <td>Byte-based input</td>
  </tr>
  <tr>
   <td><code>BufferedOutputStream</code></td>
   <td><code>OutputStream</code></td>
   <td>Byte-based output</td>
  </tr>
  <tr>
   <td><code>BufferedReader</code></td>
   <td><code>Reader</code></td>
   <td>Character-based input</td>
  </tr>
  <tr>
   <td><code>BufferedWriter</code></td>
   <td><code>Writer</code></td>
   <td>Character-based output</td>
  </tr>
 </tbody>
</table><h3 id="how-bufferedinputstream-works">How BufferedInputStream Works</h3><p><code>BufferedInputStream</code> wraps an existing <code>InputStream</code> and reads a block of bytes (default 8192 bytes) into an internal buffer. When your program reads from the stream, it accesses data from the buffer, not the file or socket directly‚Äîunless the buffer is empty.</p><h4 id="example-reading-a-file-efficiently">Example: Reading a File Efficiently</h4><div class="code-block"><button class="copy-button" onclick="copyCode(this)">üìã</button>
 <pre><code class="language-java">import java.io.*;

public class BufferedInputExample {
    public static void main(String[] args) {
        try (
            FileInputStream fis = new FileInputStream("input.txt");
            BufferedInputStream bis = new BufferedInputStream(fis)
        ) {
            int byteData;
            while ((byteData = bis.read()) != -1) {
                System.out.print((char) byteData); // Convert byte to char
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}</code></pre>
</div><p><strong>Why it's efficient</strong>: Instead of one disk read per byte, a chunk of data is loaded at once, then served byte-by-byte from memory.</p><h3 id="how-bufferedoutputstream-works">How BufferedOutputStream Works</h3><p><code>BufferedOutputStream</code> collects bytes in a memory buffer and writes them in chunks. This avoids frequent, slow writes to disk or a network stream.</p><h4 id="example-writing-to-a-file-efficiently">Example: Writing to a File Efficiently</h4><div class="code-block"><button class="copy-button" onclick="copyCode(this)">üìã</button>
 <pre><code class="language-java">import java.io.*;

public class BufferedOutputExample {
    public static void main(String[] args) {
        try (
            FileOutputStream fos = new FileOutputStream("output.txt");
            BufferedOutputStream bos = new BufferedOutputStream(fos)
        ) {
            String message = "Buffered output stream example in Java.";
            bos.write(message.getBytes());
            bos.flush(); // Ensure data is written from buffer to file
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}</code></pre>
</div><p><strong>Important</strong>: Always call <code>flush()</code> before closing to ensure remaining data in the buffer is written.</p><h3 id="how-bufferedreader-works">How BufferedReader Works</h3><p><code>BufferedReader</code> reads characters efficiently by wrapping a <code>Reader</code> (e.g., <code>FileReader</code> or <code>InputStreamReader</code>). It also provides <strong>convenient methods like <code>readLine()</code></strong>, which are not available in unbuffered readers.</p><h4 id="example-reading-text-line-by-line">Example: Reading Text Line-by-Line</h4><div class="code-block"><button class="copy-button" onclick="copyCode(this)">üìã</button>
 <pre><code class="language-java">import java.io.*;

public class BufferedReaderExample {
    public static void main(String[] args) {
        try (
            BufferedReader reader = new BufferedReader(new FileReader("notes.txt"))
        ) {
            String line;
            while ((line = reader.readLine()) != null) {
                System.out.println(line); // Print each line of the file
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}</code></pre>
</div><p><strong>Benefits</strong>:</p><ul>
 <li>Efficient reading of characters, arrays, or lines.</li>
 <li>Less overhead than reading character-by-character.</li>
</ul><h3 id="how-bufferedwriter-works">How BufferedWriter Works</h3><p><code>BufferedWriter</code> buffers character data and writes it in bulk. It also includes a <code>newLine()</code> method to write platform-specific line separators.</p><h4 id="example-writing-text-with-bufferedwriter">Example: Writing Text with BufferedWriter</h4><div class="code-block"><button class="copy-button" onclick="copyCode(this)">üìã</button>
 <pre><code class="language-java">import java.io.*;

public class BufferedWriterExample {
    public static void main(String[] args) {
        try (
            BufferedWriter writer = new BufferedWriter(new FileWriter("log.txt"))
        ) {
            writer.write("BufferedWriter is efficient for writing text.");
            writer.newLine();
            writer.write("It reduces the number of write operations.");
            writer.flush(); // Push remaining data to file
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}</code></pre>
</div><p><strong>Note</strong>: Like <code>BufferedOutputStream</code>, always flush the writer to avoid data loss.</p><h3 id="when-to-use-buffered-streams">When to Use Buffered Streams</h3><p>Buffered streams are especially useful when:</p><ul>
 <li>Working with large files</li>
 <li>Reading/writing data over slow IO channels (e.g., network)</li>
 <li>Processing structured text (like log files or CSVs)</li>
 <li>You need to minimize the overhead of IO operations</li>
</ul><h3 id="default-buffer-size-and-customization">Default Buffer Size and Customization</h3><p>By default, Java uses an <strong>8 KB (8192 bytes)</strong> buffer for buffered streams. You can specify a different size:</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">üìã</button>
 <pre><code class="language-java">import java.io.BufferedInputStream;
import java.io.FileInputStream;

public class Test {

    public static void main(String[] argv) throws Exception {
        BufferedInputStream bis = new BufferedInputStream(new FileInputStream("data.bin"), 16384); // 16 KB buffer
    }
}</code></pre>
</div><p>Custom buffer sizes can optimize performance depending on the data volume and system architecture.</p><h3 id="recap">Recap</h3><p>Buffered streams in Java are vital for <strong>efficient IO performance</strong>. By reading and writing data in blocks rather than byte-by-byte or character-by-character, they reduce the number of costly interactions with the file system or network. Whether you're dealing with binary or text data, buffered streams offer higher speed, lower latency, and improved application responsiveness. As a best practice, always prefer buffered streams unless working with very small data or special cases where buffering is unnecessary.</p><div class = "chapter-navi-section">
<a href="#top" class="nav-button prev">‚Üë</a>
<a href='java-io-and-nio.htm#java-io-fundamentals' class="nav-button toc-link">Index</a>
<a href="#bottom" class="nav-button next">‚Üì</a>
</div>
<h2 id='data-streams-for-primitive-types'>2.6 Data Streams for Primitive Types</h2><p>Java‚Äôs standard input and output streams (<code>InputStream</code> and <code>OutputStream</code>) operate at the byte level and lack the ability to directly read or write <strong>Java primitive data types</strong> (like <code>int</code>, <code>float</code>, or <code>boolean</code>). To bridge this gap, Java provides <strong>data streams</strong>, specifically <code>DataInputStream</code> and <code>DataOutputStream</code>, which enable applications to read and write <strong>Java primitives and strings in a platform-independent and efficient way</strong>.</p><h3 id="why-use-data-streams">Why Use Data Streams?</h3><p>Data streams offer:</p><ul>
 <li><strong>Direct support for Java primitive types</strong>: <code>int</code>, <code>float</code>, <code>long</code>, <code>boolean</code>, <code>double</code>, etc.</li>
 <li><strong>Platform independence</strong>: Data is written and read in a machine-neutral format.</li>
 <li><strong>Tight integration with <code>InputStream</code>/<code>OutputStream</code></strong>: These classes wrap around byte streams, extending their capabilities.</li>
</ul><p>This makes them ideal for saving and restoring structured binary data in a format that can later be decoded accurately‚Äîwithout manual byte parsing.</p><h3 id="dataoutputstream">DataOutputStream</h3><p><code>DataOutputStream</code> extends <code>FilterOutputStream</code> and provides methods to write Java primitives in a standardized binary format.</p><h4 id="key-methods">Key Methods</h4><table>
 <thead>
  <tr>
   <th>Method</th>
   <th>Description</th>
  </tr>
 </thead>
 <tbody>
  <tr>
   <td><code>writeInt(int v)</code></td>
   <td>Writes 4 bytes for an int</td>
  </tr>
  <tr>
   <td><code>writeDouble(double v)</code></td>
   <td>Writes 8 bytes for a double</td>
  </tr>
  <tr>
   <td><code>writeBoolean(boolean v)</code></td>
   <td>Writes 1 byte (<code>0</code> or <code>1</code>)</td>
  </tr>
  <tr>
   <td><code>writeUTF(String s)</code></td>
   <td>Writes a string in modified UTF-8 format</td>
  </tr>
  <tr>
   <td><code>writeChar(int v)</code></td>
   <td>Writes 2 bytes for a char</td>
  </tr>
 </tbody>
</table><h4 id="constructor">Constructor</h4><div class="code-block"><button class="copy-button" onclick="copyCode(this)">‚ñØ</button>
 <pre><code class="language-Java">DataOutputStream dos = new DataOutputStream(new FileOutputStream("data.bin"));</code></pre>
</div><h3 id="datainputstream">DataInputStream</h3><p><code>DataInputStream</code> extends <code>FilterInputStream</code> and complements <code>DataOutputStream</code> by reading data in the same format it was written.</p><h4 id="key-methods">Key Methods</h4><table>
 <thead>
  <tr>
   <th>Method</th>
   <th>Description</th>
  </tr>
 </thead>
 <tbody>
  <tr>
   <td><code>readInt()</code></td>
   <td>Reads 4 bytes and returns an int</td>
  </tr>
  <tr>
   <td><code>readDouble()</code></td>
   <td>Reads 8 bytes and returns a double</td>
  </tr>
  <tr>
   <td><code>readBoolean()</code></td>
   <td>Reads 1 byte and returns boolean</td>
  </tr>
  <tr>
   <td><code>readUTF()</code></td>
   <td>Reads a string in modified UTF-8</td>
  </tr>
  <tr>
   <td><code>readChar()</code></td>
   <td>Reads 2 bytes and returns a char</td>
  </tr>
 </tbody>
</table><h4 id="constructor">Constructor</h4><div class="code-block"><button class="copy-button" onclick="copyCode(this)">‚ñØ</button>
 <pre><code class="language-java">DataInputStream dis = new DataInputStream(new FileInputStream("data.bin"));</code></pre>
</div><p><strong>Important</strong>: The order in which you read data <strong>must exactly match</strong> the order it was written.</p><h3 id="example-writing-primitive-data-using-dataoutputstream">Example: Writing Primitive Data Using DataOutputStream</h3><div class="code-block"><button class="copy-button" onclick="copyCode(this)">üìã</button>
 <pre><code class="language-java">import java.io.*;

public class DataOutputExample {
    public static void main(String[] args) {
        try (DataOutputStream dos = new DataOutputStream(new FileOutputStream("data.bin"))) {
            dos.writeInt(42);             // 4 bytes
            dos.writeDouble(3.14159);     // 8 bytes
            dos.writeBoolean(true);       // 1 byte
            dos.writeUTF("Hello, Java");  // String with length prefix
            dos.writeChar('J');           // 2 bytes
            System.out.println("Data written to file.");
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}</code></pre>
</div><p><strong>Explanation</strong>:</p><ul>
 <li>Each method writes the respective primitive in a binary format.</li>
 <li><code>writeUTF</code> prepends the string with its length in bytes, encoded in modified UTF-8.</li>
</ul><h3 id="example-reading-primitive-data-using-datainputstream">Example: Reading Primitive Data Using DataInputStream</h3><div class="code-block"><button class="copy-button" onclick="copyCode(this)">üìã</button>
 <pre><code class="language-java">import java.io.*;

public class DataInputExample {
    public static void main(String[] args) {
        try (DataInputStream dis = new DataInputStream(new FileInputStream("data.bin"))) {
            int intValue = dis.readInt();
            double doubleValue = dis.readDouble();
            boolean boolValue = dis.readBoolean();
            String strValue = dis.readUTF();
            char charValue = dis.readChar();

            System.out.println("Read values:");
            System.out.println("Int: " + intValue);
            System.out.println("Double: " + doubleValue);
            System.out.println("Boolean: " + boolValue);
            System.out.println("String: " + strValue);
            System.out.println("Char: " + charValue);
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}</code></pre>
</div><p><strong>Explanation</strong>:</p><ul>
 <li>Values are read back in <strong>exactly the same order and format</strong> they were written.</li>
 <li>Mismatching read/write order will result in corrupt data or exceptions (e.g., <code>EOFException</code>).</li>
</ul><h3 id="common-use-cases">Common Use Cases</h3><ul>
 <li><strong>Saving structured data</strong>: Such as game state, user settings, or application configuration in binary form.</li>
 <li><strong>Reading/writing binary protocols</strong>: When interacting with custom or third-party binary data formats.</li>
 <li><strong>Socket programming</strong>: To send and receive primitive values over network streams efficiently.</li>
</ul><h3 id="handling-exceptions">Handling Exceptions</h3><p>Data streams can throw several checked exceptions:</p><ul>
 <li><code>IOException</code>: General IO issues (file not found, access denied, etc.).</li>
 <li><code>EOFException</code>: Reached the end of file unexpectedly while reading.</li>
</ul><p>Always wrap stream operations in <code>try-with-resources</code> to ensure automatic resource management.</p><h3 id="important-considerations">Important Considerations</h3><ul>
 <li>Data written with <code>DataOutputStream</code> can only be reliably read with <code>DataInputStream</code> (or a decoder that understands the format).</li>
 <li><code>writeUTF()</code> is <strong>not suitable</strong> for storing very large strings (limit: 65,535 bytes).</li>
 <li>For <strong>textual data</strong>, prefer character streams (e.g., <code>BufferedReader</code>, <code>BufferedWriter</code>) unless binary encoding is required.</li>
</ul><h3 id="recap">Recap</h3><p><code>DataInputStream</code> and <code>DataOutputStream</code> are powerful tools for binary IO in Java. They eliminate the complexity of manually converting primitives to and from byte arrays, ensuring accurate and portable storage of Java‚Äôs basic data types. Whether you're building a low-level file format or communicating over sockets, data streams provide a clean, efficient, and consistent way to serialize and deserialize primitive values.</p><div class = "chapter-navi-section">
<a href="java-io-and-nio-introduction-to-java-io-and-nio.htm" class="nav-button prev">‚Üê</a>
<a href='java-io-and-nio.htm#java-io-fundamentals' class="nav-button toc-link">Index</a>
<a href="java-io-and-nio-file-and-directory-operations.htm" class="nav-button next">‚Üí</a>
</div>
<section class="download-section">
  <div class="book-cover" style="background-color: #f9f6f1;border: 1px solid #ccc;"> 
    <div class="book-cover-title" style="font-size: 18px;color: #333;top: 20px;">Java IO and NIO</div>
    <div class="book-cover-author">readbytes</div>
    <div class="book-cover-bottom-stripe" style="background-color: #333;"></div>
    <img class="book-cover-icon" style="width: 80px;height: 90px;top: 60px;" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFoAAABaCAYAAAA4qEECAAADAElEQVR4Xu2Zu6oTURSGjze0UfANtLAUzgOI4DOItc+VKk1uJ12aadNa21vbCpYK4wQmcPiYzL5k7eXM2f8HP0JYa/3ZX2PEmxshxAPi7u6uLRH2VA3lWId9VdK27WOKsQ47q6RpmucUYx12VolEOyHRToyJ5mwI7ufeeZBItBMS7YREOyHRTki0ExLthEQ7IdFOSLQTEu2ERDsxJtoq7KwSiXZCop04Ho9PKcY67KwWirEO+6qGcqzCHhGBJDoh0U5ItAP7/f6bRDtAyV3+ckYYQNHr9fo1Z8SVtG37iKI5Mzv4IKuwJwXeuvbef4ePsQ77YuGdLp85MysGHmQa9sXAG7l3JgUfZB32heh+0t3yRvfZD87NDj7KOuwLwf2cG5OEj7IO+8bg7imr1eoV55Lh0VC4bwE7cru4n3Jns9l85d7YPmdCSV8oADtyu7gfe4fzMbucCyV9oQDsyO3i/tid7i+395xjuHMfzoaSvlAAduR2cf/+ne7PT/x8JL94mwzsjCZ5wTN8XAjuTynT/nKJcH9KmfaXS4T7U8q0v1wi3J9Skr8cH3cJ7l3I98Ph8HLg86SuM9zPvRMDO0JJXwjQ/Wx6yx3kI3cGZqK6CPdz78TAjlDSF0ZYLpcvOH9O0zQX/xnL2ZiuIbifeycGdoSSvjACZ2N2TnA+do9wP/dODOwIhfvZ8HCfn5wbYmDPNOybLXxYn9+cu8TArmnYN1v4sNTHcdc67JslfFTOw7hvHfbNEj6q+3n3gTMheMM67JsdfNA1j+Idq7BnlvBR2+32DWfElazX63cUzRlhACVLdCEk2QmJdmC3232RaAcoucsfzogAAxJNwp6qoRzrsK9aKMY6i8XiGTurhGKsc/ofGHZWCcVYR6J7KMY6Et1DMedwLgT3JRpQjEQXgmIkuhAUI9GFoBiJLgTFSHQhKEaiC0ExEl0IipHoQlCMRBeCYiS6EBQj0YWgGOtIdA/FWEeieyjGOhLdQzHW2e/3T9hZJRRjHfZVDeVYhT1CiDnzD27IzgFe/xOvAAAAAElFTkSuQmCC"/>
  </div>
  <div class="download-info">
    <h2 id='bottom'>Download This Ebook</h2>
    <p class="format-label">Available formats:</p>
    <div class="download-buttons">
      <a href="java-io-and-nio.pdf" class="download-button">üìÑ PDF</a>
      <a href="java-io-and-nio.epub" class="download-button">üìò EPUB</a>
    </div>
  </div>
</section><div class='related-books'>
<h2>Java In-Depth Books</h2>
<div class='related-book-list'>
<a href="java-io-and-nio.htm">
<div class="book-cover" style="background-color: #f9f6f1;border: 1px solid #ccc;"> 
    <div class="book-cover-title" style="font-size: 18px;color: #333;top: 20px;">Java IO and NIO</div>
    <div class="book-cover-author">readbytes</div>
    <div class="book-cover-bottom-stripe" style="background-color: #333;"></div>
    <img class="book-cover-icon" style="width: 80px;height: 90px;top: 60px;" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFoAAABaCAYAAAA4qEECAAADAElEQVR4Xu2Zu6oTURSGjze0UfANtLAUzgOI4DOItc+VKk1uJ12aadNa21vbCpYK4wQmcPiYzL5k7eXM2f8HP0JYa/3ZX2PEmxshxAPi7u6uLRH2VA3lWId9VdK27WOKsQ47q6RpmucUYx12VolEOyHRToyJ5mwI7ufeeZBItBMS7YREOyHRTki0ExLthEQ7IdFOSLQTEu2ERDsxJtoq7KwSiXZCop04Ho9PKcY67KwWirEO+6qGcqzCHhGBJDoh0U5ItAP7/f6bRDtAyV3+ckYYQNHr9fo1Z8SVtG37iKI5Mzv4IKuwJwXeuvbef4ePsQ77YuGdLp85MysGHmQa9sXAG7l3JgUfZB32heh+0t3yRvfZD87NDj7KOuwLwf2cG5OEj7IO+8bg7imr1eoV55Lh0VC4bwE7cru4n3Jns9l85d7YPmdCSV8oADtyu7gfe4fzMbucCyV9oQDsyO3i/tid7i+395xjuHMfzoaSvlAAduR2cf/+ne7PT/x8JL94mwzsjCZ5wTN8XAjuTynT/nKJcH9KmfaXS4T7U8q0v1wi3J9Skr8cH3cJ7l3I98Ph8HLg86SuM9zPvRMDO0JJXwjQ/Wx6yx3kI3cGZqK6CPdz78TAjlDSF0ZYLpcvOH9O0zQX/xnL2ZiuIbifeycGdoSSvjACZ2N2TnA+do9wP/dODOwIhfvZ8HCfn5wbYmDPNOybLXxYn9+cu8TArmnYN1v4sNTHcdc67JslfFTOw7hvHfbNEj6q+3n3gTMheMM67JsdfNA1j+Idq7BnlvBR2+32DWfElazX63cUzRlhACVLdCEk2QmJdmC3232RaAcoucsfzogAAxJNwp6qoRzrsK9aKMY6i8XiGTurhGKsc/ofGHZWCcVYR6J7KMY6Et1DMedwLgT3JRpQjEQXgmIkuhAUI9GFoBiJLgTFSHQhKEaiC0ExEl0IipHoQlCMRBeCYiS6EBQj0YWgGOtIdA/FWEeieyjGOhLdQzHW2e/3T9hZJRRjHfZVDeVYhT1CiDnzD27IzgFe/xOvAAAAAElFTkSuQmCC"/>
  </div>
</a>


<a href="java-collections.htm">
<div class="book-cover" style="background-color: #f9f6f1;border: 1px solid #ccc;"> 
    <div class="book-cover-title" style="font-size: 18px;color: #333;top: 20px;">Java Collections</div>
    <div class="book-cover-author">readbytes</div>
    <div class="book-cover-bottom-stripe" style="background-color: #333;"></div>
    <img class="book-cover-icon" style="width: 80px;height: 90px;top: 60px;" src='data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFoAAABaCAYAAAA4qEECAAADAElEQVR4Xu2dQYrUUBRFIw50JI7FrYgrcAPOXYPORHci7sah4EAQFyA6dNKosZK2Ee8/dOclP7/+i/fAmaR+Xr17KehJV2oYjDHGGGM6YRxzmgZdPKvdMt4vl03vLU15ZsYnsORB7Apd7mh2gS51VM/K+LVc6LA+0/QNKZax9RnvlG+C/tI7+6PYuYLV0MHoc72rX8ZvsP9Gq6BDyWzo/jXcjA4sfKN39E+RoYaf9F2CFAPFjGiG3b0Y5r9111LcJGZEM7QW0UNqRjTDWXwQXCojmoEk9MxmHwWGZ0QzkMT4ujy31b/D4UU8uITp/J4uRDOQxPiyPFfDy+HwQnFoCdPZFi5AM5BE/0VP51r5brgRzUASexU9/piG60VxEdO5lt6AZiCJ3Yoep+Fw8Z8DS5gHNfLncCOagSSWFE2M38tzanFBXcS9k/OwBi5AM5DE2qIn9JxaXFAXM33S5oE7+nFYhGYgiRxFX7FH4V+GEJqBJHIV3QGagSRcdBDNQBIuOohmIAkXHUQzkISLDqIZSMJFB9EMJOGig2gGknDRQTQDSbjoIJqBJHIUfffkPLCC74dNaAaSyFH0PKyiL4bVaAaS6L/oedAOrkQzkISLDqIZSMJFB9EMJNF/0bdPzsMquxLNQBL9Fz3x4eQ8sJIb0AwkkaPoK56efLvSV0MVNANJ5Cq6AzQDSbjoIJqBJFx0EM1AEi46iGYgCRcdRDOQhIsOohlIwkUH0Qwk4aKDaAaScNFBNANJuOggmoEkXHQQzUASLjqIZiAJFx1EM5CEiw6iGUjCRQfRDCSxtuh2X63oDM1AEkuKXmtxQc2IZiCJ3Yqu9vW3ztAMJLFX0ZfD4YXiUDI0A0m46CCagSTyfOm+EzQDSeiZzT4ODM+IZjiLD4NLZUQztBbRQ2pGNMPu1nh4lR/H9sfP+i5BioFgNnT/Gm5GB6Ib/im8Nf0+MtMPgb3Wquhwqw1Vwg/qbkix0EHtAl3qaHaDfx6kIf7Bm8YUyyY1Dbp4Fo0xxhhj/kd+A/PkOH57kF8HAAAAAElFTkSuQmCC'/>
  </div>
</a>


<a href="java-regex.htm">
<div class="book-cover" style="background-color: #f9f6f1;border: 1px solid #ccc;"> 
    <div class="book-cover-title" style="font-size: 18px;color: #333;top: 20px;">Java Regex</div>
    <div class="book-cover-author">readbytes</div>
    <div class="book-cover-bottom-stripe" style="background-color: #333;"></div>
    <img class="book-cover-icon" style="width: 80px;height: 90px;top: 60px;" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFoAAABaCAYAAAA4qEECAAAFo0lEQVR4Xu2d3WscVRiH+y/YXuuFkov6H9je2huvlAQvFalCEW8qiFRFQcGrmoJ4U5TSLWglFqRIlJqCH6XWalM/0lrT1O1ukt3sV5qPTZrP3XHfLTM983vPztc5s+zZPQ88N5l3Z9inwzA70Dl79iQks29oM7N3yBkoW98ZO6RC62ANdvDBtYF9lJEcxHNi+CWnOvmXs5rN9aX03eg74vcWxV6xObX3iUdxp2P7DzqDztiTB1lsaoX9InF631BJ3NH408N4vIFn/NCwL/aZVjPsGAj+a1mCwV7YUwqeyZZoxDqz8ZpsiYfY7mzQNdtGVkdsiH3b2Mj6CIztbrB3F+qMHxqRh84Iv/gsehDO6oe/IN0/ju0/gPOWhNAPO3ZW27M5HXyhTwtP4Sx68S4f9NRPuJbgnEURsa0Xmp5QWfQyMfLwqZ8XunrtT5yzKEKPWFnoem4O5xKxsVbS5vbmMu7eKOr5OUnovHro1ep0KppKPT+vP/TGWpkF0qWp2NBdwobuEjY0MnXbcb4cd5xCGbco0XOhb8wuOhdnGp4//7fl254ah9/urAZ6KrQYGL01V0sndLPJw8pUxJjQ5OXsBh5KjVZjFjRIBXoqdKWcZXHRK/kGHi45GDJMBXoqNFku3WVx0V9nNcTGiK7nLgRvT0jPhSZLacfGeK7Xb4bPJaQnQz+InWNx0USXEQzn+vsUTvKZfgxNFhfyLC4a68x+7QMejrwieVqJM+QX3+BUZHo6NDlfnGNx0auzdPsQAQxHXprEKT7jqkDPhyZni/MsLhopNoY7kcEJPuN6bBQnY2FEaDJXLLC4aGhsjIfgdtdX3sHJ2BgTmswVwmMHXrMxoBgb/+76snpkwqjQZKnusLhox7uRryd4yDA1YVxoYmG1yeKi0jP7nzs8ZJAaMTI0UVhJEPvN4zxmJzVjbGhidik8tu8ygjE7mQJGha7XZvBQTnYxPHb7zF6o8qAyU8KY0Gv37uJhPGZq4bEXpnI8KpoiRoTe3lzBQzCmq51j59aabSu/3OBxSU23cEH0fOgHT+ej8W+Fx3Yju9YuXO16ZCKV0DvVSWfrzlnm+tyP/pCVW2xGNAlibIzsunT+p65GJroamhRD4zbVyC7TFR4XXf7qIn4sVVIJ3bj9meNce0OqGLM5+Rbb7jMhePmQWXzqWWf15Of40dRIJfTmwmV2hiY1LhhUJkV2Xfn4FO4iFXo+NBkVDCpTjOzFPvEp7ko7RoQmw8CgMjGw6PJourGNCU12AoPKXHpvlMVFl4+fxF1rw6jQJIJBZbpgWJnLH34i7F0fxoamnzEYVKZI6ZkXWViZS+9+5PucDowNjUFlIlt/3GRRO7n4+vv4cSWMDI1BZcpYP/89Cxpk7cgx3EVijAuNQWV2AkOSbZpN9nfX6uHkP5xE+i50EBgRwe1e7BeO4mhs+ip0GBjw/nc/4AibCZqNQ9+EjgLGI50G/yzOeLMK9EXoqBQPPMfixYm9cek3HIuM8aHjgvFcmzs7OMpm2v8oCTE6dBJ2q/dYPC/29rZvFrcPZGgVdss1FtCLvX6/PVN5/lW2beBC62C3VGURw2z/D66EGBdaJ7vFMosZpAoDHZqIGluVgQ/dJuAnuI7IhA0NVEaOtOMuHrVP74zEhu4SNnSXkIdWfHnVbr3AAunSVOjkZaF1vI4NA+nQZKSvY7MvGNSP9AWDpEUvYlv7EtgU8UK7Sz/Z0Ongnc34/mi7apA+xNWHxND21fOa8S4buHiZu4GWJbKo8W2nxRTE0PasVkdsiZ3b2NjqhEYmaNkhGzs5Yrszjzz+GPb1QQtq2djxEZu17pvL2FWK70M2dijYC3sGgmc2LUtk8SPeXcQ6kxFcdo+kG/FBR+tSqCK4U1F6QlW7/rezms33pfTdxKdwMrGXMhm7XLWo/uWqZdgF2OPxPxXwJpKIkhiiAAAAAElFTkSuQmCC"/>
  </div>
</a>


<a href="java-functional-programming.htm">
<div class="book-cover" style="background-color: #f9f6f1;border: 1px solid #ccc;"> 
    <div class="book-cover-title" style="font-size: 18px;color: #333;top: 20px;">Java Functional Programming</div>
    <div class="book-cover-author">readbytes</div>
    <div class="book-cover-bottom-stripe" style="background-color: #333;"></div>
    <img class="book-cover-icon" style="width: 80px;height: 80px;top: 80px;" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFoAAABaCAYAAAA4qEECAAADzUlEQVR4Xu2bO4sUURCFlxVBzfwLJkb+A1MxEgMRDBQDRTBRwchARk00MRFBAwNBzEQwMBfEBz7wbWIkiIGJoInio9wZdmZ7T1V3V91bPVhaH3xJ973n3jk2vdO968JCkiRJkiRRIYphWOgI/zB/uyHBDxHFUODmIxkK3HwkQ4Gbj2QY6BDffCTDgBuPZhhw49EMA248miGgW3zj0QwBbjqiIcBNRzQEuOlohoA+8Y1HMgy4cauJEizO5EZMS0RoUSjPYKIEi7OaKMHirCZKsDiTi5iWiNAmoTyDiRIszmqiBIsz+QXTklZYeQYTJXSUl2cxUYLFWU2UYHEmb2Na0gorz2CihJ7w8iwmSrA4q4kSLM7kYUxLWmHlGUyU0C9ensVECRZnNQS4abPPMNEOy7S4BdN00L5GxmU8q4cuNXL24tll2KYrLIXW8yyLJdAJnkP3cFQ/9FzIGeEgHOBgCZhh1Qod5xkzH+PoduiVMH/qqDkQT3q4trGAEpZh1AId4/OZb3EWh14K89DRdDCecNIKzjdp+IelHcL8Nj/g7BU6r2R0+3gCHvRyN26tHdoszDdoAef2KpQt3pN7ZAc81YLzrFrAuSrfNOY/Es4rZAdcfbCywS7YPIvfMa0buiBkaFz6ATn+POy4xmvjhfGgsxpwjsUSigsr8el0UTzh7c9Vn5FBe4Q5BkuZXKFCnqsPmwviyQHsAsdarWF8tWGem/dxMRwwkG3gOJMvMM1O7S8aRJtX8hQ2aCDbwHEWvXAte3pPlmCDBxKhK3yMRU9cbiOKp0k+aQg3+K7pTdUPyHeYVgELL9At7/zqLA9KH0YmNh5qqqHPwgJWLzby8JxBb1y+Wxve+vXCwguc5Lzmxy164lLy1IL32SJ0Qwi3+k04ZtSLqttFm3dxlUJY8Lzdijsqo+QtnFqPK5u2CcFz1APT++RSPe7ZLHSO1qL6zYiXmu/WXdAaIXRO1lD8mnSpsOKHmpu4CyMscB5W/m8rlqex8TBS+lBTDQYObS2Y16vwxFfydbAaDBzaWmgXz2y14/46fg3Kxre5E2cXwoKH8geuXIb4hzNo11u4ZVRX9kmcVQELH0hP6BTPnym9T26h8559Gkc7wBYZQG/oLF+D/WZEgfht5AyOcoLeC4s5OwR0oLHGVTyrh643cvbjWWewGFc/4mr/MXRQKMjJBMCCvEwAWsdL8jARwJKqvYMrJDNYWRUmHWBZNSY9YGGlJj1gYUWew9REhBVnNFFCX3l5FhMDWJ7WpAAssc+kAiyzzcQJLHbibxyVJEmSJMk/xB+4wdarC+OVAQAAAABJRU5ErkJggg=="/>
  </div>
</a>


<a href="java-streams.htm">
<div class="book-cover" style="background-color: #f9f6f1;border: 1px solid #ccc;"> 
    <div class="book-cover-title" style="font-size: 18px;color: #333;top: 20px;">Java Streams</div>
    <div class="book-cover-author">readbytes</div>
    <div class="book-cover-bottom-stripe" style="background-color: #333;"></div>
    <img class="book-cover-icon" style="width: 80px;height: 80px;top: 60px;" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFoAAABaCAYAAAA4qEECAAACbklEQVR4Xu3cP4oUQRiG8S8xEzESDI1MPIRHEQQPYTK9iCyewMxrGIiCoaFnWFkMTIwUxD894KI8VbNdVdNfzdR87w+eRKa2ul+WVZM1G8+3ud+d+mhBvbZ0DO/uWEAcoVfhcIBehcQRvAvt1dz7gjjaVfxcrhcmxTiwvkudcGAN7YQDa2gnHFhDO+HAGtoJB24ZmmdzhcdBWobh2VzhcZCWYXg2V3gcpGUYns0VHgdpGYZnc4XHQVqG4dlc4XGQlmF4Nld4HKRlGJ7NFR4HaRmGZ3MN48Hcu7lLS19ihI7SPUsfdPSOCh/ulDoKfKhT7KC2P3P5QKfawfBBTr2D4ENEqDs+QJS64uWR6ubc0ssj1Q0vjlYXvLS1X3Mv5x7NPTyi+Jy5uuClNY2Az5zL3RtLLy1pJHz2XO544VLbHw+j4TvkcscLlxoR3yGXO154XaPie+Ry9djSC69rVHyPXK62/xTjhbu6+HtmRHyXXK6iDH1wGroTDd2Jhu5EQ3eioTvR0J1o6E40tAMOt1YCHGitBDjQWglwoLUS4EBrJcCB1kqAA62VwFOnREREROSIPbP7/CNZ28Y+2KT/hPjbjnyVOPl/ZA3tZLLzZGiN7YAD/+smPyqt0nH1Xe2Cw7LndpdHpBZH3ZXs4YndSAbdleyBYy4ljTjkUtKAI5a0sS/8MrKEI5YmFTZ2mQxYmlTgeDVt7DO/nOzC8WqTApPdSoarTQpM9ikZrjYpMNmPZLjapMDZ/JcZh6tNCkx2OxmuNinE4WraDPnbZw5ksp/JgKVJJQ5YmjTgiEvJHib7mgyaS1Yy2dtk3DP7zo9F9wfJyGVFhM8g5gAAAABJRU5ErkJggg=="/>
  </div>
</a>



<a href='java.htm'><div class='book-cover' style='background-color: #f9f6f1;color: #111111;border: 1px solid #ccc;display: flex;justify-content: center;align-items: center;text-align: center;'>More Java Books</div></a>
</div>
</div>
  </div>
  <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/prism.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
  
  <script>
    function copyCode(button) {
      const code = button.nextElementSibling.innerText;
      navigator.clipboard.writeText(code).then(() => {
        button.textContent = 'Copied!';
        setTimeout(() => { button.textContent = 'Copy'; }, 1500);
      });
    }
  </script>  
<div id="floatingLog" aria-live="polite" role="alert"></div>
<footer class="page-footer">
    <nav>
      <a href="https://readbytes.github.io">Home</a> | 
      Email:<script language="JavaScript" type="text/javascript">
var part1 = 'yinpeng';var part6 = '263';var part2 = Math.pow(2,6);var part3 = String.fromCharCode(part2);var part4 = 'hotmail dot com';var part5 = part1 + String.fromCharCode(part2) + part4;document.write(part1 + part6 + part3 + part4);
</script>
    </nav>
  <p>¬© 2025 ‚Äî All rights reserved.</p>    
  </footer>

</body>
</html>