<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Java IO and NIO Advanced Java IO Concepts</title>
<link rel='shortcut icon' href='https://java2s.com/style/favicon.ico'>
<link href="https://fonts.googleapis.com/css2?family=Merriweather&display=swap" rel="stylesheet" />
<link href="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet" />


  <script>
  const mode = localStorage.getItem('mode') || 'light';
  document.documentElement.classList.add(`${mode}-mode`);
  </script>   
<style> 
html {
  scroll-behavior: smooth;
}

body {
  font-family: 'Merriweather', serif;
  margin: 0;
  padding: 2rem 1rem;
  font-size: 15px;
  line-height: 1.5;
  transition: background-color 0.3s, color 0.3s;
}

.container {
  max-width: 700px;
  margin: 0 auto;
  padding: 1rem 2rem;
  box-shadow: 0 0 15px rgba(0,0,0,0.1);
}

h1, h2, h3 {
  font-weight: 600;
  margin-top: 2.5rem;
  margin-bottom: 1rem;
  line-height: 1.2;
}

h1 { font-size: 1.8rem; }
h2 { font-size: 1.4rem; }
h3 { font-size: 1.2rem; }

table {
  width: 100%;
  border-collapse: collapse;
  font-family: sans-serif;
  font-size: 1em;
  margin: 1em 0;
}

th, td {
  padding: 0.6em 1em;
  text-align: left;
  border: 1px solid;
}

tr:nth-child(even) {
  background-color: inherit;
}

tr:hover {
  background-color: inherit;
}

a {
  text-decoration: none;
  transition: color 0.2s;
}

a:hover {
  text-decoration: underline;
}

code {
  color: #d35400;
}

.book-title-chapter {
  font-family: 'Merriweather', serif;
  font-size: 2rem;
  font-weight: bold;
  text-align: center;
  margin-bottom: 2rem;
  border-bottom: 2px solid;
  padding-bottom: 0.5rem;
}

.book-subtitle-chapter {
  text-align: center;
  font-size: 1rem;
  margin-top: -1rem;
  margin-bottom: 2rem;
}

.related-books {
  margin-top: 40px;
}

.related-book-list {
  display: flex;
  flex-wrap: wrap;
  gap: 20px;
}

    .book-cover {
      width: 130px;
      height: 180px;
      font-family: Arial, sans-serif;
      position: relative;
      overflow: hidden;      
      line-height: normal;
      box-shadow: 2px 2px 4px rgba(0,0,0,0.1);
    }
    .book-cover-bottom-stripe {
      position: absolute;
      bottom: 0;
      left: 0;
      height: 5px;
      width: 100%;
    }
    .book-cover-title {
      position: absolute;
      width: 100%;
      text-align: center;
      font-weight: bold;
    }
     
    .book-cover-icon {
      position: absolute;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      align-items: center;
      justify-content: center; 
    }

    .book-cover-author {
      position: absolute;
      bottom: 10px;
      width: 100%;
      text-align: center;
      font-size: 8px;
      color: #333;
    }

.page-footer {
  margin-top: 4rem;
  padding: 1rem 0;
  text-align: center;
  font-size: 0.85rem;
  border-top: 1px solid;
}

.chapter-navi-section {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding-bottom: 10px;
}

.nav-link {
  color: inherit;
  text-decoration: none;
  opacity: 0.5;
  transition: opacity 0.3s ease, text-decoration 0.3s ease;
}

.nav-link:hover {
  opacity: 0.9;
  text-decoration: underline;
}

.prev { text-align: left; }
.toc-link { text-align: center; }
.next { text-align: right; }

.download-section {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 2rem;
  padding: 2rem 1rem;
  max-width: 600px;
  margin: 3rem auto;
  border-radius: 12px;
  box-shadow: 0 4px 10px rgba(0,0,0,0.05);
}

.download-info h2 {
  margin: 0 0 0.5rem;
  font-size: 1.2rem;
}

.format-label {
  margin: 0 0 0.5rem;
  font-size: 0.95rem;
}

.download-buttons {
  display: flex;
  gap: 1rem;
}

.download-button {
  background-color: #4A90E2;
  color: white;
  padding: 0.5em 1.2em;
  border-radius: 25px;
  font-size: 0.95rem;
  text-decoration: none;
  transition: background-color 0.3s ease;
}

.download-button:hover {
  background-color: #357ABD;
}

.code-block {
  position: relative;
  margin-bottom: 1em;
}

.copy-button {
  background: transparent;
  color: white;
  position: absolute;
  top: 8px;
  right: 8px;
  border: none;
  padding: 4px 8px;
  font-size: 12px;
  border-radius: 4px;
  cursor: pointer;
  z-index: 1;
}

.copy-button:hover {
  background-color: #0056b3;
}

.snippet-container {
  overflow: hidden;
}

.snippet-header {
  padding: 0.75rem 1rem;
  cursor: pointer;
  font-size: 1rem;
    background-color: #eeeeee;
    color:  #111111; 
    border-radius: 8px;
    cursor: pointer;
    box-shadow: 0 4px 6px rgba(0,0,0,0.1);  
}

.snippet-body {
  display: none;
  font-family: monospace;
}

.snippet-container.open .snippet-body {
  display: block;
}

.CodeMirror {
  border: 2px solid #ccc;
  border-radius: 4px;
  resize: vertical;
}

/* === Light Mode === */
html.light-mode {
  background-color: #f8f7f5;
  color: #333;
}

html.light-mode .container {
  background: white;
}

html.light-mode .book-title-chapter {
  color: #2c3e50;
  border-color: #ccc;
}
html.light-mode .book-subtitle-chapter{
  color: #888;
}

html.light-mode .page-footer,
html.light-mode .series-name,
html.light-mode .book-subtitle,
html.light-mode .format-label {
  color: #888;
}

html.light-mode .related-books h2 {
  color: #333;
  border-bottom: 2px solid #eee;
}

html.light-mode .book-title {
  color: #fff;
}

html.light-mode .book-cover {
  border: 1px solid #ccc;
}

html.light-mode th {
  background-color: #f2f2f2;
}

html.light-mode tr:nth-child(even) {
  background-color: #fafafa;
}

html.light-mode tr:hover {
  background-color: #e6f7ff;
}

html.light-mode a,
html.light-mode .page-footer a {
  color: #000;
}

/* === Dark Mode === */
html.dark-mode {
  background-color: #181818;
  color: #e0e0e0;
}

html.dark-mode .container {
  background: #222;
}

html.dark-mode .book-title-chapter {
  color: #ddd;
  border-color: #444;
}

html.dark-mode .snippet-header {
    background-color: #333;
    color:  #ddd; 
}


html.dark-mode .book-subtitle-chapter,
html.dark-mode .page-footer,
html.dark-mode .series-name,
html.dark-mode .book-subtitle,
html.dark-mode .book-footer,
html.dark-mode .format-label {
  color: #aaa;
}

html.dark-mode .related-books h2 {
  color: #ddd;
  border-bottom: 2px solid #333;
}

html.dark-mode .book-title {
  color: #fff;
}

html.dark-mode .book-cover {
  border: 1px solid #555;
}

html.dark-mode th {
  background-color: #333;
  color: #fff;
}

html.dark-mode td {
  border-color: #444;
}

html.dark-mode tr:nth-child(even) {
  background-color: #2a2a2a;
}

html.dark-mode tr:hover {
  background-color: #2c3e50;
}

html.dark-mode a,
html.dark-mode .page-footer a {
  color: #eee;
}

    .dialog-backdrop {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: rgba(0,0,0,0.5);
      display: none;
      justify-content: center;
      align-items: center;
      z-index: 10;
    }

    .dialog {
      background: white;
      padding: 20px;
      width: 90vw;
      height: 80vh;
      border-radius: 8px;
      box-shadow: 0 0 20px rgba(0,0,0,0.3);
      display: flex;
      flex-direction: column;
    }
    .dialog-content {
      display: flex;
      flex: 1;
      gap: 20px;
      margin-top: 10px;
    }
    .dialog h2 {
      margin-top: 0;
    }

    .textarea_dialog {
      width: 50%;
      height: 100%;
      resize: none;
      font-family: monospace;
      font-size: 14px;
      padding: 10px;
      box-sizing: border-box;
      border: 1px solid #ccc;
    }

    .iframe_dialog {
      width: 50%;
      height: 100%;
      border: 1px solid #ccc;
    }
    .controls_dialog {
      display: flex;
      justify-content: space-between;
      margin-top: 10px;
    }    
    button { padding: 0.5em 1em; background: green; color: white; border: none; cursor: pointer; }
    button:hover { background: #1e7e34; }
    .result_iframe { width:99%; height:200px; margin-top: 1em;  resize: both;border:1px solid #ccc;}        
</style>
</head>
<body> 
  <div class="container">
    <div class = "chapter-navi-section">
<a href="java-io-and-nio-file-and-directory-operations.htm" class="nav-button prev">←</a>
<a href='java-io-and-nio.htm#advanced-java-io-concepts' class="nav-button toc-link">Index</a>
<a href="java-io-and-nio-introduction-to-java-nio-new-io.htm" class="nav-button next">→</a>
</div>

    <h1 class="book-title-chapter" id = 'top'>Advanced Java IO Concepts</h1>
    <h3 class="book-subtitle-chapter">Java IO and NIO</h3>   
    <!-- <h1 class ="chapter-title"></h1> -->
    <h2 id='object-serialization-and-deserialization'>4.1 Object Serialization and Deserialization</h2><p>Java provides a powerful mechanism called <strong>serialization</strong> that allows you to convert an object into a sequence of bytes, which can then be saved to a file, transmitted over a network, or stored for later retrieval. The reverse process, <strong>deserialization</strong>, reconstructs the object from these bytes back into memory.</p><h3 id="what-is-serialization">What is Serialization?</h3><p><strong>Serialization</strong> is the process of transforming the state of an object into a byte stream. This byte stream captures the object's data, and sometimes metadata, so it can be stored or transmitted. The key benefit is that the object’s entire state can be saved and restored later, enabling:</p><ul>
 <li><strong>Object persistence</strong>: Saving objects to files or databases for later use.</li>
 <li><strong>Communication</strong>: Sending objects over a network between different Java virtual machines (JVMs).</li>
 <li><strong>Caching</strong>: Storing objects in memory or disk caches for fast access.</li>
</ul><p>Without serialization, saving or transmitting complex objects would require manual conversion to a suitable format.</p><h3 id="the-serializable-interface">The <code>Serializable</code> Interface</h3><p>In Java, an object must explicitly indicate that it can be serialized by implementing the <strong>marker interface</strong> <code>java.io.Serializable</code>. This interface has no methods; it simply marks the class as serializable.</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-java">import java.io.Serializable;

public class Person implements Serializable {
    private static final long serialVersionUID = 1L;

    private String name;
    private int age;

    // Constructor, getters, setters...
}</code></pre>
</div><ul>
 <li>The <strong><code>serialVersionUID</code></strong> is a unique identifier for the class version. It helps during deserialization to ensure that a serialized object corresponds to a compatible class version. If not provided, Java generates one automatically, but explicitly defining it is best practice for version control.</li>
</ul><h3 id="how-serialization-works-in-java">How Serialization Works in Java</h3><p>The standard serialization mechanism uses two classes from the <code>java.io</code> package:</p><ul>
 <li><strong><code>ObjectOutputStream</code></strong> — Writes serialized objects to an output stream (e.g., file or socket).</li>
 <li><strong><code>ObjectInputStream</code></strong> — Reads serialized objects from an input stream and reconstructs them.</li>
</ul><h3 id="basic-serialization-example">Basic Serialization Example</h3><p>This example shows how to serialize a <code>Person</code> object to a file.</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-java">import java.io.*;

public class SerializeExample {
    public static void main(String[] args) {
        Person person = new Person("Alice", 30);

        try (FileOutputStream fileOut = new FileOutputStream("person.ser");
             ObjectOutputStream out = new ObjectOutputStream(fileOut)) {

            out.writeObject(person);  // Serialize the person object
            System.out.println("Object serialized to person.ser");
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}</code></pre>
</div><ul>
 <li>The object is converted into bytes and written to the file <code>person.ser</code>.</li>
 <li>Note the use of <strong>try-with-resources</strong> to automatically close streams.</li>
</ul><h3 id="basic-deserialization-example">Basic Deserialization Example</h3><p>To restore the serialized object from the file:</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-java">import java.io.*;

public class DeserializeExample {
    public static void main(String[] args) {
        try (FileInputStream fileIn = new FileInputStream("person.ser");
             ObjectInputStream in = new ObjectInputStream(fileIn)) {

            Person person = (Person) in.readObject();  // Deserialize object
            System.out.println("Deserialized Person:");
            System.out.println("Name: " + person.getName());
            System.out.println("Age: " + person.getAge());

        } catch (IOException | ClassNotFoundException e) {
            e.printStackTrace();
        }
    }
}</code></pre>
</div><ul>
 <li>The <code>readObject()</code> method reads the byte stream and reconstructs the <code>Person</code> object.</li>
 <li>You need to cast the returned object to the appropriate class.</li>
 <li>Handle both <code>IOException</code> and <code>ClassNotFoundException</code>.</li>
</ul><h3 id="important-considerations">Important Considerations</h3><h4 id="transient-fields">Transient Fields</h4><p>If a field should <strong>not</strong> be serialized (e.g., sensitive information or fields that can be recalculated), declare it as <code>transient</code>:</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-java">private transient String password;</code></pre>
</div><p>Such fields are ignored during serialization and restored with default values (<code>null</code> for objects, zero for primitives) on deserialization.</p><h4 id="object-graph-serialization">Object Graph Serialization</h4><p>Java serialization handles entire <strong>object graphs</strong>. If a serialized object references other objects (fields holding other objects), those referenced objects must also implement <code>Serializable</code>. The whole graph is serialized recursively.</p><h4 id="customization-via-writeobject-and-readobject">Customization via <code>writeObject</code> and <code>readObject</code></h4><p>Classes can customize the serialization process by defining these private methods:</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-Java">private void writeObject(ObjectOutputStream out) throws IOException {
    // Custom serialization logic
}

private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
    // Custom deserialization logic
}</code></pre>
</div><p>This allows, for example, encryption, compression, or special handling of certain fields.</p><h4 id="serial-version-uid">Serial Version UID</h4><p>Changing a class structure without updating <code>serialVersionUID</code> can lead to <strong><code>InvalidClassException</code></strong> during deserialization. Always update or maintain consistent version UIDs when evolving classes.</p><h3 id="why-serialization-is-useful">Why Serialization is Useful</h3><ul>
 <li><strong>Persistence:</strong> Saving program state easily without converting objects manually.</li>
 <li><strong>Network Communication:</strong> Transmitting Java objects in distributed systems (e.g., RMI, messaging).</li>
 <li><strong>Caching:</strong> Storing objects in serialized form to disk or memory for later reuse.</li>
 <li><strong>Deep Cloning:</strong> Creating deep copies of objects via serialization.</li>
</ul><h3 id="limitations-and-alternatives">Limitations and Alternatives</h3><ul>
 <li>Java serialization can be <strong>slow and produce large output</strong>.</li>
 <li>It is <strong>Java-specific</strong>, so serialized files may not be portable across languages.</li>
 <li>Security risks if deserializing untrusted data (can lead to exploits).</li>
 <li>Alternatives include <strong>JSON, XML, Protocol Buffers</strong>, or <strong>custom serialization</strong> formats for interoperability and control.</li>
</ul><h3 id="recap">Recap</h3><ul>
 <li>Serialization converts Java objects into byte streams for storage or transmission.</li>
 <li>Deserialization reconstructs objects from these byte streams.</li>
 <li>Implement <code>Serializable</code> to mark classes for serialization.</li>
 <li>Use <code>ObjectOutputStream</code> and <code>ObjectInputStream</code> for serialization/deserialization.</li>
 <li>Manage versioning with <code>serialVersionUID</code>.</li>
 <li>Use <code>transient</code> fields to exclude sensitive or non-serializable data.</li>
 <li>Be aware of security and performance implications.</li>
</ul><div class = "chapter-navi-section">
<a href="#top" class="nav-button prev">↑</a>
<a href='java-io-and-nio.htm#advanced-java-io-concepts' class="nav-button toc-link">Index</a>
<a href="#bottom" class="nav-button next">↓</a>
</div>
<h2 id='using-objectinputstream-and-objectoutputstream'>4.2 Using ObjectInputStream and ObjectOutputStream</h2><p>Serialization in Java revolves around two core classes: <strong><code>ObjectOutputStream</code></strong> and <strong><code>ObjectInputStream</code></strong>. These classes provide the functionality to convert Java objects into a byte stream and vice versa, enabling easy persistence and communication of complex data structures.</p><h3 id="what-are-objectoutputstream-and-objectinputstream">What Are <code>ObjectOutputStream</code> and <code>ObjectInputStream</code>?</h3><ul>
 <li><strong><code>ObjectOutputStream</code></strong>: Wraps around an underlying <code>OutputStream</code> and writes Java objects as a serialized stream of bytes.</li>
 <li><strong><code>ObjectInputStream</code></strong>: Wraps around an <code>InputStream</code> and reads serialized bytes, reconstructing Java objects.</li>
</ul><p>Together, they simplify the process of writing and reading serializable objects to/from files, network sockets, or any stream.</p><h3 id="how-do-these-classes-work">How Do These Classes Work?</h3><ul>
 <li><code>ObjectOutputStream</code> serializes objects implementing the <code>Serializable</code> interface, including their entire object graph (all referenced objects).</li>
 <li><code>ObjectInputStream</code> reads the byte stream and recreates the objects in memory.</li>
 <li>Both streams handle the metadata necessary to maintain object identity, versioning, and type information.</li>
</ul><h3 id="basic-usage-writing-objects-to-a-file">Basic Usage: Writing Objects to a File</h3><p>The common pattern is to wrap a <code>FileOutputStream</code> with an <code>ObjectOutputStream</code>. This allows writing objects directly to a file.</p><h4 id="example-serializing-a-person-object">Example: Serializing a <code>Person</code> Object</h4><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-java">import java.io.*;

public class SerializeDemo {
    public static void main(String[] args) {
        Person person = new Person("Alice", 30);

        try (FileOutputStream fos = new FileOutputStream("person.ser");
             ObjectOutputStream oos = new ObjectOutputStream(fos)) {

            oos.writeObject(person);  // Serialize the person object
            System.out.println("Object serialized successfully.");

        } catch (IOException e) {
            System.err.println("Serialization failed:");
            e.printStackTrace();
        }
    }
}</code></pre>
</div><ul>
 <li><strong><code>writeObject(Object obj)</code></strong> serializes the given object.</li>
 <li>The <strong>try-with-resources</strong> block ensures streams are closed automatically.</li>
 <li>If <code>person</code> references other serializable objects, they are also serialized recursively.</li>
</ul><h3 id="reading-objects-from-a-file">Reading Objects from a File</h3><p>To deserialize, wrap a <code>FileInputStream</code> with an <code>ObjectInputStream</code> and call <code>readObject()</code>:</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-java">import java.io.*;

public class DeserializeDemo {
    public static void main(String[] args) {
        try (FileInputStream fis = new FileInputStream("person.ser");
             ObjectInputStream ois = new ObjectInputStream(fis)) {

            Person person = (Person) ois.readObject();  // Deserialize object
            System.out.println("Deserialized Person:");
            System.out.println("Name: " + person.getName());
            System.out.println("Age: " + person.getAge());

        } catch (IOException | ClassNotFoundException e) {
            System.err.println("Deserialization failed:");
            e.printStackTrace();
        }
    }
}</code></pre>
</div><ul>
 <li><p><strong><code>readObject()</code></strong> reads and reconstructs the object.</p></li>
 <li><p>It returns <code>Object</code>, so a cast is required.</p></li>
 <li><p>Handle both <code>IOException</code> and <code>ClassNotFoundException</code>:</p>
  <ul>
   <li><code>IOException</code> for stream or file errors.</li>
   <li><code>ClassNotFoundException</code> if the class of the serialized object isn't found.</li>
  </ul></li>
</ul><h3 id="handling-versioning-with-serialversionuid">Handling Versioning with <code>serialVersionUID</code></h3><p>Java serialization includes a <strong>version control mechanism</strong> using the <code>serialVersionUID</code> field, which helps detect class mismatches between serialized objects and the current class version.</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-java">import java.io.Serializable;

public class Person implements Serializable {
    private static final long serialVersionUID = 1L;

    private String name;
    private int age;

    // Constructors, getters, setters...
}</code></pre>
</div><ul>
 <li>If the <code>serialVersionUID</code> of the serialized class and the class at deserialization differ, an <code>InvalidClassException</code> is thrown.</li>
 <li>Explicitly declaring <code>serialVersionUID</code> protects against accidental incompatibilities caused by compiler-generated values.</li>
 <li>When evolving classes (adding/removing fields), update the <code>serialVersionUID</code> accordingly.</li>
</ul><h3 id="important-considerations-when-using-these-streams">Important Considerations When Using These Streams</h3><h4 id="closing-streams">Closing Streams</h4><p>Always close streams after use to free system resources and avoid data corruption. Use try-with-resources or explicit <code>close()</code> calls.</p><h4 id="transient-fields">Transient Fields</h4><p>Fields marked <code>transient</code> are not serialized and will have default values after deserialization.</p><h4 id="custom-serialization">Custom Serialization</h4><p>Classes can override <code>writeObject</code> and <code>readObject</code> private methods to customize serialization (e.g., encrypting data or handling transient fields).</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-Java">private void writeObject(ObjectOutputStream out) throws IOException {
    // Custom serialization logic
    out.defaultWriteObject();
}

private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
    // Custom deserialization logic
    in.defaultReadObject();
}</code></pre>
</div><h4 id="serializing-collections">Serializing Collections</h4><p>Common Java collections like <code>ArrayList</code>, <code>HashMap</code>, etc., implement <code>Serializable</code> and can be serialized directly.</p><h3 id="full-example-serialize-and-deserialize-multiple-objects">Full Example: Serialize and Deserialize Multiple Objects</h3><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-java">import java.io.*;
import java.util.ArrayList;
import java.util.List;

public class SerializeMultipleObjects {
    public static void main(String[] args) {
        List&lt;Person&gt; people = new ArrayList&lt;&gt;();
        people.add(new Person("Alice", 30));
        people.add(new Person("Bob", 25));

        // Serialize list of people
        try (ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream("people.ser"))) {
            oos.writeObject(people);
            System.out.println("List serialized.");
        } catch (IOException e) {
            e.printStackTrace();
        }

        // Deserialize list of people
        try (ObjectInputStream ois = new ObjectInputStream(new FileInputStream("people.ser"))) {
            List&lt;Person&gt; deserializedPeople = (List&lt;Person&gt;) ois.readObject();
            System.out.println("Deserialized people:");
            for (Person p : deserializedPeople) {
                System.out.println(p.getName() + ", Age: " + p.getAge());
            }
        } catch (IOException | ClassNotFoundException e) {
            e.printStackTrace();
        }
    }
}</code></pre>
</div><h3 id="recap">Recap</h3><ul>
 <li><strong><code>ObjectOutputStream</code></strong> and <strong><code>ObjectInputStream</code></strong> provide seamless Java object serialization and deserialization.</li>
 <li>Use <strong><code>writeObject()</code></strong> to serialize objects and <strong><code>readObject()</code></strong> to deserialize.</li>
 <li>Always handle exceptions (<code>IOException</code>, <code>ClassNotFoundException</code>) properly.</li>
 <li>Use <strong><code>serialVersionUID</code></strong> to maintain version compatibility.</li>
 <li>Customize serialization if needed using <code>writeObject</code> and <code>readObject</code>.</li>
 <li>Close streams to avoid resource leaks, preferably using try-with-resources.</li>
 <li>These classes enable saving, transmitting, and restoring complex Java objects efficiently.</li>
</ul><div class = "chapter-navi-section">
<a href="#top" class="nav-button prev">↑</a>
<a href='java-io-and-nio.htm#advanced-java-io-concepts' class="nav-button toc-link">Index</a>
<a href="#bottom" class="nav-button next">↓</a>
</div>
<h2 id='externalizable-interface'>4.3 Externalizable Interface</h2><p>Java provides two main interfaces for object serialization: <strong><code>Serializable</code></strong> and <strong><code>Externalizable</code></strong>. While both enable object serialization, <code>Externalizable</code> offers greater control over the serialization process, allowing developers to customize exactly how an object's data is written and read. This section explains the <code>Externalizable</code> interface, how it differs from <code>Serializable</code>, and when and how to use it effectively.</p><h3 id="what-is-externalizable">What is <code>Externalizable</code>?</h3><p><code>Externalizable</code> is a subinterface of <code>Serializable</code> defined in the <code>java.io</code> package. It requires the implementing class to explicitly define <strong>how its fields are serialized and deserialized</strong> by overriding two methods:</p><ul>
 <li><code>void writeExternal(ObjectOutput out) throws IOException</code></li>
 <li><code>void readExternal(ObjectInput in) throws IOException, ClassNotFoundException</code></li>
</ul><p>In contrast, <code>Serializable</code> uses <strong>default serialization</strong>, which automatically serializes all non-transient fields.</p><h3 id="key-differences-between-serializable-and-externalizable">Key Differences Between <code>Serializable</code> and <code>Externalizable</code></h3><table>
 <thead>
  <tr>
   <th>Aspect</th>
   <th><code>Serializable</code></th>
   <th><code>Externalizable</code></th>
  </tr>
 </thead>
 <tbody>
  <tr>
   <td>Serialization Logic</td>
   <td>Automatic by JVM, serializes all non-transient fields</td>
   <td>Manual; developer writes explicit serialization code</td>
  </tr>
  <tr>
   <td>Methods to Override</td>
   <td>None mandatory (optional <code>writeObject/readObject</code>)</td>
   <td>Must implement <code>writeExternal</code> and <code>readExternal</code></td>
  </tr>
  <tr>
   <td>Control Over Data Written</td>
   <td>Limited</td>
   <td>Complete control over what and how to serialize</td>
  </tr>
  <tr>
   <td>Performance</td>
   <td>Simpler, but can be slower due to extra metadata</td>
   <td>Can be faster and more compact, if implemented carefully</td>
  </tr>
  <tr>
   <td>Use Case</td>
   <td>General-purpose serialization</td>
   <td>When custom serialization is needed or optimized serialization required</td>
  </tr>
 </tbody>
</table><h3 id="why-use-externalizable">Why Use <code>Externalizable</code>?</h3><p><code>Externalizable</code> is ideal when:</p><ul>
 <li>You want <strong>fine-grained control</strong> over the serialized format.</li>
 <li>You need to <strong>optimize performance</strong> or <strong>minimize serialized data size</strong>.</li>
 <li>You want to <strong>exclude certain fields selectively</strong> without relying on <code>transient</code>.</li>
 <li>You want to <strong>serialize only parts of the object</strong> or include external resources.</li>
 <li>You need to maintain <strong>compatibility across different versions</strong> of a class by managing the serialized form explicitly.</li>
</ul><h3 id="implementing-the-externalizable-interface">Implementing the <code>Externalizable</code> Interface</h3><p>When a class implements <code>Externalizable</code>, it <strong>must</strong> provide implementations for both <code>writeExternal</code> and <code>readExternal</code>. The serialization runtime will not automatically serialize any fields.</p><h3 id="example-implementing-externalizable">Example: Implementing <code>Externalizable</code></h3><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-java">import java.io.*;

public class Person implements Externalizable {
    private String name;
    private int age;
    private transient String password; // will not be serialized

    // Mandatory no-arg constructor for deserialization
    public Person() {}

    public Person(String name, int age, String password) {
        this.name = name;
        this.age = age;
        this.password = password;
    }

    // Serialize object data manually
    @Override
    public void writeExternal(ObjectOutput out) throws IOException {
        out.writeUTF(name);   // Write name as UTF string
        out.writeInt(age);    // Write age as int
        // Intentionally exclude password for security
    }

    // Deserialize object data manually
    @Override
    public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {
        name = in.readUTF();
        age = in.readInt();
        // password remains null after deserialization
    }

    @Override
    public String toString() {
        return "Person{name='" + name + "', age=" + age + ", password='" + password + "'}";
    }
}</code></pre>
</div><h3 id="testing-serialization-and-deserialization">Testing Serialization and Deserialization</h3><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-java">public class ExternalizableTest {
    public static void main(String[] args) {
        Person person = new Person("Alice", 30, "secretPass");

        // Serialize to file
        try (ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream("personExt.ser"))) {
            oos.writeObject(person);
            System.out.println("Person serialized.");
        } catch (IOException e) {
            e.printStackTrace();
        }

        // Deserialize from file
        try (ObjectInputStream ois = new ObjectInputStream(new FileInputStream("personExt.ser"))) {
            Person deserializedPerson = (Person) ois.readObject();
            System.out.println("Deserialized: " + deserializedPerson);
        } catch (IOException | ClassNotFoundException e) {
            e.printStackTrace();
        }
    }
}</code></pre>
</div><p><strong>Output:</strong></p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-bash">Person serialized.
Deserialized: Person{name='Alice', age=30, password='null'}</code></pre>
</div><p>The password is not serialized because it was deliberately excluded in <code>writeExternal</code>.</p><h3 id="important-notes">Important Notes</h3><ul>
 <li><strong>No-arg Constructor Requirement:</strong> The class must have a <strong>public no-argument constructor</strong>. This constructor is called during deserialization before <code>readExternal</code>.</li>
 <li><strong>Complete Responsibility:</strong> The developer is fully responsible for writing and reading every field, including handling data types and order. Failing to do so causes corrupt or inconsistent data.</li>
 <li><strong>Versioning:</strong> Since you control serialization, you can design a custom versioning scheme (e.g., write a version number first) to maintain backward compatibility.</li>
 <li><strong>Security:</strong> You can exclude sensitive data, or even encrypt data during serialization.</li>
</ul><h3 id="when-to-prefer-externalizable">When to Prefer <code>Externalizable</code></h3><ul>
 <li>When you want <strong>full control</strong> over serialized data format for optimization or compliance with a protocol.</li>
 <li>When you want to <strong>exclude transient data explicitly</strong> or handle it in a custom way.</li>
 <li>When implementing <strong>custom serialization schemes</strong>, such as compressing or encrypting data.</li>
 <li>When working in environments where you need to <strong>interoperate with non-Java systems</strong> by defining your own serialization format.</li>
</ul><p>For typical use cases where default serialization suffices, <code>Serializable</code> is easier and less error-prone.</p><h3 id="recap">Recap</h3><ul>
 <li><code>Externalizable</code> extends <code>Serializable</code> but requires explicit implementation of <code>writeExternal</code> and <code>readExternal</code>.</li>
 <li>It offers <strong>total control</strong> over what and how an object is serialized.</li>
 <li>You must provide a <strong>no-argument constructor</strong>.</li>
 <li>Used for <strong>performance tuning</strong>, <strong>security</strong>, and <strong>custom serialization logic</strong>.</li>
 <li>It is more complex but powerful when the default <code>Serializable</code> mechanism is insufficient.</li>
</ul><div class = "chapter-navi-section">
<a href="#top" class="nav-button prev">↑</a>
<a href='java-io-and-nio.htm#advanced-java-io-concepts' class="nav-button toc-link">Index</a>
<a href="#bottom" class="nav-button next">↓</a>
</div>
<h2 id='piped-streams-for-inter-thread-communication'>4.4 Piped Streams for Inter-thread Communication</h2><p>In Java IO, <strong>piped streams</strong> provide a simple yet powerful mechanism for threads to communicate by sending data through a stream, similar to how one thread writes data that another thread reads. The classes <strong><code>PipedInputStream</code></strong> and <strong><code>PipedOutputStream</code></strong> are designed to work together to create a <strong>pipe</strong> — a one-way communication channel — between threads.</p><h3 id="what-are-piped-streams">What Are Piped Streams?</h3><ul>
 <li><strong><code>PipedOutputStream</code></strong> acts as the <strong>producer</strong> end, where data is written.</li>
 <li><strong><code>PipedInputStream</code></strong> acts as the <strong>consumer</strong> end, where data is read.</li>
 <li>These streams are connected such that bytes written to the <code>PipedOutputStream</code> are available to read from the connected <code>PipedInputStream</code>.</li>
</ul><p>This mechanism is analogous to a physical pipe: data flows in one end and emerges from the other.</p><h3 id="why-use-piped-streams">Why Use Piped Streams?</h3><ul>
 <li><strong>Thread communication:</strong> Piped streams are primarily used to connect two threads where one thread produces data and the other consumes it.</li>
 <li><strong>Data streaming:</strong> Unlike shared variables or queues, piped streams provide stream-based communication, making it suitable for IO-oriented workflows.</li>
 <li><strong>Decoupling:</strong> Producer and consumer threads can operate independently but remain synchronized through the pipe.</li>
</ul><h3 id="how-do-piped-streams-work">How Do Piped Streams Work?</h3><p>To establish a pipe:</p><ol>
 <li>Create a <code>PipedOutputStream</code>.</li>
 <li>Create a <code>PipedInputStream</code>.</li>
 <li>Connect them using the constructor or the <code>connect()</code> method.</li>
</ol><p>After connection, writing bytes to the <code>PipedOutputStream</code> makes those bytes available for reading from the <code>PipedInputStream</code>.</p><h3 id="thread-safety-and-synchronization">Thread Safety and Synchronization</h3><ul>
 <li>The piped streams <strong>internally synchronize</strong> data transfer between threads.</li>
 <li>However, the producer and consumer threads must handle their respective stream’s lifecycle properly.</li>
 <li>If the consumer reads faster than the producer writes, it will block waiting for data.</li>
 <li>If the producer writes faster than the buffer capacity, it will block until space becomes available.</li>
</ul><h3 id="example-producer-consumer-using-piped-streams">Example: Producer-Consumer Using Piped Streams</h3><p>The example demonstrates two threads:</p><ul>
 <li>A <strong>Producer</strong> thread writes messages to a <code>PipedOutputStream</code>.</li>
 <li>A <strong>Consumer</strong> thread reads messages from the connected <code>PipedInputStream</code>.</li>
</ul><div class="code-block"><button class="copy-button" onclick="copyCode(this)">📋</button>
 <pre><code class="language-java">import java.io.*;

public class PipedStreamExample {

    public static void main(String[] args) {
        try {
            // Create piped input and output streams and connect them
            PipedOutputStream pos = new PipedOutputStream();
            PipedInputStream pis = new PipedInputStream(pos);

            // Producer thread writes to PipedOutputStream
            Thread producer = new Thread(() -&gt; {
                try (PrintWriter writer = new PrintWriter(pos)) {
                    String[] messages = {"Hello", "from", "the", "Producer", "thread!"};
                    for (String msg : messages) {
                        writer.println(msg);
                        writer.flush(); // Ensure data is sent immediately
                        System.out.println("Producer sent: " + msg);
                        Thread.sleep(500); // Simulate delay
                    }
                } catch (InterruptedException e) {
                    System.err.println("Producer error: " + e.getMessage());
                }
            });

            // Consumer thread reads from PipedInputStream
            Thread consumer = new Thread(() -&gt; {
                try (BufferedReader reader = new BufferedReader(new InputStreamReader(pis))) {
                    String line;
                    while ((line = reader.readLine()) != null) {
                        System.out.println("Consumer received: " + line);
                    }
                } catch (IOException e) {
                    System.err.println("Consumer error: " + e.getMessage());
                }
            });

            // Start both threads
            consumer.start();
            producer.start();

            // Wait for threads to finish
            producer.join();
            // Closing the output stream signals end of data, consumer will exit read loop
            pos.close();
            consumer.join();

        } catch (IOException | InterruptedException e) {
            e.printStackTrace();
        }
    }
}</code></pre>
</div><h3 id="explanation-of-the-example">Explanation of the Example</h3><ul>
 <li><strong>Connection:</strong> The <code>PipedInputStream</code> is constructed with the <code>PipedOutputStream</code> as an argument, connecting the two.</li>
 <li><strong>Producer thread:</strong> Uses a <code>PrintWriter</code> wrapped around the <code>PipedOutputStream</code> to write strings line-by-line.</li>
 <li><strong>Consumer thread:</strong> Uses a <code>BufferedReader</code> wrapped around an <code>InputStreamReader</code> on the <code>PipedInputStream</code> to read lines.</li>
 <li>Both threads run concurrently; the consumer blocks waiting for input when none is available.</li>
 <li>The producer flushes the writer after each message to ensure data is sent promptly.</li>
 <li>When the producer finishes, it closes the <code>PipedOutputStream</code>. This causes the consumer’s read loop to terminate since <code>readLine()</code> returns <code>null</code> on end-of-stream.</li>
 <li>Proper exception handling captures IO errors or interruptions.</li>
 <li>The main thread waits for both threads to complete using <code>join()</code>.</li>
</ul><h3 id="benefits-and-limitations">Benefits and Limitations</h3><p><strong>Benefits:</strong></p><ul>
 <li>Provides a direct, stream-based communication channel between threads.</li>
 <li>Useful for decoupling producer-consumer workflows.</li>
 <li>Easy to use with existing stream-based APIs.</li>
</ul><p><strong>Limitations:</strong></p><ul>
 <li>Only supports one-way communication per pair of piped streams.</li>
 <li>Buffer size is fixed internally (default 1024 bytes); can block if buffer fills or empties.</li>
 <li>Not suitable for high-performance or complex thread coordination; consider using higher-level concurrency utilities (e.g., <code>BlockingQueue</code>) for complex scenarios.</li>
 <li>Can be prone to deadlocks if not managed carefully (e.g., both threads waiting on each other).</li>
</ul><h3 id="best-practices">Best Practices</h3><ul>
 <li>Always <strong>connect</strong> <code>PipedInputStream</code> and <code>PipedOutputStream</code> before use.</li>
 <li>Use <strong>try-with-resources</strong> or explicitly close streams to avoid resource leaks.</li>
 <li>Properly <strong>handle exceptions</strong> in both producer and consumer threads.</li>
 <li>Avoid long blocking operations while holding the pipe to prevent deadlocks.</li>
 <li>Consider buffer size adjustments by using the constructor <code>PipedInputStream(int pipeSize)</code> if necessary.</li>
 <li>For <strong>bidirectional communication</strong>, use two pairs of piped streams or higher-level constructs.</li>
</ul><h3 id="recap">Recap</h3><ul>
 <li><code>PipedInputStream</code> and <code>PipedOutputStream</code> allow one thread to send data directly to another using a stream.</li>
 <li>They enable simple inter-thread communication using standard IO stream paradigms.</li>
 <li>The producer writes bytes; the consumer reads those bytes, synchronized by the underlying pipe buffer.</li>
 <li>Proper connection, synchronization, and resource management are essential to avoid deadlocks and errors.</li>
 <li>Piped streams are ideal for lightweight producer-consumer scenarios but less suited for complex concurrency.</li>
</ul><div class = "chapter-navi-section">
<a href="#top" class="nav-button prev">↑</a>
<a href='java-io-and-nio.htm#advanced-java-io-concepts' class="nav-button toc-link">Index</a>
<a href="#bottom" class="nav-button next">↓</a>
</div>
<h2 id='pushbackinputstream-and-mark-reset-methods'>4.5 PushbackInputStream and Mark/Reset Methods</h2><p>Java IO streams provide versatile tools for reading data sequentially. However, in some scenarios—such as parsing or processing complex data formats—you may need the ability to <strong>“unread”</strong> bytes or <strong>go back</strong> to a previously read position in the stream. This is where <strong><code>PushbackInputStream</code></strong> and the <strong><code>mark()</code> / <code>reset()</code></strong> methods come into play.</p><h3 id="what-is-pushbackinputstream">What is <code>PushbackInputStream</code>?</h3><p><code>PushbackInputStream</code> is a subclass of <code>FilterInputStream</code> that allows you to <strong>push bytes back</strong> into the input stream, effectively “unreading” them. This is especially useful in parsing scenarios where you read ahead some bytes to decide how to process them but realize that some of those bytes belong to the next data unit.</p><h3 id="how-does-pushbackinputstream-work">How Does <code>PushbackInputStream</code> Work?</h3><ul>
 <li>When you read bytes normally, they are consumed and lost from the stream.</li>
 <li>With a <code>PushbackInputStream</code>, you can call the <code>unread()</code> method to push one or more bytes back into an internal buffer.</li>
 <li>The next read operations will first consume the bytes in the pushback buffer before reading new bytes from the underlying stream.</li>
</ul><h3 id="common-use-case-lookahead-in-parsing">Common Use Case: Lookahead in Parsing</h3><p>Imagine reading a stream where the next few bytes determine how to interpret the data, but you do not want to lose these bytes permanently if you decide to process them differently. <code>PushbackInputStream</code> lets you peek and then push bytes back so they can be reread.</p><h3 id="example-using-pushbackinputstream">Example: Using <code>PushbackInputStream</code></h3><div class="code-block"><button class="copy-button" onclick="copyCode(this)">📋</button>
 <pre><code class="language-java">import java.io.*;

public class PushbackExample {
    public static void main(String[] args) throws IOException {
        byte[] data = { 'a', 'b', 'c', 'd' };
        ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(data);
        PushbackInputStream pushbackInputStream = new PushbackInputStream(byteArrayInputStream);

        int firstByte = pushbackInputStream.read();
        System.out.println("Read byte: " + (char) firstByte); // Output: a

        int secondByte = pushbackInputStream.read();
        System.out.println("Read byte: " + (char) secondByte); // Output: b

        // Decide to "unread" the second byte
        pushbackInputStream.unread(secondByte);
        System.out.println("Pushed back byte: " + (char) secondByte);

        // Read again, should get the same byte
        int rereadByte = pushbackInputStream.read();
        System.out.println("Reread byte: " + (char) rereadByte); // Output: b

        pushbackInputStream.close();
    }
}</code></pre>
</div><p><strong>Output:</strong></p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-bash">Read byte: a
Read byte: b
Pushed back byte: b
Reread byte: b</code></pre>
</div><h3 id="important-notes-about-pushbackinputstream">Important Notes About <code>PushbackInputStream</code></h3><ul>
 <li>The constructor can take a <strong>pushback buffer size</strong>, allowing multiple bytes to be pushed back. The default size is 1 byte.</li>
 <li>Attempting to unread more bytes than the buffer size causes an <code>IOException</code>.</li>
 <li>It works only for <strong>byte streams</strong> (<code>InputStream</code>), not character streams (<code>Reader</code>).</li>
</ul><h3 id="the-mark-and-reset-methods">The <code>mark()</code> and <code>reset()</code> Methods</h3><p>While <code>PushbackInputStream</code> lets you “unread” bytes, many streams support <strong>marking a position</strong> and later <strong>resetting</strong> the stream back to that position, allowing multiple bytes to be reread without pushing them back individually.</p><h3 id="how-mark-and-reset-work">How <code>mark()</code> and <code>reset()</code> Work</h3><ul>
 <li>Calling <strong><code>mark(int readlimit)</code></strong> tells the stream to remember the current position and keep a buffer of up to <code>readlimit</code> bytes for possible reset.</li>
 <li>Later, calling <strong><code>reset()</code></strong> resets the stream back to that marked position.</li>
 <li>This is useful for lookahead or tentative reading: you can read ahead, and if needed, rewind to the mark to reread or discard.</li>
</ul><h3 id="which-streams-support-mark-reset">Which Streams Support mark/reset?</h3><ul>
 <li>Not all input streams support <code>mark</code> and <code>reset</code>.</li>
 <li>To check, call <code>markSupported()</code>; if it returns <code>true</code>, you can safely use <code>mark()</code> and <code>reset()</code>.</li>
 <li>Common supporting streams include <code>BufferedInputStream</code>, <code>ByteArrayInputStream</code>, and many readers like <code>BufferedReader</code>.</li>
</ul><h3 id="example-using-mark-and-reset">Example: Using mark() and reset()</h3><div class="code-block"><button class="copy-button" onclick="copyCode(this)">📋</button>
 <pre><code class="language-java">import java.io.*;

public class MarkResetExample {
    public static void main(String[] args) throws IOException {
        byte[] data = { 'x', 'y', 'z' };
        ByteArrayInputStream bais = new ByteArrayInputStream(data);
        BufferedInputStream bis = new BufferedInputStream(bais);

        System.out.println("Read: " + (char) bis.read()); // x

        if (bis.markSupported()) {
            bis.mark(10); // mark current position with a buffer limit
            System.out.println("Read after mark: " + (char) bis.read()); // y
            System.out.println("Read after mark: " + (char) bis.read()); // z

            bis.reset(); // reset to marked position
            System.out.println("After reset: " + (char) bis.read()); // y (again)
        }

        bis.close();
    }
}</code></pre>
</div><p><strong>Output:</strong></p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-bash">Read: x
Read after mark: y
Read after mark: z
After reset: y</code></pre>
</div><h3 id="use-cases-for-mark-reset">Use Cases for mark/reset</h3><ul>
 <li><strong>Parsing protocols or file formats</strong> where you need to peek ahead without losing data.</li>
 <li><strong>Conditional processing</strong>, where you read a segment to decide on a strategy, then rewind.</li>
 <li>Implementing <strong>tokenizers</strong> or <strong>lexers</strong> that require lookahead.</li>
 <li>Avoids manual pushback when multiple bytes need to be reread.</li>
</ul><h3 id="comparing-pushback-and-mark-reset">Comparing Pushback and mark/reset</h3><table>
 <thead>
  <tr>
   <th>Feature</th>
   <th><code>PushbackInputStream</code></th>
   <th><code>mark()</code> / <code>reset()</code></th>
  </tr>
 </thead>
 <tbody>
  <tr>
   <td>Usage</td>
   <td>Manually unread bytes</td>
   <td>Mark and rewind stream position</td>
  </tr>
  <tr>
   <td>Buffer Size</td>
   <td>Fixed buffer size specified in constructor (default 1)</td>
   <td>Managed internally by the stream, up to readlimit</td>
  </tr>
  <tr>
   <td>Flexibility</td>
   <td>Precise byte-level unread</td>
   <td>Allows rewinding to a mark position</td>
  </tr>
  <tr>
   <td>Stream Support</td>
   <td>Only byte streams (<code>InputStream</code>)</td>
   <td>Depends on stream; many support it</td>
  </tr>
  <tr>
   <td>Typical Use</td>
   <td>Single or few bytes lookahead/unread</td>
   <td>Larger lookahead with automatic rewind</td>
  </tr>
 </tbody>
</table><h3 id="recap">Recap</h3><ul>
 <li><strong><code>PushbackInputStream</code></strong> allows unread bytes to be pushed back into the stream for subsequent re-reading, useful for simple lookahead or correcting read decisions.</li>
 <li><strong><code>mark()</code> and <code>reset()</code></strong> let you mark a stream position and rewind to it later, enabling flexible multi-byte lookahead and reprocessing.</li>
 <li>Both are essential tools in building parsers, tokenizers, and protocols requiring conditional reading.</li>
 <li>Always check <code>markSupported()</code> before using <code>mark/reset</code>.</li>
 <li>Use <code>PushbackInputStream</code> when you want explicit unread control with a small buffer; use <code>mark/reset</code> for more extensive or automatic rewind functionality.</li>
</ul><div class = "chapter-navi-section">
<a href="java-io-and-nio-file-and-directory-operations.htm" class="nav-button prev">←</a>
<a href='java-io-and-nio.htm#advanced-java-io-concepts' class="nav-button toc-link">Index</a>
<a href="java-io-and-nio-introduction-to-java-nio-new-io.htm" class="nav-button next">→</a>
</div>
<section class="download-section">
  <div class="book-cover" style="background-color: #f9f6f1;border: 1px solid #ccc;"> 
    <div class="book-cover-title" style="font-size: 18px;color: #333;top: 20px;">Java IO and NIO</div>
    <div class="book-cover-author">readbytes</div>
    <div class="book-cover-bottom-stripe" style="background-color: #333;"></div>
    <img class="book-cover-icon" style="width: 80px;height: 90px;top: 60px;" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFoAAABaCAYAAAA4qEECAAADAElEQVR4Xu2Zu6oTURSGjze0UfANtLAUzgOI4DOItc+VKk1uJ12aadNa21vbCpYK4wQmcPiYzL5k7eXM2f8HP0JYa/3ZX2PEmxshxAPi7u6uLRH2VA3lWId9VdK27WOKsQ47q6RpmucUYx12VolEOyHRToyJ5mwI7ufeeZBItBMS7YREOyHRTki0ExLthEQ7IdFOSLQTEu2ERDsxJtoq7KwSiXZCop04Ho9PKcY67KwWirEO+6qGcqzCHhGBJDoh0U5ItAP7/f6bRDtAyV3+ckYYQNHr9fo1Z8SVtG37iKI5Mzv4IKuwJwXeuvbef4ePsQ77YuGdLp85MysGHmQa9sXAG7l3JgUfZB32heh+0t3yRvfZD87NDj7KOuwLwf2cG5OEj7IO+8bg7imr1eoV55Lh0VC4bwE7cru4n3Jns9l85d7YPmdCSV8oADtyu7gfe4fzMbucCyV9oQDsyO3i/tid7i+395xjuHMfzoaSvlAAduR2cf/+ne7PT/x8JL94mwzsjCZ5wTN8XAjuTynT/nKJcH9KmfaXS4T7U8q0v1wi3J9Skr8cH3cJ7l3I98Ph8HLg86SuM9zPvRMDO0JJXwjQ/Wx6yx3kI3cGZqK6CPdz78TAjlDSF0ZYLpcvOH9O0zQX/xnL2ZiuIbifeycGdoSSvjACZ2N2TnA+do9wP/dODOwIhfvZ8HCfn5wbYmDPNOybLXxYn9+cu8TArmnYN1v4sNTHcdc67JslfFTOw7hvHfbNEj6q+3n3gTMheMM67JsdfNA1j+Idq7BnlvBR2+32DWfElazX63cUzRlhACVLdCEk2QmJdmC3232RaAcoucsfzogAAxJNwp6qoRzrsK9aKMY6i8XiGTurhGKsc/ofGHZWCcVYR6J7KMY6Et1DMedwLgT3JRpQjEQXgmIkuhAUI9GFoBiJLgTFSHQhKEaiC0ExEl0IipHoQlCMRBeCYiS6EBQj0YWgGOtIdA/FWEeieyjGOhLdQzHW2e/3T9hZJRRjHfZVDeVYhT1CiDnzD27IzgFe/xOvAAAAAElFTkSuQmCC"/>
  </div>
  <div class="download-info">
    <h2 id='bottom'>Download This Ebook</h2>
    <p class="format-label">Available formats:</p>
    <div class="download-buttons">
      <a href="java-io-and-nio.pdf" class="download-button">📄 PDF</a>
      <a href="java-io-and-nio.epub" class="download-button">📘 EPUB</a>
    </div>
  </div>
</section><div class='related-books'>
<h2>Java In-Depth Books</h2>
<div class='related-book-list'>
<a href="java-io-and-nio.htm">
<div class="book-cover" style="background-color: #f9f6f1;border: 1px solid #ccc;"> 
    <div class="book-cover-title" style="font-size: 18px;color: #333;top: 20px;">Java IO and NIO</div>
    <div class="book-cover-author">readbytes</div>
    <div class="book-cover-bottom-stripe" style="background-color: #333;"></div>
    <img class="book-cover-icon" style="width: 80px;height: 90px;top: 60px;" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFoAAABaCAYAAAA4qEECAAADAElEQVR4Xu2Zu6oTURSGjze0UfANtLAUzgOI4DOItc+VKk1uJ12aadNa21vbCpYK4wQmcPiYzL5k7eXM2f8HP0JYa/3ZX2PEmxshxAPi7u6uLRH2VA3lWId9VdK27WOKsQ47q6RpmucUYx12VolEOyHRToyJ5mwI7ufeeZBItBMS7YREOyHRTki0ExLthEQ7IdFOSLQTEu2ERDsxJtoq7KwSiXZCop04Ho9PKcY67KwWirEO+6qGcqzCHhGBJDoh0U5ItAP7/f6bRDtAyV3+ckYYQNHr9fo1Z8SVtG37iKI5Mzv4IKuwJwXeuvbef4ePsQ77YuGdLp85MysGHmQa9sXAG7l3JgUfZB32heh+0t3yRvfZD87NDj7KOuwLwf2cG5OEj7IO+8bg7imr1eoV55Lh0VC4bwE7cru4n3Jns9l85d7YPmdCSV8oADtyu7gfe4fzMbucCyV9oQDsyO3i/tid7i+395xjuHMfzoaSvlAAduR2cf/+ne7PT/x8JL94mwzsjCZ5wTN8XAjuTynT/nKJcH9KmfaXS4T7U8q0v1wi3J9Skr8cH3cJ7l3I98Ph8HLg86SuM9zPvRMDO0JJXwjQ/Wx6yx3kI3cGZqK6CPdz78TAjlDSF0ZYLpcvOH9O0zQX/xnL2ZiuIbifeycGdoSSvjACZ2N2TnA+do9wP/dODOwIhfvZ8HCfn5wbYmDPNOybLXxYn9+cu8TArmnYN1v4sNTHcdc67JslfFTOw7hvHfbNEj6q+3n3gTMheMM67JsdfNA1j+Idq7BnlvBR2+32DWfElazX63cUzRlhACVLdCEk2QmJdmC3232RaAcoucsfzogAAxJNwp6qoRzrsK9aKMY6i8XiGTurhGKsc/ofGHZWCcVYR6J7KMY6Et1DMedwLgT3JRpQjEQXgmIkuhAUI9GFoBiJLgTFSHQhKEaiC0ExEl0IipHoQlCMRBeCYiS6EBQj0YWgGOtIdA/FWEeieyjGOhLdQzHW2e/3T9hZJRRjHfZVDeVYhT1CiDnzD27IzgFe/xOvAAAAAElFTkSuQmCC"/>
  </div>
</a>


<a href="java-collections.htm">
<div class="book-cover" style="background-color: #f9f6f1;border: 1px solid #ccc;"> 
    <div class="book-cover-title" style="font-size: 18px;color: #333;top: 20px;">Java Collections</div>
    <div class="book-cover-author">readbytes</div>
    <div class="book-cover-bottom-stripe" style="background-color: #333;"></div>
    <img class="book-cover-icon" style="width: 80px;height: 90px;top: 60px;" src='data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFoAAABaCAYAAAA4qEECAAADAElEQVR4Xu2dQYrUUBRFIw50JI7FrYgrcAPOXYPORHci7sah4EAQFyA6dNKosZK2Ee8/dOclP7/+i/fAmaR+Xr17KehJV2oYjDHGGGM6YRxzmgZdPKvdMt4vl03vLU15ZsYnsORB7Apd7mh2gS51VM/K+LVc6LA+0/QNKZax9RnvlG+C/tI7+6PYuYLV0MHoc72rX8ZvsP9Gq6BDyWzo/jXcjA4sfKN39E+RoYaf9F2CFAPFjGiG3b0Y5r9111LcJGZEM7QW0UNqRjTDWXwQXCojmoEk9MxmHwWGZ0QzkMT4ujy31b/D4UU8uITp/J4uRDOQxPiyPFfDy+HwQnFoCdPZFi5AM5BE/0VP51r5brgRzUASexU9/piG60VxEdO5lt6AZiCJ3Yoep+Fw8Z8DS5gHNfLncCOagSSWFE2M38tzanFBXcS9k/OwBi5AM5DE2qIn9JxaXFAXM33S5oE7+nFYhGYgiRxFX7FH4V+GEJqBJHIV3QGagSRcdBDNQBIuOohmIAkXHUQzkISLDqIZSMJFB9EMJOGig2gGknDRQTQDSbjoIJqBJHIUfffkPLCC74dNaAaSyFH0PKyiL4bVaAaS6L/oedAOrkQzkISLDqIZSMJFB9EMJNF/0bdPzsMquxLNQBL9Fz3x4eQ8sJIb0AwkkaPoK56efLvSV0MVNANJ5Cq6AzQDSbjoIJqBJFx0EM1AEi46iGYgCRcdRDOQhIsOohlIwkUH0Qwk4aKDaAaScNFBNANJuOggmoEkXHQQzUASLjqIZiAJFx1EM5CEiw6iGUjCRQfRDCSxtuh2X63oDM1AEkuKXmtxQc2IZiCJ3Yqu9vW3ztAMJLFX0ZfD4YXiUDI0A0m46CCagSTyfOm+EzQDSeiZzT4ODM+IZjiLD4NLZUQztBbRQ2pGNMPu1nh4lR/H9sfP+i5BioFgNnT/Gm5GB6Ib/im8Nf0+MtMPgb3Wquhwqw1Vwg/qbkix0EHtAl3qaHaDfx6kIf7Bm8YUyyY1Dbp4Fo0xxhhj/kd+A/PkOH57kF8HAAAAAElFTkSuQmCC'/>
  </div>
</a>


<a href="java-regex.htm">
<div class="book-cover" style="background-color: #f9f6f1;border: 1px solid #ccc;"> 
    <div class="book-cover-title" style="font-size: 18px;color: #333;top: 20px;">Java Regex</div>
    <div class="book-cover-author">readbytes</div>
    <div class="book-cover-bottom-stripe" style="background-color: #333;"></div>
    <img class="book-cover-icon" style="width: 80px;height: 90px;top: 60px;" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFoAAABaCAYAAAA4qEECAAAFo0lEQVR4Xu2d3WscVRiH+y/YXuuFkov6H9je2huvlAQvFalCEW8qiFRFQcGrmoJ4U5TSLWglFqRIlJqCH6XWalM/0lrT1O1ukt3sV5qPTZrP3XHfLTM983vPztc5s+zZPQ88N5l3Z9inwzA70Dl79iQks29oM7N3yBkoW98ZO6RC62ANdvDBtYF9lJEcxHNi+CWnOvmXs5rN9aX03eg74vcWxV6xObX3iUdxp2P7DzqDztiTB1lsaoX9InF631BJ3NH408N4vIFn/NCwL/aZVjPsGAj+a1mCwV7YUwqeyZZoxDqz8ZpsiYfY7mzQNdtGVkdsiH3b2Mj6CIztbrB3F+qMHxqRh84Iv/gsehDO6oe/IN0/ju0/gPOWhNAPO3ZW27M5HXyhTwtP4Sx68S4f9NRPuJbgnEURsa0Xmp5QWfQyMfLwqZ8XunrtT5yzKEKPWFnoem4O5xKxsVbS5vbmMu7eKOr5OUnovHro1ep0KppKPT+vP/TGWpkF0qWp2NBdwobuEjY0MnXbcb4cd5xCGbco0XOhb8wuOhdnGp4//7fl254ah9/urAZ6KrQYGL01V0sndLPJw8pUxJjQ5OXsBh5KjVZjFjRIBXoqdKWcZXHRK/kGHi45GDJMBXoqNFku3WVx0V9nNcTGiK7nLgRvT0jPhSZLacfGeK7Xb4bPJaQnQz+InWNx0USXEQzn+vsUTvKZfgxNFhfyLC4a68x+7QMejrwieVqJM+QX3+BUZHo6NDlfnGNx0auzdPsQAQxHXprEKT7jqkDPhyZni/MsLhopNoY7kcEJPuN6bBQnY2FEaDJXLLC4aGhsjIfgdtdX3sHJ2BgTmswVwmMHXrMxoBgb/+76snpkwqjQZKnusLhox7uRryd4yDA1YVxoYmG1yeKi0jP7nzs8ZJAaMTI0UVhJEPvN4zxmJzVjbGhidik8tu8ygjE7mQJGha7XZvBQTnYxPHb7zF6o8qAyU8KY0Gv37uJhPGZq4bEXpnI8KpoiRoTe3lzBQzCmq51j59aabSu/3OBxSU23cEH0fOgHT+ej8W+Fx3Yju9YuXO16ZCKV0DvVSWfrzlnm+tyP/pCVW2xGNAlibIzsunT+p65GJroamhRD4zbVyC7TFR4XXf7qIn4sVVIJ3bj9meNce0OqGLM5+Rbb7jMhePmQWXzqWWf15Of40dRIJfTmwmV2hiY1LhhUJkV2Xfn4FO4iFXo+NBkVDCpTjOzFPvEp7ko7RoQmw8CgMjGw6PJourGNCU12AoPKXHpvlMVFl4+fxF1rw6jQJIJBZbpgWJnLH34i7F0fxoamnzEYVKZI6ZkXWViZS+9+5PucDowNjUFlIlt/3GRRO7n4+vv4cSWMDI1BZcpYP/89Cxpk7cgx3EVijAuNQWV2AkOSbZpN9nfX6uHkP5xE+i50EBgRwe1e7BeO4mhs+ip0GBjw/nc/4AibCZqNQ9+EjgLGI50G/yzOeLMK9EXoqBQPPMfixYm9cek3HIuM8aHjgvFcmzs7OMpm2v8oCTE6dBJ2q/dYPC/29rZvFrcPZGgVdss1FtCLvX6/PVN5/lW2beBC62C3VGURw2z/D66EGBdaJ7vFMosZpAoDHZqIGluVgQ/dJuAnuI7IhA0NVEaOtOMuHrVP74zEhu4SNnSXkIdWfHnVbr3AAunSVOjkZaF1vI4NA+nQZKSvY7MvGNSP9AWDpEUvYlv7EtgU8UK7Sz/Z0Ongnc34/mi7apA+xNWHxND21fOa8S4buHiZu4GWJbKo8W2nxRTE0PasVkdsiZ3b2NjqhEYmaNkhGzs5Yrszjzz+GPb1QQtq2djxEZu17pvL2FWK70M2dijYC3sGgmc2LUtk8SPeXcQ6kxFcdo+kG/FBR+tSqCK4U1F6QlW7/rezms33pfTdxKdwMrGXMhm7XLWo/uWqZdgF2OPxPxXwJpKIkhiiAAAAAElFTkSuQmCC"/>
  </div>
</a>


<a href="java-functional-programming.htm">
<div class="book-cover" style="background-color: #f9f6f1;border: 1px solid #ccc;"> 
    <div class="book-cover-title" style="font-size: 18px;color: #333;top: 20px;">Java Functional Programming</div>
    <div class="book-cover-author">readbytes</div>
    <div class="book-cover-bottom-stripe" style="background-color: #333;"></div>
    <img class="book-cover-icon" style="width: 80px;height: 80px;top: 80px;" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFoAAABaCAYAAAA4qEECAAADzUlEQVR4Xu2bO4sUURCFlxVBzfwLJkb+A1MxEgMRDBQDRTBRwchARk00MRFBAwNBzEQwMBfEBz7wbWIkiIGJoInio9wZdmZ7T1V3V91bPVhaH3xJ973n3jk2vdO968JCkiRJkiRRIYphWOgI/zB/uyHBDxHFUODmIxkK3HwkQ4Gbj2QY6BDffCTDgBuPZhhw49EMA248miGgW3zj0QwBbjqiIcBNRzQEuOlohoA+8Y1HMgy4cauJEizO5EZMS0RoUSjPYKIEi7OaKMHirCZKsDiTi5iWiNAmoTyDiRIszmqiBIsz+QXTklZYeQYTJXSUl2cxUYLFWU2UYHEmb2Na0gorz2CihJ7w8iwmSrA4q4kSLM7kYUxLWmHlGUyU0C9ensVECRZnNQS4abPPMNEOy7S4BdN00L5GxmU8q4cuNXL24tll2KYrLIXW8yyLJdAJnkP3cFQ/9FzIGeEgHOBgCZhh1Qod5xkzH+PoduiVMH/qqDkQT3q4trGAEpZh1AId4/OZb3EWh14K89DRdDCecNIKzjdp+IelHcL8Nj/g7BU6r2R0+3gCHvRyN26tHdoszDdoAef2KpQt3pN7ZAc81YLzrFrAuSrfNOY/Es4rZAdcfbCywS7YPIvfMa0buiBkaFz6ATn+POy4xmvjhfGgsxpwjsUSigsr8el0UTzh7c9Vn5FBe4Q5BkuZXKFCnqsPmwviyQHsAsdarWF8tWGem/dxMRwwkG3gOJMvMM1O7S8aRJtX8hQ2aCDbwHEWvXAte3pPlmCDBxKhK3yMRU9cbiOKp0k+aQg3+K7pTdUPyHeYVgELL9At7/zqLA9KH0YmNh5qqqHPwgJWLzby8JxBb1y+Wxve+vXCwguc5Lzmxy164lLy1IL32SJ0Qwi3+k04ZtSLqttFm3dxlUJY8Lzdijsqo+QtnFqPK5u2CcFz1APT++RSPe7ZLHSO1qL6zYiXmu/WXdAaIXRO1lD8mnSpsOKHmpu4CyMscB5W/m8rlqex8TBS+lBTDQYObS2Y16vwxFfydbAaDBzaWmgXz2y14/46fg3Kxre5E2cXwoKH8geuXIb4hzNo11u4ZVRX9kmcVQELH0hP6BTPnym9T26h8559Gkc7wBYZQG/oLF+D/WZEgfht5AyOcoLeC4s5OwR0oLHGVTyrh643cvbjWWewGFc/4mr/MXRQKMjJBMCCvEwAWsdL8jARwJKqvYMrJDNYWRUmHWBZNSY9YGGlJj1gYUWew9REhBVnNFFCX3l5FhMDWJ7WpAAssc+kAiyzzcQJLHbibxyVJEmSJMk/xB+4wdarC+OVAQAAAABJRU5ErkJggg=="/>
  </div>
</a>


<a href="java-streams.htm">
<div class="book-cover" style="background-color: #f9f6f1;border: 1px solid #ccc;"> 
    <div class="book-cover-title" style="font-size: 18px;color: #333;top: 20px;">Java Streams</div>
    <div class="book-cover-author">readbytes</div>
    <div class="book-cover-bottom-stripe" style="background-color: #333;"></div>
    <img class="book-cover-icon" style="width: 80px;height: 80px;top: 60px;" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFoAAABaCAYAAAA4qEECAAACbklEQVR4Xu3cP4oUQRiG8S8xEzESDI1MPIRHEQQPYTK9iCyewMxrGIiCoaFnWFkMTIwUxD894KI8VbNdVdNfzdR87w+eRKa2ul+WVZM1G8+3ud+d+mhBvbZ0DO/uWEAcoVfhcIBehcQRvAvt1dz7gjjaVfxcrhcmxTiwvkudcGAN7YQDa2gnHFhDO+HAGtoJB24ZmmdzhcdBWobh2VzhcZCWYXg2V3gcpGUYns0VHgdpGYZnc4XHQVqG4dlc4XGQlmF4Nld4HKRlGJ7NFR4HaRmGZ3MN48Hcu7lLS19ihI7SPUsfdPSOCh/ulDoKfKhT7KC2P3P5QKfawfBBTr2D4ENEqDs+QJS64uWR6ubc0ssj1Q0vjlYXvLS1X3Mv5x7NPTyi+Jy5uuClNY2Az5zL3RtLLy1pJHz2XO544VLbHw+j4TvkcscLlxoR3yGXO154XaPie+Ry9djSC69rVHyPXK62/xTjhbu6+HtmRHyXXK6iDH1wGroTDd2Jhu5EQ3eioTvR0J1o6E40tAMOt1YCHGitBDjQWglwoLUS4EBrJcCB1kqAA62VwFOnREREROSIPbP7/CNZ28Y+2KT/hPjbjnyVOPl/ZA3tZLLzZGiN7YAD/+smPyqt0nH1Xe2Cw7LndpdHpBZH3ZXs4YndSAbdleyBYy4ljTjkUtKAI5a0sS/8MrKEI5YmFTZ2mQxYmlTgeDVt7DO/nOzC8WqTApPdSoarTQpM9ikZrjYpMNmPZLjapMDZ/JcZh6tNCkx2OxmuNinE4WraDPnbZw5ksp/JgKVJJQ5YmjTgiEvJHib7mgyaS1Yy2dtk3DP7zo9F9wfJyGVFhM8g5gAAAABJRU5ErkJggg=="/>
  </div>
</a>



<a href='java.htm'><div class='book-cover' style='background-color: #f9f6f1;color: #111111;border: 1px solid #ccc;display: flex;justify-content: center;align-items: center;text-align: center;'>More Java Books</div></a>
</div>
</div>
  </div>
  <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/prism.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
  
  <script>
    function copyCode(button) {
      const code = button.nextElementSibling.innerText;
      navigator.clipboard.writeText(code).then(() => {
        button.textContent = 'Copied!';
        setTimeout(() => { button.textContent = 'Copy'; }, 1500);
      });
    }
  </script>  
<div id="floatingLog" aria-live="polite" role="alert"></div>
<footer class="page-footer">
    <nav>
      <a href="https://readbytes.github.io">Home</a> | 
      Email:<script language="JavaScript" type="text/javascript">
var part1 = 'yinpeng';var part6 = '263';var part2 = Math.pow(2,6);var part3 = String.fromCharCode(part2);var part4 = 'hotmail dot com';var part5 = part1 + String.fromCharCode(part2) + part4;document.write(part1 + part6 + part3 + part4);
</script>
    </nav>
  <p>© 2025 — All rights reserved.</p>    
  </footer>

</body>
</html>