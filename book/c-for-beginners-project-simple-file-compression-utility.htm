<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>C for Beginners Project: Simple File Compression Utility</title>
<link rel='shortcut icon' href='https://java2s.com/style/favicon.ico'>
<link href="https://fonts.googleapis.com/css2?family=Merriweather&display=swap" rel="stylesheet" />
<link href="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet" />


  <script>
  const mode = localStorage.getItem('mode') || 'light';
  document.documentElement.classList.add(`${mode}-mode`);
  </script>   
<style> 
html {
  scroll-behavior: smooth;
}

body {
  font-family: 'Merriweather', serif;
  margin: 0;
  padding: 2rem 1rem;
  font-size: 15px;
  line-height: 1.5;
  transition: background-color 0.3s, color 0.3s;
}

.container {
  max-width: 700px;
  margin: 0 auto;
  padding: 1rem 2rem;
  box-shadow: 0 0 15px rgba(0,0,0,0.1);
}

h1, h2, h3 {
  font-weight: 600;
  margin-top: 2.5rem;
  margin-bottom: 1rem;
  line-height: 1.2;
}

h1 { font-size: 1.8rem; }
h2 { font-size: 1.4rem; }
h3 { font-size: 1.2rem; }

table {
  width: 100%;
  border-collapse: collapse;
  font-family: sans-serif;
  font-size: 1em;
  margin: 1em 0;
}

th, td {
  padding: 0.6em 1em;
  text-align: left;
  border: 1px solid;
}

tr:nth-child(even) {
  background-color: inherit;
}

tr:hover {
  background-color: inherit;
}

a {
  text-decoration: none;
  transition: color 0.2s;
}

a:hover {
  text-decoration: underline;
}

code {
  color: #d35400;
}

.book-title-chapter {
  font-family: 'Merriweather', serif;
  font-size: 2rem;
  font-weight: bold;
  text-align: center;
  margin-bottom: 2rem;
  border-bottom: 2px solid;
  padding-bottom: 0.5rem;
}

.book-subtitle-chapter {
  text-align: center;
  font-size: 1rem;
  margin-top: -1rem;
  margin-bottom: 2rem;
}

.related-books {
  margin-top: 40px;
}

.related-book-list {
  display: flex;
  flex-wrap: wrap;
  gap: 20px;
}

    .book-cover {
      width: 130px;
      height: 180px;
      font-family: Arial, sans-serif;
      position: relative;
      overflow: hidden;      
      line-height: normal;
      box-shadow: 2px 2px 4px rgba(0,0,0,0.1);
    }
    .book-cover-bottom-stripe {
      position: absolute;
      bottom: 0;
      left: 0;
      height: 5px;
      width: 100%;
    }
    .book-cover-title {
      position: absolute;
      width: 100%;
      text-align: center;
      font-weight: bold;
    }
     
    .book-cover-icon {
      position: absolute;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      align-items: center;
      justify-content: center; 
    }

    .book-cover-author {
      position: absolute;
      bottom: 10px;
      width: 100%;
      text-align: center;
      font-size: 8px;
      color: #333;
    }

.page-footer {
  margin-top: 4rem;
  padding: 1rem 0;
  text-align: center;
  font-size: 0.85rem;
  border-top: 1px solid;
}

.chapter-navi-section {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding-bottom: 10px;
}

.nav-link {
  color: inherit;
  text-decoration: none;
  opacity: 0.5;
  transition: opacity 0.3s ease, text-decoration 0.3s ease;
}

.nav-link:hover {
  opacity: 0.9;
  text-decoration: underline;
}

.prev { text-align: left; }
.toc-link { text-align: center; }
.next { text-align: right; }

.download-section {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 2rem;
  padding: 2rem 1rem;
  max-width: 600px;
  margin: 3rem auto;
  border-radius: 12px;
  box-shadow: 0 4px 10px rgba(0,0,0,0.05);
}

.download-info h2 {
  margin: 0 0 0.5rem;
  font-size: 1.2rem;
}

.format-label {
  margin: 0 0 0.5rem;
  font-size: 0.95rem;
}

.download-buttons {
  display: flex;
  gap: 1rem;
}

.download-button {
  background-color: #4A90E2;
  color: white;
  padding: 0.5em 1.2em;
  border-radius: 25px;
  font-size: 0.95rem;
  text-decoration: none;
  transition: background-color 0.3s ease;
}

.download-button:hover {
  background-color: #357ABD;
}

.code-block {
  position: relative;
  margin-bottom: 1em;
}

.copy-button {
  background: transparent;
  color: white;
  position: absolute;
  top: 8px;
  right: 8px;
  border: none;
  padding: 4px 8px;
  font-size: 12px;
  border-radius: 4px;
  cursor: pointer;
  z-index: 1;
}

.copy-button:hover {
  background-color: #0056b3;
}

.snippet-container {
  overflow: hidden;
}

.snippet-header {
  padding: 0.75rem 1rem;
  cursor: pointer;
  font-size: 1rem;
    background-color: #eeeeee;
    color:  #111111; 
    border-radius: 8px;
    cursor: pointer;
    box-shadow: 0 4px 6px rgba(0,0,0,0.1);  
}

.snippet-body {
  display: none;
  font-family: monospace;
}

.snippet-container.open .snippet-body {
  display: block;
}

.CodeMirror {
  border: 2px solid #ccc;
  border-radius: 4px;
  resize: vertical;
}

/* === Light Mode === */
html.light-mode {
  background-color: #f8f7f5;
  color: #333;
}

html.light-mode .container {
  background: white;
}

html.light-mode .book-title-chapter {
  color: #2c3e50;
  border-color: #ccc;
}
html.light-mode .book-subtitle-chapter{
  color: #888;
}

html.light-mode .page-footer,
html.light-mode .series-name,
html.light-mode .book-subtitle,
html.light-mode .format-label {
  color: #888;
}

html.light-mode .related-books h2 {
  color: #333;
  border-bottom: 2px solid #eee;
}

html.light-mode .book-title {
  color: #fff;
}

html.light-mode .book-cover {
  border: 1px solid #ccc;
}

html.light-mode th {
  background-color: #f2f2f2;
}

html.light-mode tr:nth-child(even) {
  background-color: #fafafa;
}

html.light-mode tr:hover {
  background-color: #e6f7ff;
}

html.light-mode a,
html.light-mode .page-footer a {
  color: #000;
}

/* === Dark Mode === */
html.dark-mode {
  background-color: #181818;
  color: #e0e0e0;
}

html.dark-mode .container {
  background: #222;
}

html.dark-mode .book-title-chapter {
  color: #ddd;
  border-color: #444;
}

html.dark-mode .snippet-header {
    background-color: #333;
    color:  #ddd; 
}


html.dark-mode .book-subtitle-chapter,
html.dark-mode .page-footer,
html.dark-mode .series-name,
html.dark-mode .book-subtitle,
html.dark-mode .book-footer,
html.dark-mode .format-label {
  color: #aaa;
}

html.dark-mode .related-books h2 {
  color: #ddd;
  border-bottom: 2px solid #333;
}

html.dark-mode .book-title {
  color: #fff;
}

html.dark-mode .book-cover {
  border: 1px solid #555;
}

html.dark-mode th {
  background-color: #333;
  color: #fff;
}

html.dark-mode td {
  border-color: #444;
}

html.dark-mode tr:nth-child(even) {
  background-color: #2a2a2a;
}

html.dark-mode tr:hover {
  background-color: #2c3e50;
}

html.dark-mode a,
html.dark-mode .page-footer a {
  color: #eee;
}

    .dialog-backdrop {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: rgba(0,0,0,0.5);
      display: none;
      justify-content: center;
      align-items: center;
      z-index: 10;
    }

    .dialog {
      background: white;
      padding: 20px;
      width: 90vw;
      height: 80vh;
      border-radius: 8px;
      box-shadow: 0 0 20px rgba(0,0,0,0.3);
      display: flex;
      flex-direction: column;
    }
    .dialog-content {
      display: flex;
      flex: 1;
      gap: 20px;
      margin-top: 10px;
    }
    .dialog h2 {
      margin-top: 0;
    }

    .textarea_dialog {
      width: 50%;
      height: 100%;
      resize: none;
      font-family: monospace;
      font-size: 14px;
      padding: 10px;
      box-sizing: border-box;
      border: 1px solid #ccc;
    }

    .iframe_dialog {
      width: 50%;
      height: 100%;
      border: 1px solid #ccc;
    }
    .controls_dialog {
      display: flex;
      justify-content: space-between;
      margin-top: 10px;
    }    
    button { padding: 0.5em 1em; background: green; color: white; border: none; cursor: pointer; }
    button:hover { background: #1e7e34; }
    .result_iframe { width:99%; height:200px; margin-top: 1em;  resize: both;border:1px solid #ccc;}        
</style>
</head>
<body> 
  <div class="container">
    <div class = "chapter-navi-section">
<a href="c-for-beginners-project-building-a-command-line-calculator.htm" class="nav-button prev">←</a>
<a href='c-for-beginners.htm#project-simple-file-compression-utility' class="nav-button toc-link">Index</a>
<a href="" class="nav-button next"></a>
</div>

    <h1 class="book-title-chapter" id = 'top'>Project: Simple File Compression Utility</h1>
    <h3 class="book-subtitle-chapter">C for Beginners</h3>   
    <!-- <h1 class ="chapter-title"></h1> -->
    <h2 id='reading-file-bytes'>21.1 Reading File Bytes</h2><p>When building a file compression utility, one of the fundamental tasks is to read the raw data bytes from a file. Unlike text files where you might read line by line, compression requires working with the file in <strong>binary mode</strong>, reading the exact bytes as they exist without any translation or alteration. In this section, we'll explore how to open files for binary reading, efficiently read chunks of bytes, handle the end-of-file (EOF) condition, and implement robust error checking to ensure your program behaves correctly and reliably.</p><h3 id="opening-a-file-in-binary-mode">Opening a File in Binary Mode</h3><p>In C, the standard library provides the <code>fopen()</code> function to open files. To read a file in binary mode, you pass the mode string <code>"rb"</code> (read binary). This mode ensures that bytes are read exactly as they are on disk, without any newline translation or character encoding conversions that might occur in text mode.</p><p>Here’s a simple example of opening a file for binary reading:</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-c">#include &lt;stdio.h&gt;

FILE *file = fopen("input.dat", "rb");
if (file == NULL) {
    perror("Error opening file");
    // Handle error (e.g., exit or retry)
}</code></pre>
</div><p>If <code>fopen()</code> returns <code>NULL</code>, it means the file could not be opened, possibly due to it not existing, permission issues, or other file system errors. Always check the return value before proceeding.</p><h3 id="reading-raw-bytes-efficiently">Reading Raw Bytes Efficiently</h3><p>Once the file is open, you can read raw bytes using <code>fread()</code>. This function reads a specified number of elements, each of a certain size, from the file into a buffer.</p><p>The syntax of <code>fread()</code> is:</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-c">size_t fread(void *buffer, size_t size, size_t count, FILE *stream);</code></pre>
</div><ul>
 <li><code>buffer</code> is the pointer to the memory where data will be stored.</li>
 <li><code>size</code> is the size of each element (usually 1 byte when reading raw data).</li>
 <li><code>count</code> is the number of elements to read.</li>
 <li><code>stream</code> is the file pointer.</li>
</ul><p>The function returns the number of elements successfully read, which can be less than <code>count</code> if the end of file is reached or an error occurs.</p><h3 id="reading-in-chunks">Reading in Chunks</h3><p>Reading the entire file at once may not be practical for large files due to memory constraints. Instead, read in fixed-size chunks (buffers). This approach balances memory usage and performance.</p><p>Example reading chunks of 1024 bytes:</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-c">#define BUFFER_SIZE 1024

unsigned char buffer[BUFFER_SIZE];
size_t bytesRead;

while ((bytesRead = fread(buffer, 1, BUFFER_SIZE, file)) &gt; 0) {
    // Process bytesRead bytes from buffer here
    // For example, compress or analyze the data
}</code></pre>
</div><p>The loop continues until <code>fread()</code> returns 0, indicating no more data.</p><h3 id="handling-end-of-file-and-errors">Handling End-of-File and Errors</h3><p>Simply checking if <code>fread()</code> returns zero is not enough to distinguish between end-of-file and an error condition. Use <code>feof()</code> and <code>ferror()</code> to identify what happened.</p><p>Example:</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-c">if (ferror(file)) {
    perror("Error reading file");
    // Handle the error, possibly exit
} else if (feof(file)) {
    // End of file reached successfully
}</code></pre>
</div><p>Always perform these checks after your read loop finishes.</p><h3 id="buffering-strategies">Buffering Strategies</h3><p>File I/O is buffered by default, meaning the system reads data in blocks behind the scenes to improve performance. When reading large files, you can tune the buffer size to optimize throughput.</p><p>Choosing a larger buffer size (e.g., 4KB or 8KB) can reduce the number of system calls and speed up reading. However, too large a buffer wastes memory, so balance according to your application needs.</p><p>You can also disable buffering for specific scenarios using <code>setbuf()</code> or <code>setvbuf()</code> but typically the default buffering is sufficient.</p><h3 id="complete-example-reading-a-file-byte-by-byte-vs-chunk">Complete Example: Reading a File Byte-by-Byte vs. Chunk</h3><p>Here’s a comparison of two approaches:</p><p><strong>Byte-by-byte reading (inefficient):</strong></p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-c">FILE *file = fopen("input.dat", "rb");
if (!file) {
    perror("Failed to open file");
    return 1;
}

int byte;
while ((byte = fgetc(file)) != EOF) {
    unsigned char c = (unsigned char)byte;
    // Process single byte c
}

fclose(file);</code></pre>
</div><p><strong>Chunk reading (efficient):</strong></p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-c">#define BUFFER_SIZE 4096
unsigned char buffer[BUFFER_SIZE];
size_t bytesRead;

FILE *file = fopen("input.dat", "rb");
if (!file) {
    perror("Failed to open file");
    return 1;
}

while ((bytesRead = fread(buffer, 1, BUFFER_SIZE, file)) &gt; 0) {
    // Process buffer[0..bytesRead-1]
}

if (ferror(file)) {
    perror("Error during file read");
}

fclose(file);</code></pre>
</div><p>As you can see, chunk reading reduces function call overhead and generally runs faster, especially on larger files.</p><h3 id="best-practices-for-file-reading-in-compression-utilities">Best Practices for File Reading in Compression Utilities</h3><ul>
 <li><strong>Always check for errors:</strong> After opening files and reading data, validate the success of these operations.</li>
 <li><strong>Read in reasonably sized buffers:</strong> Avoid very small reads that cause performance hits and huge buffers that waste memory.</li>
 <li><strong>Clean up resources:</strong> Always close files after use to free system resources.</li>
 <li><strong>Handle partial reads:</strong> Sometimes <code>fread()</code> returns less than requested due to EOF or interruptions. Always process the actual bytes read.</li>
 <li><strong>Use binary mode:</strong> For compression, you want exact bytes, so always open files with <code>"rb"</code> (read) and <code>"wb"</code> (write) modes for binary safety.</li>
</ul><h3 id="summary">Summary</h3><p>Reading raw bytes from files is foundational in creating a compression utility. By opening files in binary mode and reading data in chunks using <code>fread()</code>, you ensure efficient, accurate, and safe access to file contents. Proper error handling and resource management safeguard your program against common file I/O pitfalls. With these techniques, you are ready to build the next steps of your compression project, working directly on the raw byte data.</p><div class = "chapter-navi-section">
<a href="#top" class="nav-button prev">↑</a>
<a href='c-for-beginners.htm#project-simple-file-compression-utility' class="nav-button toc-link">Index</a>
<a href="#bottom" class="nav-button next">↓</a>
</div>
<h2 id='using-bitwise-operations'>21.2 Using Bitwise Operations</h2><p>In file compression, one of the keys to achieving compact storage is working directly with bits, the smallest units of data. Bitwise operations in C allow you to manipulate individual bits within bytes or larger data types, enabling techniques such as bit packing, masking, and shifting. These operations are essential for encoding data more efficiently by reducing the amount of space needed to store information like flags, repetitive values, or small ranges of numbers.</p><p>This section explains how bitwise operators can be used to compress data, along with practical examples that demonstrate packing multiple pieces of information into single bytes and manipulating bits effectively.</p><h3 id="why-use-bitwise-operations-for-compression">Why Use Bitwise Operations for Compression?</h3><p>Typically, computers store data in bytes (8 bits), and many applications waste space by storing small pieces of information in full bytes or larger units. Bitwise operations help you:</p><ul>
 <li><strong>Pack multiple boolean flags into one byte</strong> (e.g., storing 8 on/off settings in a single byte).</li>
 <li><strong>Represent small ranges of values compactly</strong> using fewer bits than the standard types.</li>
 <li><strong>Manipulate data at the bit level</strong> to implement custom compression schemes, such as run-length encoding or Huffman coding.</li>
</ul><p>By working directly with bits, your program can dramatically reduce file sizes, an important goal for compression utilities.</p><h3 id="essential-bitwise-operators">Essential Bitwise Operators</h3><p>Before diving into examples, let's review the core bitwise operators in C:</p><table>
 <thead>
  <tr>
   <th>Operator</th>
   <th>Description</th>
   <th>Example</th>
  </tr>
 </thead>
 <tbody>
  <tr>
   <td><code>&amp;</code></td>
   <td>Bitwise AND: sets bits to 1 only if both bits are 1</td>
   <td><code>x &amp; 0x0F</code> masks lower 4 bits</td>
  </tr>
  <tr>
   <td>|</td>
   <td>Bitwise OR: sets bits to 1 if either bit is 1</td>
   <td>x | 0x80 sets the highest bit</td>
  </tr>
  <tr>
   <td><code>^</code></td>
   <td>Bitwise XOR: sets bits to 1 if bits differ</td>
   <td><code>x ^ 0xFF</code> inverts bits</td>
  </tr>
  <tr>
   <td><code>~</code></td>
   <td>Bitwise NOT: flips all bits</td>
   <td><code>~x</code> inverts every bit</td>
  </tr>
  <tr>
   <td><code>&lt;&lt;</code></td>
   <td>Left shift: shifts bits left, adding zeros on the right</td>
   <td><code>x &lt;&lt; 2</code> shifts bits left by 2</td>
  </tr>
  <tr>
   <td><code>&gt;&gt;</code></td>
   <td>Right shift: shifts bits right</td>
   <td><code>x &gt;&gt; 3</code> shifts bits right by 3</td>
  </tr>
 </tbody>
</table><h3 id="bit-masking-extracting-and-modifying-bits">Bit Masking: Extracting and Modifying Bits</h3><p><strong>Masking</strong> allows you to isolate or modify specific bits using <code>&amp;</code> and <code>|</code>.</p><h4 id="extracting-bits">Extracting bits</h4><p>Suppose you want to extract the lower 3 bits of a byte:</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-c">unsigned char byte = 0b10101100;  // binary literal
unsigned char lower3 = byte &amp; 0x07; // 0x07 = 00000111 in binary
// lower3 is 0b00000100 (decimal 4)</code></pre>
</div><p>Here, the mask <code>0x07</code> keeps only the lowest 3 bits, setting the rest to zero.</p><h4 id="setting-bits">Setting bits</h4><p>To set specific bits without affecting others, use bitwise OR (<code>|</code>):</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-c">unsigned char byte = 0b10100000;
byte = byte | 0x0F;  // Set the lower 4 bits to 1
// byte becomes 0b10101111</code></pre>
</div><h4 id="clearing-bits">Clearing bits</h4><p>To clear (set to zero) certain bits, use bitwise AND with a negated mask:</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-c">unsigned char byte = 0b11111111;
byte = byte &amp; ~0x0F;  // Clear lower 4 bits
// byte becomes 0b11110000</code></pre>
</div><h3 id="bit-shifting-packing-and-unpacking-data">Bit Shifting: Packing and Unpacking Data</h3><p>Bit shifting moves bits left or right, enabling you to pack multiple small values into one larger value or extract them later.</p><h4 id="packing-two-4-bit-values-into-one-byte">Packing two 4-bit values into one byte</h4><p>Imagine you have two values, each fitting in 4 bits (0-15):</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-c">unsigned char high = 9;  // 0b1001
unsigned char low = 5;   // 0b0101

unsigned char packed = (high &lt;&lt; 4) | (low &amp; 0x0F);
// packed = 0b10010101 = 149 decimal</code></pre>
</div><p>The high value is shifted left 4 bits to occupy the upper nibble (half-byte), and the low value stays in the lower nibble. Masking <code>low</code> with <code>0x0F</code> ensures only the lower 4 bits are used.</p><p>To unpack:</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-c">unsigned char unpackedHigh = (packed &gt;&gt; 4) &amp; 0x0F;
unsigned char unpackedLow = packed &amp; 0x0F;</code></pre>
</div><h3 id="example-using-bits-to-represent-flags">Example: Using Bits to Represent Flags</h3><p>Suppose you want to store multiple boolean flags compactly, such as user permissions:</p><table>
 <thead>
  <tr>
   <th>Permission</th>
   <th>Bit Position</th>
  </tr>
 </thead>
 <tbody>
  <tr>
   <td>Read</td>
   <td>0</td>
  </tr>
  <tr>
   <td>Write</td>
   <td>1</td>
  </tr>
  <tr>
   <td>Execute</td>
   <td>2</td>
  </tr>
  <tr>
   <td>Delete</td>
   <td>3</td>
  </tr>
  <tr>
   <td>Share</td>
   <td>4</td>
  </tr>
 </tbody>
</table><p>You can use a single <code>unsigned char</code> to store these:</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-c">unsigned char permissions = 0;  // All flags off

// Set Read and Execute permissions
permissions |= (1 &lt;&lt; 0);  // Read
permissions |= (1 &lt;&lt; 2);  // Execute

// Check if Write permission is set
if (permissions &amp; (1 &lt;&lt; 1)) {
    printf("Write permission granted\n");
} else {
    printf("Write permission denied\n");
}

// Clear Execute permission
permissions &amp;= ~(1 &lt;&lt; 2);</code></pre>
</div><p>Using bits saves space and simplifies logic when handling multiple flags.</p><h3 id="compressing-repetitive-data-with-bit-manipulation">Compressing Repetitive Data with Bit Manipulation</h3><p>Compression algorithms often encode repeated data compactly by packing counts and values together.</p><p>For example, in a simple run-length encoding (RLE) scheme, you could store a run length (up to 15) and a repeated value in a single byte:</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-c">unsigned char runLength = 10; // max 15 (4 bits)
unsigned char value = 3;      // max 15 (4 bits)

unsigned char encoded = (runLength &lt;&lt; 4) | (value &amp; 0x0F);</code></pre>
</div><p>This packing reduces two pieces of information into one byte, saving memory.</p><h3 id="practical-tips">Practical Tips</h3><ul>
 <li>Always <strong>mask bits</strong> before combining to avoid overflow or unintended bits.</li>
 <li>Be mindful of <strong>signed vs unsigned</strong> data types when shifting bits.</li>
 <li>Use <strong>parentheses</strong> to ensure correct order of operations in expressions with shifts and bitwise operators.</li>
 <li>For multi-byte packing, consider <strong>endianness</strong> and portability.</li>
 <li>Combine bitwise operations with buffers for reading/writing compressed bit streams.</li>
</ul><h3 id="summary">Summary</h3><p>Bitwise operations empower your compression utility to represent data compactly and efficiently. Mastering masking, shifting, and bit packing techniques lets you squeeze more information into fewer bytes, which is the essence of compression. Whether managing flags, encoding repeated patterns, or designing custom formats, bitwise manipulation forms the foundation of many advanced compression algorithms.</p><p>With these tools, you can start crafting clever schemes to reduce file sizes and enhance your compression project's effectiveness.</p><div class = "chapter-navi-section">
<a href="#top" class="nav-button prev">↑</a>
<a href='c-for-beginners.htm#project-simple-file-compression-utility' class="nav-button toc-link">Index</a>
<a href="#bottom" class="nav-button next">↓</a>
</div>
<h2 id='writing-compressed-output'>21.3 Writing Compressed Output</h2><p>After reading raw data from a file and applying bitwise operations to compress it, the next crucial step is to write this compressed data back to a file. Writing compressed output correctly ensures that the compressed file is compact, accurate, and can be decompressed without errors later. This section explores techniques for writing compressed data efficiently in binary mode, managing buffers, and maintaining file integrity.</p><h3 id="opening-files-in-binary-mode-for-writing">Opening Files in Binary Mode for Writing</h3><p>When writing compressed data, it's essential to open your output file in <strong>binary mode</strong> using <code>"wb"</code> mode with <code>fopen()</code>:</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-c">FILE *outFile = fopen("compressed.bin", "wb");
if (outFile == NULL) {
    perror("Failed to open output file");
    return 1;
}</code></pre>
</div><p>Binary mode prevents unwanted transformations of bytes (like newline conversion on Windows), preserving exact bit patterns critical for compression.</p><h3 id="writing-bytes-vs-bits">Writing Bytes vs Bits</h3><p>Since file systems generally store data in bytes (8 bits), but your compression algorithm might produce data in bits or partial bytes, you need a strategy to write these bits correctly.</p><ul>
 <li><strong>Writing full bytes</strong> is straightforward with <code>fwrite()</code> or <code>fputc()</code>.</li>
 <li><strong>Writing individual bits</strong> requires accumulating bits in a buffer until you have a full byte to write.</li>
</ul><h3 id="managing-an-output-bit-buffer">Managing an Output Bit Buffer</h3><p>To handle bits, maintain a byte-sized buffer and a counter tracking how many bits have been written so far:</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-c">unsigned char bitBuffer = 0;
int bitCount = 0;
FILE *outFile;  // Assume already opened

void writeBit(int bit) {
    bitBuffer = (bitBuffer &lt;&lt; 1) | (bit &amp; 1);
    bitCount++;

    if (bitCount == 8) {
        fputc(bitBuffer, outFile);
        bitBuffer = 0;
        bitCount = 0;
    }
}</code></pre>
</div><p>Each call to <code>writeBit()</code> adds a single bit to the buffer. When the buffer reaches 8 bits, it writes the byte to the file and resets.</p><h3 id="flushing-remaining-bits">Flushing Remaining Bits</h3><p>After processing all bits, you often have some bits left in the buffer (less than 8). To preserve data integrity, flush these bits by padding the remaining bits (usually with zeros) and writing the final byte:</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-c">void flushBits() {
    if (bitCount &gt; 0) {
        bitBuffer &lt;&lt;= (8 - bitCount);  // Shift left to fill the rest with 0s
        fputc(bitBuffer, outFile);
        bitBuffer = 0;
        bitCount = 0;
    }
}</code></pre>
</div><p>Without this step, the last bits might be lost or incorrectly interpreted during decompression.</p><h3 id="writing-full-bytes">Writing Full Bytes</h3><p>Sometimes, the compressed data naturally aligns with bytes (e.g., after bit packing). Writing these bytes is simple:</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-c">unsigned char data = 0xAB;
fputc(data, outFile);

// Or writing multiple bytes:
unsigned char buffer[] = {0xAB, 0xCD, 0xEF};
fwrite(buffer, sizeof(unsigned char), 3, outFile);</code></pre>
</div><p>Use <code>fwrite()</code> for performance when writing large blocks at once.</p><h3 id="buffering-strategies">Buffering Strategies</h3><p>Efficient file I/O often uses buffering to minimize the number of system calls:</p><ul>
 <li>The C standard library provides buffering automatically for file streams.</li>
 <li>You can use your own buffers to accumulate compressed data before writing larger chunks at once.</li>
</ul><p>Example of buffering compressed bytes before writing:</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-c">#define BUFFER_SIZE 1024
unsigned char outBuffer[BUFFER_SIZE];
int bufferIndex = 0;

void bufferWrite(unsigned char byte) {
    outBuffer[bufferIndex++] = byte;
    if (bufferIndex == BUFFER_SIZE) {
        fwrite(outBuffer, 1, BUFFER_SIZE, outFile);
        bufferIndex = 0;
    }
}

void flushBuffer() {
    if (bufferIndex &gt; 0) {
        fwrite(outBuffer, 1, bufferIndex, outFile);
        bufferIndex = 0;
    }
}</code></pre>
</div><p>Buffering reduces overhead and improves write performance, especially on large files.</p><h3 id="preserving-file-integrity-and-format">Preserving File Integrity and Format</h3><p>When writing compressed data, it’s important to:</p><ul>
 <li><strong>Write any metadata or headers</strong> needed for decompression (e.g., original file size, compression method).</li>
 <li><strong>Maintain a consistent file format</strong> so the decompressor knows how to interpret the bits.</li>
 <li><strong>Handle errors during writing</strong> (e.g., disk full, permission issues) by checking the return values of <code>fwrite()</code> and <code>fputc()</code> and reacting appropriately.</li>
</ul><p>Example:</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-c">if (fwrite(outBuffer, 1, bufferIndex, outFile) != bufferIndex) {
    perror("Error writing output file");
    // Handle error (e.g., clean up and exit)
}</code></pre>
</div><h3 id="example-writing-bits-to-a-file">Example: Writing Bits to a File</h3><p>Here's a small example combining the above concepts:</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-c">#include &lt;stdio.h&gt;

FILE *outFile;
unsigned char bitBuffer = 0;
int bitCount = 0;

void writeBit(int bit) {
    bitBuffer = (bitBuffer &lt;&lt; 1) | (bit &amp; 1);
    bitCount++;
    if (bitCount == 8) {
        fputc(bitBuffer, outFile);
        bitBuffer = 0;
        bitCount = 0;
    }
}

void flushBits() {
    if (bitCount &gt; 0) {
        bitBuffer &lt;&lt;= (8 - bitCount);
        fputc(bitBuffer, outFile);
        bitBuffer = 0;
        bitCount = 0;
    }
}

int main() {
    outFile = fopen("compressed.bin", "wb");
    if (!outFile) {
        perror("Failed to open file");
        return 1;
    }

    // Write bits: 1101 (4 bits)
    writeBit(1);
    writeBit(1);
    writeBit(0);
    writeBit(1);

    // Flush remaining bits to write partial byte
    flushBits();

    fclose(outFile);
    return 0;
}</code></pre>
</div><p>This code writes four bits <code>1101</code> padded with zeros to form a byte.</p><h3 id="summary">Summary</h3><p>Writing compressed output requires careful bit-level management to ensure data is stored compactly and correctly:</p><ul>
 <li>Open files in binary mode (<code>"wb"</code>) to avoid data corruption.</li>
 <li>Use an output bit buffer to accumulate bits and write full bytes.</li>
 <li>Flush remaining bits by padding to maintain file integrity.</li>
 <li>Consider buffering strategies to optimize I/O performance.</li>
 <li>Always check for errors during writing and close files properly.</li>
</ul><p>By following these techniques, your compression utility can produce reliable, space-saving files ready for efficient decompression.</p><div class = "chapter-navi-section">
<a href="c-for-beginners-project-building-a-command-line-calculator.htm" class="nav-button prev">←</a>
<a href='c-for-beginners.htm#project-simple-file-compression-utility' class="nav-button toc-link">Index</a>
<a href="" class="nav-button next"></a>
</div>
<section class="download-section">
  <div class="book-cover" style="background-color: #f9f6f1;border: 1px solid #ccc;"> 
    <div class="book-cover-title" style="font-size: 18px;color: #333;top: 20px;">C for Beginners</div>
    <div class="book-cover-author">readbytes</div>
    <div class="book-cover-bottom-stripe" style="background-color: #333;"></div>
    <img class="book-cover-icon" style="width: 90px;height: 90px;top: 70px;" src="data:image/png;base64,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"/>
  </div>
  <div class="download-info">
    <h2 id='bottom'>Download This Ebook</h2>
    <p class="format-label">Available formats:</p>
    <div class="download-buttons">
      <a href="c-for-beginners.pdf" class="download-button">📄 PDF</a>
      <a href="c-for-beginners.epub" class="download-button">📘 EPUB</a>
    </div>
  </div>
</section><div class='related-books'>
<h2>C Introduction Books</h2>
<div class='related-book-list'>
<a href="c-for-beginners.htm">
<div class="book-cover" style="background-color: #f9f6f1;border: 1px solid #ccc;"> 
    <div class="book-cover-title" style="font-size: 18px;color: #333;top: 20px;">C for Beginners</div>
    <div class="book-cover-author">readbytes</div>
    <div class="book-cover-bottom-stripe" style="background-color: #333;"></div>
    <img class="book-cover-icon" style="width: 90px;height: 90px;top: 70px;" src="data:image/png;base64,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"/>
  </div>
</a>



<a href='c.htm'><div class='book-cover' style='background-color: #f9f6f1;color: #111111;border: 1px solid #ccc;display: flex;justify-content: center;align-items: center;text-align: center;'>More C Books</div></a>
</div>
</div>
  </div>
  <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/prism.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
  
  <script>
    function copyCode(button) {
      const code = button.nextElementSibling.innerText;
      navigator.clipboard.writeText(code).then(() => {
        button.textContent = 'Copied!';
        setTimeout(() => { button.textContent = 'Copy'; }, 1500);
      });
    }
  </script>  
<div id="floatingLog" aria-live="polite" role="alert"></div>
<footer class="page-footer">
    <nav>
      <a href="https://readbytes.github.io">Home</a> | 
      Email:<script language="JavaScript" type="text/javascript">
var part1 = 'yinpeng';var part6 = '263';var part2 = Math.pow(2,6);var part3 = String.fromCharCode(part2);var part4 = 'hotmail dot com';var part5 = part1 + String.fromCharCode(part2) + part4;document.write(part1 + part6 + part3 + part4);
</script>
    </nav>
  <p>© 2025 — All rights reserved.</p>    
  </footer>

</body>
</html>