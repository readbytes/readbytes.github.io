<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>JavaScript Algorithms Greedy Algorithms</title>
<link rel='shortcut icon' href='https://java2s.com/style/favicon.ico'>
<link href="https://fonts.googleapis.com/css2?family=Merriweather&display=swap" rel="stylesheet" />
<link href="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet" />


  <script>
  const mode = localStorage.getItem('mode') || 'light';
  document.documentElement.classList.add(`${mode}-mode`);
  </script>   
<style> 
html {
  scroll-behavior: smooth;
}

body {
  font-family: 'Merriweather', serif;
  margin: 0;
  padding: 2rem 1rem;
  font-size: 15px;
  line-height: 1.5;
  transition: background-color 0.3s, color 0.3s;
}

.container {
  max-width: 700px;
  margin: 0 auto;
  padding: 1rem 2rem;
  box-shadow: 0 0 15px rgba(0,0,0,0.1);
}

h1, h2, h3 {
  font-weight: 600;
  margin-top: 2.5rem;
  margin-bottom: 1rem;
  line-height: 1.2;
}

h1 { font-size: 1.8rem; }
h2 { font-size: 1.4rem; }
h3 { font-size: 1.2rem; }

table {
  width: 100%;
  border-collapse: collapse;
  font-family: sans-serif;
  font-size: 1em;
  margin: 1em 0;
}

th, td {
  padding: 0.6em 1em;
  text-align: left;
  border: 1px solid;
}

tr:nth-child(even) {
  background-color: inherit;
}

tr:hover {
  background-color: inherit;
}

a {
  text-decoration: none;
  transition: color 0.2s;
}

a:hover {
  text-decoration: underline;
}

code {
  color: #d35400;
}

.book-title-chapter {
  font-family: 'Merriweather', serif;
  font-size: 2rem;
  font-weight: bold;
  text-align: center;
  margin-bottom: 2rem;
  border-bottom: 2px solid;
  padding-bottom: 0.5rem;
}

.book-subtitle-chapter {
  text-align: center;
  font-size: 1rem;
  margin-top: -1rem;
  margin-bottom: 2rem;
}

.related-books {
  margin-top: 40px;
}

.related-book-list {
  display: flex;
  flex-wrap: wrap;
  gap: 20px;
}

    .book-cover {
      width: 130px;
      height: 180px;
      font-family: Arial, sans-serif;
      position: relative;
      overflow: hidden;      
      line-height: normal;
      box-shadow: 2px 2px 4px rgba(0,0,0,0.1);
    }
    .book-cover-bottom-stripe {
      position: absolute;
      bottom: 0;
      left: 0;
      height: 5px;
      width: 100%;
    }
    .book-cover-title {
      position: absolute;
      width: 100%;
      text-align: center;
      font-weight: bold;
    }
     
    .book-cover-icon {
      position: absolute;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      align-items: center;
      justify-content: center; 
    }

    .book-cover-author {
      position: absolute;
      bottom: 10px;
      width: 100%;
      text-align: center;
      font-size: 8px;
      color: #333;
    }

.page-footer {
  margin-top: 4rem;
  padding: 1rem 0;
  text-align: center;
  font-size: 0.85rem;
  border-top: 1px solid;
}

.chapter-navi-section {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding-bottom: 10px;
}

.nav-link {
  color: inherit;
  text-decoration: none;
  opacity: 0.5;
  transition: opacity 0.3s ease, text-decoration 0.3s ease;
}

.nav-link:hover {
  opacity: 0.9;
  text-decoration: underline;
}

.prev { text-align: left; }
.toc-link { text-align: center; }
.next { text-align: right; }

.download-section {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 2rem;
  padding: 2rem 1rem;
  max-width: 600px;
  margin: 3rem auto;
  border-radius: 12px;
  box-shadow: 0 4px 10px rgba(0,0,0,0.05);
}

.download-info h2 {
  margin: 0 0 0.5rem;
  font-size: 1.2rem;
}

.format-label {
  margin: 0 0 0.5rem;
  font-size: 0.95rem;
}

.download-buttons {
  display: flex;
  gap: 1rem;
}

.download-button {
  background-color: #4A90E2;
  color: white;
  padding: 0.5em 1.2em;
  border-radius: 25px;
  font-size: 0.95rem;
  text-decoration: none;
  transition: background-color 0.3s ease;
}

.download-button:hover {
  background-color: #357ABD;
}

.code-block {
  position: relative;
  margin-bottom: 1em;
}

.copy-button {
  background: transparent;
  color: white;
  position: absolute;
  top: 8px;
  right: 8px;
  border: none;
  padding: 4px 8px;
  font-size: 12px;
  border-radius: 4px;
  cursor: pointer;
  z-index: 1;
}

.copy-button:hover {
  background-color: #0056b3;
}

.snippet-container {
  overflow: hidden;
}

.snippet-header {
  padding: 0.75rem 1rem;
  cursor: pointer;
  font-size: 1rem;
    background-color: #eeeeee;
    color:  #111111; 
    border-radius: 8px;
    cursor: pointer;
    box-shadow: 0 4px 6px rgba(0,0,0,0.1);  
}

.snippet-body {
  display: none;
  font-family: monospace;
}

.snippet-container.open .snippet-body {
  display: block;
}

.CodeMirror {
  border: 2px solid #ccc;
  border-radius: 4px;
  resize: vertical;
}

/* === Light Mode === */
html.light-mode {
  background-color: #f8f7f5;
  color: #333;
}

html.light-mode .container {
  background: white;
}

html.light-mode .book-title-chapter {
  color: #2c3e50;
  border-color: #ccc;
}
html.light-mode .book-subtitle-chapter{
  color: #888;
}

html.light-mode .page-footer,
html.light-mode .series-name,
html.light-mode .book-subtitle,
html.light-mode .format-label {
  color: #888;
}

html.light-mode .related-books h2 {
  color: #333;
  border-bottom: 2px solid #eee;
}

html.light-mode .book-title {
  color: #fff;
}

html.light-mode .book-cover {
  border: 1px solid #ccc;
}

html.light-mode th {
  background-color: #f2f2f2;
}

html.light-mode tr:nth-child(even) {
  background-color: #fafafa;
}

html.light-mode tr:hover {
  background-color: #e6f7ff;
}

html.light-mode a,
html.light-mode .page-footer a {
  color: #000;
}

/* === Dark Mode === */
html.dark-mode {
  background-color: #181818;
  color: #e0e0e0;
}

html.dark-mode .container {
  background: #222;
}

html.dark-mode .book-title-chapter {
  color: #ddd;
  border-color: #444;
}

html.dark-mode .snippet-header {
    background-color: #333;
    color:  #ddd; 
}


html.dark-mode .book-subtitle-chapter,
html.dark-mode .page-footer,
html.dark-mode .series-name,
html.dark-mode .book-subtitle,
html.dark-mode .book-footer,
html.dark-mode .format-label {
  color: #aaa;
}

html.dark-mode .related-books h2 {
  color: #ddd;
  border-bottom: 2px solid #333;
}

html.dark-mode .book-title {
  color: #fff;
}

html.dark-mode .book-cover {
  border: 1px solid #555;
}

html.dark-mode th {
  background-color: #333;
  color: #fff;
}

html.dark-mode td {
  border-color: #444;
}

html.dark-mode tr:nth-child(even) {
  background-color: #2a2a2a;
}

html.dark-mode tr:hover {
  background-color: #2c3e50;
}

html.dark-mode a,
html.dark-mode .page-footer a {
  color: #eee;
}

    .dialog-backdrop {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: rgba(0,0,0,0.5);
      display: none;
      justify-content: center;
      align-items: center;
      z-index: 10;
    }

    .dialog {
      background: white;
      padding: 20px;
      width: 90vw;
      height: 80vh;
      border-radius: 8px;
      box-shadow: 0 0 20px rgba(0,0,0,0.3);
      display: flex;
      flex-direction: column;
    }
    .dialog-content {
      display: flex;
      flex: 1;
      gap: 20px;
      margin-top: 10px;
    }
    .dialog h2 {
      margin-top: 0;
    }

    .textarea_dialog {
      width: 50%;
      height: 100%;
      resize: none;
      font-family: monospace;
      font-size: 14px;
      padding: 10px;
      box-sizing: border-box;
      border: 1px solid #ccc;
    }

    .iframe_dialog {
      width: 50%;
      height: 100%;
      border: 1px solid #ccc;
    }
    .controls_dialog {
      display: flex;
      justify-content: space-between;
      margin-top: 10px;
    }    
    button { padding: 0.5em 1em; background: green; color: white; border: none; cursor: pointer; }
    button:hover { background: #1e7e34; }
    .result_iframe { width:99%; height:200px; margin-top: 1em;  resize: both;border:1px solid #ccc;}        
</style>
</head>
<body> 
  <div class="container">
    <div class = "chapter-navi-section">
<a href="javascript-algorithms-principles-of-dynamic-programming-classic-problems.htm" class="nav-button prev">←</a>
<a href='javascript-algorithms.htm#greedy-algorithms' class="nav-button toc-link">Index</a>
<a href="javascript-algorithms-backtracking-and-recursion.htm" class="nav-button next">→</a>
</div>

    <h1 class="book-title-chapter" id = 'top'>Greedy Algorithms</h1>
    <h3 class="book-subtitle-chapter">JavaScript Algorithms</h3>   
    <!-- <h1 class ="chapter-title"></h1> -->
    <h2 id='when-greedy-works'>19.1 When Greedy Works</h2><p>Greedy algorithms are a powerful class of algorithms that solve optimization problems by making a sequence of locally optimal choices—choices that seem best at each individual step—without revisiting or revising past decisions. The central idea is simple: at every step, pick the best available option and hope that this sequence of local decisions leads to a globally optimal solution. While this approach is intuitive and often fast, it does not always work. Understanding <em>when</em> greedy strategies yield correct results is essential for applying them effectively.</p><h3 id="the-greedy-paradigm">The Greedy Paradigm</h3><p>A greedy algorithm operates in a step-by-step manner:</p><ol>
 <li><strong>Greedy choice</strong>: At each stage, select the best local option available.</li>
 <li><strong>Feasibility</strong>: Ensure that the current choice does not violate the problem constraints.</li>
 <li><strong>Irrevocability</strong>: Once a choice is made, it is never changed or undone.</li>
</ol><p>Because of their simplicity and efficiency, greedy algorithms typically run in linear or linearithmic time, and are easy to implement. However, their correctness depends on whether the locally optimal decisions also lead to a <em>globally optimal</em> outcome.</p><h3 id="conditions-for-greedy-optimality">Conditions for Greedy Optimality</h3><p>There are two key conditions that must be met for a greedy algorithm to work correctly:</p><ol>
 <li><p><strong>Greedy-choice property</strong>: A globally optimal solution can be arrived at by making a series of locally optimal choices. This means that there exists an optimal solution that starts with the greedy choice.</p></li>
 <li><p><strong>Optimal substructure</strong>: The problem’s solution can be constructed optimally from optimal solutions to its subproblems. This is also a requirement for dynamic programming, but dynamic programming allows for multiple overlapping subproblems, while greedy algorithms typically process each subproblem just once.</p></li>
</ol><p>When both of these properties hold, a greedy algorithm can be used to solve the problem efficiently.</p><h3 id="greedy-vs-dynamic-programming">Greedy vs. Dynamic Programming</h3><p>At first glance, greedy algorithms and dynamic programming appear similar because both exploit the optimal substructure property. The key difference lies in the treatment of subproblems:</p><ul>
 <li><strong>Dynamic Programming</strong> solves all subproblems and uses their results to build the solution. It is more cautious and revisits decisions to guarantee optimality.</li>
 <li><strong>Greedy Algorithms</strong> make one pass and commit to choices immediately. They avoid recomputation and typically require less memory.</li>
</ul><p>For example, consider the <strong>0/1 Knapsack Problem</strong> versus the <strong>Fractional Knapsack Problem</strong>. The 0/1 version requires dynamic programming, since the best choice for one item may depend on later options. In contrast, the fractional version can be solved greedily: sort items by value-to-weight ratio, and pick as much of the highest ratio items as possible. Here, both greedy-choice and optimal substructure properties hold, so the greedy approach yields the optimal solution.</p><h3 id="examples-of-greedy-appropriate-problems">Examples of Greedy-Appropriate Problems</h3><p>Greedy algorithms are especially effective in problems involving:</p><ul>
 <li><strong>Scheduling</strong>: Selecting a subset of non-overlapping intervals (e.g., activity selection).</li>
 <li><strong>Compression</strong>: Constructing optimal prefix-free codes (e.g., Huffman coding).</li>
 <li><strong>Graph traversal</strong>: Finding minimum spanning trees (e.g., Prim’s or Kruskal’s algorithms).</li>
 <li><strong>Pathfinding</strong>: Dijkstra’s algorithm for shortest paths in graphs with non-negative weights.</li>
</ul><p>In each of these, the problem structure allows greedy choices to accumulate into an optimal solution.</p><h3 id="how-to-identify-greedy-problems">How to Identify Greedy Problems</h3><p>To decide whether a greedy approach is appropriate:</p><ul>
 <li><strong>Check for the greedy-choice property</strong>: Can you always choose the best-looking option and still build a globally optimal solution?</li>
 <li><strong>Check for optimal substructure</strong>: Can the solution be constructed from solutions to smaller instances of the same problem?</li>
 <li><strong>Test small examples</strong>: Try greedy strategies on simple inputs. If they consistently yield the best answer, the problem may be amenable to a greedy solution.</li>
 <li><strong>Compare with dynamic programming</strong>: If a known dynamic programming solution exists, examine whether some subproblems are being solved redundantly. This might indicate an opportunity for a greedy simplification.</li>
</ul><h3 id="conclusion">Conclusion</h3><p>Greedy algorithms offer elegant and efficient solutions to a subset of optimization problems, provided certain structural conditions are met. They are most effective when each decision naturally leads closer to the best overall outcome. While not universally applicable, recognizing the greedy-choice property and optimal substructure can help identify when a greedy approach is both correct and advantageous.</p><div class = "chapter-navi-section">
<a href="#top" class="nav-button prev">↑</a>
<a href='javascript-algorithms.htm#greedy-algorithms' class="nav-button toc-link">Index</a>
<a href="#bottom" class="nav-button next">↓</a>
</div>
<h2 id='activity-selection'>19.2 Activity Selection</h2><p>The <strong>Activity Selection Problem</strong> is a classic example of where a greedy algorithm produces an optimal solution. The problem involves choosing the largest possible number of activities (or intervals) that do not overlap in time. Each activity has a <strong>start time</strong> and an <strong>end time</strong>, and the goal is to select the <strong>maximum number of non-conflicting activities</strong> from a given list.</p><h3 id="problem-statement">Problem Statement</h3><p>Formally, you're given <code>n</code> activities, each with a start time <code>start[i]</code> and finish time <code>end[i]</code>. An activity <code>i</code> is compatible with activity <code>j</code> if their time intervals do not overlap: that is, either <code>end[i] &lt;= start[j]</code> or <code>end[j] &lt;= start[i]</code>.</p><p>Your task is to select the largest subset of non-overlapping activities.</p><h3 id="why-greedy-works">Why Greedy Works</h3><p>This problem has both:</p><ul>
 <li><strong>Optimal substructure</strong>: An optimal solution to the whole problem contains within it optimal solutions to subproblems.</li>
 <li><strong>Greedy-choice property</strong>: If we always pick the activity that finishes earliest (among those that start after the last chosen activity), we can still build a globally optimal solution.</li>
</ul><p>Intuitively, finishing activities early leaves more room for subsequent ones. So, by always selecting the activity with the <strong>earliest finish time</strong> that doesn't conflict with the ones already selected, we can maximize the number of activities.</p><h3 id="greedy-strategy">Greedy Strategy</h3><ol>
 <li><p><strong>Sort the activities</strong> in increasing order of finish times.</p></li>
 <li><p><strong>Select the first activity</strong> (it finishes earliest).</p></li>
 <li><p><strong>Iterate through the remaining activities</strong>:</p>
  <ul>
   <li>If an activity's start time is greater than or equal to the finish time of the last selected activity, select it.</li>
  </ul></li>
</ol><p>This process ensures that each choice leaves as much space as possible for future selections.</p><h3 id="javascript-implementation">JavaScript Implementation</h3><p>Here is a simple implementation of the greedy solution in JavaScript:</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-js">function activitySelection(activities) {
  // Sort activities by end time
  activities.sort((a, b) =&gt; a.end - b.end);

  const selected = [];
  let lastEndTime = 0;

  for (const activity of activities) {
    if (activity.start &gt;= lastEndTime) {
      selected.push(activity);
      lastEndTime = activity.end;
    }
  }

  return selected;
}

// Example usage:
const activities = [
  { start: 1, end: 4 },
  { start: 3, end: 5 },
  { start: 0, end: 6 },
  { start: 5, end: 7 },
  { start: 8, end: 9 },
  { start: 5, end: 9 }
];

const result = activitySelection(activities);
console.log("Selected activities:", result);</code></pre>
</div><p><strong>Output:</strong></p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-bash">Selected activities: [ { start: 1, end: 4 }, { start: 5, end: 7 }, { start: 8, end: 9 } ]</code></pre>
</div><p>This solution has a time complexity of <strong>O(n log n)</strong> due to the sorting step, and <strong>O(n)</strong> for the selection phase.</p><h3 id="real-world-applications">Real-World Applications</h3><p>The activity selection problem models many <strong>scheduling</strong> and <strong>resource allocation</strong> scenarios, such as:</p><ul>
 <li><strong>Classroom scheduling</strong>: Assigning lectures to a classroom so that no two lectures overlap.</li>
 <li><strong>Meeting rooms</strong>: Scheduling the maximum number of meetings in a single room.</li>
 <li><strong>CPU task scheduling</strong>: Running as many non-overlapping processes on a single core as possible.</li>
 <li><strong>Job interviews</strong>: A recruiter wants to meet as many candidates as possible without overlapping interviews.</li>
</ul><p>In all these cases, the greedy approach is ideal when:</p><ul>
 <li>Only one resource (e.g., one room or machine) is available.</li>
 <li>The objective is to maximize <strong>quantity</strong> (e.g., number of tasks), not the <strong>value</strong> of each task.</li>
</ul><h3 id="key-takeaways">Key Takeaways</h3><ul>
 <li>The activity selection problem is a fundamental example of a greedy algorithm that is provably optimal.</li>
 <li>The greedy strategy relies on <strong>sorting by finish time</strong>, then choosing non-overlapping activities.</li>
 <li>This approach is fast, efficient, and practical for many real-life scheduling scenarios.</li>
</ul><p>By understanding the structure of this problem and why greedy decisions work here, you build intuition for applying similar strategies in more complex scheduling and optimization tasks.</p><div class = "chapter-navi-section">
<a href="#top" class="nav-button prev">↑</a>
<a href='javascript-algorithms.htm#greedy-algorithms' class="nav-button toc-link">Index</a>
<a href="#bottom" class="nav-button next">↓</a>
</div>
<h2 id='huffman-encoding'>19.3 Huffman Encoding</h2><p><strong>Huffman Encoding</strong> is a classic greedy algorithm used in data compression to assign variable-length codes to input characters, with shorter codes assigned to more frequent characters. The key idea is to reduce the total number of bits required to encode a message, making compression efficient without losing any information. Huffman coding is widely used in file formats like ZIP and JPEG, and in data transmission protocols.</p><h3 id="the-problem">The Problem</h3><p>Given a set of characters and their frequencies (i.e., how often each character appears in a message), construct a <strong>binary prefix code</strong> that minimizes the total encoded length of the message.</p><ul>
 <li><strong>Prefix code</strong>: No code is a prefix of another (e.g., if <code>A = 0</code>, <code>B</code> cannot be <code>01</code>).</li>
 <li><strong>Goal</strong>: Minimize the total cost, calculated as <code>frequency × code length</code> summed over all characters.</li>
</ul><p>For example, suppose we have the characters:</p><table>
 <thead>
  <tr>
   <th>Character</th>
   <th>Frequency</th>
  </tr>
 </thead>
 <tbody>
  <tr>
   <td>A</td>
   <td>5</td>
  </tr>
  <tr>
   <td>B</td>
   <td>9</td>
  </tr>
  <tr>
   <td>C</td>
   <td>12</td>
  </tr>
  <tr>
   <td>D</td>
   <td>13</td>
  </tr>
  <tr>
   <td>E</td>
   <td>16</td>
  </tr>
  <tr>
   <td>F</td>
   <td>45</td>
  </tr>
 </tbody>
</table><p>We want to generate binary codes such that frequently used characters have shorter codes and less frequent ones have longer codes.</p><div class="snippet-container" id="<!DOCTYPE html>
<html lang=&quot;en&quot;>
<head>
<meta charset=&quot;UTF-8&quot; />
<title>Huffman Encoding with Explanation Overlays</title>
<style>
  body {
    font-family: sans-serif;
    text-align: center;
    padding: 20px;
    background: #f4f4f4;
  }
  canvas {
    border: 1px solid #ccc;
    background: #fff;
    display: block;
    margin: 0 auto;
  }
  button {
    font-size: 16px;
    padding: 8px 12px;
    margin: 10px;
  }
  #freqTable, #codes, #explanation {
    max-width: 700px;
    margin: 10px auto;
    text-align: left;
    font-family: monospace;
    background: #fff;
    padding: 12px;
    border-radius: 6px;
    box-shadow: 0 0 8px #ccc;
    white-space: pre-wrap;
  }
  #explanation {
    font-size: 15px;
    line-height: 1.4;
    color: #222;
  }
</style>
</head>
<body>

<h2>Huffman Encoding Visualization with Detailed Explanation</h2>
<button onclick=&quot;startHuffman()&quot;>Start Huffman Encoding</button>
<canvas id=&quot;canvas&quot; width=&quot;600&quot; height=&quot;400&quot;></canvas>

<div id=&quot;freqTable&quot;></div>
<div id=&quot;explanation&quot;></div>
<div id=&quot;codes&quot;></div>

<script>
  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d');
  const freqTableDiv = document.getElementById('freqTable');
  const codesDiv = document.getElementById('codes');
  const explanationDiv = document.getElementById('explanation');

  // Example input string
  const inputString = &quot;this is an example of huffman encoding&quot;;

  // Calculate frequencies
  function calcFrequencies(str) {
    const freq = {};
    for (const ch of str) {
      freq[ch] = (freq[ch] || 0) + 1;
    }
    return freq;
  }

  class Node {
    constructor(char, freq, left = null, right = null) {
      this.char = char;
      this.freq = freq;
      this.left = left;
      this.right = right;
      this.x = 0;
      this.y = 0;
    }
  }

  function buildPriorityQueue(freqs) {
    const nodes = [];
    for (const [char, freq] of Object.entries(freqs)) {
      nodes.push(new Node(char, freq));
    }
    return nodes.sort((a,b) => a.freq - b.freq);
  }

  let nodesQueue;
  let mergeSteps = [];
  let root = null;

  function startHuffman() {
    freqTableDiv.textContent = &quot;Frequency Table:\n&quot; + Object.entries(freqs).map(([c,f]) => `'${c}': ${f}`).join('\n');
    codesDiv.textContent = &quot;&quot;;
    explanationDiv.textContent = &quot;Starting Huffman Encoding...\n\n&quot; +
      &quot;We begin by building a priority queue of nodes from characters sorted by frequency.&quot;;
    nodesQueue = buildPriorityQueue(freqs);
    mergeSteps = [];
    root = null;
    drawInitialQueue();
    setTimeout(buildTreeStepwise, 1500);
  }

  function buildTreeStepwise() {
    if (nodesQueue.length === 1) {
      root = nodesQueue[0];
      drawTree(root);
      explanationDiv.textContent = &quot;All nodes merged! Huffman tree construction completed.\n\n&quot; +
        &quot;Now, we generate Huffman codes by traversing the tree from root to leaves:\n&quot; +
        &quot;- Left edge adds '0' to the code\n- Right edge adds '1' to the code&quot;;
      displayCodes(root);
      return;
    }

    // Take two smallest nodes
    const left = nodesQueue.shift();
    const right = nodesQueue.shift();

    explanationDiv.textContent =
      `Step ${mergeSteps.length + 1}: Merge two nodes with smallest frequencies:\n` +
      ` - '${left.char === null ? 'Internal' : left.char}' (freq: ${left.freq})\n` +
      ` - '${right.char === null ? 'Internal' : right.char}' (freq: ${right.freq})\n\n` +
      &quot;Create new internal node with combined frequency and add back to the priority queue.&quot;;

    const merged = new Node(null, left.freq + right.freq, left, right);
    mergeSteps.push({left, right, merged});
    nodesQueue.push(merged);
    nodesQueue.sort((a,b) => a.freq - b.freq);

    drawMergeStep(mergeSteps.length - 1);
    setTimeout(buildTreeStepwise, 2500);
  }

  function assignPositions(node, depth=0, xMin=0, xMax=canvas.width) {
    if (!node) return;
    node.y = 50 + depth * 70;
    if (!node.left &amp;&amp; !node.right) {
      node.x = (xMin + xMax) / 2;
      return;
    }
    assignPositions(node.left, depth+1, xMin, (xMin+xMax)/2);
    assignPositions(node.right, depth+1, (xMin+xMax)/2, xMax);
    node.x = (node.left.x + node.right.x) / 2;
  }

  function drawTree(node) {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    assignPositions(node);
    ctx.strokeStyle = &quot;#333&quot;;
    ctx.fillStyle = &quot;#0074D9&quot;;
    ctx.lineWidth = 2;
    ctx.font = &quot;14px monospace&quot;;
    ctx.textAlign = &quot;center&quot;;
    ctx.textBaseline = &quot;middle&quot;;

    function drawNode(n) {
      if (!n) return;
      if(n.left) {
        ctx.beginPath();
        ctx.moveTo(n.x, n.y);
        ctx.lineTo(n.left.x, n.left.y);
        ctx.stroke();
        drawNode(n.left);
      }
      if(n.right) {
        ctx.beginPath();
        ctx.moveTo(n.x, n.y);
        ctx.lineTo(n.right.x, n.right.y);
        ctx.stroke();
        drawNode(n.right);
      }

      ctx.beginPath();
      ctx.arc(n.x, n.y, 20, 0, 2 * Math.PI);
      ctx.fill();
      ctx.stroke();

      ctx.fillStyle = &quot;#fff&quot;;
      if(n.char === null){
        ctx.fillText(n.freq, n.x, n.y);
      } else {
        ctx.fillText(n.char, n.x, n.y-6);
        ctx.fillText(n.freq, n.x, n.y+10);
      }
      ctx.fillStyle = &quot;#0074D9&quot;;
    }
    drawNode(node);
  }

  function drawMergeStep(stepIdx) {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    const step = mergeSteps[stepIdx];
    assignPositions(step.merged);
    ctx.strokeStyle = &quot;#ccc&quot;;
    ctx.fillStyle = &quot;#3498db&quot;;
    ctx.lineWidth = 2;
    ctx.font = &quot;14px monospace&quot;;
    ctx.textAlign = &quot;center&quot;;
    ctx.textBaseline = &quot;middle&quot;;

    // Draw all previous merges (lighter)
    for (let i=0; i<stepIdx; i++) {
      drawNodeSubtree(mergeSteps[i].merged, &quot;#ccc&quot;, &quot;#3498db&quot;);
    }

    // Draw current merged subtree highlighted
    drawNodeSubtree(step.merged, &quot;#e67e22&quot;, &quot;#d35400&quot;);

    // Draw remaining nodesQueue (leaves or unmerged)
    for (const node of nodesQueue) {
      if (!mergeSteps.some(ms => ms.merged === node)) {
        ctx.beginPath();
        ctx.arc(node.x || 0, node.y || 0, 20, 0, 2 * Math.PI);
        ctx.fillStyle = &quot;#3498db&quot;;
        ctx.fill();
        ctx.strokeStyle = &quot;#2980b9&quot;;
        ctx.stroke();
        ctx.fillStyle = &quot;#fff&quot;;
        ctx.fillText(node.char, node.x || 0, (node.y || 0)-6);
        ctx.fillText(node.freq, node.x || 0, (node.y || 0)+10);
      }
    }

    function drawNodeSubtree(node, edgeColor, fillColor) {
      if (!node) return;
      ctx.strokeStyle = edgeColor;
      ctx.fillStyle = fillColor;
      ctx.lineWidth = 2;

      if(node.left){
        ctx.beginPath();
        ctx.moveTo(node.x, node.y);
        ctx.lineTo(node.left.x, node.left.y);
        ctx.stroke();
        drawNodeSubtree(node.left, edgeColor, fillColor);
      }
      if(node.right){
        ctx.beginPath();
        ctx.moveTo(node.x, node.y);
        ctx.lineTo(node.right.x, node.right.y);
        ctx.stroke();
        drawNodeSubtree(node.right, edgeColor, fillColor);
      }
      ctx.beginPath();
      ctx.arc(node.x, node.y, 20, 0, 2 * Math.PI);
      ctx.fill();
      ctx.stroke();

      ctx.fillStyle = &quot;#fff&quot;;
      if(node.char === null){
        ctx.fillText(node.freq, node.x, node.y);
      } else {
        ctx.fillText(node.char, node.x, node.y-6);
        ctx.fillText(node.freq, node.x, node.y+10);
      }
    }
  }

  function generateCodes(node, prefix = '', codes = {}) {
    if (!node) return codes;
    if (node.char !== null) {
      codes[node.char] = prefix;
    }
    generateCodes(node.left, prefix + '0', codes);
    generateCodes(node.right, prefix + '1', codes);
    return codes;
  }

  function displayCodes(rootNode) {
    const codes = generateCodes(rootNode);
    let text = &quot;Huffman Codes:\n&quot;;
    for (const [ch, code] of Object.entries(codes)) {
      const displayChar = ch === ' ' ? &quot;' '&quot; : ch;
      text += `${displayChar} : ${code}\n`;
    }
    codesDiv.textContent = text + &quot;\n&quot; +
      &quot;Each code is derived by traversing the tree:\n&quot; +
      &quot;- '0' when going left\n&quot; +
      &quot;- '1' when going right\n&quot; +
      &quot;This yields prefix-free binary codes for lossless compression.&quot;;
  }

  function drawInitialQueue() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    const stepNodes = nodesQueue.slice();
    // Lay out nodes evenly horizontally
    const gap = canvas.width / (stepNodes.length + 1);
    stepNodes.forEach((node, i) => {
      node.x = gap * (i+1);
      node.y = canvas.height / 2;
      // Draw node
      ctx.beginPath();
      ctx.arc(node.x, node.y, 20, 0, 2 * Math.PI);
      ctx.fillStyle = &quot;#3498db&quot;;
      ctx.fill();
      ctx.strokeStyle = &quot;#2980b9&quot;;
      ctx.lineWidth = 2;
      ctx.stroke();

      ctx.fillStyle = &quot;#fff&quot;;
      ctx.font = &quot;14px monospace&quot;;
      ctx.textAlign = &quot;center&quot;;
      ctx.textBaseline = &quot;middle&quot;;
      ctx.fillText(node.char, node.x, node.y - 8);
      ctx.fillText(node.freq, node.x, node.y + 10);
    });
  }

  // Frequencies of input string
  const freqs = calcFrequencies(inputString);

  // Initial display
  freqTableDiv.textContent = &quot;Frequency Table:\n&quot; + Object.entries(freqs).map(([c,f]) => `'${c}': ${f}`).join('\n');
  codesDiv.textContent = &quot;&quot;;
  explanationDiv.textContent = &quot;Press the button to start Huffman Encoding.&quot;;
  drawTree(null);
</script>

</body>
</html>ID"><textarea id="2jYwd" style="display: none;">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
&lt;meta charset="UTF-8" /&gt;
&lt;title&gt;Huffman Encoding with Explanation Overlays&lt;/title&gt;
&lt;style&gt;
  body {
    font-family: sans-serif;
    text-align: center;
    padding: 20px;
    background: #f4f4f4;
  }
  canvas {
    border: 1px solid #ccc;
    background: #fff;
    display: block;
    margin: 0 auto;
  }
  button {
    font-size: 16px;
    padding: 8px 12px;
    margin: 10px;
  }
  #freqTable, #codes, #explanation {
    max-width: 700px;
    margin: 10px auto;
    text-align: left;
    font-family: monospace;
    background: #fff;
    padding: 12px;
    border-radius: 6px;
    box-shadow: 0 0 8px #ccc;
    white-space: pre-wrap;
  }
  #explanation {
    font-size: 15px;
    line-height: 1.4;
    color: #222;
  }
&lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;h2&gt;Huffman Encoding Visualization with Detailed Explanation&lt;/h2&gt;
&lt;button onclick="startHuffman()"&gt;Start Huffman Encoding&lt;/button&gt;
&lt;canvas id="canvas" width="600" height="400"&gt;&lt;/canvas&gt;

&lt;div id="freqTable"&gt;&lt;/div&gt;
&lt;div id="explanation"&gt;&lt;/div&gt;
&lt;div id="codes"&gt;&lt;/div&gt;

&lt;script&gt;
  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d');
  const freqTableDiv = document.getElementById('freqTable');
  const codesDiv = document.getElementById('codes');
  const explanationDiv = document.getElementById('explanation');

  // Example input string
  const inputString = "this is an example of huffman encoding";

  // Calculate frequencies
  function calcFrequencies(str) {
    const freq = {};
    for (const ch of str) {
      freq[ch] = (freq[ch] || 0) + 1;
    }
    return freq;
  }

  class Node {
    constructor(char, freq, left = null, right = null) {
      this.char = char;
      this.freq = freq;
      this.left = left;
      this.right = right;
      this.x = 0;
      this.y = 0;
    }
  }

  function buildPriorityQueue(freqs) {
    const nodes = [];
    for (const [char, freq] of Object.entries(freqs)) {
      nodes.push(new Node(char, freq));
    }
    return nodes.sort((a,b) =&gt; a.freq - b.freq);
  }

  let nodesQueue;
  let mergeSteps = [];
  let root = null;

  function startHuffman() {
    freqTableDiv.textContent = "Frequency Table:\n" + Object.entries(freqs).map(([c,f]) =&gt; `'${c}': ${f}`).join('\n');
    codesDiv.textContent = "";
    explanationDiv.textContent = "Starting Huffman Encoding...\n\n" +
      "We begin by building a priority queue of nodes from characters sorted by frequency.";
    nodesQueue = buildPriorityQueue(freqs);
    mergeSteps = [];
    root = null;
    drawInitialQueue();
    setTimeout(buildTreeStepwise, 1500);
  }

  function buildTreeStepwise() {
    if (nodesQueue.length === 1) {
      root = nodesQueue[0];
      drawTree(root);
      explanationDiv.textContent = "All nodes merged! Huffman tree construction completed.\n\n" +
        "Now, we generate Huffman codes by traversing the tree from root to leaves:\n" +
        "- Left edge adds '0' to the code\n- Right edge adds '1' to the code";
      displayCodes(root);
      return;
    }

    // Take two smallest nodes
    const left = nodesQueue.shift();
    const right = nodesQueue.shift();

    explanationDiv.textContent =
      `Step ${mergeSteps.length + 1}: Merge two nodes with smallest frequencies:\n` +
      ` - '${left.char === null ? 'Internal' : left.char}' (freq: ${left.freq})\n` +
      ` - '${right.char === null ? 'Internal' : right.char}' (freq: ${right.freq})\n\n` +
      "Create new internal node with combined frequency and add back to the priority queue.";

    const merged = new Node(null, left.freq + right.freq, left, right);
    mergeSteps.push({left, right, merged});
    nodesQueue.push(merged);
    nodesQueue.sort((a,b) =&gt; a.freq - b.freq);

    drawMergeStep(mergeSteps.length - 1);
    setTimeout(buildTreeStepwise, 2500);
  }

  function assignPositions(node, depth=0, xMin=0, xMax=canvas.width) {
    if (!node) return;
    node.y = 50 + depth * 70;
    if (!node.left &amp;&amp; !node.right) {
      node.x = (xMin + xMax) / 2;
      return;
    }
    assignPositions(node.left, depth+1, xMin, (xMin+xMax)/2);
    assignPositions(node.right, depth+1, (xMin+xMax)/2, xMax);
    node.x = (node.left.x + node.right.x) / 2;
  }

  function drawTree(node) {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    assignPositions(node);
    ctx.strokeStyle = "#333";
    ctx.fillStyle = "#0074D9";
    ctx.lineWidth = 2;
    ctx.font = "14px monospace";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";

    function drawNode(n) {
      if (!n) return;
      if(n.left) {
        ctx.beginPath();
        ctx.moveTo(n.x, n.y);
        ctx.lineTo(n.left.x, n.left.y);
        ctx.stroke();
        drawNode(n.left);
      }
      if(n.right) {
        ctx.beginPath();
        ctx.moveTo(n.x, n.y);
        ctx.lineTo(n.right.x, n.right.y);
        ctx.stroke();
        drawNode(n.right);
      }

      ctx.beginPath();
      ctx.arc(n.x, n.y, 20, 0, 2 * Math.PI);
      ctx.fill();
      ctx.stroke();

      ctx.fillStyle = "#fff";
      if(n.char === null){
        ctx.fillText(n.freq, n.x, n.y);
      } else {
        ctx.fillText(n.char, n.x, n.y-6);
        ctx.fillText(n.freq, n.x, n.y+10);
      }
      ctx.fillStyle = "#0074D9";
    }
    drawNode(node);
  }

  function drawMergeStep(stepIdx) {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    const step = mergeSteps[stepIdx];
    assignPositions(step.merged);
    ctx.strokeStyle = "#ccc";
    ctx.fillStyle = "#3498db";
    ctx.lineWidth = 2;
    ctx.font = "14px monospace";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";

    // Draw all previous merges (lighter)
    for (let i=0; i&lt;stepIdx; i++) {
      drawNodeSubtree(mergeSteps[i].merged, "#ccc", "#3498db");
    }

    // Draw current merged subtree highlighted
    drawNodeSubtree(step.merged, "#e67e22", "#d35400");

    // Draw remaining nodesQueue (leaves or unmerged)
    for (const node of nodesQueue) {
      if (!mergeSteps.some(ms =&gt; ms.merged === node)) {
        ctx.beginPath();
        ctx.arc(node.x || 0, node.y || 0, 20, 0, 2 * Math.PI);
        ctx.fillStyle = "#3498db";
        ctx.fill();
        ctx.strokeStyle = "#2980b9";
        ctx.stroke();
        ctx.fillStyle = "#fff";
        ctx.fillText(node.char, node.x || 0, (node.y || 0)-6);
        ctx.fillText(node.freq, node.x || 0, (node.y || 0)+10);
      }
    }

    function drawNodeSubtree(node, edgeColor, fillColor) {
      if (!node) return;
      ctx.strokeStyle = edgeColor;
      ctx.fillStyle = fillColor;
      ctx.lineWidth = 2;

      if(node.left){
        ctx.beginPath();
        ctx.moveTo(node.x, node.y);
        ctx.lineTo(node.left.x, node.left.y);
        ctx.stroke();
        drawNodeSubtree(node.left, edgeColor, fillColor);
      }
      if(node.right){
        ctx.beginPath();
        ctx.moveTo(node.x, node.y);
        ctx.lineTo(node.right.x, node.right.y);
        ctx.stroke();
        drawNodeSubtree(node.right, edgeColor, fillColor);
      }
      ctx.beginPath();
      ctx.arc(node.x, node.y, 20, 0, 2 * Math.PI);
      ctx.fill();
      ctx.stroke();

      ctx.fillStyle = "#fff";
      if(node.char === null){
        ctx.fillText(node.freq, node.x, node.y);
      } else {
        ctx.fillText(node.char, node.x, node.y-6);
        ctx.fillText(node.freq, node.x, node.y+10);
      }
    }
  }

  function generateCodes(node, prefix = '', codes = {}) {
    if (!node) return codes;
    if (node.char !== null) {
      codes[node.char] = prefix;
    }
    generateCodes(node.left, prefix + '0', codes);
    generateCodes(node.right, prefix + '1', codes);
    return codes;
  }

  function displayCodes(rootNode) {
    const codes = generateCodes(rootNode);
    let text = "Huffman Codes:\n";
    for (const [ch, code] of Object.entries(codes)) {
      const displayChar = ch === ' ' ? "' '" : ch;
      text += `${displayChar} : ${code}\n`;
    }
    codesDiv.textContent = text + "\n" +
      "Each code is derived by traversing the tree:\n" +
      "- '0' when going left\n" +
      "- '1' when going right\n" +
      "This yields prefix-free binary codes for lossless compression.";
  }

  function drawInitialQueue() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    const stepNodes = nodesQueue.slice();
    // Lay out nodes evenly horizontally
    const gap = canvas.width / (stepNodes.length + 1);
    stepNodes.forEach((node, i) =&gt; {
      node.x = gap * (i+1);
      node.y = canvas.height / 2;
      // Draw node
      ctx.beginPath();
      ctx.arc(node.x, node.y, 20, 0, 2 * Math.PI);
      ctx.fillStyle = "#3498db";
      ctx.fill();
      ctx.strokeStyle = "#2980b9";
      ctx.lineWidth = 2;
      ctx.stroke();

      ctx.fillStyle = "#fff";
      ctx.font = "14px monospace";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText(node.char, node.x, node.y - 8);
      ctx.fillText(node.freq, node.x, node.y + 10);
    });
  }

  // Frequencies of input string
  const freqs = calcFrequencies(inputString);

  // Initial display
  freqTableDiv.textContent = "Frequency Table:\n" + Object.entries(freqs).map(([c,f]) =&gt; `'${c}': ${f}`).join('\n');
  codesDiv.textContent = "";
  explanationDiv.textContent = "Press the button to start Huffman Encoding.";
  drawTree(null);
&lt;/script&gt;

&lt;/body&gt;
&lt;/html&gt;</textarea> <iframe id="a0PPX" class="result_iframe" style="border:none;"></iframe>
 <script>{
const textarea = document.getElementById("2jYwd");
const iframe = document.getElementById("a0PPX");
const html = textarea.value;
const iframeHTML = `${html}`;
const doc = iframe.contentDocument || iframe.contentWindow.document;
doc.open();
doc.write(iframeHTML);
doc.close();
setTimeout(() => {
   iframe.style.height = '0px';
   let contentHeight = Math.max(doc.body.scrollHeight,doc.documentElement.scrollHeight);
   if(contentHeight < 10 || contentHeight > 800){
	   contentHeight = 800;
   } 
   iframe.style.height = contentHeight + 'px';
}, 50);
}
		</script>
</div><h3 id="the-greedy-approach">The Greedy Approach</h3><p>Huffman’s algorithm uses a greedy strategy and a <strong>priority queue</strong> (min-heap) to build a binary tree with minimum total weighted path length:</p><ol>
 <li><p><strong>Start with leaf nodes</strong> for each character, each with its frequency.</p></li>
 <li><p><strong>Insert all nodes</strong> into a min-heap ordered by frequency.</p></li>
 <li><p>While there is more than one node in the heap:</p>
  <ul>
   <li>Remove the two nodes with the lowest frequencies.</li>
   <li>Create a new node with these two as children, and frequency equal to their sum.</li>
   <li>Insert the new node back into the heap.</li>
  </ul></li>
 <li><p>The remaining node becomes the <strong>root of the Huffman tree</strong>.</p></li>
</ol><p>The tree is then traversed to assign binary codes: left edges represent <code>0</code>, and right edges represent <code>1</code>.</p><h3 id="javascript-implementation">JavaScript Implementation</h3><p>Here is a simplified JavaScript implementation of Huffman encoding using a priority queue:</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-js">class Node {
  constructor(char, freq, left = null, right = null) {
    this.char = char;
    this.freq = freq;
    this.left = left;
    this.right = right;
  }
}

// Priority queue using array (simplified)
function buildHuffmanTree(charFreqs) {
  let queue = [];

  for (const [char, freq] of Object.entries(charFreqs)) {
    queue.push(new Node(char, freq));
  }

  queue.sort((a, b) =&gt; a.freq - b.freq);

  while (queue.length &gt; 1) {
    const left = queue.shift();
    const right = queue.shift();

    const newNode = new Node(null, left.freq + right.freq, left, right);
    queue.push(newNode);
    queue.sort((a, b) =&gt; a.freq - b.freq);
  }

  return queue[0]; // Root of Huffman tree
}

function generateCodes(node, prefix = "", codes = {}) {
  if (!node.left &amp;&amp; !node.right) {
    codes[node.char] = prefix;
    return codes;
  }
  if (node.left) generateCodes(node.left, prefix + "0", codes);
  if (node.right) generateCodes(node.right, prefix + "1", codes);
  return codes;
}

// Example
const frequencies = {
  A: 5, B: 9, C: 12, D: 13, E: 16, F: 45
};

const huffmanTree = buildHuffmanTree(frequencies);
const codes = generateCodes(huffmanTree);

console.log("Huffman Codes:", codes);</code></pre>
</div><p><strong>Sample Output:</strong></p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-bash">Huffman Codes: { F: '0', C: '100', D: '101', A: '1100', B: '1101', E: '111' }</code></pre>
</div><p>In this output, the most frequent character <code>F</code> has the shortest code (<code>0</code>), while less frequent characters like <code>A</code> have longer codes (<code>1100</code>). This minimizes the overall size of encoded messages.</p><h3 id="why-its-greedy">Why Its Greedy</h3><p>Huffman’s algorithm makes greedy decisions by always combining the two least frequent symbols (or subtrees) at each step. This locally optimal choice ensures that more frequent symbols end up closer to the root (shorter codes), which in turn minimizes the weighted sum of the tree depths.</p><p>The correctness of this greedy strategy is supported by the <strong>Greedy-Choice Property</strong> and <strong>Optimal Substructure</strong>, which guarantee that combining the least frequent items at each step produces an optimal prefix code.</p><h3 id="applications-in-data-compression">Applications in Data Compression</h3><p>Huffman coding is widely used in both theoretical and real-world compression tools:</p><ul>
 <li><strong>File formats</strong>: ZIP, GZIP, JPEG, PNG use Huffman encoding as part of their compression pipeline.</li>
 <li><strong>Multimedia codecs</strong>: MP3 and MPEG video formats include Huffman-like coding for entropy compression.</li>
 <li><strong>Network protocols</strong>: Efficient encoding for transmitting data over bandwidth-constrained connections.</li>
</ul><p>Its strength lies in its ability to compress data <strong>without loss</strong>, preserving full fidelity of the original content while reducing space.</p><h3 id="summary">Summary</h3><p>Huffman encoding is a powerful example of greedy algorithms in action. By always combining the least frequent symbols first, we build an optimal prefix-free encoding tree. The approach is efficient, easy to implement, and highly effective in practice. Huffman’s algorithm is a foundational concept in computer science and a great demonstration of how greedy techniques can lead to provably optimal solutions.</p><div class = "chapter-navi-section">
<a href="#top" class="nav-button prev">↑</a>
<a href='javascript-algorithms.htm#greedy-algorithms' class="nav-button toc-link">Index</a>
<a href="#bottom" class="nav-button next">↓</a>
</div>
<h2 id='interval-scheduling'>19.4 Interval Scheduling</h2><p>The <strong>interval scheduling problem</strong> is a fundamental problem in resource allocation and scheduling, where the goal is to choose a subset of non-overlapping intervals from a given list. This is closely related to the <strong>activity selection problem</strong>, but can vary in complexity depending on the constraints of the specific scenario.</p><p>These problems commonly arise in scheduling systems, such as meeting room assignments, booking conference slots, CPU job scheduling, or managing shared resources over time.</p><h3 id="problem-definition">Problem Definition</h3><p>In the most basic form, interval scheduling is defined as:</p><blockquote>
 <p><strong>Given</strong>: A list of intervals, each with a <code>start</code> and <code>end</code> time. <strong>Goal</strong>: Select the maximum number of mutually non-overlapping intervals.</p>
</blockquote><p>For example, imagine a shared meeting room and several teams wanting to book it. Each booking request is an interval, and your goal is to accept as many non-overlapping meetings as possible using a single room.</p><div class="snippet-container" id="<!DOCTYPE html>
<html lang=&quot;en&quot;>
<head>
<meta charset=&quot;UTF-8&quot; />
<title>Interval Scheduling Problem Visualization</title>
<style>
  body {
    font-family: sans-serif;
    padding: 20px;
    background: #fafafa;
    text-align: center;
  }
  canvas {
    border: 1px solid #ccc;
    background: #fff;
    display: block;
    margin: 10px auto;
  }
  button {
    font-size: 16px;
    padding: 8px 14px;
    margin: 10px;
  }
  #explanation {
    max-width: 700px;
    margin: 20px auto;
    font-family: monospace;
    background: #fff;
    padding: 12px;
    border-radius: 6px;
    box-shadow: 0 0 8px #ccc;
    white-space: pre-wrap;
    text-align: left;
  }
</style>
</head>
<body>

<h2>Interval Scheduling Problem Visualization</h2>
<button onclick=&quot;startScheduling()&quot;>Start Interval Scheduling</button>
<canvas id=&quot;canvas&quot; width=&quot;800&quot; height=&quot;300&quot;></canvas>
<div id=&quot;explanation&quot;>Press &quot;Start Interval Scheduling&quot; to begin.</div>

<script>
  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d');
  const explanationDiv = document.getElementById('explanation');

  // Sample intervals: [start, end]
  const intervals = [
    [1, 4],
    [3, 5],
    [0, 6],
    [5, 7],
    [3, 9],
    [5, 9],
    [6, 10],
    [8, 11],
    [8, 12],
    [2, 14],
    [12, 16],
  ];

  // Sort intervals by finish time (end)
  const sortedIntervals = intervals.slice().sort((a,b) => a[1] - b[1]);

  let selected = [];
  let stepIndex = 0;

  // Constants for drawing
  const timelineStart = 0;
  const timelineEnd = 16;
  const marginLeft = 50;
  const marginRight = 50;
  const marginTop = 40;
  const intervalHeight = 25;
  const gap = 10;
  const totalHeight = (intervalHeight + gap) * sortedIntervals.length + marginTop;

  canvas.height = totalHeight;

  function timeToX(t) {
    const usableWidth = canvas.width - marginLeft - marginRight;
    return marginLeft + (t - timelineStart) / (timelineEnd - timelineStart) * usableWidth;
  }

  function drawIntervals(currentIndex = -1) {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // Draw timeline axis
    ctx.strokeStyle = '#333';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(marginLeft, marginTop - 20);
    ctx.lineTo(canvas.width - marginRight, marginTop - 20);
    ctx.stroke();

    // Draw timeline ticks and labels
    ctx.fillStyle = '#333';
    ctx.font = '14px monospace';
    ctx.textAlign = 'center';
    for (let t = timelineStart; t <= timelineEnd; t++) {
      let x = timeToX(t);
      ctx.beginPath();
      ctx.moveTo(x, marginTop - 25);
      ctx.lineTo(x, marginTop - 15);
      ctx.stroke();
      ctx.fillText(t, x, marginTop - 35);
    }

    // Draw all intervals as bars
    for (let i = 0; i < sortedIntervals.length; i++) {
      const [start, end] = sortedIntervals[i];
      const x1 = timeToX(start);
      const x2 = timeToX(end);
      const y = marginTop + i * (intervalHeight + gap);

      // Determine bar color based on selection and current step
      if (selected.includes(i)) {
        ctx.fillStyle = '#27ae60'; // selected green
      } else if (i === currentIndex) {
        ctx.fillStyle = '#f39c12'; // current orange
      } else {
        ctx.fillStyle = '#7f8c8d'; // default gray
      }

      // Draw rectangle for interval
      ctx.fillRect(x1, y, x2 - x1, intervalHeight);

      // Draw border
      ctx.strokeStyle = '#333';
      ctx.lineWidth = 1;
      ctx.strokeRect(x1, y, x2 - x1, intervalHeight);

      // Draw text label [start,end]
      ctx.fillStyle = '#fff';
      ctx.font = '14px monospace';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(`[${start},${end}]`, (x1 + x2)/2, y + intervalHeight/2);
    }
  }

  function startScheduling() {
    selected = [];
    stepIndex = 0;
    explanationDiv.textContent = &quot;Intervals sorted by earliest finish time.\n&quot; +
      &quot;We select intervals greedily, choosing the earliest finishing compatible interval at each step.&quot;;
    drawIntervals();
    setTimeout(stepScheduling, 1500);
  }

  function stepScheduling() {
    if (stepIndex >= sortedIntervals.length) {
      explanationDiv.textContent += &quot;\n\nScheduling complete.\nSelected intervals:\n&quot; +
        selected.map(i => `[${sortedIntervals[i][0]},${sortedIntervals[i][1]}]`).join(', ');
      drawIntervals(-1);
      return;
    }

    const [curStart, curEnd] = sortedIntervals[stepIndex];
    let canSelect = true;

    if (selected.length > 0) {
      const lastSelected = sortedIntervals[selected[selected.length-1]];
      if (curStart < lastSelected[1]) {
        canSelect = false;
      }
    }

    explanationDiv.textContent =
      `Step ${stepIndex+1}:\n` +
      `Considering interval [${curStart}, ${curEnd}]\n` +
      (canSelect
        ? `This interval does not overlap with previously selected intervals.\nSelecting it.`
        : `This interval overlaps with previously selected interval [${sortedIntervals[selected[selected.length-1]][0]}, ${sortedIntervals[selected[selected.length-1]][1]}]. Skipping it.`);

    if (canSelect) {
      selected.push(stepIndex);
    }

    drawIntervals(stepIndex);
    stepIndex++;
    setTimeout(stepScheduling, 2000);
  }

  // Initial draw
  drawIntervals();
</script>

</body>
</html>ID"><textarea id="9Iqoo" style="display: none;">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
&lt;meta charset="UTF-8" /&gt;
&lt;title&gt;Interval Scheduling Problem Visualization&lt;/title&gt;
&lt;style&gt;
  body {
    font-family: sans-serif;
    padding: 20px;
    background: #fafafa;
    text-align: center;
  }
  canvas {
    border: 1px solid #ccc;
    background: #fff;
    display: block;
    margin: 10px auto;
  }
  button {
    font-size: 16px;
    padding: 8px 14px;
    margin: 10px;
  }
  #explanation {
    max-width: 700px;
    margin: 20px auto;
    font-family: monospace;
    background: #fff;
    padding: 12px;
    border-radius: 6px;
    box-shadow: 0 0 8px #ccc;
    white-space: pre-wrap;
    text-align: left;
  }
&lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;h2&gt;Interval Scheduling Problem Visualization&lt;/h2&gt;
&lt;button onclick="startScheduling()"&gt;Start Interval Scheduling&lt;/button&gt;
&lt;canvas id="canvas" width="800" height="300"&gt;&lt;/canvas&gt;
&lt;div id="explanation"&gt;Press "Start Interval Scheduling" to begin.&lt;/div&gt;

&lt;script&gt;
  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d');
  const explanationDiv = document.getElementById('explanation');

  // Sample intervals: [start, end]
  const intervals = [
    [1, 4],
    [3, 5],
    [0, 6],
    [5, 7],
    [3, 9],
    [5, 9],
    [6, 10],
    [8, 11],
    [8, 12],
    [2, 14],
    [12, 16],
  ];

  // Sort intervals by finish time (end)
  const sortedIntervals = intervals.slice().sort((a,b) =&gt; a[1] - b[1]);

  let selected = [];
  let stepIndex = 0;

  // Constants for drawing
  const timelineStart = 0;
  const timelineEnd = 16;
  const marginLeft = 50;
  const marginRight = 50;
  const marginTop = 40;
  const intervalHeight = 25;
  const gap = 10;
  const totalHeight = (intervalHeight + gap) * sortedIntervals.length + marginTop;

  canvas.height = totalHeight;

  function timeToX(t) {
    const usableWidth = canvas.width - marginLeft - marginRight;
    return marginLeft + (t - timelineStart) / (timelineEnd - timelineStart) * usableWidth;
  }

  function drawIntervals(currentIndex = -1) {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // Draw timeline axis
    ctx.strokeStyle = '#333';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(marginLeft, marginTop - 20);
    ctx.lineTo(canvas.width - marginRight, marginTop - 20);
    ctx.stroke();

    // Draw timeline ticks and labels
    ctx.fillStyle = '#333';
    ctx.font = '14px monospace';
    ctx.textAlign = 'center';
    for (let t = timelineStart; t &lt;= timelineEnd; t++) {
      let x = timeToX(t);
      ctx.beginPath();
      ctx.moveTo(x, marginTop - 25);
      ctx.lineTo(x, marginTop - 15);
      ctx.stroke();
      ctx.fillText(t, x, marginTop - 35);
    }

    // Draw all intervals as bars
    for (let i = 0; i &lt; sortedIntervals.length; i++) {
      const [start, end] = sortedIntervals[i];
      const x1 = timeToX(start);
      const x2 = timeToX(end);
      const y = marginTop + i * (intervalHeight + gap);

      // Determine bar color based on selection and current step
      if (selected.includes(i)) {
        ctx.fillStyle = '#27ae60'; // selected green
      } else if (i === currentIndex) {
        ctx.fillStyle = '#f39c12'; // current orange
      } else {
        ctx.fillStyle = '#7f8c8d'; // default gray
      }

      // Draw rectangle for interval
      ctx.fillRect(x1, y, x2 - x1, intervalHeight);

      // Draw border
      ctx.strokeStyle = '#333';
      ctx.lineWidth = 1;
      ctx.strokeRect(x1, y, x2 - x1, intervalHeight);

      // Draw text label [start,end]
      ctx.fillStyle = '#fff';
      ctx.font = '14px monospace';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(`[${start},${end}]`, (x1 + x2)/2, y + intervalHeight/2);
    }
  }

  function startScheduling() {
    selected = [];
    stepIndex = 0;
    explanationDiv.textContent = "Intervals sorted by earliest finish time.\n" +
      "We select intervals greedily, choosing the earliest finishing compatible interval at each step.";
    drawIntervals();
    setTimeout(stepScheduling, 1500);
  }

  function stepScheduling() {
    if (stepIndex &gt;= sortedIntervals.length) {
      explanationDiv.textContent += "\n\nScheduling complete.\nSelected intervals:\n" +
        selected.map(i =&gt; `[${sortedIntervals[i][0]},${sortedIntervals[i][1]}]`).join(', ');
      drawIntervals(-1);
      return;
    }

    const [curStart, curEnd] = sortedIntervals[stepIndex];
    let canSelect = true;

    if (selected.length &gt; 0) {
      const lastSelected = sortedIntervals[selected[selected.length-1]];
      if (curStart &lt; lastSelected[1]) {
        canSelect = false;
      }
    }

    explanationDiv.textContent =
      `Step ${stepIndex+1}:\n` +
      `Considering interval [${curStart}, ${curEnd}]\n` +
      (canSelect
        ? `This interval does not overlap with previously selected intervals.\nSelecting it.`
        : `This interval overlaps with previously selected interval [${sortedIntervals[selected[selected.length-1]][0]}, ${sortedIntervals[selected[selected.length-1]][1]}]. Skipping it.`);

    if (canSelect) {
      selected.push(stepIndex);
    }

    drawIntervals(stepIndex);
    stepIndex++;
    setTimeout(stepScheduling, 2000);
  }

  // Initial draw
  drawIntervals();
&lt;/script&gt;

&lt;/body&gt;
&lt;/html&gt;</textarea> <iframe id="kpdJ2" class="result_iframe" style="border:none;"></iframe>
 <script>{
const textarea = document.getElementById("9Iqoo");
const iframe = document.getElementById("kpdJ2");
const html = textarea.value;
const iframeHTML = `${html}`;
const doc = iframe.contentDocument || iframe.contentWindow.document;
doc.open();
doc.write(iframeHTML);
doc.close();
setTimeout(() => {
   iframe.style.height = '0px';
   let contentHeight = Math.max(doc.body.scrollHeight,doc.documentElement.scrollHeight);
   if(contentHeight < 10 || contentHeight > 800){
	   contentHeight = 800;
   } 
   iframe.style.height = contentHeight + 'px';
}, 50);
}
		</script>
</div><h3 id="greedy-strategy-earliest-finish-time">Greedy Strategy: Earliest Finish Time</h3><p>This problem can be solved efficiently with a greedy strategy:</p><ol>
 <li><p><strong>Sort the intervals by their end times</strong>.</p></li>
 <li><p><strong>Select the first interval</strong> (the one that ends earliest).</p></li>
 <li><p>For each subsequent interval:</p>
  <ul>
   <li>If its start time is greater than or equal to the end time of the last selected interval, select it.</li>
  </ul></li>
</ol><p>Why does this work? Choosing the interval that ends earliest <strong>leaves more room</strong> for upcoming intervals, maximizing the total number that can be scheduled. This strategy has both the <strong>greedy-choice property</strong> and <strong>optimal substructure</strong>, making it ideal for greedy algorithms.</p><h3 id="javascript-implementation">JavaScript Implementation</h3><p>Let’s implement a basic interval scheduling algorithm in JavaScript:</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-js">function scheduleIntervals(intervals) {
  // Sort intervals by end time
  intervals.sort((a, b) =&gt; a.end - b.end);

  const result = [];
  let currentEnd = 0;

  for (const interval of intervals) {
    if (interval.start &gt;= currentEnd) {
      result.push(interval);
      currentEnd = interval.end;
    }
  }

  return result;
}

// Example usage:
const intervals = [
  { start: 1, end: 3 },
  { start: 2, end: 5 },
  { start: 4, end: 7 },
  { start: 6, end: 9 },
  { start: 8, end: 10 }
];

const scheduled = scheduleIntervals(intervals);
console.log("Scheduled intervals:", scheduled);</code></pre>
</div><p><strong>Output:</strong></p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-bash">Scheduled intervals: [
  { start: 1, end: 3 },
  { start: 4, end: 7 },
  { start: 8, end: 10 }
]</code></pre>
</div><p>This implementation has a time complexity of <strong>O(n log n)</strong> due to the sorting step and runs in <strong>O(n)</strong> for interval selection.</p><h3 id="variations-and-constraints">Variations and Constraints</h3><p>Not all interval scheduling problems use the same greedy rule. Different constraints can change the optimal strategy:</p><ol>
 <li><p><strong>Weighted Interval Scheduling</strong>: Each interval has a weight (e.g., value or profit), and the goal is to maximize the total weight rather than the number of intervals. Greedy methods don't work here — dynamic programming is needed.</p></li>
 <li><p><strong>Multiple Resources (k rooms)</strong>: Instead of selecting a subset, the goal may be to assign all intervals to the fewest number of rooms such that no intervals in a room overlap. This leads to the <strong>Interval Partitioning</strong> problem, which also involves sorting and uses a <strong>priority queue</strong> to assign rooms efficiently.</p></li>
 <li><p><strong>Minimizing Idle Time</strong>: Some scheduling problems aim to minimize the total idle time between jobs. These require more sophisticated approaches and often cannot be solved greedily.</p></li>
</ol><h3 id="real-world-applications">Real-World Applications</h3><p>Interval scheduling is widely applicable in modern systems:</p><ul>
 <li><strong>Calendar management</strong>: Scheduling as many meetings as possible without conflict.</li>
 <li><strong>Classroom or lab usage</strong>: Assigning events to shared resources without overlaps.</li>
 <li><strong>Job scheduling on a processor</strong>: Running as many jobs as possible without overlaps.</li>
 <li><strong>Television broadcast</strong>: Scheduling non-overlapping shows to maximize viewership slots.</li>
</ul><p>In many calendar and scheduling apps (like Google Calendar or Microsoft Outlook), the underlying logic for finding available times or suggesting optimal meeting slots is based on interval scheduling principles.</p><h3 id="summary">Summary</h3><p>Interval scheduling is a classic greedy problem where selecting intervals with the <strong>earliest finish time</strong> leads to an optimal solution. This technique is powerful and widely applicable, but the correct greedy strategy depends on the problem’s constraints. By identifying when greedy algorithms are appropriate and understanding how to adapt them for variations, you can effectively solve many real-world scheduling challenges using simple and efficient logic in JavaScript.</p><div class = "chapter-navi-section">
<a href="javascript-algorithms-principles-of-dynamic-programming-classic-problems.htm" class="nav-button prev">←</a>
<a href='javascript-algorithms.htm#greedy-algorithms' class="nav-button toc-link">Index</a>
<a href="javascript-algorithms-backtracking-and-recursion.htm" class="nav-button next">→</a>
</div>
<section class="download-section">
  <div class="book-cover" style="background-color: #f9f6f1;border: 1px solid #ccc;"> 
    <div class="book-cover-title" style="font-size: 18px;color: #333;top: 20px;">JavaScript Algorithms</div>
    <div class="book-cover-author">readbytes</div>
    <div class="book-cover-bottom-stripe" style="background-color: #333;"></div>
    <img class="book-cover-icon" style="width: 80px;height: 80px;top: 70px;" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFoAAABaCAYAAAA4qEECAAAErElEQVR4Xu2dPWgUQRiGo6BB8I+AlV3w9gzptLBWsLQ89O7ARrDXSivTCTaCnWhn7pQTxOoInpjCeEQQLC2CjVqoVSwMFpp1Jtzo7Luzs/Nd7uZ29r4HPpDsu7vPvIl7+SGTmRmGYRiGYZjCEzVacdnn9NX7+3DdXkGhMg+u3Su6SNztzsZvevH/efED8zrJbM+6EGJ2K5Hv9w9gRpHnXMyik2VsYVaHWJx7tt/bTOQ3urOYUch3QJ5z0YtOCeuQiqNlvybyto/ktbVDcG2jc5GLNgoriMW5Z/svPyfy693DmFHE71ePwrUznQta9ISeyViyKBIziri/Mpe8tt25kEXjMR1ScbQsPC5W5jCjMJT8DTM6MuO6vrHjIkIszj2LL3y2ktOPiy+Y0VE5l/V5IU+EVBwtm/wUzva4SL/wOZUsJ2993rCJEIujZJMl2174Up/C5T8u9LGtzyu6SNkH1+6VhUargkJlHVy7f5aW9qJUqeZy5zguufToBeAxZoRw0Z7goj3BRXuCi/YEF+0BvWQue0xgwfrMiy+aMM8QEUW+w2IHb8fC/+C5jCOGMhOPiqi+vG47zjiABVbr7XOYUWC2Um+fxwwDiKJeYXGYMYHniNnGDDPAUJZTyYph30nTg+G7f5VLj89gzBW8lu2xMzWIIt5iMZgZBrzmqK4bJFhENOLnatRsfcR7YKb0YAELF5+cwsyowHudrLcvYKZ0iIV+wIVjZhzgPaMR/+8pFIbFeilZUWm2Vyd5/5GxWOvsx4VkTbXROovn+wJdMqfevoHnFoKUaMbgeZMAnbIGzysEKGmZiX4DKKo/um5wMg6eWwhsgtVm62cRFoEOJg/xtltZxwqBTV4inuEHcZHztc4RzI0LvLeY15iRBF+0wrDgsX6qZXpUYEanNEVLROY3ZfHDgvdwuU+pipYs1h7OpUqI4z2YGxa8dqXefooZE6UrWoGFiMn8nRIXoubyTbymeLPzO7C0RUuiRvuXoRwyeI1hrlPqoiUnap1jWNLilU7mr0sgeK746rOFGRdKX7QCC4tyHiXi+DU8BzMUpqZoiSzXpTzMZOUoTFXROxh+xKV/gYPHqvVlp88q8pi+ogdgoabBc3bD1BYtEdfcxnLHeK/pLVoiHxvJktsPMDMKpr5oX3DRnuCiPcFFe4KL9gQX7Qku2hNctCe4aE94K1puD6mXNsmpOv74KUTnxEdmEQb9TOA5kx70M6KfcO/u8/j2nWffxb+XskZm9MHjw2YjgrTKygnFeUaF5cSEjZ4c9kJyz/Z7mxTpEJ0T0nhMhyRBy+5sTuXioAjR2UmaKEHJ/tsBLM9BJ0TnXGmiBCWb2GbN5oCE6GyVJkq4Z3FXxo3ubJaDiRCdM6VJErSscTtik0MWITobpYkS7lncKVfblREdbITonJImSVCyKAz7i1KkQ3ROSJMkaNnc7Ygp0iE6Z0pjTockjC8iBmEJRTpEZ6M0ZnRIwrhTrmU7Yop0iM4paTyusyvhnO2IKdIhOqdeWLLYlbDtL0oM/jaKi4MiRGcnaZIwPt8c/zZKnoNOiM4J6SIM+pnAcyY96GekYJtvf0I/EyE6MwzDMAzDjI+/5MPGam/zucIAAAAASUVORK5CYII="/>
  </div>
  <div class="download-info">
    <h2 id='bottom'>Download This Ebook</h2>
    <p class="format-label">Available formats:</p>
    <div class="download-buttons">
      <a href="javascript-algorithms.pdf" class="download-button">📄 PDF</a>
      <a href="javascript-algorithms.epub" class="download-button">📘 EPUB</a>
    </div>
  </div>
</section><div class='related-books'>
<h2>Javascript In-Depth Books</h2>
<div class='related-book-list'>
<a href="javascript-clean-code.htm">
<div class="book-cover" style="background-color: #f9f6f1;border: 1px solid #ccc;"> 
    <div class="book-cover-title" style="font-size: 18px;color: #333;top: 20px;">JavaScript Clean Code</div>
    <div class="book-cover-author">readbytes</div>
    <div class="book-cover-bottom-stripe" style="background-color: #333;"></div>
    <img class="book-cover-icon" style="width: 90px;height: 90px;top: 65px;" src='data:image/png;base64,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'/>
  </div>
</a>


<a href="javascript-coding-best-practices.htm">
<div class="book-cover" style="background-color: #f9f6f1;border: 1px solid #ccc;"> 
    <div class="book-cover-title" style="font-size: 16px;color: #333;top: 20px;">JavaScript Coding Best Practices</div>
    <div class="book-cover-author">readbytes</div>
    <div class="book-cover-bottom-stripe" style="background-color: #333;"></div>
    <img class="book-cover-icon" style="width: 80px;height: 80px;top: 80px;" src='data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFoAAABaCAYAAAA4qEECAAADdklEQVR4Xu2dPW/UMBjHH0QRlRA7MDDBgBAbH4ABNsRCQXwHFpAQQwVKws1IwMaXYO/M1I0VWEC8bIgy81LO53sS54l9OSe2G7f/n/S/c2zXefpT4g6nXIkAAADkQUFvqKR9JECUyw4lbXYmIqGyaYpWHXtNBwhCST8XbpcH2jyIQ+1XvRS0VQ+8opPzvrfLvDfayLpRDpmKbpMh+lw90N1jkCFhlNvFsXqxieb2Np2tx0A/EJ0IiE6Et2iOKVqOmQEa6aNXNLdxRfsB0YmA6ER4i+bYRMs5MoqK7nf6x6ai76KS6cG1Mr2iuW0TDdxAdCIgOhHeojku0XJejMQ41x063rvmGOQaa4jeXry7Rd+a/9yLqGFk/5g09T/vjKmUdK2eMwRv0dx2iQZ2IDoR3qI5q0Tv07HO/IPIlJA1BRGt/rDI+QeRKSFr6hXN7VWiQReIToS36JLOrxT9mk7QjK63YiLHQiQHBojWcYmW88wTyL5QyQFZa69obrtEAzsQnQiIToS3aI5LtJw3NGPX8//Zm/U5Y2DWpegVzW2XaGAHohMB0YnwFs2xiZZzYkSf50un35YpIWvqFc1tm+jHdDpqfM71iE615h80QUUDNxCdCG/RHJdoOW9IFPpzuu7YmHRrfFn3xUbWsIbob4t3t+hd0g/DDEtF75brbHTGxqap8ceyb6Pui423aG67RAM7EJ0Ib9ElfXSKruirV44SA0Tr2ETLOX05SsjfuVc0t22igRuITgREJ8JbNMcULcfMAI300Sua27ii/YDoREB0IrxFI+PSKxqEBaITAdGJaIlG4mfxUtA9qugGEiHKrSEaW0csstyjO7djBmQnWn9GqZ98bR5S2pXTJkeGopXYX/VxRXtZXNUt0TO6KMcnh9wu5PFUKehCI7qkv3J8krDcXCQrKvpjis6jaEVBVxfJhdpv+yo5I+eBgSiXrbuvOfgtpCPj0zgl/pJu9QA9CEvzpQTLL+uu6F9jHgSBfSq3LWa0Zbn0kTEp6G5b8lRQxYXYwviWBQ5Cygm51qGipJ2gcvTtuyO7Ae9roQi93qFBSXlKV2T3YJ7RZYi2EUNKjDWz5gldiiJFrTmbrw2WxNpPY62bLVrIZ9k9mpI+QbRJTBkx186OmDJirp0FJT2o99BUqeihLOPwo//hWVdGzBT0QZYBAAAA/AcQ1vXmtMbyGwAAAABJRU5ErkJggg=='/>
  </div>
</a>


<a href="javascript-asynchronous-programming.htm">
<div class="book-cover" style="background-color: #f9f6f1;border: 1px solid #ccc;"> 
    <div class="book-cover-title" style="font-size: 18px;color: #333;top: 20px;">JavaScript Asynchronous Programming</div>
    <div class="book-cover-author">readbytes</div>
    <div class="book-cover-bottom-stripe" style="background-color: #333;"></div>
    <img class="book-cover-icon" style="width: 80px;height: 80px;top: 80px;" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFoAAABaCAYAAAA4qEECAAADU0lEQVR4Xu2cvW7UQBRGkwKJV0CipqJbG9pIFLGXRyD2IgpeghegQ9DRUNHQUdLQUVFAC0h0tFEKkMJPCEykRHKObzZrr6/t8X5H+qrMN3PvUbQpEmVra8NI8vLfWWazh1f4ddEBVcmVPOA5sQZB6DND8mkWj3hetCQI/VAXXE3xhB3RkrrcWl6wI1qQZuUrQ+75ZOVr9kQL0mxxpya3nnfsiRbs7Ny/ashFiq/siZbU5Z7PLC9/sCNaQrlGfrIjWmLIxXd28Z0d0QKKvSCSvQ5pXr41pF6QxT77vRF+Or+vDzTdhJW36cAdDrEpoQdX+PgmhS482ebjmxTKcIMPb1roww0+vGmhDzf4MMPzY4fzL8tsd+8a+27w8Wp4Nga4w7Kw6wofr+Qzz8aAsYcZ9tzhAIMN0gFh7l/cwwp7vcAhBh1mDcLMf7iDFfZ6g4MMPlALwrzHnN/IMXu9YgwUlehktY+LI/Z6xxgqGtFhzgPObeQve4NgDBaF6Nl88YUzGxn246KKMVwUojlvPYtx/dqqPuD4RSeX/aXSvDxgZ3BqQ0YhunjOec+SzstvPD8KOGgMok/gvKf5xHOjwRg2CtEnVOdNs+Ipvz4qKDgm0VFBwRLtBAVLtBMULNFOULBEO0HBEu0EBUu0ExQs0U5QsEQ7QcES7QQFS7QTFCzRTlCwRDtBwRLtBAVLtBMULNFOULBEO0HBEu0EBUu0ExQs0U5QsEQ7QcES7QQFS7QTFCzRTlBw16LDXb897o0OCu5SSLjniPd2dXd0UEKXMnhn1/dHBQV0KYJ3Mjw/abh8lxJ4pxV2JgsX71oA77XCziTh0h7L824r7EwOLuy1OO+3ws6k4LKeSydZech3GHYmAxf1XniWl2/4FsPOJOCSfSyb5sVLvsewEz1csK9l+ZYVdqKGyzFpXj5O7hY3u0q6u5fxjWXhvNHCxcYYzhwlXGqM4cxRwqXGmPDxdci5o4SLjTGcOVq42JgSvqOH+8+4HtzO713nkmMI5xQrQpGXhX3RAMq8KOyJBtyalzco1Ap7ohkr/RtllkRDKNQKO6IhFGqFHdEQCrXCjmgIhVphRzSEQq2wIxpCoVbYES2gVIbnRUsoVpKdCEL3KViSnUjm5cepSf4Pt8Ix0I7hKy8AAAAASUVORK5CYII="/>
  </div>
</a>


<a href="javascript-pragmatic-developer.htm">
<div class="book-cover" style="background-color: #f9f6f1;border: 1px solid #ccc;"> 
    <div class="book-cover-title" style="font-size: 18px;color: #333;top: 20px;">JavaScript Pragmatic Developer</div>
    <div class="book-cover-author">readbytes</div>
    <div class="book-cover-bottom-stripe" style="background-color: #333;"></div>
    <img class="book-cover-icon" style="width: 80px;height: 70px;top: 85px;" src="data:image/png;base64,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"/>
  </div>
</a>


<a href="javascript-algorithms.htm">
<div class="book-cover" style="background-color: #f9f6f1;border: 1px solid #ccc;"> 
    <div class="book-cover-title" style="font-size: 18px;color: #333;top: 20px;">JavaScript Algorithms</div>
    <div class="book-cover-author">readbytes</div>
    <div class="book-cover-bottom-stripe" style="background-color: #333;"></div>
    <img class="book-cover-icon" style="width: 80px;height: 80px;top: 70px;" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFoAAABaCAYAAAA4qEECAAAErElEQVR4Xu2dPWgUQRiGo6BB8I+AlV3w9gzptLBWsLQ89O7ARrDXSivTCTaCnWhn7pQTxOoInpjCeEQQLC2CjVqoVSwMFpp1Jtzo7Luzs/Nd7uZ29r4HPpDsu7vPvIl7+SGTmRmGYRiGYZjCEzVacdnn9NX7+3DdXkGhMg+u3Su6SNztzsZvevH/efED8zrJbM+6EGJ2K5Hv9w9gRpHnXMyik2VsYVaHWJx7tt/bTOQ3urOYUch3QJ5z0YtOCeuQiqNlvybyto/ktbVDcG2jc5GLNgoriMW5Z/svPyfy693DmFHE71ePwrUznQta9ISeyViyKBIziri/Mpe8tt25kEXjMR1ScbQsPC5W5jCjMJT8DTM6MuO6vrHjIkIszj2LL3y2ktOPiy+Y0VE5l/V5IU+EVBwtm/wUzva4SL/wOZUsJ2993rCJEIujZJMl2174Up/C5T8u9LGtzyu6SNkH1+6VhUargkJlHVy7f5aW9qJUqeZy5zguufToBeAxZoRw0Z7goj3BRXuCi/YEF+0BvWQue0xgwfrMiy+aMM8QEUW+w2IHb8fC/+C5jCOGMhOPiqi+vG47zjiABVbr7XOYUWC2Um+fxwwDiKJeYXGYMYHniNnGDDPAUJZTyYph30nTg+G7f5VLj89gzBW8lu2xMzWIIt5iMZgZBrzmqK4bJFhENOLnatRsfcR7YKb0YAELF5+cwsyowHudrLcvYKZ0iIV+wIVjZhzgPaMR/+8pFIbFeilZUWm2Vyd5/5GxWOvsx4VkTbXROovn+wJdMqfevoHnFoKUaMbgeZMAnbIGzysEKGmZiX4DKKo/um5wMg6eWwhsgtVm62cRFoEOJg/xtltZxwqBTV4inuEHcZHztc4RzI0LvLeY15iRBF+0wrDgsX6qZXpUYEanNEVLROY3ZfHDgvdwuU+pipYs1h7OpUqI4z2YGxa8dqXefooZE6UrWoGFiMn8nRIXoubyTbymeLPzO7C0RUuiRvuXoRwyeI1hrlPqoiUnap1jWNLilU7mr0sgeK746rOFGRdKX7QCC4tyHiXi+DU8BzMUpqZoiSzXpTzMZOUoTFXROxh+xKV/gYPHqvVlp88q8pi+ogdgoabBc3bD1BYtEdfcxnLHeK/pLVoiHxvJktsPMDMKpr5oX3DRnuCiPcFFe4KL9gQX7Qku2hNctCe4aE94K1puD6mXNsmpOv74KUTnxEdmEQb9TOA5kx70M6KfcO/u8/j2nWffxb+XskZm9MHjw2YjgrTKygnFeUaF5cSEjZ4c9kJyz/Z7mxTpEJ0T0nhMhyRBy+5sTuXioAjR2UmaKEHJ/tsBLM9BJ0TnXGmiBCWb2GbN5oCE6GyVJkq4Z3FXxo3ubJaDiRCdM6VJErSscTtik0MWITobpYkS7lncKVfblREdbITonJImSVCyKAz7i1KkQ3ROSJMkaNnc7Ygp0iE6Z0pjTockjC8iBmEJRTpEZ6M0ZnRIwrhTrmU7Yop0iM4paTyusyvhnO2IKdIhOqdeWLLYlbDtL0oM/jaKi4MiRGcnaZIwPt8c/zZKnoNOiM4J6SIM+pnAcyY96GekYJtvf0I/EyE6MwzDMAzDjI+/5MPGam/zucIAAAAASUVORK5CYII="/>
  </div>
</a>



<a href='javascript.htm'><div class='book-cover' style='background-color: #f9f6f1;color: #111111;border: 1px solid #ccc;display: flex;justify-content: center;align-items: center;text-align: center;'>More Javascript Books</div></a>
</div>
</div>
  </div>
  <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/prism.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
  
  <script>
    function copyCode(button) {
      const code = button.nextElementSibling.innerText;
      navigator.clipboard.writeText(code).then(() => {
        button.textContent = 'Copied!';
        setTimeout(() => { button.textContent = 'Copy'; }, 1500);
      });
    }
  </script>  
<div id="floatingLog" aria-live="polite" role="alert"></div>
<footer class="page-footer">
    <nav>
      <a href="https://readbytes.github.io">Home</a> | 
      Email:<script language="JavaScript" type="text/javascript">
var part1 = 'yinpeng';var part6 = '263';var part2 = Math.pow(2,6);var part3 = String.fromCharCode(part2);var part4 = 'hotmail dot com';var part5 = part1 + String.fromCharCode(part2) + part4;document.write(part1 + part6 + part3 + part4);
</script>
    </nav>
  <p>© 2025 — All rights reserved.</p>    
  </footer>

</body>
</html>