<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Java Collections Performance and Memory Considerations</title>
<link rel='shortcut icon' href='https://java2s.com/style/favicon.ico'>
<link href="https://fonts.googleapis.com/css2?family=Merriweather&display=swap" rel="stylesheet" />
<link href="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet" />


  <script>
  const mode = localStorage.getItem('mode') || 'light';
  document.documentElement.classList.add(`${mode}-mode`);
  </script>   
<style> 
html {
  scroll-behavior: smooth;
}

body {
  font-family: 'Merriweather', serif;
  margin: 0;
  padding: 2rem 1rem;
  font-size: 15px;
  line-height: 1.5;
  transition: background-color 0.3s, color 0.3s;
}

.container {
  max-width: 700px;
  margin: 0 auto;
  padding: 1rem 2rem;
  box-shadow: 0 0 15px rgba(0,0,0,0.1);
}

h1, h2, h3 {
  font-weight: 600;
  margin-top: 2.5rem;
  margin-bottom: 1rem;
  line-height: 1.2;
}

h1 { font-size: 1.8rem; }
h2 { font-size: 1.4rem; }
h3 { font-size: 1.2rem; }

table {
  width: 100%;
  border-collapse: collapse;
  font-family: sans-serif;
  font-size: 1em;
  margin: 1em 0;
}

th, td {
  padding: 0.6em 1em;
  text-align: left;
  border: 1px solid;
}

tr:nth-child(even) {
  background-color: inherit;
}

tr:hover {
  background-color: inherit;
}

a {
  text-decoration: none;
  transition: color 0.2s;
}

a:hover {
  text-decoration: underline;
}

code {
  color: #d35400;
}

.book-title-chapter {
  font-family: 'Merriweather', serif;
  font-size: 2rem;
  font-weight: bold;
  text-align: center;
  margin-bottom: 2rem;
  border-bottom: 2px solid;
  padding-bottom: 0.5rem;
}

.book-subtitle-chapter {
  text-align: center;
  font-size: 1rem;
  margin-top: -1rem;
  margin-bottom: 2rem;
}

.related-books {
  margin-top: 40px;
}

.related-book-list {
  display: flex;
  flex-wrap: wrap;
  gap: 20px;
}

    .book-cover {
      width: 130px;
      height: 180px;
      font-family: Arial, sans-serif;
      position: relative;
      overflow: hidden;      
      line-height: normal;
      box-shadow: 2px 2px 4px rgba(0,0,0,0.1);
    }
    .book-cover-bottom-stripe {
      position: absolute;
      bottom: 0;
      left: 0;
      height: 5px;
      width: 100%;
    }
    .book-cover-title {
      position: absolute;
      width: 100%;
      text-align: center;
      font-weight: bold;
    }
     
    .book-cover-icon {
      position: absolute;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      align-items: center;
      justify-content: center; 
    }

    .book-cover-author {
      position: absolute;
      bottom: 10px;
      width: 100%;
      text-align: center;
      font-size: 8px;
      color: #333;
    }

.page-footer {
  margin-top: 4rem;
  padding: 1rem 0;
  text-align: center;
  font-size: 0.85rem;
  border-top: 1px solid;
}

.chapter-navi-section {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding-bottom: 10px;
}

.nav-link {
  color: inherit;
  text-decoration: none;
  opacity: 0.5;
  transition: opacity 0.3s ease, text-decoration 0.3s ease;
}

.nav-link:hover {
  opacity: 0.9;
  text-decoration: underline;
}

.prev { text-align: left; }
.toc-link { text-align: center; }
.next { text-align: right; }

.download-section {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 2rem;
  padding: 2rem 1rem;
  max-width: 600px;
  margin: 3rem auto;
  border-radius: 12px;
  box-shadow: 0 4px 10px rgba(0,0,0,0.05);
}

.download-info h2 {
  margin: 0 0 0.5rem;
  font-size: 1.2rem;
}

.format-label {
  margin: 0 0 0.5rem;
  font-size: 0.95rem;
}

.download-buttons {
  display: flex;
  gap: 1rem;
}

.download-button {
  background-color: #4A90E2;
  color: white;
  padding: 0.5em 1.2em;
  border-radius: 25px;
  font-size: 0.95rem;
  text-decoration: none;
  transition: background-color 0.3s ease;
}

.download-button:hover {
  background-color: #357ABD;
}

.code-block {
  position: relative;
  margin-bottom: 1em;
}

.copy-button {
  background: transparent;
  color: white;
  position: absolute;
  top: 8px;
  right: 8px;
  border: none;
  padding: 4px 8px;
  font-size: 12px;
  border-radius: 4px;
  cursor: pointer;
  z-index: 1;
}

.copy-button:hover {
  background-color: #0056b3;
}

.snippet-container {
  overflow: hidden;
}

.snippet-header {
  padding: 0.75rem 1rem;
  cursor: pointer;
  font-size: 1rem;
 
    background-color: #eeeeee;
    color:  #111111; 
    border-radius: 8px;
    cursor: pointer;
    box-shadow: 0 4px 6px rgba(0,0,0,0.1);  
}

.snippet-body {
  display: none;
  font-family: monospace;
}

.snippet-container.open .snippet-body {
  display: block;
}

.CodeMirror {
  border: 2px solid #ccc;
  border-radius: 4px;
  resize: vertical;
}

/* === Light Mode === */
html.light-mode {
  background-color: #f8f7f5;
  color: #333;
}

html.light-mode .container {
  background: white;
}

html.light-mode .book-title-chapter {
  color: #2c3e50;
  border-color: #ccc;
}
html.light-mode .book-subtitle-chapter{
  color: #888;
}

html.light-mode .page-footer,
html.light-mode .series-name,
html.light-mode .book-subtitle,
html.light-mode .format-label {
  color: #888;
}

html.light-mode .related-books h2 {
  color: #333;
  border-bottom: 2px solid #eee;
}

html.light-mode .book-title {
  color: #fff;
}

html.light-mode .book-cover {
  border: 1px solid #ccc;
}

html.light-mode th {
  background-color: #f2f2f2;
}

html.light-mode tr:nth-child(even) {
  background-color: #fafafa;
}

html.light-mode tr:hover {
  background-color: #e6f7ff;
}

html.light-mode a,
html.light-mode .page-footer a {
  color: #000;
}

/* === Dark Mode === */
html.dark-mode {
  background-color: #181818;
  color: #e0e0e0;
}

html.dark-mode .container {
  background: #222;
}

html.dark-mode .book-title-chapter {
  color: #ddd;
  border-color: #444;
}

html.dark-mode .snippet-header {
    background-color: #333;
    color:  #ddd; 
}


html.dark-mode .book-subtitle-chapter,
html.dark-mode .page-footer,
html.dark-mode .series-name,
html.dark-mode .book-subtitle,
html.dark-mode .book-footer,
html.dark-mode .format-label {
  color: #aaa;
}

html.dark-mode .related-books h2 {
  color: #ddd;
  border-bottom: 2px solid #333;
}

html.dark-mode .book-title {
  color: #fff;
}

html.dark-mode .book-cover {
  border: 1px solid #555;
}

html.dark-mode th {
  background-color: #333;
  color: #fff;
}

html.dark-mode td {
  border-color: #444;
}

html.dark-mode tr:nth-child(even) {
  background-color: #2a2a2a;
}

html.dark-mode tr:hover {
  background-color: #2c3e50;
}

html.dark-mode a,
html.dark-mode .page-footer a {
  color: #eee;
}


    button { padding: 0.5em 1em; background: green; color: white; border: none; cursor: pointer; }
    button:hover { background: #1e7e34; }
    .result_iframe { width:99%; height:200px; margin-top: 1em;  resize: both;border:1px solid #ccc;}        
</style>
</head>
<body> 
  <div class="container">
    <div class = "chapter-navi-section">
<a href="java-collections-collections-utility-class.htm" class="nav-button prev">←</a>
<a href='java-collections.htm#performance-and-memory-considerations' class="nav-button toc-link">Index</a>
<a href="java-collections-generics-and-collections.htm" class="nav-button next">→</a>
</div>

    <h1 class="book-title-chapter" id = 'top'>Performance and Memory Considerations</h1>
    <h3 class="book-subtitle-chapter">Java Collections</h3>   
    <!-- <h1 class ="chapter-title"></h1> -->
    <h2 id='understanding-time-and-space-complexity'>11.1 Understanding Time and Space Complexity</h2><p>When working with Java Collections or any data structures, it’s crucial to understand how efficiently they perform. This efficiency is often measured using <em>time complexity</em> and <em>space complexity</em>, which describe how the resources needed by an operation grow as the size of the data grows. Let’s explore these concepts with beginner-friendly explanations and examples.</p><h3 id="what-is-time-complexity">What is Time Complexity?</h3><p>Time complexity tells us how the time to perform an operation changes with the size of the input (usually denoted as <em>n</em>). It is expressed using <em>Big O notation</em> (pronounced “big-oh”), which provides an upper bound on the number of steps an operation takes.</p><p>For example:</p><ul>
 <li><strong>O(1)</strong> — <em>Constant time</em>: The operation takes the same amount of time regardless of the collection size. Accessing an element by index in an <code>ArrayList</code> is O(1).</li>
 <li><strong>O(n)</strong> — <em>Linear time</em>: The time grows proportionally with the size of the collection. Searching for a value in a linked list without any index is O(n) because you may need to check every element.</li>
 <li><strong>O(log n)</strong> — <em>Logarithmic time</em>: The time increases logarithmically, which is much faster than linear for large <em>n</em>. A <code>TreeMap</code> lookup is O(log n) because it uses a balanced tree structure.</li>
 <li><strong>O(n²)</strong> — <em>Quadratic time</em>: The time grows with the square of <em>n</em>. Nested loops over collections often result in O(n²) complexity and are usually less efficient.</li>
</ul><p>Understanding Big O helps you predict how a program will scale as data grows.</p><h3 id="space-complexity">Space Complexity</h3><p>Space complexity refers to how much extra memory an operation or data structure requires relative to the input size. For example, an <code>ArrayList</code> might use additional memory to keep a backing array larger than the number of elements, which affects its space complexity.</p><h3 id="analyzing-common-collection-operations">Analyzing Common Collection Operations</h3><p>Here’s how time complexity typically looks for common operations in popular collections:</p><table>
 <thead>
  <tr>
   <th>Operation</th>
   <th>ArrayList</th>
   <th>LinkedList</th>
   <th>HashSet/HashMap</th>
   <th>TreeSet/TreeMap</th>
  </tr>
 </thead>
 <tbody>
  <tr>
   <td><strong>Add (end)</strong></td>
   <td>O(1)*</td>
   <td>O(1)</td>
   <td>O(1) average</td>
   <td>O(log n)</td>
  </tr>
  <tr>
   <td><strong>Add (middle)</strong></td>
   <td>O(n)</td>
   <td>O(1) (after node)</td>
   <td>N/A</td>
   <td>N/A</td>
  </tr>
  <tr>
   <td><strong>Remove</strong></td>
   <td>O(n)</td>
   <td>O(1) (after node)</td>
   <td>O(1) average</td>
   <td>O(log n)</td>
  </tr>
  <tr>
   <td><strong>Contains/Search</strong></td>
   <td>O(n)</td>
   <td>O(n)</td>
   <td>O(1) average</td>
   <td>O(log n)</td>
  </tr>
  <tr>
   <td><strong>Iteration</strong></td>
   <td>O(n)</td>
   <td>O(n)</td>
   <td>O(n)</td>
   <td>O(n)</td>
  </tr>
 </tbody>
</table><p>*Note: ArrayList’s add at end is O(1) <em>amortized</em>, because occasionally it resizes its backing array, which is an O(n) operation.</p><h3 id="why-complexity-matters-in-real-world">Why Complexity Matters in Real World</h3><p>Imagine you have a list of 1,000 items vs. 1 million items:</p><ul>
 <li>An O(n) operation means 1,000 steps for 1,000 items, but 1 million steps for 1 million items.</li>
 <li>An O(log n) operation, on the other hand, grows much slower: about 10 steps for 1,000 items and about 20 for 1 million.</li>
</ul><p>Choosing the right collection based on complexity ensures your programs remain fast and responsive even as data grows.</p><h3 id="practical-example-searching-in-a-list-vs-hashset">Practical Example: Searching in a List vs. HashSet</h3><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-java">List&lt;String&gt; list = new ArrayList&lt;&gt;();
Set&lt;String&gt; set = new HashSet&lt;&gt;();

// Adding 1 million elements (omitted for brevity)

String key = "example";

// Searching in list - O(n)
boolean foundInList = list.contains(key);

// Searching in HashSet - O(1) average
boolean foundInSet = set.contains(key);</code></pre>
</div><p>Here, searching in a HashSet is typically much faster for large datasets because it uses hashing internally, providing nearly constant-time lookup.</p><p>By understanding these foundational concepts of time and space complexity, you can make informed choices about which Java Collections to use and how to write more efficient code that scales well with your data.</p><div class = "chapter-navi-section">
<a href="#top" class="nav-button prev">↑</a>
<a href='java-collections.htm#performance-and-memory-considerations' class="nav-button toc-link">Index</a>
<a href="#bottom" class="nav-button next">↓</a>
</div>
<h2 id='choosing-the-right-collection-for-your-use-case'>11.2 Choosing the Right Collection for Your Use Case</h2><p>Selecting the most suitable Java Collection depends on your specific needs regarding performance, ordering, thread safety, and memory usage. Understanding the trade-offs among Lists, Sets, Maps, and Queues will help you pick the right tool for the job and write efficient, maintainable code.</p><h3 id="performance-characteristics">Performance Characteristics</h3><ul>
 <li><p><strong>Lists (ArrayList, LinkedList):</strong> Use an <strong>ArrayList</strong> when you need fast random access (<code>get(index)</code> is O(1)) and mostly add or remove elements at the end. However, inserting or removing elements in the middle can be slow (O(n)) due to shifting. Use a <strong>LinkedList</strong> if you frequently add or remove elements at the beginning or middle (O(1) with an iterator), but note that accessing elements by index is slower (O(n)).</p></li>
 <li><p><strong>Sets (HashSet, LinkedHashSet, TreeSet):</strong> Use a <strong>HashSet</strong> for fast lookup, insertion, and deletion (O(1) average), when order is not important. Choose <strong>LinkedHashSet</strong> if you need to maintain insertion order while still getting near-constant time performance. Use a <strong>TreeSet</strong> when you need a sorted set with elements in natural or custom order, keeping O(log n) performance but with higher overhead.</p></li>
 <li><p><strong>Maps (HashMap, LinkedHashMap, TreeMap):</strong> Similar logic applies: <strong>HashMap</strong> for fast, unordered key-value access; <strong>LinkedHashMap</strong> for predictable iteration order; and <strong>TreeMap</strong> for sorted keys.</p></li>
 <li><p><strong>Queues (LinkedList, PriorityQueue, ArrayDeque):</strong> Use a <strong>LinkedList</strong> or <strong>ArrayDeque</strong> for FIFO queues; <strong>ArrayDeque</strong> offers better performance and less memory overhead. Use <strong>PriorityQueue</strong> when you require elements to be processed based on priority rather than insertion order.</p></li>
</ul><h3 id="ordering-requirements">Ordering Requirements</h3><p>If your application depends on maintaining element order, choose collections that explicitly support it:</p><ul>
 <li>For insertion order, use <code>LinkedHashSet</code> or <code>LinkedHashMap</code>.</li>
 <li>For sorted order, pick <code>TreeSet</code> or <code>TreeMap</code>.</li>
 <li>If order doesn’t matter, standard <code>HashSet</code> or <code>HashMap</code> are more efficient.</li>
</ul><h3 id="thread-safety">Thread Safety</h3><p>Most collections in Java are <strong>not thread-safe</strong> by default:</p><ul>
 <li>Use <strong>ConcurrentHashMap</strong> or other classes in the <code>java.util.concurrent</code> package when working in multi-threaded environments.</li>
 <li>Alternatively, use synchronized wrappers from <code>Collections.synchronizedList()</code>, <code>synchronizedMap()</code>, etc., but beware of performance costs due to locking.</li>
 <li>For immutable collections, Java 9+ offers factory methods like <code>List.of()</code> that are inherently thread-safe.</li>
</ul><h3 id="memory-constraints">Memory Constraints</h3><p>If memory is a concern, consider:</p><ul>
 <li><strong>ArrayList</strong> generally uses less memory than LinkedList because it stores elements in a contiguous array, whereas LinkedList stores node objects with references.</li>
 <li><strong>Hash-based collections</strong> (HashSet, HashMap) consume more memory due to the internal hash table and load factor.</li>
 <li>Specialized collections like <strong>EnumSet</strong> and <strong>EnumMap</strong> provide very memory-efficient handling for enums.</li>
</ul><h3 id="practical-scenario-comparison">Practical Scenario Comparison</h3><table>
 <thead>
  <tr>
   <th>Use Case</th>
   <th>Recommended Collection</th>
   <th>Reason</th>
  </tr>
 </thead>
 <tbody>
  <tr>
   <td>Fast random access, mostly reads</td>
   <td>ArrayList</td>
   <td>O(1) access, low overhead</td>
  </tr>
  <tr>
   <td>Frequent insertions/removals</td>
   <td>LinkedList</td>
   <td>Efficient add/remove at ends</td>
  </tr>
  <tr>
   <td>Unique elements, order unimportant</td>
   <td>HashSet</td>
   <td>Fast lookup, no duplicates</td>
  </tr>
  <tr>
   <td>Unique elements, insertion order</td>
   <td>LinkedHashSet</td>
   <td>Maintains order, fast operations</td>
  </tr>
  <tr>
   <td>Sorted keys or elements</td>
   <td>TreeMap/TreeSet</td>
   <td>Maintains sorted order</td>
  </tr>
  <tr>
   <td>Thread-safe map access</td>
   <td>ConcurrentHashMap</td>
   <td>Lock-free concurrency</td>
  </tr>
  <tr>
   <td>Task scheduling by priority</td>
   <td>PriorityQueue</td>
   <td>Prioritizes processing order</td>
  </tr>
 </tbody>
</table><h3 id="summary">Summary</h3><p>Choosing the right collection is a balance between your application's specific performance needs, ordering requirements, concurrency model, and memory footprint. Knowing these trade-offs helps you design efficient data handling and avoid common pitfalls like unnecessary synchronization overhead or poor iteration performance.</p><p>By carefully analyzing your use case scenarios and matching them to the strengths of Java’s collection classes, you ensure scalable and maintainable code in your projects.</p><div class = "chapter-navi-section">
<a href="#top" class="nav-button prev">↑</a>
<a href='java-collections.htm#performance-and-memory-considerations' class="nav-button toc-link">Index</a>
<a href="#bottom" class="nav-button next">↓</a>
</div>
<h2 id='memory-footprint-of-collections'>11.3 Memory Footprint of Collections</h2><p>Understanding how collections consume memory is crucial for writing efficient Java applications, especially when handling large amounts of data or working in resource-constrained environments. Different collection implementations use various internal data structures, which directly impact their memory usage.</p><h3 id="internal-data-structures-and-their-overhead">Internal Data Structures and Their Overhead</h3><ul>
 <li><p><strong>Array-based Collections (ArrayList, ArrayDeque):</strong> These collections use a dynamically resizing array to store elements. The primary memory cost comes from the array itself, which is a contiguous block of references. When the array reaches capacity, it resizes—usually doubling its size—allocating a new larger array and copying elements over. This resizing causes temporary memory overhead and may lead to some unused slots in the array, increasing memory usage slightly beyond the actual number of elements.</p></li>
 <li><p><strong>Linked Collections (LinkedList, LinkedHashSet):</strong> Linked collections store elements in nodes, each containing the element plus one or more references (links) to other nodes. For example, a doubly linked list node stores references to both the previous and next nodes. This overhead per element is higher than array-based collections because each node object adds memory cost for the object header and pointers, often three times or more the size of the actual stored data reference.</p></li>
 <li><p><strong>Hash-based Collections (HashMap, HashSet):</strong> Hash-based collections use arrays of buckets, where each bucket can hold one or more entries (nodes). These entries store key-value pairs along with metadata like the hash code and a reference to the next entry (in case of collisions). The <strong>load factor</strong>—a measure of how full the hash table can get before resizing—affects memory usage and performance. A lower load factor reduces collisions (improving speed) but increases memory usage due to more empty buckets; a higher load factor saves memory but may slow down operations due to collisions.</p></li>
 <li><p><strong>Tree-based Collections (TreeMap, TreeSet):</strong> These collections use balanced tree structures, typically red-black trees, where each node stores references to its left and right child, its parent, and the stored element(s). The memory cost per element is relatively high due to these multiple references and additional balancing data, but they provide sorted ordering with good performance.</p></li>
</ul><h3 id="factors-influencing-memory-usage">Factors Influencing Memory Usage</h3><ol>
 <li><p><strong>Load Factor and Capacity:</strong> In hash-based collections, tuning the load factor and initial capacity can significantly affect memory. A larger initial capacity with a higher load factor reduces the frequency of resizing but increases memory footprint upfront.</p></li>
 <li><p><strong>Object References:</strong> Collections store references to objects, not the objects themselves. The memory cost depends on how large or complex the stored objects are. Minimizing unnecessary object creation or using primitive wrappers sparingly helps reduce overall memory use.</p></li>
 <li><p><strong>Resizing Overhead:</strong> Array-based and hash-based collections resize dynamically, which temporarily requires additional memory for the new array or table. Frequent resizing can lead to memory fragmentation or spikes in usage.</p></li>
</ol><h3 id="tips-to-reduce-memory-usage">Tips to Reduce Memory Usage</h3><ul>
 <li><p><strong>Choose the right collection:</strong> For example, prefer <code>ArrayList</code> over <code>LinkedList</code> when fast random access is needed and insertions/removals are infrequent.</p></li>
 <li><p><strong>Set initial capacity wisely:</strong> If you know approximately how many elements you'll store, set the initial capacity to avoid frequent resizing.</p></li>
 <li><p><strong>Consider specialized collections:</strong> Use <code>EnumSet</code> or <code>EnumMap</code> for enums, as they use bit vectors internally, which are extremely memory efficient.</p></li>
 <li><p><strong>Avoid storing unnecessary data:</strong> Keep the stored objects as lean as possible and consider using primitive collections from third-party libraries when performance and memory are critical.</p></li>
</ul><h3 id="summary">Summary</h3><p>Memory usage varies widely among Java collections due to their internal designs—arrays, linked nodes, hash tables, or trees—all have different overheads. By understanding these factors and tuning your collections accordingly, you can optimize memory footprint while maintaining good performance. This balance is essential for scalable and efficient applications.</p><div class = "chapter-navi-section">
<a href="#top" class="nav-button prev">↑</a>
<a href='java-collections.htm#performance-and-memory-considerations' class="nav-button toc-link">Index</a>
<a href="#bottom" class="nav-button next">↓</a>
</div>
<h2 id='runnable-examples-performance-comparisons'>11.4 Runnable Examples: Performance comparisons</h2><p>When choosing a collection, understanding performance trade-offs is essential. In this section, we’ll run simple timing tests to compare <code>ArrayList</code>, <code>LinkedList</code>, and <code>HashSet</code> for <code>add</code>, <code>remove</code>, and <code>contains</code> operations. These comparisons provide insight into how internal data structures affect runtime behavior.</p><blockquote>
 <p>⚠ <strong>Note:</strong> These examples are meant to demonstrate relative performance and are not rigorous benchmarks. Factors such as JVM warm-up and system load can affect timings.</p>
</blockquote><h3 id="example-comparing-add-and-contains-performance">Example: Comparing Add and Contains Performance</h3><div class="code-block"><button class="copy-button" onclick="copyCode(this)">📋</button>
 <pre><code class="language-java">import java.util.*;

public class PerformanceComparison {
    public static void main(String[] args) {
        int size = 100_000;
        List&lt;Integer&gt; arrayList = new ArrayList&lt;&gt;();
        List&lt;Integer&gt; linkedList = new LinkedList&lt;&gt;();
        Set&lt;Integer&gt; hashSet = new HashSet&lt;&gt;();

        // Measure ArrayList add
        long start = System.nanoTime();
        for (int i = 0; i &lt; size; i++) arrayList.add(i);
        long end = System.nanoTime();
        System.out.println("ArrayList add: " + (end - start) / 1_000_000.0 + " ms");

        // Measure LinkedList add
        start = System.nanoTime();
        for (int i = 0; i &lt; size; i++) linkedList.add(i);
        end = System.nanoTime();
        System.out.println("LinkedList add: " + (end - start) / 1_000_000.0 + " ms");

        // Measure HashSet add
        start = System.nanoTime();
        for (int i = 0; i &lt; size; i++) hashSet.add(i);
        end = System.nanoTime();
        System.out.println("HashSet add: " + (end - start) / 1_000_000.0 + " ms");

        // Measure ArrayList contains
        start = System.nanoTime();
        arrayList.contains(size / 2);
        end = System.nanoTime();
        System.out.println("ArrayList contains: " + (end - start) + " ns");

        // Measure LinkedList contains
        start = System.nanoTime();
        linkedList.contains(size / 2);
        end = System.nanoTime();
        System.out.println("LinkedList contains: " + (end - start) + " ns");

        // Measure HashSet contains
        start = System.nanoTime();
        hashSet.contains(size / 2);
        end = System.nanoTime();
        System.out.println("HashSet contains: " + (end - start) + " ns");
    }
}</code></pre>
</div><h3 id="output-example-results">Output (Example Results)</h3><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-bash">ArrayList add: 8.2 ms  
LinkedList add: 12.4 ms  
HashSet add: 14.6 ms  
ArrayList contains: 22143 ns  
LinkedList contains: 65832 ns  
HashSet contains: 103 ns</code></pre>
</div><h3 id="analysis">Analysis</h3><ul>
 <li><p><strong>Add Performance:</strong> <code>ArrayList</code> is faster than <code>LinkedList</code> due to contiguous memory and fewer object allocations. <code>HashSet</code> is slightly slower due to hashing overhead.</p></li>
 <li><p><strong>Contains Performance:</strong> <code>HashSet</code> is vastly faster because it uses hash-based lookup (O(1)). <code>ArrayList</code> and <code>LinkedList</code> perform linear searches (O(n)), but <code>LinkedList</code> is worse due to pointer chasing and no cache locality.</p></li>
 <li><p><strong>Remove Performance (not shown):</strong> <code>ArrayList</code> remove at index is fast at the end but slow at the front (due to shifting). <code>LinkedList</code> is better at front/mid deletes but worse at random access.</p></li>
</ul><h3 id="practical-implications">Practical Implications</h3><ul>
 <li>Use <strong>ArrayList</strong> for fast access and bulk appends.</li>
 <li>Use <strong>LinkedList</strong> only if you frequently insert/remove from the beginning or middle.</li>
 <li>Use <strong>HashSet</strong> when fast membership tests (<code>contains</code>) are critical.</li>
</ul><h3 id="final-notes">Final Notes</h3><ul>
 <li>Always test with real-world data patterns.</li>
 <li>JVM warm-up (via loops or benchmarking tools like JMH) is required for precise measurements.</li>
 <li>Memory footprint, GC behavior, and thread safety should also factor into collection choice for production systems.</li>
</ul><div class = "chapter-navi-section">
<a href="java-collections-collections-utility-class.htm" class="nav-button prev">←</a>
<a href='java-collections.htm#performance-and-memory-considerations' class="nav-button toc-link">Index</a>
<a href="java-collections-generics-and-collections.htm" class="nav-button next">→</a>
</div>
<section class="download-section">
  <div class="book-cover" style="background-color: #f9f6f1;border: 1px solid #ccc;"> 
    <div class="book-cover-title" style="font-size: 18px;color: #333;top: 20px;">Java Collections</div>
    <div class="book-cover-author">readbytes</div>
    <div class="book-cover-bottom-stripe" style="background-color: #333;"></div>
    <img class="book-cover-icon" style="width: 80px;height: 90px;top: 60px;" src='data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFoAAABaCAYAAAA4qEECAAADAElEQVR4Xu2dQYrUUBRFIw50JI7FrYgrcAPOXYPORHci7sah4EAQFyA6dNKosZK2Ee8/dOclP7/+i/fAmaR+Xr17KehJV2oYjDHGGGM6YRxzmgZdPKvdMt4vl03vLU15ZsYnsORB7Apd7mh2gS51VM/K+LVc6LA+0/QNKZax9RnvlG+C/tI7+6PYuYLV0MHoc72rX8ZvsP9Gq6BDyWzo/jXcjA4sfKN39E+RoYaf9F2CFAPFjGiG3b0Y5r9111LcJGZEM7QW0UNqRjTDWXwQXCojmoEk9MxmHwWGZ0QzkMT4ujy31b/D4UU8uITp/J4uRDOQxPiyPFfDy+HwQnFoCdPZFi5AM5BE/0VP51r5brgRzUASexU9/piG60VxEdO5lt6AZiCJ3Yoep+Fw8Z8DS5gHNfLncCOagSSWFE2M38tzanFBXcS9k/OwBi5AM5DE2qIn9JxaXFAXM33S5oE7+nFYhGYgiRxFX7FH4V+GEJqBJHIV3QGagSRcdBDNQBIuOohmIAkXHUQzkISLDqIZSMJFB9EMJOGig2gGknDRQTQDSbjoIJqBJHIUfffkPLCC74dNaAaSyFH0PKyiL4bVaAaS6L/oedAOrkQzkISLDqIZSMJFB9EMJNF/0bdPzsMquxLNQBL9Fz3x4eQ8sJIb0AwkkaPoK56efLvSV0MVNANJ5Cq6AzQDSbjoIJqBJFx0EM1AEi46iGYgCRcdRDOQhIsOohlIwkUH0Qwk4aKDaAaScNFBNANJuOggmoEkXHQQzUASLjqIZiAJFx1EM5CEiw6iGUjCRQfRDCSxtuh2X63oDM1AEkuKXmtxQc2IZiCJ3Yqu9vW3ztAMJLFX0ZfD4YXiUDI0A0m46CCagSTyfOm+EzQDSeiZzT4ODM+IZjiLD4NLZUQztBbRQ2pGNMPu1nh4lR/H9sfP+i5BioFgNnT/Gm5GB6Ib/im8Nf0+MtMPgb3Wquhwqw1Vwg/qbkix0EHtAl3qaHaDfx6kIf7Bm8YUyyY1Dbp4Fo0xxhhj/kd+A/PkOH57kF8HAAAAAElFTkSuQmCC'/>
  </div>
  <div class="download-info">
    <h2 id='bottom'>Download This Ebook</h2>
    <p class="format-label">Available formats:</p>
    <div class="download-buttons">
      <a href="java-collections.pdf" class="download-button">📄 PDF</a>
      <a href="java-collections.epub" class="download-button">📘 EPUB</a>
    </div>
  </div>
</section><div class='related-books'>
<h2>Java In-Depth Books</h2>
<div class='related-book-list'>
<a href="java-io-and-nio.htm">
<div class="book-cover" style="background-color: #f9f6f1;border: 1px solid #ccc;"> 
    <div class="book-cover-title" style="font-size: 18px;color: #333;top: 20px;">Java IO and NIO</div>
    <div class="book-cover-author">readbytes</div>
    <div class="book-cover-bottom-stripe" style="background-color: #333;"></div>
    <img class="book-cover-icon" style="width: 80px;height: 90px;top: 60px;" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFoAAABaCAYAAAA4qEECAAADAElEQVR4Xu2Zu6oTURSGjze0UfANtLAUzgOI4DOItc+VKk1uJ12aadNa21vbCpYK4wQmcPiYzL5k7eXM2f8HP0JYa/3ZX2PEmxshxAPi7u6uLRH2VA3lWId9VdK27WOKsQ47q6RpmucUYx12VolEOyHRToyJ5mwI7ufeeZBItBMS7YREOyHRTki0ExLthEQ7IdFOSLQTEu2ERDsxJtoq7KwSiXZCop04Ho9PKcY67KwWirEO+6qGcqzCHhGBJDoh0U5ItAP7/f6bRDtAyV3+ckYYQNHr9fo1Z8SVtG37iKI5Mzv4IKuwJwXeuvbef4ePsQ77YuGdLp85MysGHmQa9sXAG7l3JgUfZB32heh+0t3yRvfZD87NDj7KOuwLwf2cG5OEj7IO+8bg7imr1eoV55Lh0VC4bwE7cru4n3Jns9l85d7YPmdCSV8oADtyu7gfe4fzMbucCyV9oQDsyO3i/tid7i+395xjuHMfzoaSvlAAduR2cf/+ne7PT/x8JL94mwzsjCZ5wTN8XAjuTynT/nKJcH9KmfaXS4T7U8q0v1wi3J9Skr8cH3cJ7l3I98Ph8HLg86SuM9zPvRMDO0JJXwjQ/Wx6yx3kI3cGZqK6CPdz78TAjlDSF0ZYLpcvOH9O0zQX/xnL2ZiuIbifeycGdoSSvjACZ2N2TnA+do9wP/dODOwIhfvZ8HCfn5wbYmDPNOybLXxYn9+cu8TArmnYN1v4sNTHcdc67JslfFTOw7hvHfbNEj6q+3n3gTMheMM67JsdfNA1j+Idq7BnlvBR2+32DWfElazX63cUzRlhACVLdCEk2QmJdmC3232RaAcoucsfzogAAxJNwp6qoRzrsK9aKMY6i8XiGTurhGKsc/ofGHZWCcVYR6J7KMY6Et1DMedwLgT3JRpQjEQXgmIkuhAUI9GFoBiJLgTFSHQhKEaiC0ExEl0IipHoQlCMRBeCYiS6EBQj0YWgGOtIdA/FWEeieyjGOhLdQzHW2e/3T9hZJRRjHfZVDeVYhT1CiDnzD27IzgFe/xOvAAAAAElFTkSuQmCC"/>
  </div>
</a>


<a href="java-collections.htm">
<div class="book-cover" style="background-color: #f9f6f1;border: 1px solid #ccc;"> 
    <div class="book-cover-title" style="font-size: 18px;color: #333;top: 20px;">Java Collections</div>
    <div class="book-cover-author">readbytes</div>
    <div class="book-cover-bottom-stripe" style="background-color: #333;"></div>
    <img class="book-cover-icon" style="width: 80px;height: 90px;top: 60px;" src='data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFoAAABaCAYAAAA4qEECAAADAElEQVR4Xu2dQYrUUBRFIw50JI7FrYgrcAPOXYPORHci7sah4EAQFyA6dNKosZK2Ee8/dOclP7/+i/fAmaR+Xr17KehJV2oYjDHGGGM6YRxzmgZdPKvdMt4vl03vLU15ZsYnsORB7Apd7mh2gS51VM/K+LVc6LA+0/QNKZax9RnvlG+C/tI7+6PYuYLV0MHoc72rX8ZvsP9Gq6BDyWzo/jXcjA4sfKN39E+RoYaf9F2CFAPFjGiG3b0Y5r9111LcJGZEM7QW0UNqRjTDWXwQXCojmoEk9MxmHwWGZ0QzkMT4ujy31b/D4UU8uITp/J4uRDOQxPiyPFfDy+HwQnFoCdPZFi5AM5BE/0VP51r5brgRzUASexU9/piG60VxEdO5lt6AZiCJ3Yoep+Fw8Z8DS5gHNfLncCOagSSWFE2M38tzanFBXcS9k/OwBi5AM5DE2qIn9JxaXFAXM33S5oE7+nFYhGYgiRxFX7FH4V+GEJqBJHIV3QGagSRcdBDNQBIuOohmIAkXHUQzkISLDqIZSMJFB9EMJOGig2gGknDRQTQDSbjoIJqBJHIUfffkPLCC74dNaAaSyFH0PKyiL4bVaAaS6L/oedAOrkQzkISLDqIZSMJFB9EMJNF/0bdPzsMquxLNQBL9Fz3x4eQ8sJIb0AwkkaPoK56efLvSV0MVNANJ5Cq6AzQDSbjoIJqBJFx0EM1AEi46iGYgCRcdRDOQhIsOohlIwkUH0Qwk4aKDaAaScNFBNANJuOggmoEkXHQQzUASLjqIZiAJFx1EM5CEiw6iGUjCRQfRDCSxtuh2X63oDM1AEkuKXmtxQc2IZiCJ3Yqu9vW3ztAMJLFX0ZfD4YXiUDI0A0m46CCagSTyfOm+EzQDSeiZzT4ODM+IZjiLD4NLZUQztBbRQ2pGNMPu1nh4lR/H9sfP+i5BioFgNnT/Gm5GB6Ib/im8Nf0+MtMPgb3Wquhwqw1Vwg/qbkix0EHtAl3qaHaDfx6kIf7Bm8YUyyY1Dbp4Fo0xxhhj/kd+A/PkOH57kF8HAAAAAElFTkSuQmCC'/>
  </div>
</a>


<a href="java-regex.htm">
<div class="book-cover" style="background-color: #f9f6f1;border: 1px solid #ccc;"> 
    <div class="book-cover-title" style="font-size: 18px;color: #333;top: 20px;">Java Regex</div>
    <div class="book-cover-author">readbytes</div>
    <div class="book-cover-bottom-stripe" style="background-color: #333;"></div>
    <img class="book-cover-icon" style="width: 80px;height: 90px;top: 60px;" src="data:image/png;base64,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"/>
  </div>
</a>


<a href="java-functional-programming.htm">
<div class="book-cover" style="background-color: #f9f6f1;border: 1px solid #ccc;"> 
    <div class="book-cover-title" style="font-size: 18px;color: #333;top: 20px;">Java Functional Programming</div>
    <div class="book-cover-author">readbytes</div>
    <div class="book-cover-bottom-stripe" style="background-color: #333;"></div>
    <img class="book-cover-icon" style="width: 80px;height: 80px;top: 80px;" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFoAAABaCAYAAAA4qEECAAADzUlEQVR4Xu2bO4sUURCFlxVBzfwLJkb+A1MxEgMRDBQDRTBRwchARk00MRFBAwNBzEQwMBfEBz7wbWIkiIGJoInio9wZdmZ7T1V3V91bPVhaH3xJ973n3jk2vdO968JCkiRJkiRRIYphWOgI/zB/uyHBDxHFUODmIxkK3HwkQ4Gbj2QY6BDffCTDgBuPZhhw49EMA248miGgW3zj0QwBbjqiIcBNRzQEuOlohoA+8Y1HMgy4cauJEizO5EZMS0RoUSjPYKIEi7OaKMHirCZKsDiTi5iWiNAmoTyDiRIszmqiBIsz+QXTklZYeQYTJXSUl2cxUYLFWU2UYHEmb2Na0gorz2CihJ7w8iwmSrA4q4kSLM7kYUxLWmHlGUyU0C9ensVECRZnNQS4abPPMNEOy7S4BdN00L5GxmU8q4cuNXL24tll2KYrLIXW8yyLJdAJnkP3cFQ/9FzIGeEgHOBgCZhh1Qod5xkzH+PoduiVMH/qqDkQT3q4trGAEpZh1AId4/OZb3EWh14K89DRdDCecNIKzjdp+IelHcL8Nj/g7BU6r2R0+3gCHvRyN26tHdoszDdoAef2KpQt3pN7ZAc81YLzrFrAuSrfNOY/Es4rZAdcfbCywS7YPIvfMa0buiBkaFz6ATn+POy4xmvjhfGgsxpwjsUSigsr8el0UTzh7c9Vn5FBe4Q5BkuZXKFCnqsPmwviyQHsAsdarWF8tWGem/dxMRwwkG3gOJMvMM1O7S8aRJtX8hQ2aCDbwHEWvXAte3pPlmCDBxKhK3yMRU9cbiOKp0k+aQg3+K7pTdUPyHeYVgELL9At7/zqLA9KH0YmNh5qqqHPwgJWLzby8JxBb1y+Wxve+vXCwguc5Lzmxy164lLy1IL32SJ0Qwi3+k04ZtSLqttFm3dxlUJY8Lzdijsqo+QtnFqPK5u2CcFz1APT++RSPe7ZLHSO1qL6zYiXmu/WXdAaIXRO1lD8mnSpsOKHmpu4CyMscB5W/m8rlqex8TBS+lBTDQYObS2Y16vwxFfydbAaDBzaWmgXz2y14/46fg3Kxre5E2cXwoKH8geuXIb4hzNo11u4ZVRX9kmcVQELH0hP6BTPnym9T26h8559Gkc7wBYZQG/oLF+D/WZEgfht5AyOcoLeC4s5OwR0oLHGVTyrh643cvbjWWewGFc/4mr/MXRQKMjJBMCCvEwAWsdL8jARwJKqvYMrJDNYWRUmHWBZNSY9YGGlJj1gYUWew9REhBVnNFFCX3l5FhMDWJ7WpAAssc+kAiyzzcQJLHbibxyVJEmSJMk/xB+4wdarC+OVAQAAAABJRU5ErkJggg=="/>
  </div>
</a>


<a href="java-streams.htm">
<div class="book-cover" style="background-color: #f9f6f1;border: 1px solid #ccc;"> 
    <div class="book-cover-title" style="font-size: 18px;color: #333;top: 20px;">Java Streams</div>
    <div class="book-cover-author">readbytes</div>
    <div class="book-cover-bottom-stripe" style="background-color: #333;"></div>
    <img class="book-cover-icon" style="width: 80px;height: 80px;top: 60px;" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFoAAABaCAYAAAA4qEECAAACbklEQVR4Xu3cP4oUQRiG8S8xEzESDI1MPIRHEQQPYTK9iCyewMxrGIiCoaFnWFkMTIwUxD894KI8VbNdVdNfzdR87w+eRKa2ul+WVZM1G8+3ud+d+mhBvbZ0DO/uWEAcoVfhcIBehcQRvAvt1dz7gjjaVfxcrhcmxTiwvkudcGAN7YQDa2gnHFhDO+HAGtoJB24ZmmdzhcdBWobh2VzhcZCWYXg2V3gcpGUYns0VHgdpGYZnc4XHQVqG4dlc4XGQlmF4Nld4HKRlGJ7NFR4HaRmGZ3MN48Hcu7lLS19ihI7SPUsfdPSOCh/ulDoKfKhT7KC2P3P5QKfawfBBTr2D4ENEqDs+QJS64uWR6ubc0ssj1Q0vjlYXvLS1X3Mv5x7NPTyi+Jy5uuClNY2Az5zL3RtLLy1pJHz2XO544VLbHw+j4TvkcscLlxoR3yGXO154XaPie+Ry9djSC69rVHyPXK62/xTjhbu6+HtmRHyXXK6iDH1wGroTDd2Jhu5EQ3eioTvR0J1o6E40tAMOt1YCHGitBDjQWglwoLUS4EBrJcCB1kqAA62VwFOnREREROSIPbP7/CNZ28Y+2KT/hPjbjnyVOPl/ZA3tZLLzZGiN7YAD/+smPyqt0nH1Xe2Cw7LndpdHpBZH3ZXs4YndSAbdleyBYy4ljTjkUtKAI5a0sS/8MrKEI5YmFTZ2mQxYmlTgeDVt7DO/nOzC8WqTApPdSoarTQpM9ikZrjYpMNmPZLjapMDZ/JcZh6tNCkx2OxmuNinE4WraDPnbZw5ksp/JgKVJJQ5YmjTgiEvJHib7mgyaS1Yy2dtk3DP7zo9F9wfJyGVFhM8g5gAAAABJRU5ErkJggg=="/>
  </div>
</a>



<a href='java.htm'><div class='book-cover' style='background-color: #f9f6f1;color: #111111;border: 1px solid #ccc;display: flex;justify-content: center;align-items: center;text-align: center;'>More Java Books</div></a>
</div>
</div>
  </div>
  <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/prism.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
  
  <script>
    function copyCode(button) {
      const code = button.nextElementSibling.innerText;
      navigator.clipboard.writeText(code).then(() => {
        button.textContent = 'Copied!';
        setTimeout(() => { button.textContent = 'Copy'; }, 1500);
      });
    }
  </script>  
<div id="floatingLog" aria-live="polite" role="alert"></div>
<footer class="page-footer">
    <nav>
      <a href="https://readbytes.github.io">Home</a> | 
      Email:<script language="JavaScript" type="text/javascript">
var part1 = 'yinpeng';var part6 = '263';var part2 = Math.pow(2,6);var part3 = String.fromCharCode(part2);var part4 = 'hotmail dot com';var part5 = part1 + String.fromCharCode(part2) + part4;document.write(part1 + part6 + part3 + part4);
</script>
    </nav>
  <p>© 2025 — All rights reserved.</p>    
  </footer>

</body>
</html>