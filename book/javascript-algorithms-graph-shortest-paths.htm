<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>JavaScript Algorithms Graph Shortest Paths</title>
<link rel='shortcut icon' href='https://java2s.com/style/favicon.ico'>
<link href="https://fonts.googleapis.com/css2?family=Merriweather&display=swap" rel="stylesheet" />
<link href="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet" />

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/codemirror.min.css" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/theme/material.css"> <!-- Dark theme -->
<script src="https://cdn.jsdelivr.net/npm/typescript@5/lib/typescript.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/codemirror.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/mode/htmlmixed/htmlmixed.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/mode/xml/xml.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/mode/css/css.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/mode/javascript/javascript.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/mode/javascript/typescript.min.js"></script>
<style>
    #floatingLog {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(20, 20, 20, 0.95);
      color: white;
      font-family: monospace;
      font-size: 14px;
      padding: 16px 20px;
      border-radius: 8px;
      box-shadow: 0 4px 16px rgba(0, 0, 0, 0.4);
      max-width: 80%;
      max-height: 200px;
      overflow-y: auto;
      display: none;
      z-index: 9999;
      pointer-events: none;
      white-space: pre-wrap;
      text-align: center;
    }
</style>
<script>
  const codeMirrorMap = new Map();
  const iframeMap = new Map();
  
 

  let dismissTimer;
  function showFloatingLog(message) {
	const floatingLog = document.getElementById('floatingLog');

    if (floatingLog.style.display !== 'block') {
      floatingLog.textContent = '';
      floatingLog.style.display = 'block'; 
    }

    floatingLog.textContent += message + '\n';
    floatingLog.scrollTop = floatingLog.scrollHeight; 
    clearTimeout(dismissTimer);
    dismissTimer = setTimeout(() => {
      floatingLog.style.display = 'none';
      floatingLog.textContent = '';
    }, 2000);
  }
  window.addEventListener('message', (event) => {
	    if (!iframeMap.has(event.source)) return;

	    if (event.data?.type === 'console-log') {
	      showFloatingLog(event.data.message);
	    }
  });  
  function renderIframe(button,textarea_id, iframe_id) {
      const html = codeMirrorMap.get(textarea_id).getValue();
      const iframe = document.getElementById(iframe_id);
  
      const oldIframe = iframe;
      const newIframe = document.createElement('iframe');
      newIframe.className ="result_iframe";
      
      newIframe.id = iframe_id;
      oldIframe.replaceWith(newIframe);
 

      // Track the iframe in the map
      iframeMap.set(newIframe.contentWindow, button);

      const overrideScript = `
        <script>
          (function() {
            const originalLog = console.log;
            console.log = function(...args) {
              originalLog.apply(console, args);
              window.parent.postMessage({
                type: 'console-log',
                message: args.map(a => {
                  try { return JSON.stringify(a); }
                  catch { return String(a); }
                }).join(' ')
              }, '*');
            };
          })();
        <\/script>
      `;

      const iframeHTML = `
        <!DOCTYPE html>
        <html>
        <body>
          ${overrideScript}
          ${html}
        </body>
        </html>
      `;
 
      const doc = newIframe.contentDocument || newIframe.contentWindow.document;
      doc.open();
      doc.write(iframeHTML);
      doc.close();

      
      setTimeout(() => {
    	  newIframe.style.height = '0px';
    	   let contentHeight = Math.max(doc.body.scrollHeight,doc.documentElement.scrollHeight);
 
    	   if(contentHeight < 150 || contentHeight > 600){
    		   contentHeight = 600;
    	   } 
    	   newIframe.style.height = contentHeight + 'px';
    	}, 50);      
      
  }
  function renderIframeForClientTypescript(textarea_id, iframe_id) {
      let code = codeMirrorMap.get(textarea_id).getValue();
      code = ts.transpile(code);
      const iframe = document.getElementById(iframe_id);
      const doc = iframe.contentDocument || iframe.contentWindow.document;

const html = `
  <!DOCTYPE html>
  <html>
    <head>
      <title>Output</title>
      <style>
        body { font-family: monospace; padding: 1em; background: #f4f4f4; color: #222; }
        pre { white-space: pre-wrap; word-break: break-word; }
        .error { color: red; }
      </style>
    </head>
    <body>
      <pre id="log"></pre>
      <script>
        (function(){
          const logEl = document.getElementById('log');
          const origLog = console.log;
          const origError = console.error;

          console.log = (...args) => {
            logEl.textContent += args.join(' ') + '\\n';
            origLog.apply(console, args);
          };
          console.table = (...args) => {
            logEl.textContent += args.join(' ') + '\\n';
            origLog.apply(console, args);
          };

          console.error = (...args) => {
            logEl.innerHTML +='<span class="error">' + args.join(' ') + '</span>';
            origError.apply(console, args);
          };
          window.addEventListener("error", function (event) {
              console.error("Caught by event listener:", event.message);
          });    
          try {             
              ${code};
          } catch (err) {
            console.error(err.stack || err.message);
          }
        })();
      <\/script>
    </body>
  </html>
`;

      iframe.style.display = "block";
      iframe.srcdoc = html;  
  }

    function renderIframeForClientJavascript(textarea_id, iframe_id) {
        const code = codeMirrorMap.get(textarea_id).getValue();
        const iframe = document.getElementById(iframe_id);
        const doc = iframe.contentDocument || iframe.contentWindow.document;

  const html = `
    <!DOCTYPE html>
    <html>
      <head>
        <title>Output</title>
        <style>
          body { font-family: monospace; padding: 1em; background: #1e1e1e; color: #eee; }
          pre { white-space: pre-wrap; word-break: break-word; }
          .error { color: red; }
        </style>
      </head>
      <body>
        <pre id="log"></pre>
        <script>
          (function(){
            const logEl = document.getElementById('log');
            const origLog = console.log;
            const origError = console.error;

            console.log = (...args) => {
              logEl.textContent += args.join(' ') + '\\n';
              origLog.apply(console, args);
            };
            console.table = (...args) => {
              logEl.textContent += args.join(' ') + '\\n';
              origLog.apply(console, args);
            };

            console.error = (...args) => {
              logEl.innerHTML +='<span class="error">' + args.join(' ') + '</span>';
              origError.apply(console, args);
            };
            window.addEventListener("error", function (event) {
                console.error("Caught by event listener:", event.message);
            });    
            try {
             ${code}; 
            } catch (err) {
              console.error(err.stack || err.message);
            }
          })();
        <\/script>
      </body>
    </html>
  `;
        iframe.style.display = "block";
        iframe.srcdoc = html;  
    }
    function toggleSnippetAndRefresh(id, textarea_id) {
      const box = document.getElementById(id);
      box.classList.toggle("open");
      codeMirrorMap.get(textarea_id).refresh();
    }

  </script>
  <script>
  const mode = localStorage.getItem('mode') || 'light';
  document.documentElement.classList.add(`${mode}-mode`);
  </script>   
<style> 
html {
  scroll-behavior: smooth;
}

body {
  font-family: 'Merriweather', serif;
  margin: 0;
  padding: 2rem 1rem;
  font-size: 15px;
  line-height: 1.5;
  transition: background-color 0.3s, color 0.3s;
}

.container {
  max-width: 700px;
  margin: 0 auto;
  padding: 1rem 2rem;
  box-shadow: 0 0 15px rgba(0,0,0,0.1);
}

h1, h2, h3 {
  font-weight: 600;
  margin-top: 2.5rem;
  margin-bottom: 1rem;
  line-height: 1.2;
}

h1 { font-size: 1.8rem; }
h2 { font-size: 1.4rem; }
h3 { font-size: 1.2rem; }

table {
  width: 100%;
  border-collapse: collapse;
  font-family: sans-serif;
  font-size: 1em;
  margin: 1em 0;
}

th, td {
  padding: 0.6em 1em;
  text-align: left;
  border: 1px solid;
}

tr:nth-child(even) {
  background-color: inherit;
}

tr:hover {
  background-color: inherit;
}

a {
  text-decoration: none;
  transition: color 0.2s;
}

a:hover {
  text-decoration: underline;
}

code {
  color: #d35400;
}

.book-title-chapter {
  font-family: 'Merriweather', serif;
  font-size: 2rem;
  font-weight: bold;
  text-align: center;
  margin-bottom: 2rem;
  border-bottom: 2px solid;
  padding-bottom: 0.5rem;
}

.book-subtitle-chapter {
  text-align: center;
  font-size: 1rem;
  margin-top: -1rem;
  margin-bottom: 2rem;
}

.related-books {
  margin-top: 40px;
}

.related-book-list {
  display: flex;
  flex-wrap: wrap;
  gap: 20px;
}

    .book-cover {
      width: 130px;
      height: 180px;
      font-family: Arial, sans-serif;
      position: relative;
      overflow: hidden;      
      line-height: normal;
      box-shadow: 2px 2px 4px rgba(0,0,0,0.1);
    }
    .book-cover-bottom-stripe {
      position: absolute;
      bottom: 0;
      left: 0;
      height: 5px;
      width: 100%;
    }
    .book-cover-title {
      position: absolute;
      width: 100%;
      text-align: center;
      font-weight: bold;
    }
     
    .book-cover-icon {
      position: absolute;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      align-items: center;
      justify-content: center; 
    }

    .book-cover-author {
      position: absolute;
      bottom: 10px;
      width: 100%;
      text-align: center;
      font-size: 8px;
      color: #333;
    }

.page-footer {
  margin-top: 4rem;
  padding: 1rem 0;
  text-align: center;
  font-size: 0.85rem;
  border-top: 1px solid;
}

.chapter-navi-section {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding-bottom: 10px;
}

.nav-link {
  color: inherit;
  text-decoration: none;
  opacity: 0.5;
  transition: opacity 0.3s ease, text-decoration 0.3s ease;
}

.nav-link:hover {
  opacity: 0.9;
  text-decoration: underline;
}

.prev { text-align: left; }
.toc-link { text-align: center; }
.next { text-align: right; }

.download-section {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 2rem;
  padding: 2rem 1rem;
  max-width: 600px;
  margin: 3rem auto;
  border-radius: 12px;
  box-shadow: 0 4px 10px rgba(0,0,0,0.05);
}

.download-info h2 {
  margin: 0 0 0.5rem;
  font-size: 1.2rem;
}

.format-label {
  margin: 0 0 0.5rem;
  font-size: 0.95rem;
}

.download-buttons {
  display: flex;
  gap: 1rem;
}

.download-button {
  background-color: #4A90E2;
  color: white;
  padding: 0.5em 1.2em;
  border-radius: 25px;
  font-size: 0.95rem;
  text-decoration: none;
  transition: background-color 0.3s ease;
}

.download-button:hover {
  background-color: #357ABD;
}

.code-block {
  position: relative;
  margin-bottom: 1em;
}

.copy-button {
  background: transparent;
  color: white;
  position: absolute;
  top: 8px;
  right: 8px;
  border: none;
  padding: 4px 8px;
  font-size: 12px;
  border-radius: 4px;
  cursor: pointer;
  z-index: 1;
}

.copy-button:hover {
  background-color: #0056b3;
}

.snippet-container {
  overflow: hidden;
}

.snippet-header {
  padding: 0.75rem 1rem;
  cursor: pointer;
  font-size: 1rem;
    background-color: #eeeeee;
    color:  #111111; 
    border-radius: 8px;
    cursor: pointer;
    box-shadow: 0 4px 6px rgba(0,0,0,0.1);  
}

.snippet-body {
  display: none;
  font-family: monospace;
}

.snippet-container.open .snippet-body {
  display: block;
}

.CodeMirror {
  border: 2px solid #ccc;
  border-radius: 4px;
  resize: vertical;
}

/* === Light Mode === */
html.light-mode {
  background-color: #f8f7f5;
  color: #333;
}

html.light-mode .container {
  background: white;
}

html.light-mode .book-title-chapter {
  color: #2c3e50;
  border-color: #ccc;
}
html.light-mode .book-subtitle-chapter{
  color: #888;
}

html.light-mode .page-footer,
html.light-mode .series-name,
html.light-mode .book-subtitle,
html.light-mode .format-label {
  color: #888;
}

html.light-mode .related-books h2 {
  color: #333;
  border-bottom: 2px solid #eee;
}

html.light-mode .book-title {
  color: #fff;
}

html.light-mode .book-cover {
  border: 1px solid #ccc;
}

html.light-mode th {
  background-color: #f2f2f2;
}

html.light-mode tr:nth-child(even) {
  background-color: #fafafa;
}

html.light-mode tr:hover {
  background-color: #e6f7ff;
}

html.light-mode a,
html.light-mode .page-footer a {
  color: #000;
}

/* === Dark Mode === */
html.dark-mode {
  background-color: #181818;
  color: #e0e0e0;
}

html.dark-mode .container {
  background: #222;
}

html.dark-mode .book-title-chapter {
  color: #ddd;
  border-color: #444;
}

html.dark-mode .snippet-header {
    background-color: #333;
    color:  #ddd; 
}


html.dark-mode .book-subtitle-chapter,
html.dark-mode .page-footer,
html.dark-mode .series-name,
html.dark-mode .book-subtitle,
html.dark-mode .book-footer,
html.dark-mode .format-label {
  color: #aaa;
}

html.dark-mode .related-books h2 {
  color: #ddd;
  border-bottom: 2px solid #333;
}

html.dark-mode .book-title {
  color: #fff;
}

html.dark-mode .book-cover {
  border: 1px solid #555;
}

html.dark-mode th {
  background-color: #333;
  color: #fff;
}

html.dark-mode td {
  border-color: #444;
}

html.dark-mode tr:nth-child(even) {
  background-color: #2a2a2a;
}

html.dark-mode tr:hover {
  background-color: #2c3e50;
}

html.dark-mode a,
html.dark-mode .page-footer a {
  color: #eee;
}

    .dialog-backdrop {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: rgba(0,0,0,0.5);
      display: none;
      justify-content: center;
      align-items: center;
      z-index: 10;
    }

    .dialog {
      background: white;
      padding: 20px;
      width: 90vw;
      height: 80vh;
      border-radius: 8px;
      box-shadow: 0 0 20px rgba(0,0,0,0.3);
      display: flex;
      flex-direction: column;
    }
    .dialog-content {
      display: flex;
      flex: 1;
      gap: 20px;
      margin-top: 10px;
    }
    .dialog h2 {
      margin-top: 0;
    }

    .textarea_dialog {
      width: 50%;
      height: 100%;
      resize: none;
      font-family: monospace;
      font-size: 14px;
      padding: 10px;
      box-sizing: border-box;
      border: 1px solid #ccc;
    }

    .iframe_dialog {
      width: 50%;
      height: 100%;
      border: 1px solid #ccc;
    }
    .controls_dialog {
      display: flex;
      justify-content: space-between;
      margin-top: 10px;
    }    
    button { padding: 0.5em 1em; background: green; color: white; border: none; cursor: pointer; }
    button:hover { background: #1e7e34; }
    .result_iframe { width:99%; height:200px; margin-top: 1em;  resize: both;border:1px solid #ccc;}        
</style>
</head>
<body> 
  <div class="container">
    <div class = "chapter-navi-section">
<a href="javascript-algorithms-graphs-traversals.htm" class="nav-button prev">←</a>
<a href='javascript-algorithms.htm#graph-shortest-paths' class="nav-button toc-link">Index</a>
<a href="javascript-algorithms-minimum-spanning-trees.htm" class="nav-button next">→</a>
</div>

    <h1 class="book-title-chapter" id = 'top'>Graph Shortest Paths</h1>
    <h3 class="book-subtitle-chapter">JavaScript Algorithms</h3>   
    <!-- <h1 class ="chapter-title"></h1> -->
    <h2 id='dijkstra-s-algorithm'>15.1 Dijkstra’s Algorithm</h2><p><strong>Dijkstra’s Algorithm</strong> is a classic algorithm used to compute the <strong>shortest path from a source node</strong> to all other nodes in a <strong>weighted graph</strong>—as long as edge weights are <strong>non-negative</strong>. It’s widely used in applications like GPS navigation, network routing, and real-time systems where optimal paths are crucial.</p><h3 id="how-dijkstras-algorithm-works">How Dijkstras Algorithm Works</h3><p>Dijkstra's algorithm keeps track of the <strong>shortest known distance</strong> to each node and updates it as shorter paths are found. It uses a <strong>priority queue</strong> (typically a min-heap) to efficiently select the next node with the smallest tentative distance.</p><h4 id="core-steps">Core Steps:</h4><ol>
 <li><p>Initialize distances from the source to all nodes as <code>Infinity</code>, except the source itself (<code>0</code>).</p></li>
 <li><p>Use a priority queue to always process the node with the <strong>smallest tentative distance</strong>.</p></li>
 <li><p>For each unvisited neighbor of the current node:</p>
  <ul>
   <li>Calculate the new distance through the current node.</li>
   <li>If it’s smaller than the known distance, update it and reinsert the neighbor in the queue.</li>
  </ul></li>
 <li><p>Repeat until all nodes have been processed.</p></li>
</ol><div class="snippet-container" id="<!DOCTYPE html>
<html lang=&quot;en&quot;>
<head>
<meta charset=&quot;UTF-8&quot; />
<title>Dijkstra's Algorithm Visualization</title>
<style>
  body { font-family: sans-serif; text-align: center; padding: 20px; }
  canvas { border: 1px solid #ccc; background: #f9f9f9; }
  button { font-size: 16px; padding: 8px 12px; margin: 10px; }
  #info { margin-top: 10px; font-family: monospace; }
</style>
</head>
<body>

<h2>Dijkstra's Algorithm Visualization</h2>
<button onclick=&quot;startDijkstra()&quot;>Start Dijkstra</button>
<canvas id=&quot;canvas&quot; width=&quot;600&quot; height=&quot;600&quot;></canvas>
<div id=&quot;info&quot;></div>

<script>
  const canvas = document.getElementById(&quot;canvas&quot;);
  const ctx = canvas.getContext(&quot;2d&quot;);
  const infoDiv = document.getElementById(&quot;info&quot;);

  // Nodes with fixed positions
  const nodes = [
    { label: 'A', x: 150, y: 100 },
    { label: 'B', x: 350, y: 100 },
    { label: 'C', x: 550, y: 100 },
    { label: 'D', x: 150, y: 300 },
    { label: 'E', x: 350, y: 300 },
    { label: 'F', x: 550, y: 300 },
    { label: 'G', x: 350, y: 450 }
  ];

  // Edges with weights (undirected)
  // Each edge: [fromLabel, toLabel, weight]
  const edges = [
    ['A', 'B', 4], ['A', 'D', 2],
    ['B', 'C', 3], ['B', 'E', 5],
    ['C', 'F', 1],
    ['D', 'E', 8], ['D', 'G', 10],
    ['E', 'F', 2], ['E', 'G', 6],
    ['F', 'G', 3]
  ];

  // Build adjacency list: label -> [{to, weight}, ...]
  const adjList = {};
  for (const node of nodes) adjList[node.label] = [];
  for (const [from, to, w] of edges) {
    adjList[from].push({ to, weight: w });
    adjList[to].push({ to: from, weight: w }); // undirected
  }

  // Dijkstra state
  let distances = {};
  let previous = {};
  let visited = new Set();
  let pq = []; // priority queue of {label, dist}
  let currentStep = 0;
  let steps = [];

  // Priority queue helper functions
  function enqueue(label, dist) {
    pq.push({ label, dist });
    pq.sort((a,b) => a.dist - b.dist);
  }
  function dequeue() {
    return pq.shift();
  }

  function startDijkstra() {
    distances = {};
    previous = {};
    visited = new Set();
    pq = [];
    currentStep = 0;
    steps = [];

    for (const node of nodes) {
      distances[node.label] = Infinity;
      previous[node.label] = null;
    }
    distances['A'] = 0;
    enqueue('A', 0);

    // Run algorithm stepwise, recording steps for animation
    while (pq.length > 0) {
      const { label: u, dist: uDist } = dequeue();
      if (visited.has(u)) continue;
      visited.add(u);

      // Save step snapshot
      steps.push({
        current: u,
        distances: {...distances},
        previous: {...previous},
        visited: new Set(visited)
      });

      for (const { to: v, weight } of adjList[u]) {
        if (!visited.has(v)) {
          const alt = distances[u] + weight;
          if (alt < distances[v]) {
            distances[v] = alt;
            previous[v] = u;
            enqueue(v, alt);
          }
        }
      }
    }
    currentStep = 0;
    animateStep();
  }

  function animateStep() {
    if (currentStep >= steps.length) {
      infoDiv.textContent = &quot;Dijkstra completed! Final distances: &quot; + JSON.stringify(distances, null, 2);
      drawGraph(steps[steps.length-1]);
      return;
    }
    drawGraph(steps[currentStep]);
    infoDiv.textContent = `Processing node: ${steps[currentStep].current}\n` +
      `Distances: ${JSON.stringify(steps[currentStep].distances, null, 2)}\n` +
      `Visited: ${[...steps[currentStep].visited].join(', ')}`;
    currentStep++;
    setTimeout(animateStep, 1200);
  }

  // Draw graph with current step info
  function drawGraph(step) {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // Draw edges with weights
    ctx.strokeStyle = &quot;#999&quot;;
    ctx.lineWidth = 2;
    ctx.fillStyle = &quot;#000&quot;;
    ctx.font = &quot;14px Arial&quot;;

    for (const [from, to, w] of edges) {
      const fromNode = nodes.find(n => n.label === from);
      const toNode = nodes.find(n => n.label === to);
      ctx.beginPath();
      ctx.moveTo(fromNode.x, fromNode.y);
      ctx.lineTo(toNode.x, toNode.y);
      ctx.stroke();

      // Draw weight label at midpoint with offset
      const midX = (fromNode.x + toNode.x) / 2;
      const midY = (fromNode.y + toNode.y) / 2;
      ctx.fillStyle = &quot;#000&quot;;
      ctx.fillText(w, midX + 5, midY - 5);
    }

    // Draw nodes
    for (const node of nodes) {
      const dist = step.distances[node.label];
      const isVisited = step.visited.has(node.label);
      const isCurrent = step.current === node.label;

      ctx.beginPath();
      ctx.arc(node.x, node.y, 25, 0, 2 * Math.PI);
      ctx.fillStyle = isCurrent ? '#e67e22' : (isVisited ? '#2ecc71' : '#3498db');
      ctx.fill();
      ctx.stroke();

      ctx.fillStyle = '#fff';
      ctx.font = '16px Arial';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(node.label, node.x, node.y);

      // Draw distance inside node
      ctx.font = '12px Arial';
      ctx.fillText(dist === Infinity ? '∞' : dist, node.x, node.y + 30);
    }

    // Draw shortest path tree edges (bold)
    ctx.strokeStyle = '#27ae60';
    ctx.lineWidth = 4;
    for (const nodeLabel in step.previous) {
      const prev = step.previous[nodeLabel];
      if (prev) {
        const fromNode = nodes.find(n => n.label === prev);
        const toNode = nodes.find(n => n.label === nodeLabel);
        ctx.beginPath();
        ctx.moveTo(fromNode.x, fromNode.y);
        ctx.lineTo(toNode.x, toNode.y);
        ctx.stroke();
      }
    }
  }

  // Initial draw
  drawGraph({
    current: null,
    distances: nodes.reduce((acc, n) => { acc[n.label] = Infinity; return acc; }, {}),
    previous: {},
    visited: new Set()
  });
</script>

</body>
</html>ID"><textarea id="YuK7L" style="display: none;">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
&lt;meta charset="UTF-8" /&gt;
&lt;title&gt;Dijkstra's Algorithm Visualization&lt;/title&gt;
&lt;style&gt;
  body { font-family: sans-serif; text-align: center; padding: 20px; }
  canvas { border: 1px solid #ccc; background: #f9f9f9; }
  button { font-size: 16px; padding: 8px 12px; margin: 10px; }
  #info { margin-top: 10px; font-family: monospace; }
&lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;h2&gt;Dijkstra's Algorithm Visualization&lt;/h2&gt;
&lt;button onclick="startDijkstra()"&gt;Start Dijkstra&lt;/button&gt;
&lt;canvas id="canvas" width="600" height="600"&gt;&lt;/canvas&gt;
&lt;div id="info"&gt;&lt;/div&gt;

&lt;script&gt;
  const canvas = document.getElementById("canvas");
  const ctx = canvas.getContext("2d");
  const infoDiv = document.getElementById("info");

  // Nodes with fixed positions
  const nodes = [
    { label: 'A', x: 150, y: 100 },
    { label: 'B', x: 350, y: 100 },
    { label: 'C', x: 550, y: 100 },
    { label: 'D', x: 150, y: 300 },
    { label: 'E', x: 350, y: 300 },
    { label: 'F', x: 550, y: 300 },
    { label: 'G', x: 350, y: 450 }
  ];

  // Edges with weights (undirected)
  // Each edge: [fromLabel, toLabel, weight]
  const edges = [
    ['A', 'B', 4], ['A', 'D', 2],
    ['B', 'C', 3], ['B', 'E', 5],
    ['C', 'F', 1],
    ['D', 'E', 8], ['D', 'G', 10],
    ['E', 'F', 2], ['E', 'G', 6],
    ['F', 'G', 3]
  ];

  // Build adjacency list: label -&gt; [{to, weight}, ...]
  const adjList = {};
  for (const node of nodes) adjList[node.label] = [];
  for (const [from, to, w] of edges) {
    adjList[from].push({ to, weight: w });
    adjList[to].push({ to: from, weight: w }); // undirected
  }

  // Dijkstra state
  let distances = {};
  let previous = {};
  let visited = new Set();
  let pq = []; // priority queue of {label, dist}
  let currentStep = 0;
  let steps = [];

  // Priority queue helper functions
  function enqueue(label, dist) {
    pq.push({ label, dist });
    pq.sort((a,b) =&gt; a.dist - b.dist);
  }
  function dequeue() {
    return pq.shift();
  }

  function startDijkstra() {
    distances = {};
    previous = {};
    visited = new Set();
    pq = [];
    currentStep = 0;
    steps = [];

    for (const node of nodes) {
      distances[node.label] = Infinity;
      previous[node.label] = null;
    }
    distances['A'] = 0;
    enqueue('A', 0);

    // Run algorithm stepwise, recording steps for animation
    while (pq.length &gt; 0) {
      const { label: u, dist: uDist } = dequeue();
      if (visited.has(u)) continue;
      visited.add(u);

      // Save step snapshot
      steps.push({
        current: u,
        distances: {...distances},
        previous: {...previous},
        visited: new Set(visited)
      });

      for (const { to: v, weight } of adjList[u]) {
        if (!visited.has(v)) {
          const alt = distances[u] + weight;
          if (alt &lt; distances[v]) {
            distances[v] = alt;
            previous[v] = u;
            enqueue(v, alt);
          }
        }
      }
    }
    currentStep = 0;
    animateStep();
  }

  function animateStep() {
    if (currentStep &gt;= steps.length) {
      infoDiv.textContent = "Dijkstra completed! Final distances: " + JSON.stringify(distances, null, 2);
      drawGraph(steps[steps.length-1]);
      return;
    }
    drawGraph(steps[currentStep]);
    infoDiv.textContent = `Processing node: ${steps[currentStep].current}\n` +
      `Distances: ${JSON.stringify(steps[currentStep].distances, null, 2)}\n` +
      `Visited: ${[...steps[currentStep].visited].join(', ')}`;
    currentStep++;
    setTimeout(animateStep, 1200);
  }

  // Draw graph with current step info
  function drawGraph(step) {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // Draw edges with weights
    ctx.strokeStyle = "#999";
    ctx.lineWidth = 2;
    ctx.fillStyle = "#000";
    ctx.font = "14px Arial";

    for (const [from, to, w] of edges) {
      const fromNode = nodes.find(n =&gt; n.label === from);
      const toNode = nodes.find(n =&gt; n.label === to);
      ctx.beginPath();
      ctx.moveTo(fromNode.x, fromNode.y);
      ctx.lineTo(toNode.x, toNode.y);
      ctx.stroke();

      // Draw weight label at midpoint with offset
      const midX = (fromNode.x + toNode.x) / 2;
      const midY = (fromNode.y + toNode.y) / 2;
      ctx.fillStyle = "#000";
      ctx.fillText(w, midX + 5, midY - 5);
    }

    // Draw nodes
    for (const node of nodes) {
      const dist = step.distances[node.label];
      const isVisited = step.visited.has(node.label);
      const isCurrent = step.current === node.label;

      ctx.beginPath();
      ctx.arc(node.x, node.y, 25, 0, 2 * Math.PI);
      ctx.fillStyle = isCurrent ? '#e67e22' : (isVisited ? '#2ecc71' : '#3498db');
      ctx.fill();
      ctx.stroke();

      ctx.fillStyle = '#fff';
      ctx.font = '16px Arial';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(node.label, node.x, node.y);

      // Draw distance inside node
      ctx.font = '12px Arial';
      ctx.fillText(dist === Infinity ? '∞' : dist, node.x, node.y + 30);
    }

    // Draw shortest path tree edges (bold)
    ctx.strokeStyle = '#27ae60';
    ctx.lineWidth = 4;
    for (const nodeLabel in step.previous) {
      const prev = step.previous[nodeLabel];
      if (prev) {
        const fromNode = nodes.find(n =&gt; n.label === prev);
        const toNode = nodes.find(n =&gt; n.label === nodeLabel);
        ctx.beginPath();
        ctx.moveTo(fromNode.x, fromNode.y);
        ctx.lineTo(toNode.x, toNode.y);
        ctx.stroke();
      }
    }
  }

  // Initial draw
  drawGraph({
    current: null,
    distances: nodes.reduce((acc, n) =&gt; { acc[n.label] = Infinity; return acc; }, {}),
    previous: {},
    visited: new Set()
  });
&lt;/script&gt;

&lt;/body&gt;
&lt;/html&gt;</textarea> <iframe id="GnM0o" class="result_iframe" style="border:none;"></iframe>
 <script>{
const textarea = document.getElementById("YuK7L");
const iframe = document.getElementById("GnM0o");
const html = textarea.value;
const iframeHTML = `${html}`;
const doc = iframe.contentDocument || iframe.contentWindow.document;
doc.open();
doc.write(iframeHTML);
doc.close();
setTimeout(() => {
   iframe.style.height = '0px';
   let contentHeight = Math.max(doc.body.scrollHeight,doc.documentElement.scrollHeight);
   if(contentHeight < 10 || contentHeight > 800){
	   contentHeight = 800;
   } 
   iframe.style.height = contentHeight + 'px';
}, 50);
}
		</script>
</div><h3 id="graph-and-priority-queue-setup">Graph and Priority Queue Setup</h3><p>To implement Dijkstra’s in JavaScript, we need:</p><ol>
 <li><strong>Adjacency list</strong> to store the graph.</li>
 <li>A simple <strong>priority queue</strong> (we'll use a min-heap).</li>
 <li>A <strong>distance map</strong> to track the shortest known distance to each node.</li>
</ol><h3 id="javascript-implementation">JavaScript Implementation</h3><h4 id="priority-queue-min-heap">Priority Queue (Min-Heap)</h4><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-js">class PriorityQueue {
  constructor() {
    this.values = [];
  }

  enqueue(val, priority) {
    this.values.push({ val, priority });
    this.bubbleUp();
  }

  bubbleUp() {
    let idx = this.values.length - 1;
    const element = this.values[idx];

    while (idx &gt; 0) {
      let parentIdx = Math.floor((idx - 1) / 2);
      let parent = this.values[parentIdx];

      if (element.priority &gt;= parent.priority) break;
      this.values[parentIdx] = element;
      this.values[idx] = parent;
      idx = parentIdx;
    }
  }

  dequeue() {
    const min = this.values[0];
    const end = this.values.pop();
    if (this.values.length &gt; 0) {
      this.values[0] = end;
      this.sinkDown();
    }
    return min;
  }

  sinkDown() {
    let idx = 0;
    const length = this.values.length;
    const element = this.values[0];

    while (true) {
      let leftIdx = 2 * idx + 1;
      let rightIdx = 2 * idx + 2;
      let swap = null;

      if (leftIdx &lt; length) {
        if (this.values[leftIdx].priority &lt; element.priority) {
          swap = leftIdx;
        }
      }

      if (rightIdx &lt; length) {
        if (
          this.values[rightIdx].priority &lt; (swap === null ? element.priority : this.values[leftIdx].priority)
        ) {
          swap = rightIdx;
        }
      }

      if (swap === null) break;

      this.values[idx] = this.values[swap];
      this.values[swap] = element;
      idx = swap;
    }
  }

  isEmpty() {
    return this.values.length === 0;
  }
}</code></pre>
</div><h4 id="dijkstras-algorithm">Dijkstras Algorithm</h4><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-js">class Graph {
  constructor() {
    this.adjList = new Map();
  }

  addVertex(vertex) {
    if (!this.adjList.has(vertex)) this.adjList.set(vertex, []);
  }

  addEdge(v1, v2, weight) {
    this.addVertex(v1);
    this.addVertex(v2);
    this.adjList.get(v1).push({ node: v2, weight });
    // For undirected graph, also add: this.adjList.get(v2).push({ node: v1, weight });
  }

  dijkstra(start) {
    const distances = new Map();
    const pq = new PriorityQueue();
    const previous = new Map();

    for (const vertex of this.adjList.keys()) {
      distances.set(vertex, Infinity);
      previous.set(vertex, null);
    }

    distances.set(start, 0);
    pq.enqueue(start, 0);

    while (!pq.isEmpty()) {
      const { val: current } = pq.dequeue();

      for (const neighbor of this.adjList.get(current)) {
        const distance = distances.get(current) + neighbor.weight;
        if (distance &lt; distances.get(neighbor.node)) {
          distances.set(neighbor.node, distance);
          previous.set(neighbor.node, current);
          pq.enqueue(neighbor.node, distance);
        }
      }
    }

    return { distances, previous };
  }
}</code></pre>
</div><h4 id="usage-example">Usage Example</h4><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-js">const g = new Graph();
g.addEdge("A", "B", 4);
g.addEdge("A", "C", 2);
g.addEdge("B", "E", 3);
g.addEdge("C", "D", 2);
g.addEdge("D", "E", 3);
g.addEdge("C", "F", 4);
g.addEdge("E", "F", 1);

const result = g.dijkstra("A");
console.log(result.distances);</code></pre>
</div><h3 id="time-complexity">Time Complexity</h3><ul>
 <li><strong>With Binary Heap</strong>: O((V + E) * log V)</li>
 <li><strong>Without Heap</strong> (linear scan): O(V²), which is inefficient for large graphs</li>
</ul><h3 id="real-world-applications">Real-World Applications</h3><ul>
 <li><strong>GPS and Navigation Systems</strong>: Find the fastest route based on distance or time.</li>
 <li><strong>Network Routing</strong>: Optimize data packet travel in routers and switches.</li>
 <li><strong>Game Development</strong>: Pathfinding for AI movement in maps or terrains.</li>
 <li><strong>Logistics and Delivery</strong>: Optimize routes for deliveries and pickups.</li>
</ul><h3 id="summary">Summary</h3><p>Dijkstra’s algorithm is a reliable and efficient way to find the <strong>shortest path in graphs with non-negative weights</strong>. By using a <strong>priority queue</strong>, it ensures we always expand the most promising node next, making it both optimal and greedy. Mastering this algorithm is essential for solving real-world routing and optimization problems efficiently in JavaScript.</p><div class = "chapter-navi-section">
<a href="#top" class="nav-button prev">↑</a>
<a href='javascript-algorithms.htm#graph-shortest-paths' class="nav-button toc-link">Index</a>
<a href="#bottom" class="nav-button next">↓</a>
</div>
<h2 id='bellman-ford-algorithm'>15.2 Bellman-Ford Algorithm</h2><p>The <strong>Bellman-Ford algorithm</strong> is a classic solution for finding the <strong>shortest paths from a single source</strong> in a <strong>weighted graph</strong>, even when <strong>negative edge weights</strong> are present. Unlike Dijkstra’s algorithm, Bellman-Ford doesn’t assume all weights are positive, making it crucial in scenarios where penalties, costs, or debt-like relationships exist.</p><h3 id="when-to-use-bellman-ford">When to Use Bellman-Ford</h3><ul>
 <li>Graphs may contain <strong>negative edge weights</strong>.</li>
 <li>Detecting <strong>negative weight cycles</strong> is essential.</li>
 <li>You need a simpler, more robust (but slower) algorithm than Dijkstra.</li>
</ul><h3 id="core-idea-relaxation">Core Idea: Relaxation</h3><p>The Bellman-Ford algorithm works by performing a series of <strong>relaxation steps</strong>:</p><ol>
 <li><strong>Relaxation</strong> means trying to improve the shortest distance to each vertex by checking all edges.</li>
 <li>This process is repeated <strong>(V - 1)</strong> times, where <code>V</code> is the number of vertices.</li>
 <li>After <code>V - 1</code> iterations, if any edge can still be relaxed, a <strong>negative cycle exists</strong>.</li>
</ol><div class="snippet-container" id="<!DOCTYPE html>
<html lang=&quot;en&quot;>
<head>
<meta charset=&quot;UTF-8&quot; />
<title>Bellman-Ford Algorithm Visualization</title>
<style>
  body { font-family: sans-serif; text-align: center; padding: 20px; }
  canvas { border: 1px solid #ccc; background: #f9f9f9; }
  button { font-size: 16px; padding: 8px 12px; margin: 10px; }
  #info { margin-top: 10px; font-family: monospace; white-space: pre-wrap; }
</style>
</head>
<body>

<h2>Bellman-Ford Algorithm Visualization</h2>
<button onclick=&quot;startBellmanFord()&quot;>Start Bellman-Ford</button>
<canvas id=&quot;canvas&quot; width=&quot;600&quot; height=&quot;600&quot;></canvas>
<div id=&quot;info&quot;></div>

<script>
  const canvas = document.getElementById(&quot;canvas&quot;);
  const ctx = canvas.getContext(&quot;2d&quot;);
  const infoDiv = document.getElementById(&quot;info&quot;);

  // Nodes with positions
  const nodes = [
    { label: 'A', x: 150, y: 100 },
    { label: 'B', x: 350, y: 100 },
    { label: 'C', x: 550, y: 100 },
    { label: 'D', x: 150, y: 300 },
    { label: 'E', x: 350, y: 300 },
    { label: 'F', x: 550, y: 300 },
  ];

  // Directed edges with weights: [from, to, weight]
  const edges = [
    ['A', 'B', 6],
    ['A', 'D', 7],
    ['B', 'C', 5],
    ['B', 'E', -4],
    ['B', 'D', 8],
    ['C', 'B', -2],
    ['D', 'E', 9],
    ['E', 'C', 7],
    ['E', 'F', 2],
    ['F', 'A', 2],
    ['F', 'C', -5]
  ];

  // Build adjacency list for edges
  const adjList = {};
  for (const node of nodes) adjList[node.label] = [];
  for (const [from, to, w] of edges) {
    adjList[from].push({ to, weight: w });
  }

  let distances = {};
  let previous = {};
  let steps = [];
  let currentStep = 0;
  let negativeCycleDetected = false;

  function startBellmanFord() {
    distances = {};
    previous = {};
    steps = [];
    currentStep = 0;
    negativeCycleDetected = false;

    for (const node of nodes) {
      distances[node.label] = Infinity;
      previous[node.label] = null;
    }
    distances['A'] = 0;

    // Bellman-Ford relaxation steps
    const V = nodes.length;

    // Relax edges V-1 times
    for (let i = 1; i < V; i++) {
      for (const [u, v, w] of edges) {
        if (distances[u] !== Infinity &amp;&amp; distances[u] + w < distances[v]) {
          distances[v] = distances[u] + w;
          previous[v] = u;
          steps.push({
            step: `Relax edge ${u} -> ${v} (${w})`,
            distances: { ...distances },
            previous: { ...previous },
            currentEdge: [u, v, w],
            iteration: i,
            negativeCycle: false
          });
        }
      }
    }

    // Check for negative cycles
    for (const [u, v, w] of edges) {
      if (distances[u] !== Infinity &amp;&amp; distances[u] + w < distances[v]) {
        negativeCycleDetected = true;
        steps.push({
          step: `Negative cycle detected on edge ${u} -> ${v} (${w})`,
          distances: { ...distances },
          previous: { ...previous },
          currentEdge: [u, v, w],
          iteration: V,
          negativeCycle: true
        });
        break;
      }
    }

    if (steps.length === 0) {
      infoDiv.textContent = &quot;No updates needed, shortest paths are initial distances.&quot;;
      drawGraph({
        distances: distances,
        previous: previous,
        currentEdge: null,
        negativeCycle: false
      });
      return;
    }

    animateStep();
  }

  function animateStep() {
    if (currentStep >= steps.length) {
      infoDiv.textContent += negativeCycleDetected
        ? &quot;\nNegative cycle detected, shortest paths not valid!&quot;
        : &quot;\nAlgorithm completed successfully.&quot;;
      drawGraph(steps[steps.length - 1]);
      return;
    }
    const step = steps[currentStep];
    infoDiv.textContent = `Iteration: ${step.iteration}\n${step.step}\n\nDistances:\n` + 
      Object.entries(step.distances).map(([k,v]) => `${k}: ${v === Infinity ? '∞' : v}`).join('\n') + 
      (step.negativeCycle ? '\n\nNegative cycle detected!' : '');
    drawGraph(step);
    currentStep++;
    setTimeout(animateStep, 1300);
  }

  function drawGraph(step) {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // Draw edges with weights and highlight current edge
    ctx.lineWidth = 2;
    for (const [from, to, w] of edges) {
      const fromNode = nodes.find(n => n.label === from);
      const toNode = nodes.find(n => n.label === to);

      ctx.beginPath();
      ctx.strokeStyle = (step.currentEdge &amp;&amp; step.currentEdge[0] === from &amp;&amp; step.currentEdge[1] === to) ? '#e74c3c' : '#999';
      ctx.moveTo(fromNode.x, fromNode.y);
      ctx.lineTo(toNode.x, toNode.y);
      ctx.stroke();

      // Draw arrow for directed edge
      drawArrow(fromNode.x, fromNode.y, toNode.x, toNode.y, ctx.strokeStyle === '#e74c3c');

      // Draw weight label
      const midX = (fromNode.x + toNode.x) / 2;
      const midY = (fromNode.y + toNode.y) / 2;
      ctx.fillStyle = '#000';
      ctx.font = '14px Arial';
      ctx.fillText(w, midX + 5, midY - 5);
    }

    // Draw nodes
    for (const node of nodes) {
      const dist = step.distances[node.label];
      const isUpdatedNode = step.currentEdge &amp;&amp; (step.currentEdge[1] === node.label);
      ctx.beginPath();
      ctx.arc(node.x, node.y, 25, 0, 2 * Math.PI);
      ctx.fillStyle = isUpdatedNode ? '#f39c12' : '#3498db';
      ctx.fill();
      ctx.stroke();

      ctx.fillStyle = '#fff';
      ctx.font = '16px Arial';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(node.label, node.x, node.y);

      // Distance below node
      ctx.font = '12px Arial';
      ctx.fillText(dist === Infinity ? '∞' : dist, node.x, node.y + 30);
    }

    // Draw shortest path tree edges (bold)
    ctx.strokeStyle = '#27ae60';
    ctx.lineWidth = 4;
    for (const nodeLabel in step.previous) {
      const prev = step.previous[nodeLabel];
      if (prev) {
        const fromNode = nodes.find(n => n.label === prev);
        const toNode = nodes.find(n => n.label === nodeLabel);
        ctx.beginPath();
        ctx.moveTo(fromNode.x, fromNode.y);
        ctx.lineTo(toNode.x, toNode.y);
        ctx.stroke();
      }
    }
  }

  function drawArrow(fromX, fromY, toX, toY, highlight) {
    const headlen = 10;
    const angle = Math.atan2(toY - fromY, toX - fromX);
    ctx.fillStyle = highlight ? '#e74c3c' : '#999';

    ctx.beginPath();
    ctx.moveTo(toX, toY);
    ctx.lineTo(toX - headlen * Math.cos(angle - Math.PI / 6), toY - headlen * Math.sin(angle - Math.PI / 6));
    ctx.lineTo(toX - headlen * Math.cos(angle + Math.PI / 6), toY - headlen * Math.sin(angle + Math.PI / 6));
    ctx.closePath();
    ctx.fill();
  }

  // Initial draw with no distances
  drawGraph({
    distances: nodes.reduce((acc, n) => { acc[n.label] = Infinity; return acc; }, {}),
    previous: {},
    currentEdge: null,
    negativeCycle: false
  });
</script>

</body>
</html>ID"><textarea id="WDrpB" style="display: none;">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
&lt;meta charset="UTF-8" /&gt;
&lt;title&gt;Bellman-Ford Algorithm Visualization&lt;/title&gt;
&lt;style&gt;
  body { font-family: sans-serif; text-align: center; padding: 20px; }
  canvas { border: 1px solid #ccc; background: #f9f9f9; }
  button { font-size: 16px; padding: 8px 12px; margin: 10px; }
  #info { margin-top: 10px; font-family: monospace; white-space: pre-wrap; }
&lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;h2&gt;Bellman-Ford Algorithm Visualization&lt;/h2&gt;
&lt;button onclick="startBellmanFord()"&gt;Start Bellman-Ford&lt;/button&gt;
&lt;canvas id="canvas" width="600" height="600"&gt;&lt;/canvas&gt;
&lt;div id="info"&gt;&lt;/div&gt;

&lt;script&gt;
  const canvas = document.getElementById("canvas");
  const ctx = canvas.getContext("2d");
  const infoDiv = document.getElementById("info");

  // Nodes with positions
  const nodes = [
    { label: 'A', x: 150, y: 100 },
    { label: 'B', x: 350, y: 100 },
    { label: 'C', x: 550, y: 100 },
    { label: 'D', x: 150, y: 300 },
    { label: 'E', x: 350, y: 300 },
    { label: 'F', x: 550, y: 300 },
  ];

  // Directed edges with weights: [from, to, weight]
  const edges = [
    ['A', 'B', 6],
    ['A', 'D', 7],
    ['B', 'C', 5],
    ['B', 'E', -4],
    ['B', 'D', 8],
    ['C', 'B', -2],
    ['D', 'E', 9],
    ['E', 'C', 7],
    ['E', 'F', 2],
    ['F', 'A', 2],
    ['F', 'C', -5]
  ];

  // Build adjacency list for edges
  const adjList = {};
  for (const node of nodes) adjList[node.label] = [];
  for (const [from, to, w] of edges) {
    adjList[from].push({ to, weight: w });
  }

  let distances = {};
  let previous = {};
  let steps = [];
  let currentStep = 0;
  let negativeCycleDetected = false;

  function startBellmanFord() {
    distances = {};
    previous = {};
    steps = [];
    currentStep = 0;
    negativeCycleDetected = false;

    for (const node of nodes) {
      distances[node.label] = Infinity;
      previous[node.label] = null;
    }
    distances['A'] = 0;

    // Bellman-Ford relaxation steps
    const V = nodes.length;

    // Relax edges V-1 times
    for (let i = 1; i &lt; V; i++) {
      for (const [u, v, w] of edges) {
        if (distances[u] !== Infinity &amp;&amp; distances[u] + w &lt; distances[v]) {
          distances[v] = distances[u] + w;
          previous[v] = u;
          steps.push({
            step: `Relax edge ${u} -&gt; ${v} (${w})`,
            distances: { ...distances },
            previous: { ...previous },
            currentEdge: [u, v, w],
            iteration: i,
            negativeCycle: false
          });
        }
      }
    }

    // Check for negative cycles
    for (const [u, v, w] of edges) {
      if (distances[u] !== Infinity &amp;&amp; distances[u] + w &lt; distances[v]) {
        negativeCycleDetected = true;
        steps.push({
          step: `Negative cycle detected on edge ${u} -&gt; ${v} (${w})`,
          distances: { ...distances },
          previous: { ...previous },
          currentEdge: [u, v, w],
          iteration: V,
          negativeCycle: true
        });
        break;
      }
    }

    if (steps.length === 0) {
      infoDiv.textContent = "No updates needed, shortest paths are initial distances.";
      drawGraph({
        distances: distances,
        previous: previous,
        currentEdge: null,
        negativeCycle: false
      });
      return;
    }

    animateStep();
  }

  function animateStep() {
    if (currentStep &gt;= steps.length) {
      infoDiv.textContent += negativeCycleDetected
        ? "\nNegative cycle detected, shortest paths not valid!"
        : "\nAlgorithm completed successfully.";
      drawGraph(steps[steps.length - 1]);
      return;
    }
    const step = steps[currentStep];
    infoDiv.textContent = `Iteration: ${step.iteration}\n${step.step}\n\nDistances:\n` + 
      Object.entries(step.distances).map(([k,v]) =&gt; `${k}: ${v === Infinity ? '∞' : v}`).join('\n') + 
      (step.negativeCycle ? '\n\nNegative cycle detected!' : '');
    drawGraph(step);
    currentStep++;
    setTimeout(animateStep, 1300);
  }

  function drawGraph(step) {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // Draw edges with weights and highlight current edge
    ctx.lineWidth = 2;
    for (const [from, to, w] of edges) {
      const fromNode = nodes.find(n =&gt; n.label === from);
      const toNode = nodes.find(n =&gt; n.label === to);

      ctx.beginPath();
      ctx.strokeStyle = (step.currentEdge &amp;&amp; step.currentEdge[0] === from &amp;&amp; step.currentEdge[1] === to) ? '#e74c3c' : '#999';
      ctx.moveTo(fromNode.x, fromNode.y);
      ctx.lineTo(toNode.x, toNode.y);
      ctx.stroke();

      // Draw arrow for directed edge
      drawArrow(fromNode.x, fromNode.y, toNode.x, toNode.y, ctx.strokeStyle === '#e74c3c');

      // Draw weight label
      const midX = (fromNode.x + toNode.x) / 2;
      const midY = (fromNode.y + toNode.y) / 2;
      ctx.fillStyle = '#000';
      ctx.font = '14px Arial';
      ctx.fillText(w, midX + 5, midY - 5);
    }

    // Draw nodes
    for (const node of nodes) {
      const dist = step.distances[node.label];
      const isUpdatedNode = step.currentEdge &amp;&amp; (step.currentEdge[1] === node.label);
      ctx.beginPath();
      ctx.arc(node.x, node.y, 25, 0, 2 * Math.PI);
      ctx.fillStyle = isUpdatedNode ? '#f39c12' : '#3498db';
      ctx.fill();
      ctx.stroke();

      ctx.fillStyle = '#fff';
      ctx.font = '16px Arial';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(node.label, node.x, node.y);

      // Distance below node
      ctx.font = '12px Arial';
      ctx.fillText(dist === Infinity ? '∞' : dist, node.x, node.y + 30);
    }

    // Draw shortest path tree edges (bold)
    ctx.strokeStyle = '#27ae60';
    ctx.lineWidth = 4;
    for (const nodeLabel in step.previous) {
      const prev = step.previous[nodeLabel];
      if (prev) {
        const fromNode = nodes.find(n =&gt; n.label === prev);
        const toNode = nodes.find(n =&gt; n.label === nodeLabel);
        ctx.beginPath();
        ctx.moveTo(fromNode.x, fromNode.y);
        ctx.lineTo(toNode.x, toNode.y);
        ctx.stroke();
      }
    }
  }

  function drawArrow(fromX, fromY, toX, toY, highlight) {
    const headlen = 10;
    const angle = Math.atan2(toY - fromY, toX - fromX);
    ctx.fillStyle = highlight ? '#e74c3c' : '#999';

    ctx.beginPath();
    ctx.moveTo(toX, toY);
    ctx.lineTo(toX - headlen * Math.cos(angle - Math.PI / 6), toY - headlen * Math.sin(angle - Math.PI / 6));
    ctx.lineTo(toX - headlen * Math.cos(angle + Math.PI / 6), toY - headlen * Math.sin(angle + Math.PI / 6));
    ctx.closePath();
    ctx.fill();
  }

  // Initial draw with no distances
  drawGraph({
    distances: nodes.reduce((acc, n) =&gt; { acc[n.label] = Infinity; return acc; }, {}),
    previous: {},
    currentEdge: null,
    negativeCycle: false
  });
&lt;/script&gt;

&lt;/body&gt;
&lt;/html&gt;</textarea> <iframe id="Vx7Z8" class="result_iframe" style="border:none;"></iframe>
 <script>{
const textarea = document.getElementById("WDrpB");
const iframe = document.getElementById("Vx7Z8");
const html = textarea.value;
const iframeHTML = `${html}`;
const doc = iframe.contentDocument || iframe.contentWindow.document;
doc.open();
doc.write(iframeHTML);
doc.close();
setTimeout(() => {
   iframe.style.height = '0px';
   let contentHeight = Math.max(doc.body.scrollHeight,doc.documentElement.scrollHeight);
   if(contentHeight < 10 || contentHeight > 800){
	   contentHeight = 800;
   } 
   iframe.style.height = contentHeight + 'px';
}, 50);
}
		</script>
</div><h3 id="javascript-implementation">JavaScript Implementation</h3><p>Let’s implement Bellman-Ford with a simple edge list representation.</p><div>
 <div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
  <pre><code class="language-js">class Graph {
  constructor() {
    this.vertices = new Set();
    this.edges = []; // Each edge: { from, to, weight }
  }

  addEdge(from, to, weight) {
    this.vertices.add(from);
    this.vertices.add(to);
    this.edges.push({ from, to, weight });
  }

  bellmanFord(start) {
    const distances = {};
    const predecessors = {};

    // Step 1: Initialize distances
    for (let vertex of this.vertices) {
      distances[vertex] = Infinity;
      predecessors[vertex] = null;
    }
    distances[start] = 0;

    const V = this.vertices.size;

    // Step 2: Relax edges repeatedly
    for (let i = 0; i &lt; V - 1; i++) {
      for (let { from, to, weight } of this.edges) {
        if (distances[from] + weight &lt; distances[to]) {
          distances[to] = distances[from] + weight;
          predecessors[to] = from;
        }
      }
    }

    // Step 3: Check for negative-weight cycles
    for (let { from, to, weight } of this.edges) {
      if (distances[from] + weight &lt; distances[to]) {
        throw new Error("Graph contains a negative weight cycle");
      }
    }

    return { distances, predecessors };
  }
}

const g = new Graph();
g.addEdge("A", "B", 4);
g.addEdge("A", "C", 2);
g.addEdge("C", "B", -2);
g.addEdge("B", "D", 2);
g.addEdge("C", "D", 3);

const result = g.bellmanFord("A");
console.log(JSON.stringify(result.distances,null,2)); // { A: 0, B: 0, C: 2, D: 2 }</code></pre>
 </div>
 <div class="snippet-container" id="DEXPY">
  <div class="snippet-header" onclick="toggleSnippetAndRefresh('DEXPY','DBmr8')">
   Try it in editor
  </div>
  <div class="snippet-body"><textarea id="DBmr8">class Graph {
  constructor() {
    this.vertices = new Set();
    this.edges = []; // Each edge: { from, to, weight }
  }

  addEdge(from, to, weight) {
    this.vertices.add(from);
    this.vertices.add(to);
    this.edges.push({ from, to, weight });
  }

  bellmanFord(start) {
    const distances = {};
    const predecessors = {};

    // Step 1: Initialize distances
    for (let vertex of this.vertices) {
      distances[vertex] = Infinity;
      predecessors[vertex] = null;
    }
    distances[start] = 0;

    const V = this.vertices.size;

    // Step 2: Relax edges repeatedly
    for (let i = 0; i &lt; V - 1; i++) {
      for (let { from, to, weight } of this.edges) {
        if (distances[from] + weight &lt; distances[to]) {
          distances[to] = distances[from] + weight;
          predecessors[to] = from;
        }
      }
    }

    // Step 3: Check for negative-weight cycles
    for (let { from, to, weight } of this.edges) {
      if (distances[from] + weight &lt; distances[to]) {
        throw new Error("Graph contains a negative weight cycle");
      }
    }

    return { distances, predecessors };
  }
}

const g = new Graph();
g.addEdge("A", "B", 4);
g.addEdge("A", "C", 2);
g.addEdge("C", "B", -2);
g.addEdge("B", "D", 2);
g.addEdge("C", "D", 3);

const result = g.bellmanFord("A");
console.log(JSON.stringify(result.distances,null,2)); // { A: 0, B: 0, C: 2, D: 2 }</textarea> <br> <button onclick="renderIframeForClientJavascript('DBmr8','Abo7r')">Run</button> <iframe id="Abo7r" class="result_iframe" style="display: none;"></iframe>
   <script>
  {let editor1 = CodeMirror.fromTextArea(document.getElementById("DBmr8"), {
    mode: "javascript",
    lineNumbers:false,
    tabSize: 2
    });
    const mode = localStorage.getItem("mode") || "light";  
    const newTheme = mode === "dark" ? "material" : "default";
    editor1.setOption("theme", newTheme);

    codeMirrorMap.set("DBmr8", editor1);}
  </script>
  </div>
 </div>
</div><p>This shows that even with a negative edge (C → B with weight -2), Bellman-Ford still computes correct shortest paths.</p><h3 id="negative-cycle-detection">Negative Cycle Detection</h3><p>If the graph contains a cycle where the total weight is negative (e.g., a loop with net cost -3), Bellman-Ford will detect it and throw an error or return a signal that no shortest path exists due to infinite reduction.</p><h3 id="time-complexity">Time Complexity</h3><ul>
 <li><strong>Time</strong>: O(V × E) Slower than Dijkstra (O((V + E) log V) with a min-heap), especially for dense graphs.</li>
 <li><strong>Space</strong>: O(V) for storing distances and predecessors.</li>
</ul><h3 id="real-world-applications">Real-World Applications</h3><ul>
 <li><strong>Financial Systems</strong>: Detecting arbitrage opportunities (negative cycles).</li>
 <li><strong>Network Routing</strong>: Calculating paths where costs may include penalties.</li>
 <li><strong>AI &amp; Game Development</strong>: Evaluating graphs with penalties or risk factors.</li>
 <li><strong>Compiler Design</strong>: Finding optimal register allocations with weighted graphs.</li>
</ul><h3 id="dijkstra-vs-bellman-ford">Dijkstra vs Bellman-Ford</h3><table>
 <thead>
  <tr>
   <th>Feature</th>
   <th>Dijkstra</th>
   <th>Bellman-Ford</th>
  </tr>
 </thead>
 <tbody>
  <tr>
   <td>Handles negative weights</td>
   <td>❌ No</td>
   <td>✅ Yes</td>
  </tr>
  <tr>
   <td>Detects negative cycles</td>
   <td>❌ No</td>
   <td>✅ Yes</td>
  </tr>
  <tr>
   <td>Time complexity</td>
   <td>Faster (with heap)</td>
   <td>Slower (O(V × E))</td>
  </tr>
  <tr>
   <td>Implementation complexity</td>
   <td>Higher (needs heap)</td>
   <td>Simpler</td>
  </tr>
 </tbody>
</table><h3 id="summary">Summary</h3><p>The <strong>Bellman-Ford algorithm</strong> is a powerful and flexible choice for shortest path problems where edge weights may be negative or where cycle detection is necessary. Though not as fast as Dijkstra’s algorithm, its broader applicability makes it a valuable tool in any JavaScript algorithmist’s toolkit.</p><div class = "chapter-navi-section">
<a href="#top" class="nav-button prev">↑</a>
<a href='javascript-algorithms.htm#graph-shortest-paths' class="nav-button toc-link">Index</a>
<a href="#bottom" class="nav-button next">↓</a>
</div>
<h2 id='a-search-practical-frontend-use'>15.3 A* Search (Practical Frontend Use)*\*</h2><p>The <strong>A*</strong> (A-star) search algorithm is a powerful and efficient pathfinding technique, particularly popular in <strong>games</strong>, <strong>UI navigation</strong>, and <strong>interactive frontend tools</strong>. It builds upon Dijkstra’s algorithm by incorporating a <strong>heuristic function</strong>, which estimates the cost from a node to the goal. This makes A* both <strong>optimal</strong> and <strong>goal-directed</strong>, reducing unnecessary exploration.</p><h3 id="what-is-a-search">What Is A* Search?</h3><p>A* combines the best of:</p><ul>
 <li><strong>Dijkstra’s algorithm</strong>, which finds the shortest path using actual costs (<code>g(n)</code>), and</li>
 <li><strong>Greedy Best-First Search</strong>, which uses a heuristic guess (<code>h(n)</code>) to move toward the goal.</li>
</ul><p>It uses a priority function:</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-bash">f(n) = g(n) + h(n)</code></pre>
</div><p>Where:</p><ul>
 <li><code>g(n)</code> = cost from start to node <code>n</code></li>
 <li><code>h(n)</code> = estimated cost from <code>n</code> to goal (heuristic)</li>
 <li><code>f(n)</code> = total estimated cost of the path through <code>n</code></li>
</ul><div class="snippet-container" id="<!DOCTYPE html>
<html lang=&quot;en&quot;>
<head>
<meta charset=&quot;UTF-8&quot; />
<title>A* Pathfinding Visualization</title>
<style>
  body { font-family: sans-serif; text-align: center; padding: 20px; }
  canvas { border: 1px solid #ccc; background: #f9f9f9; display: block; margin: 0 auto; }
  button { font-size: 16px; padding: 8px 12px; margin: 10px; }
</style>
</head>
<body>

<h2>A* Algorithm Visualization on Grid</h2>
<button onclick=&quot;startAStar()&quot;>Start A*</button>
<canvas id=&quot;canvas&quot; width=&quot;600&quot; height=&quot;600&quot;></canvas>

<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');

const ROWS = 20;
const COLS = 20;
const CELL_SIZE = 30;

// Grid representation: 0 = walkable, 1 = obstacle
const grid = [];
for(let r=0; r<ROWS; r++){
  grid[r] = [];
  for(let c=0; c<COLS; c++){
    grid[r][c] = 0;
  }
}

// Add some obstacles
const obstacleCoords = [
  [5,5],[5,6],[5,7],[5,8],[5,9],[5,10],
  [10,3],[11,3],[12,3],[13,3],[14,3],
  [15,10],[15,11],[15,12],[15,13],[15,14],
  [8,15],[9,15],[10,15],[11,15],[12,15]
];
for(const [r,c] of obstacleCoords){
  grid[r][c] = 1;
}

const start = {r:0, c:0};
const goal = {r:ROWS-1, c:COLS-1};

function drawGrid(openSet = [], closedSet = [], path = []) {
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  for(let r=0; r<ROWS; r++) {
    for(let c=0; c<COLS; c++) {
      let color = '#3498db'; // default walkable: blue
      if(grid[r][c] === 1) color = '#555'; // obstacle: dark gray

      // Highlight sets
      if (closedSet.some(n => n.r === r &amp;&amp; n.c === c)) color = '#e74c3c'; // closed: red
      if (openSet.some(n => n.r === r &amp;&amp; n.c === c)) color = '#2ecc71'; // open: green
      if (path.some(n => n.r === r &amp;&amp; n.c === c)) color = '#f1c40f'; // path: yellow
      if(r === start.r &amp;&amp; c === start.c) color = '#27ae60'; // start: dark green
      if(r === goal.r &amp;&amp; c === goal.c) color = '#9b59b6'; // goal: purple

      ctx.fillStyle = color;
      ctx.fillRect(c*CELL_SIZE, r*CELL_SIZE, CELL_SIZE, CELL_SIZE);
      ctx.strokeStyle = '#222';
      ctx.strokeRect(c*CELL_SIZE, r*CELL_SIZE, CELL_SIZE, CELL_SIZE);
    }
  }
}

// Helper for heuristic (Manhattan distance)
function heuristic(a, b) {
  return Math.abs(a.r - b.r) + Math.abs(a.c - b.c);
}

// Get neighbors of a cell (4 directions)
function neighbors(node) {
  const results = [];
  const {r,c} = node;
  if(r>0 &amp;&amp; grid[r-1][c] === 0) results.push({r:r-1,c});
  if(r<ROWS-1 &amp;&amp; grid[r+1][c] === 0) results.push({r:r+1,c});
  if(c>0 &amp;&amp; grid[r][c-1] === 0) results.push({r,c:c-1});
  if(c<COLS-1 &amp;&amp; grid[r][c+1] === 0) results.push({r,c:c+1});
  return results;
}

// A* algorithm variables
let openSet = [];
let closedSet = [];
let cameFrom = {};
let gScore = {};
let fScore = {};
let finished = false;

function nodeKey(node) {
  return `${node.r},${node.c}`;
}

function startAStar() {
  openSet = [start];
  closedSet = [];
  cameFrom = {};
  gScore = {};
  fScore = {};
  finished = false;

  for(let r=0; r<ROWS; r++){
    for(let c=0; c<COLS; c++){
      gScore[nodeKey({r,c})] = Infinity;
      fScore[nodeKey({r,c})] = Infinity;
    }
  }
  gScore[nodeKey(start)] = 0;
  fScore[nodeKey(start)] = heuristic(start, goal);

  animateStep();
}

function reconstructPath(current) {
  const path = [];
  while (nodeKey(current) in cameFrom) {
    path.push(current);
    current = cameFrom[nodeKey(current)];
  }
  path.push(start);
  return path.reverse();
}

function animateStep() {
  if (openSet.length === 0) {
    // No path found
    info(&quot;No path found!&quot;);
    drawGrid([], closedSet, []);
    return;
  }
  // Pick node in openSet with lowest fScore
  let currentIndex = 0;
  for(let i=1; i<openSet.length; i++){
    if(fScore[nodeKey(openSet[i])] < fScore[nodeKey(openSet[currentIndex])]){
      currentIndex = i;
    }
  }
  const current = openSet[currentIndex];

  if(current.r === goal.r &amp;&amp; current.c === goal.c){
    finished = true;
    const path = reconstructPath(current);
    drawGrid(openSet, closedSet, path);
    info(&quot;Path found! Length: &quot; + (path.length -1));
    return;
  }

  openSet.splice(currentIndex, 1);
  closedSet.push(current);

  for(const neighbor of neighbors(current)){
    if(closedSet.some(n => n.r === neighbor.r &amp;&amp; n.c === neighbor.c)) continue;

    const tentativeG = gScore[nodeKey(current)] + 1;
    if(!openSet.some(n => n.r === neighbor.r &amp;&amp; n.c === neighbor.c)){
      openSet.push(neighbor);
    } else if(tentativeG >= gScore[nodeKey(neighbor)]){
      continue;
    }

    cameFrom[nodeKey(neighbor)] = current;
    gScore[nodeKey(neighbor)] = tentativeG;
    fScore[nodeKey(neighbor)] = tentativeG + heuristic(neighbor, goal);
  }

  drawGrid(openSet, closedSet, []);
  setTimeout(() => animateStep(), 100);
}

function info(text) {
  // Could add an info panel if desired
  console.log(text);
}

drawGrid();
</script>

</body>
</html>ID"><textarea id="BblwR" style="display: none;">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
&lt;meta charset="UTF-8" /&gt;
&lt;title&gt;A* Pathfinding Visualization&lt;/title&gt;
&lt;style&gt;
  body { font-family: sans-serif; text-align: center; padding: 20px; }
  canvas { border: 1px solid #ccc; background: #f9f9f9; display: block; margin: 0 auto; }
  button { font-size: 16px; padding: 8px 12px; margin: 10px; }
&lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;h2&gt;A* Algorithm Visualization on Grid&lt;/h2&gt;
&lt;button onclick="startAStar()"&gt;Start A*&lt;/button&gt;
&lt;canvas id="canvas" width="600" height="600"&gt;&lt;/canvas&gt;

&lt;script&gt;
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');

const ROWS = 20;
const COLS = 20;
const CELL_SIZE = 30;

// Grid representation: 0 = walkable, 1 = obstacle
const grid = [];
for(let r=0; r&lt;ROWS; r++){
  grid[r] = [];
  for(let c=0; c&lt;COLS; c++){
    grid[r][c] = 0;
  }
}

// Add some obstacles
const obstacleCoords = [
  [5,5],[5,6],[5,7],[5,8],[5,9],[5,10],
  [10,3],[11,3],[12,3],[13,3],[14,3],
  [15,10],[15,11],[15,12],[15,13],[15,14],
  [8,15],[9,15],[10,15],[11,15],[12,15]
];
for(const [r,c] of obstacleCoords){
  grid[r][c] = 1;
}

const start = {r:0, c:0};
const goal = {r:ROWS-1, c:COLS-1};

function drawGrid(openSet = [], closedSet = [], path = []) {
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  for(let r=0; r&lt;ROWS; r++) {
    for(let c=0; c&lt;COLS; c++) {
      let color = '#3498db'; // default walkable: blue
      if(grid[r][c] === 1) color = '#555'; // obstacle: dark gray

      // Highlight sets
      if (closedSet.some(n =&gt; n.r === r &amp;&amp; n.c === c)) color = '#e74c3c'; // closed: red
      if (openSet.some(n =&gt; n.r === r &amp;&amp; n.c === c)) color = '#2ecc71'; // open: green
      if (path.some(n =&gt; n.r === r &amp;&amp; n.c === c)) color = '#f1c40f'; // path: yellow
      if(r === start.r &amp;&amp; c === start.c) color = '#27ae60'; // start: dark green
      if(r === goal.r &amp;&amp; c === goal.c) color = '#9b59b6'; // goal: purple

      ctx.fillStyle = color;
      ctx.fillRect(c*CELL_SIZE, r*CELL_SIZE, CELL_SIZE, CELL_SIZE);
      ctx.strokeStyle = '#222';
      ctx.strokeRect(c*CELL_SIZE, r*CELL_SIZE, CELL_SIZE, CELL_SIZE);
    }
  }
}

// Helper for heuristic (Manhattan distance)
function heuristic(a, b) {
  return Math.abs(a.r - b.r) + Math.abs(a.c - b.c);
}

// Get neighbors of a cell (4 directions)
function neighbors(node) {
  const results = [];
  const {r,c} = node;
  if(r&gt;0 &amp;&amp; grid[r-1][c] === 0) results.push({r:r-1,c});
  if(r&lt;ROWS-1 &amp;&amp; grid[r+1][c] === 0) results.push({r:r+1,c});
  if(c&gt;0 &amp;&amp; grid[r][c-1] === 0) results.push({r,c:c-1});
  if(c&lt;COLS-1 &amp;&amp; grid[r][c+1] === 0) results.push({r,c:c+1});
  return results;
}

// A* algorithm variables
let openSet = [];
let closedSet = [];
let cameFrom = {};
let gScore = {};
let fScore = {};
let finished = false;

function nodeKey(node) {
  return `${node.r},${node.c}`;
}

function startAStar() {
  openSet = [start];
  closedSet = [];
  cameFrom = {};
  gScore = {};
  fScore = {};
  finished = false;

  for(let r=0; r&lt;ROWS; r++){
    for(let c=0; c&lt;COLS; c++){
      gScore[nodeKey({r,c})] = Infinity;
      fScore[nodeKey({r,c})] = Infinity;
    }
  }
  gScore[nodeKey(start)] = 0;
  fScore[nodeKey(start)] = heuristic(start, goal);

  animateStep();
}

function reconstructPath(current) {
  const path = [];
  while (nodeKey(current) in cameFrom) {
    path.push(current);
    current = cameFrom[nodeKey(current)];
  }
  path.push(start);
  return path.reverse();
}

function animateStep() {
  if (openSet.length === 0) {
    // No path found
    info("No path found!");
    drawGrid([], closedSet, []);
    return;
  }
  // Pick node in openSet with lowest fScore
  let currentIndex = 0;
  for(let i=1; i&lt;openSet.length; i++){
    if(fScore[nodeKey(openSet[i])] &lt; fScore[nodeKey(openSet[currentIndex])]){
      currentIndex = i;
    }
  }
  const current = openSet[currentIndex];

  if(current.r === goal.r &amp;&amp; current.c === goal.c){
    finished = true;
    const path = reconstructPath(current);
    drawGrid(openSet, closedSet, path);
    info("Path found! Length: " + (path.length -1));
    return;
  }

  openSet.splice(currentIndex, 1);
  closedSet.push(current);

  for(const neighbor of neighbors(current)){
    if(closedSet.some(n =&gt; n.r === neighbor.r &amp;&amp; n.c === neighbor.c)) continue;

    const tentativeG = gScore[nodeKey(current)] + 1;
    if(!openSet.some(n =&gt; n.r === neighbor.r &amp;&amp; n.c === neighbor.c)){
      openSet.push(neighbor);
    } else if(tentativeG &gt;= gScore[nodeKey(neighbor)]){
      continue;
    }

    cameFrom[nodeKey(neighbor)] = current;
    gScore[nodeKey(neighbor)] = tentativeG;
    fScore[nodeKey(neighbor)] = tentativeG + heuristic(neighbor, goal);
  }

  drawGrid(openSet, closedSet, []);
  setTimeout(() =&gt; animateStep(), 100);
}

function info(text) {
  // Could add an info panel if desired
  console.log(text);
}

drawGrid();
&lt;/script&gt;

&lt;/body&gt;
&lt;/html&gt;</textarea> <iframe id="DtCtZ" class="result_iframe" style="border:none;"></iframe>
 <script>{
const textarea = document.getElementById("BblwR");
const iframe = document.getElementById("DtCtZ");
const html = textarea.value;
const iframeHTML = `${html}`;
const doc = iframe.contentDocument || iframe.contentWindow.document;
doc.open();
doc.write(iframeHTML);
doc.close();
setTimeout(() => {
   iframe.style.height = '0px';
   let contentHeight = Math.max(doc.body.scrollHeight,doc.documentElement.scrollHeight);
   if(contentHeight < 10 || contentHeight > 800){
	   contentHeight = 800;
   } 
   iframe.style.height = contentHeight + 'px';
}, 50);
}
		</script>
</div><h3 id="javascript-implementation">JavaScript Implementation</h3><p>Let’s build a simplified A* search to navigate a <strong>2D grid</strong>, like in games or interactive maps.</p><h4 id="grid-and-heuristic-setup">Grid and Heuristic Setup</h4><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-js">function heuristic(a, b) {
  // Manhattan distance (suitable for 4-directional grids)
  return Math.abs(a[0] - b[0]) + Math.abs(a[1] - b[1]);
}</code></pre>
</div><h4 id="a-algorithm">A* Algorithm</h4><div>
 <div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
  <pre><code class="language-js">function aStar(grid, start, goal) {
  const rows = grid.length;
  const cols = grid[0].length;
  const openSet = new Set([start.toString()]);
  const cameFrom = new Map();

  const gScore = {};
  const fScore = {};

  for (let r = 0; r &lt; rows; r++) {
    for (let c = 0; c &lt; cols; c++) {
      gScore[[r, c]] = Infinity;
      fScore[[r, c]] = Infinity;
    }
  }

  gScore[start] = 0;
  fScore[start] = heuristic(start, goal);

  const queue = [{ node: start, f: fScore[start] }];

  while (queue.length &gt; 0) {
    queue.sort((a, b) =&gt; a.f - b.f); // Priority queue by f(n)
    const { node: current } = queue.shift();
    const key = current.toString();

    if (key === goal.toString()) {
      // Reconstruct path
      const path = [];
      let curr = key;
      while (curr) {
        path.unshift(curr.split(',').map(Number));
        curr = cameFrom.get(curr);
      }
      return path;
    }

    openSet.delete(key);

    for (let [dr, dc] of [[0,1],[1,0],[0,-1],[-1,0]]) {
      const nr = current[0] + dr;
      const nc = current[1] + dc;
      if (nr &lt; 0 || nc &lt; 0 || nr &gt;= rows || nc &gt;= cols || grid[nr][nc] === 1) continue;

      const neighbor = [nr, nc];
      const neighborKey = neighbor.toString();
      const tentativeG = gScore[key] + 1;

      if (tentativeG &lt; gScore[neighborKey]) {
        cameFrom.set(neighborKey, key);
        gScore[neighborKey] = tentativeG;
        fScore[neighborKey] = tentativeG + heuristic(neighbor, goal);
        if (!openSet.has(neighborKey)) {
          openSet.add(neighborKey);
          queue.push({ node: neighbor, f: fScore[neighborKey] });
        }
      }
    }
  }

  return []; // No path found
}
function heuristic(a, b) {
  // Manhattan distance (suitable for 4-directional grids)
  return Math.abs(a[0] - b[0]) + Math.abs(a[1] - b[1]);
}
const grid = [
  [0, 0, 0, 0],
  [1, 1, 0, 1],
  [0, 0, 0, 0]
];

const start = [0, 0];
const goal = [2, 3];

const path = aStar(grid, start, goal);
console.log(path);
// Output: a list of coordinates forming the shortest path</code></pre>
 </div>
 <div class="snippet-container" id="yilpc">
  <div class="snippet-header" onclick="toggleSnippetAndRefresh('yilpc','L6x0t')">
   Try it in editor
  </div>
  <div class="snippet-body"><textarea id="L6x0t">function aStar(grid, start, goal) {
  const rows = grid.length;
  const cols = grid[0].length;
  const openSet = new Set([start.toString()]);
  const cameFrom = new Map();

  const gScore = {};
  const fScore = {};

  for (let r = 0; r &lt; rows; r++) {
    for (let c = 0; c &lt; cols; c++) {
      gScore[[r, c]] = Infinity;
      fScore[[r, c]] = Infinity;
    }
  }

  gScore[start] = 0;
  fScore[start] = heuristic(start, goal);

  const queue = [{ node: start, f: fScore[start] }];

  while (queue.length &gt; 0) {
    queue.sort((a, b) =&gt; a.f - b.f); // Priority queue by f(n)
    const { node: current } = queue.shift();
    const key = current.toString();

    if (key === goal.toString()) {
      // Reconstruct path
      const path = [];
      let curr = key;
      while (curr) {
        path.unshift(curr.split(',').map(Number));
        curr = cameFrom.get(curr);
      }
      return path;
    }

    openSet.delete(key);

    for (let [dr, dc] of [[0,1],[1,0],[0,-1],[-1,0]]) {
      const nr = current[0] + dr;
      const nc = current[1] + dc;
      if (nr &lt; 0 || nc &lt; 0 || nr &gt;= rows || nc &gt;= cols || grid[nr][nc] === 1) continue;

      const neighbor = [nr, nc];
      const neighborKey = neighbor.toString();
      const tentativeG = gScore[key] + 1;

      if (tentativeG &lt; gScore[neighborKey]) {
        cameFrom.set(neighborKey, key);
        gScore[neighborKey] = tentativeG;
        fScore[neighborKey] = tentativeG + heuristic(neighbor, goal);
        if (!openSet.has(neighborKey)) {
          openSet.add(neighborKey);
          queue.push({ node: neighbor, f: fScore[neighborKey] });
        }
      }
    }
  }

  return []; // No path found
}
function heuristic(a, b) {
  // Manhattan distance (suitable for 4-directional grids)
  return Math.abs(a[0] - b[0]) + Math.abs(a[1] - b[1]);
}
const grid = [
  [0, 0, 0, 0],
  [1, 1, 0, 1],
  [0, 0, 0, 0]
];

const start = [0, 0];
const goal = [2, 3];

const path = aStar(grid, start, goal);
console.log(path);
// Output: a list of coordinates forming the shortest path</textarea> <br> <button onclick="renderIframeForClientJavascript('L6x0t','4g3nd')">Run</button> <iframe id="4g3nd" class="result_iframe" style="display: none;"></iframe>
   <script>
  {let editor1 = CodeMirror.fromTextArea(document.getElementById("L6x0t"), {
    mode: "javascript",
    lineNumbers:false,
    tabSize: 2
    });
    const mode = localStorage.getItem("mode") || "light";  
    const newTheme = mode === "dark" ? "material" : "default";
    editor1.setOption("theme", newTheme);

    codeMirrorMap.set("L6x0t", editor1);}
  </script>
  </div>
 </div>
</div><h4 id="grid-visualization">Grid Visualization</h4><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-bash">S . . .
# # . #
. . . G</code></pre>
</div><p>Where <code>S</code> = start, <code>G</code> = goal, <code>#</code> = wall. A* will explore only optimal directions toward the goal, guided by the heuristic.</p><h3 id="heuristic-function-design">Heuristic Function Design</h3><p>A* relies heavily on a good <strong>heuristic</strong>:</p><ul>
 <li><strong>Manhattan distance</strong>: <code>|x1 - x2| + |y1 - y2|</code> (for 4-directional grids)</li>
 <li><strong>Euclidean distance</strong>: <code>sqrt((x1 - x2)^2 + (y1 - y2)^2)</code> (for diagonal movement)</li>
 <li><strong>Zero heuristic</strong>: A* becomes Dijkstra’s algorithm</li>
</ul><h4 id="trade-offs">Trade-offs:</h4><ul>
 <li><strong>Admissibility</strong>: The heuristic must <strong>never overestimate</strong> the actual cost.</li>
 <li>A stronger (but admissible) heuristic makes A* faster.</li>
 <li>Over-aggressive heuristics can result in suboptimal paths.</li>
</ul><h3 id="performance-considerations">Performance Considerations</h3><ul>
 <li><strong>Time complexity</strong>: O(E), but depends on heuristic quality and branching factor.</li>
 <li><strong>Space complexity</strong>: O(V), for open set and score maps.</li>
 <li>For large grids or dense graphs, optimizations like <strong>binary heaps</strong> or <strong>early goal detection</strong> improve performance.</li>
</ul><h3 id="real-world-applications">Real-World Applications</h3><ul>
 <li><strong>Game AI</strong>: Characters finding paths on a game map.</li>
 <li><strong>Drag-and-drop UI design</strong>: Calculating valid movement areas.</li>
 <li><strong>Interactive maps</strong>: Real-time navigation or logistics planning.</li>
 <li><strong>Robot movement</strong>: Path planning in simulation or real environments.</li>
</ul><h3 id="summary">Summary</h3><p>A* Search is a flexible and efficient algorithm that finds <strong>optimal paths</strong> while reducing unnecessary exploration. It’s a go-to tool for pathfinding in <strong>frontend JavaScript</strong>, especially in interactive and visual contexts like games or layout systems. With a well-chosen heuristic and efficient implementation, A* delivers performance and precision in equal measure.</p><div class = "chapter-navi-section">
<a href="javascript-algorithms-graphs-traversals.htm" class="nav-button prev">←</a>
<a href='javascript-algorithms.htm#graph-shortest-paths' class="nav-button toc-link">Index</a>
<a href="javascript-algorithms-minimum-spanning-trees.htm" class="nav-button next">→</a>
</div>
<section class="download-section">
  <div class="book-cover" style="background-color: #f9f6f1;border: 1px solid #ccc;"> 
    <div class="book-cover-title" style="font-size: 18px;color: #333;top: 20px;">JavaScript Algorithms</div>
    <div class="book-cover-author">readbytes</div>
    <div class="book-cover-bottom-stripe" style="background-color: #333;"></div>
    <img class="book-cover-icon" style="width: 80px;height: 80px;top: 70px;" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFoAAABaCAYAAAA4qEECAAAErElEQVR4Xu2dPWgUQRiGo6BB8I+AlV3w9gzptLBWsLQ89O7ARrDXSivTCTaCnWhn7pQTxOoInpjCeEQQLC2CjVqoVSwMFpp1Jtzo7Luzs/Nd7uZ29r4HPpDsu7vPvIl7+SGTmRmGYRiGYZjCEzVacdnn9NX7+3DdXkGhMg+u3Su6SNztzsZvevH/efED8zrJbM+6EGJ2K5Hv9w9gRpHnXMyik2VsYVaHWJx7tt/bTOQ3urOYUch3QJ5z0YtOCeuQiqNlvybyto/ktbVDcG2jc5GLNgoriMW5Z/svPyfy693DmFHE71ePwrUznQta9ISeyViyKBIziri/Mpe8tt25kEXjMR1ScbQsPC5W5jCjMJT8DTM6MuO6vrHjIkIszj2LL3y2ktOPiy+Y0VE5l/V5IU+EVBwtm/wUzva4SL/wOZUsJ2993rCJEIujZJMl2174Up/C5T8u9LGtzyu6SNkH1+6VhUargkJlHVy7f5aW9qJUqeZy5zguufToBeAxZoRw0Z7goj3BRXuCi/YEF+0BvWQue0xgwfrMiy+aMM8QEUW+w2IHb8fC/+C5jCOGMhOPiqi+vG47zjiABVbr7XOYUWC2Um+fxwwDiKJeYXGYMYHniNnGDDPAUJZTyYph30nTg+G7f5VLj89gzBW8lu2xMzWIIt5iMZgZBrzmqK4bJFhENOLnatRsfcR7YKb0YAELF5+cwsyowHudrLcvYKZ0iIV+wIVjZhzgPaMR/+8pFIbFeilZUWm2Vyd5/5GxWOvsx4VkTbXROovn+wJdMqfevoHnFoKUaMbgeZMAnbIGzysEKGmZiX4DKKo/um5wMg6eWwhsgtVm62cRFoEOJg/xtltZxwqBTV4inuEHcZHztc4RzI0LvLeY15iRBF+0wrDgsX6qZXpUYEanNEVLROY3ZfHDgvdwuU+pipYs1h7OpUqI4z2YGxa8dqXefooZE6UrWoGFiMn8nRIXoubyTbymeLPzO7C0RUuiRvuXoRwyeI1hrlPqoiUnap1jWNLilU7mr0sgeK746rOFGRdKX7QCC4tyHiXi+DU8BzMUpqZoiSzXpTzMZOUoTFXROxh+xKV/gYPHqvVlp88q8pi+ogdgoabBc3bD1BYtEdfcxnLHeK/pLVoiHxvJktsPMDMKpr5oX3DRnuCiPcFFe4KL9gQX7Qku2hNctCe4aE94K1puD6mXNsmpOv74KUTnxEdmEQb9TOA5kx70M6KfcO/u8/j2nWffxb+XskZm9MHjw2YjgrTKygnFeUaF5cSEjZ4c9kJyz/Z7mxTpEJ0T0nhMhyRBy+5sTuXioAjR2UmaKEHJ/tsBLM9BJ0TnXGmiBCWb2GbN5oCE6GyVJkq4Z3FXxo3ubJaDiRCdM6VJErSscTtik0MWITobpYkS7lncKVfblREdbITonJImSVCyKAz7i1KkQ3ROSJMkaNnc7Ygp0iE6Z0pjTockjC8iBmEJRTpEZ6M0ZnRIwrhTrmU7Yop0iM4paTyusyvhnO2IKdIhOqdeWLLYlbDtL0oM/jaKi4MiRGcnaZIwPt8c/zZKnoNOiM4J6SIM+pnAcyY96GekYJtvf0I/EyE6MwzDMAzDjI+/5MPGam/zucIAAAAASUVORK5CYII="/>
  </div>
  <div class="download-info">
    <h2 id='bottom'>Download This Ebook</h2>
    <p class="format-label">Available formats:</p>
    <div class="download-buttons">
      <a href="javascript-algorithms.pdf" class="download-button">📄 PDF</a>
      <a href="javascript-algorithms.epub" class="download-button">📘 EPUB</a>
    </div>
  </div>
</section><div class='related-books'>
<h2>Javascript In-Depth Books</h2>
<div class='related-book-list'>
<a href="javascript-clean-code.htm">
<div class="book-cover" style="background-color: #f9f6f1;border: 1px solid #ccc;"> 
    <div class="book-cover-title" style="font-size: 18px;color: #333;top: 20px;">JavaScript Clean Code</div>
    <div class="book-cover-author">readbytes</div>
    <div class="book-cover-bottom-stripe" style="background-color: #333;"></div>
    <img class="book-cover-icon" style="width: 90px;height: 90px;top: 65px;" src='data:image/png;base64,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'/>
  </div>
</a>


<a href="javascript-coding-best-practices.htm">
<div class="book-cover" style="background-color: #f9f6f1;border: 1px solid #ccc;"> 
    <div class="book-cover-title" style="font-size: 16px;color: #333;top: 20px;">JavaScript Coding Best Practices</div>
    <div class="book-cover-author">readbytes</div>
    <div class="book-cover-bottom-stripe" style="background-color: #333;"></div>
    <img class="book-cover-icon" style="width: 80px;height: 80px;top: 80px;" src='data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFoAAABaCAYAAAA4qEECAAADdklEQVR4Xu2dPW/UMBjHH0QRlRA7MDDBgBAbH4ABNsRCQXwHFpAQQwVKws1IwMaXYO/M1I0VWEC8bIgy81LO53sS54l9OSe2G7f/n/S/c2zXefpT4g6nXIkAAADkQUFvqKR9JECUyw4lbXYmIqGyaYpWHXtNBwhCST8XbpcH2jyIQ+1XvRS0VQ+8opPzvrfLvDfayLpRDpmKbpMh+lw90N1jkCFhlNvFsXqxieb2Np2tx0A/EJ0IiE6Et2iOKVqOmQEa6aNXNLdxRfsB0YmA6ER4i+bYRMs5MoqK7nf6x6ai76KS6cG1Mr2iuW0TDdxAdCIgOhHeojku0XJejMQ41x063rvmGOQaa4jeXry7Rd+a/9yLqGFk/5g09T/vjKmUdK2eMwRv0dx2iQZ2IDoR3qI5q0Tv07HO/IPIlJA1BRGt/rDI+QeRKSFr6hXN7VWiQReIToS36JLOrxT9mk7QjK63YiLHQiQHBojWcYmW88wTyL5QyQFZa69obrtEAzsQnQiIToS3aI5LtJw3NGPX8//Zm/U5Y2DWpegVzW2XaGAHohMB0YnwFs2xiZZzYkSf50un35YpIWvqFc1tm+jHdDpqfM71iE615h80QUUDNxCdCG/RHJdoOW9IFPpzuu7YmHRrfFn3xUbWsIbob4t3t+hd0g/DDEtF75brbHTGxqap8ceyb6Pui423aG67RAM7EJ0Ib9ElfXSKruirV44SA0Tr2ETLOX05SsjfuVc0t22igRuITgREJ8JbNMcULcfMAI300Sua27ii/YDoREB0IrxFI+PSKxqEBaITAdGJaIlG4mfxUtA9qugGEiHKrSEaW0csstyjO7djBmQnWn9GqZ98bR5S2pXTJkeGopXYX/VxRXtZXNUt0TO6KMcnh9wu5PFUKehCI7qkv3J8krDcXCQrKvpjis6jaEVBVxfJhdpv+yo5I+eBgSiXrbuvOfgtpCPj0zgl/pJu9QA9CEvzpQTLL+uu6F9jHgSBfSq3LWa0Zbn0kTEp6G5b8lRQxYXYwviWBQ5Cygm51qGipJ2gcvTtuyO7Ae9roQi93qFBSXlKV2T3YJ7RZYi2EUNKjDWz5gldiiJFrTmbrw2WxNpPY62bLVrIZ9k9mpI+QbRJTBkx186OmDJirp0FJT2o99BUqeihLOPwo//hWVdGzBT0QZYBAAAA/AcQ1vXmtMbyGwAAAABJRU5ErkJggg=='/>
  </div>
</a>


<a href="javascript-asynchronous-programming.htm">
<div class="book-cover" style="background-color: #f9f6f1;border: 1px solid #ccc;"> 
    <div class="book-cover-title" style="font-size: 18px;color: #333;top: 20px;">JavaScript Asynchronous Programming</div>
    <div class="book-cover-author">readbytes</div>
    <div class="book-cover-bottom-stripe" style="background-color: #333;"></div>
    <img class="book-cover-icon" style="width: 80px;height: 80px;top: 80px;" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFoAAABaCAYAAAA4qEECAAADU0lEQVR4Xu2cvW7UQBRGkwKJV0CipqJbG9pIFLGXRyD2IgpeghegQ9DRUNHQUdLQUVFAC0h0tFEKkMJPCEykRHKObzZrr6/t8X5H+qrMN3PvUbQpEmVra8NI8vLfWWazh1f4ddEBVcmVPOA5sQZB6DND8mkWj3hetCQI/VAXXE3xhB3RkrrcWl6wI1qQZuUrQ+75ZOVr9kQL0mxxpya3nnfsiRbs7Ny/ashFiq/siZbU5Z7PLC9/sCNaQrlGfrIjWmLIxXd28Z0d0QKKvSCSvQ5pXr41pF6QxT77vRF+Or+vDzTdhJW36cAdDrEpoQdX+PgmhS482ebjmxTKcIMPb1roww0+vGmhDzf4MMPzY4fzL8tsd+8a+27w8Wp4Nga4w7Kw6wofr+Qzz8aAsYcZ9tzhAIMN0gFh7l/cwwp7vcAhBh1mDcLMf7iDFfZ6g4MMPlALwrzHnN/IMXu9YgwUlehktY+LI/Z6xxgqGtFhzgPObeQve4NgDBaF6Nl88YUzGxn246KKMVwUojlvPYtx/dqqPuD4RSeX/aXSvDxgZ3BqQ0YhunjOec+SzstvPD8KOGgMok/gvKf5xHOjwRg2CtEnVOdNs+Ipvz4qKDgm0VFBwRLtBAVLtBMULNFOULBEO0HBEu0EBUu0ExQs0U5QsEQ7QcES7QQFS7QTFCzRTlCwRDtBwRLtBAVLtBMULNFOULBEO0HBEu0EBUu0ExQs0U5QsEQ7QcES7QQFS7QTFCzRTlBw16LDXb897o0OCu5SSLjniPd2dXd0UEKXMnhn1/dHBQV0KYJ3Mjw/abh8lxJ4pxV2JgsX71oA77XCziTh0h7L824r7EwOLuy1OO+3ws6k4LKeSydZech3GHYmAxf1XniWl2/4FsPOJOCSfSyb5sVLvsewEz1csK9l+ZYVdqKGyzFpXj5O7hY3u0q6u5fxjWXhvNHCxcYYzhwlXGqM4cxRwqXGmPDxdci5o4SLjTGcOVq42JgSvqOH+8+4HtzO713nkmMI5xQrQpGXhX3RAMq8KOyJBtyalzco1Ap7ohkr/RtllkRDKNQKO6IhFGqFHdEQCrXCjmgIhVphRzSEQq2wIxpCoVbYES2gVIbnRUsoVpKdCEL3KViSnUjm5cepSf4Pt8Ix0I7hKy8AAAAASUVORK5CYII="/>
  </div>
</a>


<a href="javascript-pragmatic-developer.htm">
<div class="book-cover" style="background-color: #f9f6f1;border: 1px solid #ccc;"> 
    <div class="book-cover-title" style="font-size: 18px;color: #333;top: 20px;">JavaScript Pragmatic Developer</div>
    <div class="book-cover-author">readbytes</div>
    <div class="book-cover-bottom-stripe" style="background-color: #333;"></div>
    <img class="book-cover-icon" style="width: 80px;height: 70px;top: 85px;" src="data:image/png;base64,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"/>
  </div>
</a>


<a href="javascript-algorithms.htm">
<div class="book-cover" style="background-color: #f9f6f1;border: 1px solid #ccc;"> 
    <div class="book-cover-title" style="font-size: 18px;color: #333;top: 20px;">JavaScript Algorithms</div>
    <div class="book-cover-author">readbytes</div>
    <div class="book-cover-bottom-stripe" style="background-color: #333;"></div>
    <img class="book-cover-icon" style="width: 80px;height: 80px;top: 70px;" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFoAAABaCAYAAAA4qEECAAAErElEQVR4Xu2dPWgUQRiGo6BB8I+AlV3w9gzptLBWsLQ89O7ARrDXSivTCTaCnWhn7pQTxOoInpjCeEQQLC2CjVqoVSwMFpp1Jtzo7Luzs/Nd7uZ29r4HPpDsu7vPvIl7+SGTmRmGYRiGYZjCEzVacdnn9NX7+3DdXkGhMg+u3Su6SNztzsZvevH/efED8zrJbM+6EGJ2K5Hv9w9gRpHnXMyik2VsYVaHWJx7tt/bTOQ3urOYUch3QJ5z0YtOCeuQiqNlvybyto/ktbVDcG2jc5GLNgoriMW5Z/svPyfy693DmFHE71ePwrUznQta9ISeyViyKBIziri/Mpe8tt25kEXjMR1ScbQsPC5W5jCjMJT8DTM6MuO6vrHjIkIszj2LL3y2ktOPiy+Y0VE5l/V5IU+EVBwtm/wUzva4SL/wOZUsJ2993rCJEIujZJMl2174Up/C5T8u9LGtzyu6SNkH1+6VhUargkJlHVy7f5aW9qJUqeZy5zguufToBeAxZoRw0Z7goj3BRXuCi/YEF+0BvWQue0xgwfrMiy+aMM8QEUW+w2IHb8fC/+C5jCOGMhOPiqi+vG47zjiABVbr7XOYUWC2Um+fxwwDiKJeYXGYMYHniNnGDDPAUJZTyYph30nTg+G7f5VLj89gzBW8lu2xMzWIIt5iMZgZBrzmqK4bJFhENOLnatRsfcR7YKb0YAELF5+cwsyowHudrLcvYKZ0iIV+wIVjZhzgPaMR/+8pFIbFeilZUWm2Vyd5/5GxWOvsx4VkTbXROovn+wJdMqfevoHnFoKUaMbgeZMAnbIGzysEKGmZiX4DKKo/um5wMg6eWwhsgtVm62cRFoEOJg/xtltZxwqBTV4inuEHcZHztc4RzI0LvLeY15iRBF+0wrDgsX6qZXpUYEanNEVLROY3ZfHDgvdwuU+pipYs1h7OpUqI4z2YGxa8dqXefooZE6UrWoGFiMn8nRIXoubyTbymeLPzO7C0RUuiRvuXoRwyeI1hrlPqoiUnap1jWNLilU7mr0sgeK746rOFGRdKX7QCC4tyHiXi+DU8BzMUpqZoiSzXpTzMZOUoTFXROxh+xKV/gYPHqvVlp88q8pi+ogdgoabBc3bD1BYtEdfcxnLHeK/pLVoiHxvJktsPMDMKpr5oX3DRnuCiPcFFe4KL9gQX7Qku2hNctCe4aE94K1puD6mXNsmpOv74KUTnxEdmEQb9TOA5kx70M6KfcO/u8/j2nWffxb+XskZm9MHjw2YjgrTKygnFeUaF5cSEjZ4c9kJyz/Z7mxTpEJ0T0nhMhyRBy+5sTuXioAjR2UmaKEHJ/tsBLM9BJ0TnXGmiBCWb2GbN5oCE6GyVJkq4Z3FXxo3ubJaDiRCdM6VJErSscTtik0MWITobpYkS7lncKVfblREdbITonJImSVCyKAz7i1KkQ3ROSJMkaNnc7Ygp0iE6Z0pjTockjC8iBmEJRTpEZ6M0ZnRIwrhTrmU7Yop0iM4paTyusyvhnO2IKdIhOqdeWLLYlbDtL0oM/jaKi4MiRGcnaZIwPt8c/zZKnoNOiM4J6SIM+pnAcyY96GekYJtvf0I/EyE6MwzDMAzDjI+/5MPGam/zucIAAAAASUVORK5CYII="/>
  </div>
</a>



<a href='javascript.htm'><div class='book-cover' style='background-color: #f9f6f1;color: #111111;border: 1px solid #ccc;display: flex;justify-content: center;align-items: center;text-align: center;'>More Javascript Books</div></a>
</div>
</div>
  </div>
  <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/prism.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
  
  <script>
    function copyCode(button) {
      const code = button.nextElementSibling.innerText;
      navigator.clipboard.writeText(code).then(() => {
        button.textContent = 'Copied!';
        setTimeout(() => { button.textContent = 'Copy'; }, 1500);
      });
    }
  </script>  
<div id="floatingLog" aria-live="polite" role="alert"></div>
<footer class="page-footer">
    <nav>
      <a href="https://readbytes.github.io">Home</a> | 
      Email:<script language="JavaScript" type="text/javascript">
var part1 = 'yinpeng';var part6 = '263';var part2 = Math.pow(2,6);var part3 = String.fromCharCode(part2);var part4 = 'hotmail dot com';var part5 = part1 + String.fromCharCode(part2) + part4;document.write(part1 + part6 + part3 + part4);
</script>
    </nav>
  <p>© 2025 — All rights reserved.</p>    
  </footer>

</body>
</html>