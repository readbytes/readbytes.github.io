<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>C++ STL Smart Pointers and Resource Management in STL</title>
<link rel='shortcut icon' href='https://readbytes.github.io/images/favicon.ico'>
<link href="https://fonts.googleapis.com/css2?family=Merriweather&display=swap" rel="stylesheet" />
<link href="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet" />
<script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/prism.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/codemirror.min.css" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/codemirror.min.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/theme/dracula.min.css"><style>
html {scroll-behavior: smooth;}  
body {font-family: 'Merriweather', serif;;margin: 0;padding: 2rem 1rem;font-size: 15px;line-height: 1.5;transition: background-color 0.3s, color 0.3s;}
.container {max-width: 750px;margin: 0 auto;padding: 1rem 2rem;}
.light-mode {background-color: #f8f7f5;color: #333;} 
.dark-mode {background-color: #121212;color: #e0e0e0;}
a { text-decoration: none;transition: color 0.2s;}
a:hover {text-decoration: underline;}
.light-mode a {color: #555;}
.dark-mode a {color: #aaa;}
</style><style>
.related-book-list {display: flex;flex-wrap: wrap;gap: 20px;}
.related-books {margin-top: 40px;}
.related-books h2 {font-size: 22px;margin-bottom: 20px;border-bottom: 2px solid #eee;padding-bottom: 8px;}
.light-mode .related-books h2 {color: #333;border-color: #eee;}
.dark-mode .related-books h2 {color: #ddd;border-color: #333;}
</style><style>
.book-cover {width: 130px;height: 180px;font-family: Arial, sans-serif;position: relative;overflow: hidden;box-shadow: 2px 2px 4px rgba(0,0,0,0.1);}
.book-cover-bottom-stripe {position: absolute;bottom: 0;left: 0;height: 5px;width: 100%;}
.book-cover-title {position: absolute;width: 100%;text-align: center;font-weight: bold;}
.book-cover-icon {position: absolute;left: 50%;transform: translateX(-50%);display: flex;align-items: center;justify-content: center;}
.book-cover-author {position: absolute;bottom: 10px;width: 100%;text-align: center;font-size: 8px;color: #333;}
</style><style>
.book-title-toc {font-size: 32px;font-weight: bold; }
.book-subtitle-toc {font-size: 18px;margin-top: 8px;font-style: italic;}
.book-header {text-align: center;margin-bottom: 40px;}

.toc-container {border-radius: 10px;padding: 30px;margin-bottom: 40px;box-shadow: 0 8px 20px rgba(0,0,0,0.05);}
h1 {font-size: 24px;text-align: center;margin-bottom: 30px;letter-spacing: 1px;padding-bottom: 10px;}
.toc-list,.toc-section-list {list-style: none;padding: 0;margin: 0;}
.toc-section-list {padding-left: 18px;margin-top: 6px;margin-bottom: 20px; }
.toc-chapter {padding: 20px 0;}
.chapter-title,.toc-section {display: flex;justify-content: space-between;padding-top: 4px;}
.chapter-title {font-size: 17px;font-weight: bold;}
.chapter-page,.section-page {font-style: italic;}
 
 
.light-mode .book-title-toc,.light-mode .chapter-title,.light-mode .book-name {color: #222;}
.light-mode .book-subtitle-toc,.light-mode .book-sub,.light-mode .chapter-page,.light-mode .section-page {color: #666;}
.light-mode .toc-container { background: #fff;border: 1px solid #ddd;}
.light-mode h1 {border-bottom: 2px solid #eee;color: #222;}
.light-mode .toc-section {  color: #444;}

.light-mode .book-cover { border: 1px solid #ccc;box-shadow: 0 6px 12px rgba(0, 0, 0, 0.15);}
.light-mode .book-title,.light-mode .series-name {color: #fff;}
.light-mode .book-subtitle,.light-mode .book-footer {color: #aaa;}

.dark-mode .book-title-toc,.dark-mode .chapter-title,.dark-mode .book-name {color: #f5f5f5;}
.dark-mode .book-subtitle-toc,.dark-mode .book-sub,.dark-mode .chapter-page,.dark-mode .section-page {color: #aaa;}
.dark-mode .toc-container {background: #1e1e1e;border: 1px solid #444;}

.dark-mode h1 {border-bottom: 2px solid #333;color: #eee;}
.dark-mode .toc-section {color: #bbb;}

.dark-mode .related-books h2 {color: #ddd;border-bottom: 2px solid #333;}
.dark-mode .book-title,.dark-mode .series-name {color: #fff;}
.dark-mode .book-subtitle,.dark-mode .book-footer {color: #bbb;}
.dark-mode .toc-section {color: #ddd;}

@media (max-width: 600px) {
  .chapter-title,
  .toc-section {
    flex-direction: column;
    align-items: flex-start;
  }

  .chapter-page,
  .section-page {
    margin-top: 4px;
  }
}

</style><style>
.light-mode .container {box-shadow: 0 0 15px rgba(0,0,0,0.1);}
.dark-mode .container {box-shadow: 0 0 15px rgba(255, 255, 255, 0.05);}

h1, h2, h3 {font-weight: 600;margin-top: 2.5rem;margin-bottom: 1rem;line-height: 1.2;}
h1 { font-size: 1.8rem; }
h2 { font-size: 1.4rem; }
h3 { font-size: 1.2rem; }

table {width: 100%;border-collapse: collapse;font-family: sans-serif;font-size: 1em;margin: 1em 0;}
th, td {padding: 0.6em 1em;text-align: left;border: 1px solid;}
tr:nth-child(even) {  background-color: inherit;}
tr:hover { background-color: inherit;}

code {color: #d35400;}

.chapter-navi-section {display: flex;justify-content: space-between;align-items: center;padding-bottom: 10px;padding-top: 10px;}
.nav-link {color: inherit;text-decoration: none;opacity: 0.5;transition: opacity 0.3s ease, text-decoration 0.3s ease;}
.nav-link:hover {opacity: 0.9;text-decoration: underline;}
.prev { text-align: left; }
.toc-link { text-align: center; }
.next { text-align: right; }

.download-section {display: flex;align-items: center;justify-content: center;gap: 2rem;padding: 2rem 1rem;max-width: 600px;margin: 3rem auto;border-radius: 12px;box-shadow: 0 4px 10px rgba(0,0,0,0.05);}
.download-info h2 {margin: 0 0 0.5rem;font-size: 1.2rem;}
.format-label {margin: 0 0 0.5rem;font-size: 0.95rem;}
.download-buttons {display: flex;gap: 1rem;}
.download-button {background-color: #4A90E2;color: white;padding: 0.5em 1.2em;border-radius: 25px;font-size: 0.95rem;text-decoration: none;transition: background-color 0.3s ease;}
.download-button:hover {background-color: #357ABD;}

.code-block {position: relative;margin-bottom: 1em;}
.copy-button {background: transparent;color: white;position: absolute;top: 8px;right: 8px;border: none;padding: 4px 8px;font-size: 12px;border-radius: 4px;cursor: pointer;z-index: 1;}
.copy-button:hover {background-color: #0056b3;}

.snippet-container {overflow: hidden;}
.snippet-header {padding: 0.75rem 1rem;cursor: pointer;font-size: 1rem;background-color: #eeeeee;color:  #111111; border-radius: 8px;cursor: pointer;box-shadow: 0 4px 6px rgba(0,0,0,0.1); }
.snippet-body {display: none;font-family: monospace;}
.snippet-container.open .snippet-body {display: block;}

.CodeMirror {border: 2px solid #ccc;border-radius: 4px;resize: vertical;}

.light-mode .format-label {color: #888;}
.light-mode th {background-color: #f2f2f2;}
.light-mode tr:nth-child(even) {background-color: #fafafa;}
.light-mode tr:hover {background-color: #e6f7ff;}

.dark-mode .snippet-header {background-color: #333;color:  #ddd; }
.dark-mode .format-label {color: #aaa;}
.dark-mode th {background-color: #333;color: #fff;}
.dark-mode td {border-color: #444;}
.dark-mode tr:nth-child(even) {background-color: #2a2a2a;}
.dark-mode tr:hover {background-color: #2c3e50;}


.button-group-run-edit {display: flex;width: 100%;gap: 1rem;}
.button-run-edit {flex: 1;padding: 1rem;font-size: 1rem;font-weight: 600;border: none;border-radius: 8px;cursor: pointer;transition: background 0.3s, color 0.3s;}

.light-mode .button-run-edit {background-color: #f0f0f0;color: #222;box-shadow: 0 0 10px rgba(0, 0, 0, 0.05);}
.light-mode .button-run-edit:hover {background-color: #e0e0e0;}

.dark-mode .button-run-edit {background-color: #2a2a2a;color: #f5f5f5;box-shadow: 0 0 10px rgba(255, 255, 255, 0.05);}
.dark-mode .button-run-edit:hover {background-color: #3a3a3a;}

button { padding: 0.5em 1em; background: green; color: white; border: none; cursor: pointer; }
button:hover { background: #1e7e34; }
.result_iframe { width:99%; margin-top: 1em;  resize: both;background-color: #515b63;border:1px solid #ccc;}   

.dialog-backdrop {position: fixed;top: 0;left: 0;width: 100vw;height: 100vh;background: rgba(0,0,0,0.5);display: none;justify-content: center;align-items: center;z-index: 10;}
.dialog {background: #90979e;padding: 20px;width: 90vw;height: 80vh;border-radius: 8px;box-shadow: 0 0 20px rgba(0,0,0,0.3);display: flex;flex-direction: column;}
.dialog-content {display: flex;gap: 20px;margin-top: 10px;height: calc(100% - 40px);}
.editor-container, .preview-container {flex: 1;height: 100%;max-height: 100%;overflow: hidden; }
.result_iframe_dialog {width: 100%;height: 100%;resize: both;border:1px solid #ccc;overflow: auto; }   
.CodeMirror {width: 100% !important;height: 100% !important;}
</style>
</head>
<body>
<script>const mode = localStorage.getItem('mode') || 'light';document.documentElement.classList.add(`${mode}-mode`);</script>  
<div class="container"><div class = "chapter-navi-section">
<a href="cplusplus-stl-tuples-and-pairs.htm" class="nav-button prev">‚Üê</a>
<a href='cplusplus-stl.htm#smart-pointers-and-resource-management-in-stl' class="nav-button toc-link">Index</a>
<a href="cplusplus-stl-concurrency-utilities-in-stl.htm" class="nav-button next">‚Üí</a>
</div>
<div class='book-header'><h1 class='book-title-toc' id = 'top'>Smart Pointers and Resource Management in STL</h1><h3 class='book-subtitle-toc'>C++ STL</h3></div><h2 id='overview-of-std-unique-ptr-std-shared-ptr-and-std-weak-ptr'>12.1 Overview of <code>std::unique_ptr</code>, <code>std::shared_ptr</code>, and <code>std::weak_ptr</code></h2><p>Managing dynamic memory safely and efficiently is a fundamental challenge in C++. Traditional raw pointers require explicit calls to <code>delete</code> to free resources, which can easily lead to memory leaks, dangling pointers, or double deletions. To solve these problems, the C++ Standard Library provides <strong>smart pointers</strong> ‚Äî wrapper classes that automate resource management and help enforce ownership semantics.</p><h4 id="motivation-automatic-resource-management">Motivation: Automatic Resource Management</h4><p>Smart pointers encapsulate raw pointers and automatically release the associated memory when the smart pointer goes out of scope. This approach follows the RAII (Resource Acquisition Is Initialization) principle, reducing manual memory management errors and improving code safety and clarity.</p><h4 id="std-unique-ptr-exclusive-ownership"><code>std::unique_ptr</code>: Exclusive Ownership</h4><p><code>std::unique_ptr</code> represents <strong>exclusive ownership</strong> of a resource. Only one <code>unique_ptr</code> instance can own a particular resource at a time. It cannot be copied but can be moved, transferring ownership to another <code>unique_ptr</code>.</p><div class="code-block">
 <button class="copy-button" onclick="copyCode(this)">üìã</button>
 <pre><code class="language-cpp">#include &lt;memory&gt;
#include &lt;iostream&gt;

int main() {
    std::unique_ptr&lt;int&gt; ptr1 = std::make_unique&lt;int&gt;(42);
    std::cout &lt;&lt; *ptr1 &lt;&lt; '\n';

    // std::unique_ptr&lt;int&gt; ptr2 = ptr1; // Error: copy not allowed
    std::unique_ptr&lt;int&gt; ptr2 = std::move(ptr1);  // Transfer ownership

    if (!ptr1) std::cout &lt;&lt; "ptr1 is empty after move\n";
    std::cout &lt;&lt; *ptr2 &lt;&lt; '\n';
}</code></pre>
</div><p><code>unique_ptr</code> is lightweight and ideal when a single owner manages the lifetime of a resource.</p><h4 id="std-shared-ptr-shared-ownership-with-reference-counting"><code>std::shared_ptr</code>: Shared Ownership with Reference Counting</h4><p><code>std::shared_ptr</code> enables <strong>shared ownership</strong> of a resource. Multiple <code>shared_ptr</code>s can point to the same object, and the resource is destroyed only when the last <code>shared_ptr</code> owning it is destroyed or reset. This is implemented through <strong>reference counting</strong> internally.</p><div class="code-block">
 <button class="copy-button" onclick="copyCode(this)">üìã</button>
 <pre><code class="language-cpp">#include &lt;memory&gt;
#include &lt;iostream&gt;

int main() {
    std::shared_ptr&lt;int&gt; sp1 = std::make_shared&lt;int&gt;(100);
    std::shared_ptr&lt;int&gt; sp2 = sp1;  // Shared ownership

    std::cout &lt;&lt; "Count: " &lt;&lt; sp1.use_count() &lt;&lt; '\n';  // 2

    sp1.reset();  // Releases one owner
    std::cout &lt;&lt; "Count after reset: " &lt;&lt; sp2.use_count() &lt;&lt; '\n';  // 1
    std::cout &lt;&lt; *sp2 &lt;&lt; '\n';
}</code></pre>
</div><p>Because <code>shared_ptr</code> manages reference counting, it is slightly heavier than <code>unique_ptr</code> but allows multiple owners safely, including across threads. The reference counting is <strong>thread-safe</strong> in standard implementations.</p><h4 id="std-weak-ptr-non-owning-observer"><code>std::weak_ptr</code>: Non-owning Observer</h4><p><code>std::weak_ptr</code> is a <strong>non-owning</strong> smart pointer that observes an object managed by <code>shared_ptr</code> without affecting its lifetime or reference count. It is useful to break reference cycles or check if a resource is still alive without extending its lifetime.</p><div class="code-block">
 <button class="copy-button" onclick="copyCode(this)">üìã</button>
 <pre><code class="language-cpp">#include &lt;memory&gt;
#include &lt;iostream&gt;

int main() {
    std::shared_ptr&lt;int&gt; sp = std::make_shared&lt;int&gt;(77);
    std::weak_ptr&lt;int&gt; wp = sp;  // Observes but doesn't own

    if (auto locked = wp.lock()) {  // Attempts to get shared_ptr
        std::cout &lt;&lt; *locked &lt;&lt; '\n';
    }

    sp.reset();  // Resource destroyed here

    if (wp.expired()) {
        std::cout &lt;&lt; "Resource no longer exists\n";
    }
}</code></pre>
</div><p><code>weak_ptr</code> is essential in complex ownership graphs to avoid memory leaks caused by cyclic references.</p><h3 id="summary">Summary</h3><table>
 <thead>
  <tr>
   <th>Smart Pointer</th>
   <th>Ownership Type</th>
   <th>Copyable</th>
   <th>Thread-safe Reference Counting</th>
   <th>Use Case</th>
  </tr>
 </thead>
 <tbody>
  <tr>
   <td><code>std::unique_ptr</code></td>
   <td>Exclusive</td>
   <td>No</td>
   <td>N/A</td>
   <td>Single owner, lightweight resource management</td>
  </tr>
  <tr>
   <td><code>std::shared_ptr</code></td>
   <td>Shared</td>
   <td>Yes</td>
   <td>Yes</td>
   <td>Shared ownership, multiple owners, thread-safe</td>
  </tr>
  <tr>
   <td><code>std::weak_ptr</code></td>
   <td>Non-owning observer</td>
   <td>Yes</td>
   <td>Yes</td>
   <td>Observing shared resource without ownership, breaking cycles</td>
  </tr>
 </tbody>
</table><p>Smart pointers greatly simplify resource management in modern C++, making code safer and less error-prone while clearly expressing ownership semantics.</p><div class = "chapter-navi-section">
<a href="#top" class="nav-button prev">‚Üë</a>
<a href='cplusplus-stl.htm#smart-pointers-and-resource-management-in-stl' class="nav-button toc-link">Index</a>
<a href="#bottom" class="nav-button next">‚Üì</a>
</div>
<h2 id='automatic-resource-management-using-smart-pointers'>12.2 Automatic Resource Management Using Smart Pointers</h2><p>Managing dynamic memory manually in C++ is error-prone. Forgetting to delete allocated memory leads to <strong>memory leaks</strong>, while deleting memory prematurely or multiple times causes <strong>dangling pointers</strong> and undefined behavior. Smart pointers solve these issues by <strong>automating object lifetime management</strong> through RAII (Resource Acquisition Is Initialization), ensuring resources are properly released.</p><h4 id="raii-and-smart-pointers">RAII and Smart Pointers</h4><p>RAII is a C++ design idiom where resource acquisition (like dynamic memory allocation) is tied to the lifetime of an object. When the object goes out of scope, its destructor releases the resource automatically. Smart pointers apply RAII to dynamic memory by owning pointers to allocated objects and deleting them automatically when they go out of scope.</p><div class="code-block">
 <button class="copy-button" onclick="copyCode(this)">‚ñØ</button>
 <pre><code class="language-cpp">void foo() {
    std::unique_ptr&lt;int&gt; ptr = std::make_unique&lt;int&gt;(42);
    // No need to manually delete, memory freed automatically when ptr goes out of scope
}</code></pre>
</div><p>Here, <code>ptr</code> manages a dynamically allocated integer. Once <code>foo()</code> ends, <code>ptr</code> is destroyed and the memory freed, eliminating the risk of leaks.</p><h4 id="ownership-transfer-and-std-move">Ownership Transfer and <code>std::move</code></h4><p>Smart pointers like <code>std::unique_ptr</code> enforce exclusive ownership. To transfer ownership, you must use <code>std::move</code> to explicitly indicate the transfer:</p><div class="code-block">
 <button class="copy-button" onclick="copyCode(this)">‚ñØ</button>
 <pre><code class="language-cpp">void process(std::unique_ptr&lt;int&gt; p) {
    std::cout &lt;&lt; "Value: " &lt;&lt; *p &lt;&lt; '\n';
}

int main() {
    auto ptr = std::make_unique&lt;int&gt;(10);
    process(std::move(ptr));  // Ownership moves to process()

    if (!ptr) {
        std::cout &lt;&lt; "ptr is now empty after move\n";
    }
}</code></pre>
</div><p><code>std::move</code> converts <code>ptr</code> into an rvalue, allowing <code>process</code> to take ownership. Afterward, <code>ptr</code> no longer owns the memory and cannot be used to access it safely, preventing dangling pointers.</p><h4 id="smart-pointers-in-classes">Smart Pointers in Classes</h4><p>Smart pointers can be members of classes to manage dynamically allocated resources safely:</p><div class="code-block">
 <button class="copy-button" onclick="copyCode(this)">‚ñØ</button>
 <pre><code class="language-cpp">class Widget {
    std::unique_ptr&lt;int&gt; data;

public:
    Widget(int value) : data(std::make_unique&lt;int&gt;(value)) {}

    void print() const {
        std::cout &lt;&lt; "Value: " &lt;&lt; *data &lt;&lt; '\n';
    }
};

int main() {
    Widget w(123);
    w.print();
} // Automatically deletes the owned int when 'w' is destroyed</code></pre>
</div><p>No manual cleanup is needed in the destructor, and resource leaks are avoided even if exceptions occur.</p><h3 id="summary">Summary</h3><p>By encapsulating raw pointers, smart pointers automate memory management and ensure:</p><ul>
 <li>Resources are released when no longer needed.</li>
 <li>Memory leaks and dangling pointers are prevented.</li>
 <li>Ownership transfer is explicit and safe using <code>std::move</code>.</li>
 <li>RAII principles simplify resource handling, including in complex scopes or classes.</li>
</ul><p>This automatic resource management improves code safety, clarity, and maintainability in modern C++.</p><div class = "chapter-navi-section">
<a href="#top" class="nav-button prev">‚Üë</a>
<a href='cplusplus-stl.htm#smart-pointers-and-resource-management-in-stl' class="nav-button toc-link">Index</a>
<a href="#bottom" class="nav-button next">‚Üì</a>
</div>
<h2 id='custom-deleters-and-use-cases'>12.3 Custom Deleters and Use Cases</h2><p>Smart pointers in C++ not only manage dynamic memory but can also handle other resources like file handles, sockets, or custom objects that require special cleanup. This flexibility is made possible by <strong>custom deleters</strong>‚Äîuser-defined functions or function objects that specify how a resource should be released when the smart pointer is destroyed.</p><h4 id="what-are-custom-deleters">What Are Custom Deleters?</h4><p>By default, <code>std::unique_ptr</code> and <code>std::shared_ptr</code> call <code>delete</code> to free memory. However, some resources need different cleanup routines. A <strong>custom deleter</strong> tells the smart pointer what function to invoke to properly release the resource.</p><p>You can specify a custom deleter as a template parameter or as a constructor argument.</p><h4 id="using-custom-deleters-with-std-unique-ptr">Using Custom Deleters with <code>std::unique_ptr</code></h4><div class="code-block">
 <button class="copy-button" onclick="copyCode(this)">üìã</button>
 <pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;memory&gt;

// Custom deleter for FILE*
struct FileCloser {
    void operator()(FILE* file) const {
        if (file) {
            std::fclose(file);
            std::cout &lt;&lt; "File closed.\n";
        }
    }
};

int main() {
    // Open a file using fopen (C-style)
    std::unique_ptr&lt;FILE, FileCloser&gt; filePtr(std::fopen("example.txt", "w"));

    if (filePtr) {
        std::fprintf(filePtr.get(), "Hello, world!\n");
    } // filePtr destructor calls FileCloser::operator(), closing the file automatically
}</code></pre>
</div><p>Here, <code>FileCloser</code> is a functor acting as a custom deleter that closes the file using <code>fclose</code>. When <code>filePtr</code> goes out of scope, the file is automatically closed, preventing resource leaks.</p><h4 id="custom-deleters-with-std-shared-ptr">Custom Deleters with <code>std::shared_ptr</code></h4><p><code>std::shared_ptr</code> also supports custom deleters, which is especially useful for managing resources shared across multiple owners:</p><div class="code-block">
 <button class="copy-button" onclick="copyCode(this)">üìã</button>
 <pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;memory&gt;

void socket_close(int* socket) {
    if (socket) {
        std::cout &lt;&lt; "Closing socket " &lt;&lt; *socket &lt;&lt; std::endl;
        delete socket; // Simulate cleanup
    }
}

int main() {
    std::shared_ptr&lt;int&gt; socketPtr(new int(42), socket_close);

    // Multiple shared_ptr instances can share ownership safely
    std::shared_ptr&lt;int&gt; anotherPtr = socketPtr;

} // When last shared_ptr is destroyed, socket_close is called</code></pre>
</div><p>The custom deleter here simulates closing a socket. Once all <code>shared_ptr</code> instances owning the socket are destroyed, the deleter is invoked exactly once.</p><h3 id="practical-use-cases">Practical Use Cases</h3><ul>
 <li>Managing <strong>file handles</strong> opened with C APIs (<code>fopen</code>).</li>
 <li>Handling <strong>network sockets</strong> or OS-level resources.</li>
 <li>Cleaning up <strong>custom objects</strong> that require specific shutdown procedures.</li>
 <li>Replacing raw pointers in <strong>legacy code</strong> that uses special resource management.</li>
</ul><h3 id="summary">Summary</h3><p>Custom deleters extend the power of smart pointers beyond memory management, enabling <strong>safe, automatic cleanup of any resource</strong>. This ensures cleaner, safer code and reduces the risk of resource leaks in complex applications.</p><div class = "chapter-navi-section">
<a href="#top" class="nav-button prev">‚Üë</a>
<a href='cplusplus-stl.htm#smart-pointers-and-resource-management-in-stl' class="nav-button toc-link">Index</a>
<a href="#bottom" class="nav-button next">‚Üì</a>
</div>
<h2 id='examples-managing-dynamic-memory-safely'>12.4 Examples: Managing Dynamic Memory Safely</h2><p>Smart pointers are essential tools in modern C++ for managing dynamic memory safely and efficiently. They help avoid common pitfalls like memory leaks, dangling pointers, and manual <code>delete</code> mistakes. Below are comprehensive examples demonstrating how to use smart pointers with dynamic arrays, linked data structures, and polymorphic objects.</p><h4 id="example-1-managing-dynamic-arrays-with-std-unique-ptr">Example 1: Managing Dynamic Arrays with <code>std::unique_ptr</code></h4><p>Using <code>std::unique_ptr</code> with arrays ensures automatic cleanup without manual <code>delete[]</code> calls.</p><div class="code-block">
 <button class="copy-button" onclick="copyCode(this)">üìã</button>
 <pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;memory&gt;

int main() {
    // Allocate dynamic array of 5 integers
    std::unique_ptr&lt;int[]&gt; arr(new int[5]{1, 2, 3, 4, 5});

    // Access and modify elements using array syntax
    for (int i = 0; i &lt; 5; ++i) {
        arr[i] *= 2;
    }

    // Print elements
    for (int i = 0; i &lt; 5; ++i) {
        std::cout &lt;&lt; arr[i] &lt;&lt; ' ';
    }
    std::cout &lt;&lt; '\n'; // Output: 2 4 6 8 10

    // No need to manually delete[] arr; automatically freed
}</code></pre>
</div><p><strong>Key point:</strong> Use <code>std::unique_ptr&lt;T[]&gt;</code> for arrays, and avoid raw pointers entirely.</p><h4 id="example-2-building-a-simple-linked-list-with-std-shared-ptr">Example 2: Building a Simple Linked List with <code>std::shared_ptr</code></h4><p>Smart pointers make managing linked data structures safer by automating node lifetime.</p><div class="code-block">
 <button class="copy-button" onclick="copyCode(this)">üìã</button>
 <pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;memory&gt;

struct Node {
    int value;
    std::shared_ptr&lt;Node&gt; next;

    Node(int val) : value(val), next(nullptr) {}
};

int main() {
    auto head = std::make_shared&lt;Node&gt;(10);
    head-&gt;next = std::make_shared&lt;Node&gt;(20);
    head-&gt;next-&gt;next = std::make_shared&lt;Node&gt;(30);

    // Traverse list and print values
    for (auto current = head; current != nullptr; current = current-&gt;next) {
        std::cout &lt;&lt; current-&gt;value &lt;&lt; " -&gt; ";
    }
    std::cout &lt;&lt; "nullptr\n"; // Output: 10 -&gt; 20 -&gt; 30 -&gt; nullptr

    // No manual deletes; nodes freed when no longer referenced
}</code></pre>
</div><p><strong>Key point:</strong> Using <code>std::shared_ptr</code> allows multiple parts of your program to share ownership safely.</p><h4 id="example-3-polymorphic-objects-with-std-unique-ptr-and-virtual-destructors">Example 3: Polymorphic Objects with <code>std::unique_ptr</code> and Virtual Destructors</h4><p>Smart pointers handle polymorphic objects correctly when destructors are virtual.</p><div class="code-block">
 <button class="copy-button" onclick="copyCode(this)">üìã</button>
 <pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;memory&gt;

class Base {
public:
    virtual void speak() { std::cout &lt;&lt; "Base speaking\n"; }
    virtual ~Base() = default; // Virtual destructor
};

class Derived : public Base {
public:
    void speak() override { std::cout &lt;&lt; "Derived speaking\n"; }
};

int main() {
    std::unique_ptr&lt;Base&gt; ptr = std::make_unique&lt;Derived&gt;();

    ptr-&gt;speak(); // Output: Derived speaking

    // Automatic cleanup calls Derived destructor correctly
}</code></pre>
</div><p><strong>Key point:</strong> Always ensure base classes have virtual destructors when using smart pointers with inheritance.</p><h3 id="why-use-smart-pointers">Why Use Smart Pointers?</h3><ul>
 <li><strong>Automatic cleanup:</strong> No need for explicit <code>delete</code>, reducing leaks.</li>
 <li><strong>Exception safety:</strong> Resources released even if exceptions occur.</li>
 <li><strong>Clear ownership semantics:</strong> <code>unique_ptr</code> for exclusive ownership, <code>shared_ptr</code> for shared.</li>
 <li><strong>Simplified code:</strong> Easier to write and maintain than raw pointer management.</li>
</ul><h3 id="summary">Summary</h3><p>Smart pointers transform manual memory management into safe, automated operations. By adopting them in dynamic arrays, linked structures, and polymorphic hierarchies, C++ programmers create robust, maintainable, and efficient codebases without sacrificing control or performance.</p><div class = "chapter-navi-section">
<a href="cplusplus-stl-tuples-and-pairs.htm" class="nav-button prev">‚Üê</a>
<a href='cplusplus-stl.htm#smart-pointers-and-resource-management-in-stl' class="nav-button toc-link">Index</a>
<a href="cplusplus-stl-concurrency-utilities-in-stl.htm" class="nav-button next">‚Üí</a>
</div>
<section class="download-section">
  <div class="book-cover" style="background-color: #f9f6f1;border: 1px solid #ccc;"> 
    <div class="book-cover-title" style="font-size: 20px;color: #333;top: 20px;">C++ STL</div>
    <div class="book-cover-author">readbytes</div>
    <div class="book-cover-bottom-stripe" style="background-color: #333;"></div>
    <img class="book-cover-icon" style="width: 90px;height: 90px;top: 70px;" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFoAAABaCAYAAAA4qEECAAADK0lEQVR4Xu2cvWsTcRjHo+DkIKiTjiJugqTJ0cG/QcRZ/wJXQTd3ByeHDiLJnS84dHMVBHUSRQUH90pNfmfb6CKi8fqSaj93ae4lzzV3+X7gS9vkeZ7f7/lwEDq0jYYQQgghxFzQ9t0wbTzf3WO/SAllpg3niAlQYJa0uu4W54kxeA96ZykwU4JwnTPFGGLyMqd3nTNFAnFx2cOZIiee//UK5TLsEQWg3D1ZHpxgvShATLCeajsoWKKNaAfuDyVvZuGhu8paURBK1lNtBAVLtBEULNFGULBEG0HBlRfNRUrMqwW/f473GZFQvxXWVQbPD5e4zEGlcXt4eHQvvrdbU2W4zEGn5Yd3+NoovHul4DKzHN69UnCZWQ7vXim8IHzJhWY1vLtIQSRujSInhTNEBppL345R6LiwV+SAUpPCHpETimVYLwpAuRJtBOVKtBHNR4OTFCzRRlCwRBtBwRJtBAVLtBEULNFGeN3wPiVvp/+OtVmJ5qzvmdl1z1kzV8Ql53+q0/6az765gBLyConqN9i/X9hfeyiAYX0S7cCtsi9NOKf2UADDesL6LOGsWsPlx+V8d/Vo3t5x4bzyGA4P8TK1TuBeU0FpxC5T83D/0uBF6h7uXxq8SN3D/Utj80OHl6ltgvAX9y+V2IUm53eUQZQvUT4nvJ8x/e/R14+RiBeeHz4bZfPn6PW3bT908Z7s4d6Vgwsxix13mj15iGb94Ows4bxKwWUY1heF89OGcyoHFypjOZ4zKV7gVjijUjSfrJ/hUqOwdtrwvH2yzN7KkbDUTsKfrLWgufTmSPzsf2F9ZeFitVtwVqBgiTaCgiXaCAqWaCMoWKKNoGCJNoKCJdoICpZoIyhYoo2gYIk2goIl2ggKlmgjKFiijaBgiTaCgiXagLbfu0jBW+m6NdaKAsQEj9Jxl1krChATvBPWiQJ4fviJgiV6yiw+3ThOuRI9ZbzA3aRYSZ4iFx73T1FqUtg3l1DKbrr9960gvBt9f207/Rst332I1U0Iz5tbKGaa4VlzTSQk8X84Fw3PEY3p/70KTxA7UFTeeB13ibPFf1BY1nCeEEIIIYQowl8t5mhjJHw+fQAAAABJRU5ErkJggg=="/>
  </div>
  <div class="download-info">
    <h2 id='bottom'>Download This Ebook</h2>
    <p class="format-label">Available formats:</p>
    <div class="download-buttons">
      <a href="cplusplus-stl.pdf" class="download-button">üìÑ PDF</a>
      <a href="cplusplus-stl.epub" class="download-button">üìò EPUB</a>
    </div>
  </div>
</section><div class='related-books'>
<h2>C++ Introduction Books</h2>
<div class='related-book-list'>
<a href="cplusplus-for-beginners.htm">
<div class="book-cover" style="background-color: #f9f6f1;border: 1px solid #ccc;"> 
    <div class="book-cover-title" style="font-size: 18px;color: #333;top: 20px;">C++ for Beginners</div>
    <div class="book-cover-author">readbytes</div>
    <div class="book-cover-bottom-stripe" style="background-color: #333;"></div>
    <img class="book-cover-icon" style="width: 90px;height: 90px;top: 70px;" src="data:image/png;base64,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"/>
  </div>
</a>


<a href="cplusplus-syntax.htm">
<div class="book-cover" style="background-color: #f9f6f1;border: 1px solid #ccc;"> 
    <div class="book-cover-title" style="font-size: 20px;color: #333;top: 20px;">C++ Syntax</div>
    <div class="book-cover-author">readbytes</div>
    <div class="book-cover-bottom-stripe" style="background-color: #333;"></div>
    <img class="book-cover-icon" style="width: 90px;height: 90px;top: 70px;" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFoAAABaCAYAAAA4qEECAAAFZ0lEQVR4Xu2dy4scVRSH8ye0iYtkERcmzgjT2OYBuhNREMVXBh/TgsYQx5ULDYTgVl3EFyg6uFJBV76IEXdKXAVBJCgISSTRGRmZiZlADBo6M5kp+3ZbnXt/p7q6btWtc++pqQPfpu/p7vP7UnSqi+m6GzbkrMbYO50u0Tqjgx5Kqe4brSa8+XplFf0UroQ3GbDltqNRs70Y3Tw5G22//2SXU0Fyy5MXc6GyqYyYWwd9WdfGbW9uxRe9vvlBtOvZKLrpwTOiUDO7QjlALxu3zWxFf5mq++RF/YU27/40au39lwSQAspygXICwhfRY2rhv5Z6URxcEuoAQUkuQV/oM7HwSN45vUoGlwaKKQOrI1t9zuhPaD19mQwtEZRSFrq71M/sqh3JMSikTHSH6LdXeoN6Ag4rlV3Ta0RG2aTKjhfU/6Q4rGRQAgf62QhKHnzjk3wKlwRK4EI7qq99g4wf3NR8nwwqmfE9s0QAF8olOarjB1QDDisZDM+NIbqhXYXDQaWDwbnRPj46xtkGDiodDM6N7nYgWl2hwkEl09r7DwnOzZbbr131G4iemFokw0oGQ/ug2XVKRI9PzpJhJYOhfdB66m8qevsDp8iwksHQPqi8aAzsi1o0E7VoJioteuzh30lgX1RaNIb1SS2aiVo0E5UVPTH1Fwnrk8qKxqC+qUUzUYtmwovoL49dioYV9uZhx/4VEjRmWM2fp70uYRc9qrA/DxhSZ1RhvyuCEL1wfiU6PXulB/bnAUPqnJnv8+cSTtEv7HeFd9G4XpyzJGQaWLjuisqJxoCjeOVjc572y7THBayim4+cNUKdONkhPUXBgKO495AxUrTvVdrjAq+ij//k/i9UMeAo7jlojFSLzsLE4/ZfuyspuvXYb0Yo16IxXBZQ9DOv0x4XsIqeOjRvhPri20ukpwgYLgt3HTBGir75kfa4gFU01h373f5ZA4bLChauu4BNdPtF82hWhT1FuHVfh4TLCtbR47SnKKWKTqu5hWXSXwQMZsOBGZzOLOzPA7voNz66QPpcgMHy8Py7OG2/sC8P7KLjurK8RvqLgMFsmDmC05mF/XkoVbTOjinz1E4V9uSl6I+AsF6YoT1FYROtwLpzeo705AFD2YKF6y5gFf3oQfPM48h3w8+jD3+4ZIDrOnGYtz7vgyHTuBvOo7/+nva4gFW0zTdDLFyPGdN+BBQXhkyDfDN8jfa4gFW0zbWOH365bIDrMXqYE7/2wZBpoOhKXOuwEZ0VDGTLuhD98+kO6bEFA9lyXxWvRyuwcN0GdccFDGTLe1+Z87Rfoj0uEC0aw+QBC9dd4V10XMsraz2wPw0Mk4WVq33WcID/C/tdwS766uqwiP3C/jQwTBZGFfa7gl204rnDC5hvUNg7DAySlWH1yTHa6xIvol2AQUKnFs2ESNHjk3MkSOiIFI0hJFCLZqIWzYQ40c0nLpAQEhAnGgNIoRbNRC2aCVGid6b8CCh0RInG4SVRi2YiUXSIN68ae8juR0ChkSg6xNux4eDSSLwdW4g3GMTBpZF4g0EFBvUNDi4N3a0SHeRNYCfaS2RwaWii+1s/xQ+oRQzsCxxaIoOjGe8fHdKNunFoaWzSdh/SRQd363kcXBrax4a5eVm8EMJmCmn33pDA5t2f0aMZRStUM4bnBAeXhu4SPfdKb/C54Q0OLomRklWFsoUTDi8F3d11N759A/o1quF5UzIcXgq6sy7n0GtiwZN6L4RCygIDSAB9oc/UwiOba+NIDBEy+tmF1ZGMhZ/ZijK3Qh3f8wcJEyJOt0LVC19UR12harbPOdncFzfWDQGVTb8KlwT6KlyNertqHffbVSdVo96A3ar+A5kzbYSE7G+UAAAAAElFTkSuQmCC"/>
  </div>
</a>


<a href="cplusplus-stl.htm">
<div class="book-cover" style="background-color: #f9f6f1;border: 1px solid #ccc;"> 
    <div class="book-cover-title" style="font-size: 20px;color: #333;top: 20px;">C++ STL</div>
    <div class="book-cover-author">readbytes</div>
    <div class="book-cover-bottom-stripe" style="background-color: #333;"></div>
    <img class="book-cover-icon" style="width: 90px;height: 90px;top: 70px;" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFoAAABaCAYAAAA4qEECAAADK0lEQVR4Xu2cvWsTcRjHo+DkIKiTjiJugqTJ0cG/QcRZ/wJXQTd3ByeHDiLJnS84dHMVBHUSRQUH90pNfmfb6CKi8fqSaj93ae4lzzV3+X7gS9vkeZ7f7/lwEDq0jYYQQgghxFzQ9t0wbTzf3WO/SAllpg3niAlQYJa0uu4W54kxeA96ZykwU4JwnTPFGGLyMqd3nTNFAnFx2cOZIiee//UK5TLsEQWg3D1ZHpxgvShATLCeajsoWKKNaAfuDyVvZuGhu8paURBK1lNtBAVLtBEULNFGULBEG0HBlRfNRUrMqwW/f473GZFQvxXWVQbPD5e4zEGlcXt4eHQvvrdbU2W4zEGn5Yd3+NoovHul4DKzHN69UnCZWQ7vXim8IHzJhWY1vLtIQSRujSInhTNEBppL345R6LiwV+SAUpPCHpETimVYLwpAuRJtBOVKtBHNR4OTFCzRRlCwRBtBwRJtBAVLtBEULNFGeN3wPiVvp/+OtVmJ5qzvmdl1z1kzV8Ql53+q0/6az765gBLyConqN9i/X9hfeyiAYX0S7cCtsi9NOKf2UADDesL6LOGsWsPlx+V8d/Vo3t5x4bzyGA4P8TK1TuBeU0FpxC5T83D/0uBF6h7uXxq8SN3D/Utj80OHl6ltgvAX9y+V2IUm53eUQZQvUT4nvJ8x/e/R14+RiBeeHz4bZfPn6PW3bT908Z7s4d6Vgwsxix13mj15iGb94Ows4bxKwWUY1heF89OGcyoHFypjOZ4zKV7gVjijUjSfrJ/hUqOwdtrwvH2yzN7KkbDUTsKfrLWgufTmSPzsf2F9ZeFitVtwVqBgiTaCgiXaCAqWaCMoWKKNoGCJNoKCJdoICpZoIyhYoo2gYIk2goIl2ggKlmgjKFiijaBgiTaCgiXagLbfu0jBW+m6NdaKAsQEj9Jxl1krChATvBPWiQJ4fviJgiV6yiw+3ThOuRI9ZbzA3aRYSZ4iFx73T1FqUtg3l1DKbrr9960gvBt9f207/Rst332I1U0Iz5tbKGaa4VlzTSQk8X84Fw3PEY3p/70KTxA7UFTeeB13ibPFf1BY1nCeEEIIIYQowl8t5mhjJHw+fQAAAABJRU5ErkJggg=="/>
  </div>
</a>



<a href='cplusplus.htm'><div class='book-cover' style='background-color: #f9f6f1;color: #111111;border: 1px solid #ccc;display: flex;justify-content: center;align-items: center;text-align: center;'>More C++ Books</div></a>
</div>
</div><script>
function copyCode(button) {const code = button.nextElementSibling.innerText;navigator.clipboard.writeText(code).then(() => {button.textContent = 'Copied!';setTimeout(() => { button.textContent = 'Copy'; }, 1500);});}
</script></div>
<style>
.site-footer {margin-top: 60px;padding: 20px 0;border-top: 1px solid #eee;text-align: center;font-size: 14px;}
.site-footer a {text-decoration: none;}
.light-mode .site-footer {color: #777;border-color: #eee;}
.dark-mode .site-footer {color: #888;border-color: #333;}
.light-mode .site-footer a {color: #555;}
.dark-mode .site-footer a {color: #aaa;}
.site-footer a:hover {text-decoration: underline;}    
</style>
<footer class="site-footer">
<nav><a href="https://readbytes.github.io">Home</a> |Email:<script type="text/javascript">
var part1 = 'yinpeng';var part6 = '263';var part2 = Math.pow(2,6);var part3 = String.fromCharCode(part2);var part4 = 'hotmail dot com';var part5 = part1 + String.fromCharCode(part2) + part4;document.write(part1 + part6 + part3 + part4);
</script>
| <a id="mode-toggle" href="#">Toggle Dark Mode</a>
</nav><p>¬© 2025 ‚Äî All rights reserved.</p></footer>
<script>
const toggleButton = document.getElementById('mode-toggle');
const body = document.body;
const savedMode = localStorage.getItem('mode') || 'light';
body.classList.add(savedMode + '-mode');
toggleButton.addEventListener('click', () => {
      const isDark = body.classList.contains('dark-mode');
      body.classList.toggle('dark-mode', !isDark);
      body.classList.toggle('light-mode', isDark);
      localStorage.setItem('mode', isDark ? 'light' : 'dark');
});
function copyCode(button) {const code = button.nextElementSibling.innerText;navigator.clipboard.writeText(code).then(() => {button.textContent = 'Copied!';setTimeout(() => { button.textContent = 'Copy'; }, 1500);});}
</script>
</body>
</html>