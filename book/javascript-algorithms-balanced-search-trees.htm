<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>JavaScript Algorithms Balanced Search Trees</title>
<link rel='shortcut icon' href='https://java2s.com/style/favicon.ico'>
<link href="https://fonts.googleapis.com/css2?family=Merriweather&display=swap" rel="stylesheet" />
<link href="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet" />


  <script>
  const mode = localStorage.getItem('mode') || 'light';
  document.documentElement.classList.add(`${mode}-mode`);
  </script>   
<style> 
html {
  scroll-behavior: smooth;
}

body {
  font-family: 'Merriweather', serif;
  margin: 0;
  padding: 2rem 1rem;
  font-size: 15px;
  line-height: 1.5;
  transition: background-color 0.3s, color 0.3s;
}

.container {
  max-width: 700px;
  margin: 0 auto;
  padding: 1rem 2rem;
  box-shadow: 0 0 15px rgba(0,0,0,0.1);
}

h1, h2, h3 {
  font-weight: 600;
  margin-top: 2.5rem;
  margin-bottom: 1rem;
  line-height: 1.2;
}

h1 { font-size: 1.8rem; }
h2 { font-size: 1.4rem; }
h3 { font-size: 1.2rem; }

table {
  width: 100%;
  border-collapse: collapse;
  font-family: sans-serif;
  font-size: 1em;
  margin: 1em 0;
}

th, td {
  padding: 0.6em 1em;
  text-align: left;
  border: 1px solid;
}

tr:nth-child(even) {
  background-color: inherit;
}

tr:hover {
  background-color: inherit;
}

a {
  text-decoration: none;
  transition: color 0.2s;
}

a:hover {
  text-decoration: underline;
}

code {
  color: #d35400;
}

.book-title-chapter {
  font-family: 'Merriweather', serif;
  font-size: 2rem;
  font-weight: bold;
  text-align: center;
  margin-bottom: 2rem;
  border-bottom: 2px solid;
  padding-bottom: 0.5rem;
}

.book-subtitle-chapter {
  text-align: center;
  font-size: 1rem;
  margin-top: -1rem;
  margin-bottom: 2rem;
}

.related-books {
  margin-top: 40px;
}

.related-book-list {
  display: flex;
  flex-wrap: wrap;
  gap: 20px;
}

    .book-cover {
      width: 130px;
      height: 180px;
      font-family: Arial, sans-serif;
      position: relative;
      overflow: hidden;      
      line-height: normal;
      box-shadow: 2px 2px 4px rgba(0,0,0,0.1);
    }
    .book-cover-bottom-stripe {
      position: absolute;
      bottom: 0;
      left: 0;
      height: 5px;
      width: 100%;
    }
    .book-cover-title {
      position: absolute;
      width: 100%;
      text-align: center;
      font-weight: bold;
    }
     
    .book-cover-icon {
      position: absolute;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      align-items: center;
      justify-content: center; 
    }

    .book-cover-author {
      position: absolute;
      bottom: 10px;
      width: 100%;
      text-align: center;
      font-size: 8px;
      color: #333;
    }

.page-footer {
  margin-top: 4rem;
  padding: 1rem 0;
  text-align: center;
  font-size: 0.85rem;
  border-top: 1px solid;
}

.chapter-navi-section {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding-bottom: 10px;
}

.nav-link {
  color: inherit;
  text-decoration: none;
  opacity: 0.5;
  transition: opacity 0.3s ease, text-decoration 0.3s ease;
}

.nav-link:hover {
  opacity: 0.9;
  text-decoration: underline;
}

.prev { text-align: left; }
.toc-link { text-align: center; }
.next { text-align: right; }

.download-section {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 2rem;
  padding: 2rem 1rem;
  max-width: 600px;
  margin: 3rem auto;
  border-radius: 12px;
  box-shadow: 0 4px 10px rgba(0,0,0,0.05);
}

.download-info h2 {
  margin: 0 0 0.5rem;
  font-size: 1.2rem;
}

.format-label {
  margin: 0 0 0.5rem;
  font-size: 0.95rem;
}

.download-buttons {
  display: flex;
  gap: 1rem;
}

.download-button {
  background-color: #4A90E2;
  color: white;
  padding: 0.5em 1.2em;
  border-radius: 25px;
  font-size: 0.95rem;
  text-decoration: none;
  transition: background-color 0.3s ease;
}

.download-button:hover {
  background-color: #357ABD;
}

.code-block {
  position: relative;
  margin-bottom: 1em;
}

.copy-button {
  background: transparent;
  color: white;
  position: absolute;
  top: 8px;
  right: 8px;
  border: none;
  padding: 4px 8px;
  font-size: 12px;
  border-radius: 4px;
  cursor: pointer;
  z-index: 1;
}

.copy-button:hover {
  background-color: #0056b3;
}

.snippet-container {
  overflow: hidden;
}

.snippet-header {
  padding: 0.75rem 1rem;
  cursor: pointer;
  font-size: 1rem;
    background-color: #eeeeee;
    color:  #111111; 
    border-radius: 8px;
    cursor: pointer;
    box-shadow: 0 4px 6px rgba(0,0,0,0.1);  
}

.snippet-body {
  display: none;
  font-family: monospace;
}

.snippet-container.open .snippet-body {
  display: block;
}

.CodeMirror {
  border: 2px solid #ccc;
  border-radius: 4px;
  resize: vertical;
}

/* === Light Mode === */
html.light-mode {
  background-color: #f8f7f5;
  color: #333;
}

html.light-mode .container {
  background: white;
}

html.light-mode .book-title-chapter {
  color: #2c3e50;
  border-color: #ccc;
}
html.light-mode .book-subtitle-chapter{
  color: #888;
}

html.light-mode .page-footer,
html.light-mode .series-name,
html.light-mode .book-subtitle,
html.light-mode .format-label {
  color: #888;
}

html.light-mode .related-books h2 {
  color: #333;
  border-bottom: 2px solid #eee;
}

html.light-mode .book-title {
  color: #fff;
}

html.light-mode .book-cover {
  border: 1px solid #ccc;
}

html.light-mode th {
  background-color: #f2f2f2;
}

html.light-mode tr:nth-child(even) {
  background-color: #fafafa;
}

html.light-mode tr:hover {
  background-color: #e6f7ff;
}

html.light-mode a,
html.light-mode .page-footer a {
  color: #000;
}

/* === Dark Mode === */
html.dark-mode {
  background-color: #181818;
  color: #e0e0e0;
}

html.dark-mode .container {
  background: #222;
}

html.dark-mode .book-title-chapter {
  color: #ddd;
  border-color: #444;
}

html.dark-mode .snippet-header {
    background-color: #333;
    color:  #ddd; 
}


html.dark-mode .book-subtitle-chapter,
html.dark-mode .page-footer,
html.dark-mode .series-name,
html.dark-mode .book-subtitle,
html.dark-mode .book-footer,
html.dark-mode .format-label {
  color: #aaa;
}

html.dark-mode .related-books h2 {
  color: #ddd;
  border-bottom: 2px solid #333;
}

html.dark-mode .book-title {
  color: #fff;
}

html.dark-mode .book-cover {
  border: 1px solid #555;
}

html.dark-mode th {
  background-color: #333;
  color: #fff;
}

html.dark-mode td {
  border-color: #444;
}

html.dark-mode tr:nth-child(even) {
  background-color: #2a2a2a;
}

html.dark-mode tr:hover {
  background-color: #2c3e50;
}

html.dark-mode a,
html.dark-mode .page-footer a {
  color: #eee;
}

    .dialog-backdrop {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: rgba(0,0,0,0.5);
      display: none;
      justify-content: center;
      align-items: center;
      z-index: 10;
    }

    .dialog {
      background: white;
      padding: 20px;
      width: 90vw;
      height: 80vh;
      border-radius: 8px;
      box-shadow: 0 0 20px rgba(0,0,0,0.3);
      display: flex;
      flex-direction: column;
    }
    .dialog-content {
      display: flex;
      flex: 1;
      gap: 20px;
      margin-top: 10px;
    }
    .dialog h2 {
      margin-top: 0;
    }

    .textarea_dialog {
      width: 50%;
      height: 100%;
      resize: none;
      font-family: monospace;
      font-size: 14px;
      padding: 10px;
      box-sizing: border-box;
      border: 1px solid #ccc;
    }

    .iframe_dialog {
      width: 50%;
      height: 100%;
      border: 1px solid #ccc;
    }
    .controls_dialog {
      display: flex;
      justify-content: space-between;
      margin-top: 10px;
    }    
    button { padding: 0.5em 1em; background: green; color: white; border: none; cursor: pointer; }
    button:hover { background: #1e7e34; }
    .result_iframe { width:99%; height:200px; margin-top: 1em;  resize: both;border:1px solid #ccc;}        
</style>
</head>
<body> 
  <div class="container">
    <div class = "chapter-navi-section">
<a href="javascript-algorithms-heaps-and-priority-queues.htm" class="nav-button prev">←</a>
<a href='javascript-algorithms.htm#balanced-search-trees' class="nav-button toc-link">Index</a>
<a href="javascript-algorithms-graph-representations.htm" class="nav-button next">→</a>
</div>

    <h1 class="book-title-chapter" id = 'top'>Balanced Search Trees</h1>
    <h3 class="book-subtitle-chapter">JavaScript Algorithms</h3>   
    <!-- <h1 class ="chapter-title"></h1> -->
    <h2 id='red-black-trees-conceptual-overview'>12.1 Red-Black Trees (Conceptual Overview)</h2><p>A <strong>Red-Black Tree</strong> is a type of <strong>self-balancing binary search tree (BST)</strong> that ensures operations like insertion, deletion, and search happen in <strong>O(log n)</strong> time, even in the worst case. This performance guarantee is achieved by maintaining a set of <strong>coloring and structural rules</strong> that keep the tree's height roughly logarithmic in the number of nodes.</p><h3 id="what-makes-a-tree-red-black">What Makes a Tree "Red-Black"?</h3><p>Each node in a red-black tree has an additional attribute: a <strong>color</strong>, either <strong>red</strong> or <strong>black</strong>. The tree follows these <strong>five rules</strong>, known as the <strong>red-black properties</strong>, to stay balanced:</p><ol>
 <li><strong>Each node is either red or black.</strong></li>
 <li><strong>The root is always black.</strong></li>
 <li><strong>All leaves (null nodes) are considered black.</strong></li>
 <li><strong>Red nodes cannot have red children</strong> (no two red nodes can appear consecutively).</li>
 <li><strong>Every path from a node to its descendant null leaves must contain the same number of black nodes</strong> (called the <strong>black height</strong>).</li>
</ol><p>These rules restrict how unbalanced the tree can become, without enforcing perfect balance. The beauty of red-black trees is that they allow <em>some</em> imbalance to avoid constant restructuring while still guaranteeing efficient operations.</p><h3 id="rotations-and-recoloring">Rotations and Recoloring</h3><p>To maintain the red-black properties during <strong>insertions</strong> or <strong>deletions</strong>, the tree may perform:</p><ul>
 <li><strong>Rotations</strong> (left or right): These rearrange nodes locally while preserving BST order.</li>
 <li><strong>Recoloring</strong>: The colors of nodes are changed to fix any violations of the rules above.</li>
</ul><p>Let’s walk through a simplified case.</p><h4 id="insertion-example-high-level-view">Insertion Example (High-Level View)</h4><p>Suppose we insert a red node that causes <strong>two consecutive red nodes</strong> (a violation of property #4):</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-bash">B
   /
  R
 /
R  ← problem: two reds in a row</code></pre>
</div><p>To fix this:</p><ul>
 <li>If the <strong>uncle</strong> node is red, we can <strong>recolor</strong> (flip colors).</li>
 <li>If the uncle is black, we may need to <strong>rotate</strong> and recolor.</li>
</ul><p>After a left or right rotation and recoloring, the tree maintains its structure and returns to a balanced state.</p><div class="snippet-container" id="<!DOCTYPE html>
<html lang=&quot;en&quot;>
<head>
  <meta charset=&quot;UTF-8&quot;>
  <title>Red-Black Tree Visualization</title>
  <style>
    body {
      font-family: sans-serif;
      text-align: center;
      padding: 20px;
    }
    canvas {
      border: 1px solid #ccc;
      background: #f4f4f4;
    }
    input, button {
      padding: 6px 10px;
      margin: 5px;
      font-size: 16px;
    }
  </style>
</head>
<body>
  <h2>Red-Black Tree Visualizer</h2>
  <input type=&quot;number&quot; id=&quot;valueInput&quot; placeholder=&quot;Enter number&quot;>
  <button onclick=&quot;insertValue()&quot;>Insert</button>
  <canvas id=&quot;canvas&quot; width=&quot;600&quot; height=&quot;500&quot;></canvas>

  <script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');

    const RED = 'RED';
    const BLACK = 'BLACK';

    class Node {
      constructor(value, color = RED, parent = null) {
        this.value = value;
        this.color = color;
        this.parent = parent;
        this.left = null;
        this.right = null;
        this.x = 0;
        this.y = 0;
      }
    }

    let root = null;

    function insertValue() {
      const val = parseInt(document.getElementById('valueInput').value);
      if (isNaN(val)) return;
      root = insert(root, val);
      fixTree(root, val);
      layoutTree(root);
      drawTree();
      document.getElementById('valueInput').value = '';
    }

    function insert(node, value, parent = null) {
      if (!node) return new Node(value, RED, parent);
      if (value < node.value) {
        node.left = insert(node.left, value, node);
      } else if (value > node.value) {
        node.right = insert(node.right, value, node);
      }
      return node;
    }

    function fixTree(node, value) {
      let inserted = findNode(node, value);
      while (inserted !== root &amp;&amp; inserted.parent.color === RED) {
        let parent = inserted.parent;
        let grandparent = parent.parent;
        if (!grandparent) break;

        if (parent === grandparent.left) {
          let uncle = grandparent.right;
          if (uncle &amp;&amp; uncle.color === RED) {
            parent.color = BLACK;
            uncle.color = BLACK;
            grandparent.color = RED;
            inserted = grandparent;
          } else {
            if (inserted === parent.right) {
              inserted = parent;
              rotateLeft(inserted);
            }
            parent.color = BLACK;
            grandparent.color = RED;
            rotateRight(grandparent);
          }
        } else {
          let uncle = grandparent.left;
          if (uncle &amp;&amp; uncle.color === RED) {
            parent.color = BLACK;
            uncle.color = BLACK;
            grandparent.color = RED;
            inserted = grandparent;
          } else {
            if (inserted === parent.left) {
              inserted = parent;
              rotateRight(inserted);
            }
            parent.color = BLACK;
            grandparent.color = RED;
            rotateLeft(grandparent);
          }
        }
      }
      root.color = BLACK;
    }

    function rotateLeft(x) {
      const y = x.right;
      x.right = y.left;
      if (y.left) y.left.parent = x;
      y.parent = x.parent;
      if (!x.parent) root = y;
      else if (x === x.parent.left) x.parent.left = y;
      else x.parent.right = y;
      y.left = x;
      x.parent = y;
    }

    function rotateRight(x) {
      const y = x.left;
      x.left = y.right;
      if (y.right) y.right.parent = x;
      y.parent = x.parent;
      if (!x.parent) root = y;
      else if (x === x.parent.right) x.parent.right = y;
      else x.parent.left = y;
      y.right = x;
      x.parent = y;
    }

    function findNode(node, value) {
      if (!node || node.value === value) return node;
      return value < node.value ? findNode(node.left, value) : findNode(node.right, value);
    }

    function layoutTree(node, depth = 0, range = [50, canvas.width - 50]) {
      if (!node) return;
      const [start, end] = range;
      const mid = (start + end) / 2;
      node.x = mid;
      node.y = 50 + depth * 70;
      layoutTree(node.left, depth + 1, [start, mid - 20]);
      layoutTree(node.right, depth + 1, [mid + 20, end]);
    }

    function drawTree() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      drawEdges(root);
      drawNodes(root);
    }

    function drawEdges(node) {
      if (!node) return;
      if (node.left) {
        ctx.beginPath();
        ctx.moveTo(node.x, node.y);
        ctx.lineTo(node.left.x, node.left.y);
        ctx.stroke();
        drawEdges(node.left);
      }
      if (node.right) {
        ctx.beginPath();
        ctx.moveTo(node.x, node.y);
        ctx.lineTo(node.right.x, node.right.y);
        ctx.stroke();
        drawEdges(node.right);
      }
    }

    function drawNodes(node) {
      if (!node) return;
      ctx.beginPath();
      ctx.arc(node.x, node.y, 20, 0, 2 * Math.PI);
      ctx.fillStyle = node.color === RED ? '#e74c3c' : '#2c3e50';
      ctx.fill();
      ctx.stroke();

      ctx.fillStyle = '#fff';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.font = '16px Arial';
      ctx.fillText(node.value, node.x, node.y);

      drawNodes(node.left);
      drawNodes(node.right);
    }
  </script>
</body>
</html>ID"><textarea id="P4gde" style="display: none;">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
  &lt;meta charset="UTF-8"&gt;
  &lt;title&gt;Red-Black Tree Visualization&lt;/title&gt;
  &lt;style&gt;
    body {
      font-family: sans-serif;
      text-align: center;
      padding: 20px;
    }
    canvas {
      border: 1px solid #ccc;
      background: #f4f4f4;
    }
    input, button {
      padding: 6px 10px;
      margin: 5px;
      font-size: 16px;
    }
  &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;h2&gt;Red-Black Tree Visualizer&lt;/h2&gt;
  &lt;input type="number" id="valueInput" placeholder="Enter number"&gt;
  &lt;button onclick="insertValue()"&gt;Insert&lt;/button&gt;
  &lt;canvas id="canvas" width="600" height="500"&gt;&lt;/canvas&gt;

  &lt;script&gt;
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');

    const RED = 'RED';
    const BLACK = 'BLACK';

    class Node {
      constructor(value, color = RED, parent = null) {
        this.value = value;
        this.color = color;
        this.parent = parent;
        this.left = null;
        this.right = null;
        this.x = 0;
        this.y = 0;
      }
    }

    let root = null;

    function insertValue() {
      const val = parseInt(document.getElementById('valueInput').value);
      if (isNaN(val)) return;
      root = insert(root, val);
      fixTree(root, val);
      layoutTree(root);
      drawTree();
      document.getElementById('valueInput').value = '';
    }

    function insert(node, value, parent = null) {
      if (!node) return new Node(value, RED, parent);
      if (value &lt; node.value) {
        node.left = insert(node.left, value, node);
      } else if (value &gt; node.value) {
        node.right = insert(node.right, value, node);
      }
      return node;
    }

    function fixTree(node, value) {
      let inserted = findNode(node, value);
      while (inserted !== root &amp;&amp; inserted.parent.color === RED) {
        let parent = inserted.parent;
        let grandparent = parent.parent;
        if (!grandparent) break;

        if (parent === grandparent.left) {
          let uncle = grandparent.right;
          if (uncle &amp;&amp; uncle.color === RED) {
            parent.color = BLACK;
            uncle.color = BLACK;
            grandparent.color = RED;
            inserted = grandparent;
          } else {
            if (inserted === parent.right) {
              inserted = parent;
              rotateLeft(inserted);
            }
            parent.color = BLACK;
            grandparent.color = RED;
            rotateRight(grandparent);
          }
        } else {
          let uncle = grandparent.left;
          if (uncle &amp;&amp; uncle.color === RED) {
            parent.color = BLACK;
            uncle.color = BLACK;
            grandparent.color = RED;
            inserted = grandparent;
          } else {
            if (inserted === parent.left) {
              inserted = parent;
              rotateRight(inserted);
            }
            parent.color = BLACK;
            grandparent.color = RED;
            rotateLeft(grandparent);
          }
        }
      }
      root.color = BLACK;
    }

    function rotateLeft(x) {
      const y = x.right;
      x.right = y.left;
      if (y.left) y.left.parent = x;
      y.parent = x.parent;
      if (!x.parent) root = y;
      else if (x === x.parent.left) x.parent.left = y;
      else x.parent.right = y;
      y.left = x;
      x.parent = y;
    }

    function rotateRight(x) {
      const y = x.left;
      x.left = y.right;
      if (y.right) y.right.parent = x;
      y.parent = x.parent;
      if (!x.parent) root = y;
      else if (x === x.parent.right) x.parent.right = y;
      else x.parent.left = y;
      y.right = x;
      x.parent = y;
    }

    function findNode(node, value) {
      if (!node || node.value === value) return node;
      return value &lt; node.value ? findNode(node.left, value) : findNode(node.right, value);
    }

    function layoutTree(node, depth = 0, range = [50, canvas.width - 50]) {
      if (!node) return;
      const [start, end] = range;
      const mid = (start + end) / 2;
      node.x = mid;
      node.y = 50 + depth * 70;
      layoutTree(node.left, depth + 1, [start, mid - 20]);
      layoutTree(node.right, depth + 1, [mid + 20, end]);
    }

    function drawTree() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      drawEdges(root);
      drawNodes(root);
    }

    function drawEdges(node) {
      if (!node) return;
      if (node.left) {
        ctx.beginPath();
        ctx.moveTo(node.x, node.y);
        ctx.lineTo(node.left.x, node.left.y);
        ctx.stroke();
        drawEdges(node.left);
      }
      if (node.right) {
        ctx.beginPath();
        ctx.moveTo(node.x, node.y);
        ctx.lineTo(node.right.x, node.right.y);
        ctx.stroke();
        drawEdges(node.right);
      }
    }

    function drawNodes(node) {
      if (!node) return;
      ctx.beginPath();
      ctx.arc(node.x, node.y, 20, 0, 2 * Math.PI);
      ctx.fillStyle = node.color === RED ? '#e74c3c' : '#2c3e50';
      ctx.fill();
      ctx.stroke();

      ctx.fillStyle = '#fff';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.font = '16px Arial';
      ctx.fillText(node.value, node.x, node.y);

      drawNodes(node.left);
      drawNodes(node.right);
    }
  &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</textarea> <iframe id="XY4jW" class="result_iframe" style="border:none;"></iframe>
 <script>{
const textarea = document.getElementById("P4gde");
const iframe = document.getElementById("XY4jW");
const html = textarea.value;
const iframeHTML = `${html}`;
const doc = iframe.contentDocument || iframe.contentWindow.document;
doc.open();
doc.write(iframeHTML);
doc.close();
setTimeout(() => {
iframe.style.height = '0px';
const contentHeight = Math.max(
  doc.body.scrollHeight,
  doc.documentElement.scrollHeight
);
iframe.style.height = contentHeight + 'px';
}, 50);
}
		</script>
</div><h3 id="visual-representation">Visual Representation</h3><p>Here’s a visual sketch of how a left rotation works:</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-bash">Tree:
    A                   B
     \      →         / \
      B              A   C
       \
        C</code></pre>
</div><p>A rotation moves B up, A down to the left, and keeps C on the right, preserving BST order while helping rebalance.</p><h3 id="why-red-black-trees">Why Red-Black Trees?</h3><p>Red-black trees don’t aim for perfect balance but instead enforce rules that <strong>prevent worst-case degeneracy</strong>, such as descending into a linked list (as can happen with naive BSTs).</p><p>They guarantee:</p><ul>
 <li><strong>Height ≤ 2 × log(n)</strong> → keeps operations fast</li>
 <li><strong>Insert/Delete in O(log n)</strong> time consistently</li>
</ul><h3 id="real-world-usage">Real-World Usage</h3><p>Due to their efficient and predictable performance, red-black trees are commonly used in:</p><ul>
 <li><strong>JavaScript’s V8 engine</strong>: for <code>Map</code> and <code>Set</code> under the hood</li>
 <li><strong>Java’s <code>TreeMap</code> and <code>TreeSet</code></strong></li>
 <li><strong>C++ STL’s <code>std::map</code> and <code>std::set</code></strong></li>
 <li>Database indexing systems (where B-trees may not be ideal)</li>
</ul><p>They’re favored for their <strong>performance guarantees</strong> without excessive overhead.</p><h3 id="summary">Summary</h3><p>Red-black trees offer a smart compromise between performance and complexity. By enforcing simple coloring and structural rules, they ensure that binary search trees remain efficient under all conditions. While their internal mechanics can be intricate, their <strong>conceptual model</strong>—balanced through <strong>rotations and recoloring</strong>—makes them a practical foundation for many built-in and custom data structures in JavaScript and beyond.</p><div class = "chapter-navi-section">
<a href="#top" class="nav-button prev">↑</a>
<a href='javascript-algorithms.htm#balanced-search-trees' class="nav-button toc-link">Index</a>
<a href="#bottom" class="nav-button next">↓</a>
</div>
<h2 id='avl-trees-optional-in-javascript'>12.2 AVL Trees (Optional in JavaScript)</h2><p>AVL trees are one of the earliest types of <strong>self-balancing binary search trees</strong>, named after their inventors Adelson-Velsky and Landis. Like red-black trees, AVL trees maintain balance to ensure <strong>O(log n)</strong> time complexity for search, insertion, and deletion. However, AVL trees maintain a <strong>stricter balance</strong>, which leads to more frequent rebalancing operations.</p><h3 id="balance-factor-and-rebalancing">Balance Factor and Rebalancing</h3><p>The core concept of an AVL tree is the <strong>balance factor</strong> of a node, defined as:</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-text">balanceFactor = height(left subtree) - height(right subtree)</code></pre>
</div><p>Valid balance factors for all nodes are <code>-1</code>, <code>0</code>, or <code>1</code>. If a node’s balance factor becomes less than <code>-1</code> or greater than <code>1</code>, the tree becomes unbalanced and requires <strong>rotation</strong> to restore balance.</p><p>There are <strong>four cases</strong> of imbalance:</p><ol>
 <li><strong>Left-Left (LL)</strong> → Right rotation</li>
 <li><strong>Right-Right (RR)</strong> → Left rotation</li>
 <li><strong>Left-Right (LR)</strong> → Left-Right double rotation</li>
 <li><strong>Right-Left (RL)</strong> → Right-Left double rotation</li>
</ol><div class="snippet-container" id="<!DOCTYPE html>
<html lang=&quot;en&quot;>
<head>
  <meta charset=&quot;UTF-8&quot;>
  <title>AVL Tree Visualization</title>
  <style>
    body { font-family: sans-serif; text-align: center; }
    canvas { border: 1px solid #ccc; background: #f9f9f9; }
    input, button { font-size: 16px; margin: 5px; padding: 5px 10px; }
  </style>
</head>
<body>
  <h2>AVL Tree Visualizer</h2>
  <input type=&quot;number&quot; id=&quot;valueInput&quot; placeholder=&quot;Enter number&quot;>
  <button onclick=&quot;insertValue()&quot;>Insert</button>
  <canvas id=&quot;canvas&quot; width=&quot;600&quot; height=&quot;500&quot;></canvas>

  <script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');

    class AVLNode {
      constructor(value) {
        this.value = value;
        this.left = null;
        this.right = null;
        this.height = 1;
        this.x = 0;
        this.y = 0;
      }
    }

    let root = null;

    function height(node) {
      return node ? node.height : 0;
    }

    function updateHeight(node) {
      node.height = 1 + Math.max(height(node.left), height(node.right));
    }

    function getBalance(node) {
      return node ? height(node.left) - height(node.right) : 0;
    }

    function rotateRight(y) {
      const x = y.left;
      const T2 = x.right;
      x.right = y;
      y.left = T2;
      updateHeight(y);
      updateHeight(x);
      return x;
    }

    function rotateLeft(x) {
      const y = x.right;
      const T2 = y.left;
      y.left = x;
      x.right = T2;
      updateHeight(x);
      updateHeight(y);
      return y;
    }

    function insert(node, value) {
      if (!node) return new AVLNode(value);
      if (value < node.value) node.left = insert(node.left, value);
      else if (value > node.value) node.right = insert(node.right, value);
      else return node;

      updateHeight(node);
      const balance = getBalance(node);

      if (balance > 1 &amp;&amp; value < node.left.value) return rotateRight(node);
      if (balance < -1 &amp;&amp; value > node.right.value) return rotateLeft(node);
      if (balance > 1 &amp;&amp; value > node.left.value) {
        node.left = rotateLeft(node.left);
        return rotateRight(node);
      }
      if (balance < -1 &amp;&amp; value < node.right.value) {
        node.right = rotateRight(node.right);
        return rotateLeft(node);
      }

      return node;
    }

    function insertValue() {
      const val = parseInt(document.getElementById('valueInput').value);
      if (isNaN(val)) return;
      root = insert(root, val);
      layoutTree(root);
      drawTree();
      document.getElementById('valueInput').value = '';
    }

    function layoutTree(node, depth = 0, range = [50, canvas.width - 50]) {
      if (!node) return;
      const [start, end] = range;
      const mid = (start + end) / 2;
      node.x = mid;
      node.y = 50 + depth * 70;
      layoutTree(node.left, depth + 1, [start, mid - 20]);
      layoutTree(node.right, depth + 1, [mid + 20, end]);
    }

    function drawTree() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      drawEdges(root);
      drawNodes(root);
    }

    function drawEdges(node) {
      if (!node) return;
      if (node.left) {
        ctx.beginPath();
        ctx.moveTo(node.x, node.y);
        ctx.lineTo(node.left.x, node.left.y);
        ctx.stroke();
        drawEdges(node.left);
      }
      if (node.right) {
        ctx.beginPath();
        ctx.moveTo(node.x, node.y);
        ctx.lineTo(node.right.x, node.right.y);
        ctx.stroke();
        drawEdges(node.right);
      }
    }

    function drawNodes(node) {
      if (!node) return;
      ctx.beginPath();
      ctx.arc(node.x, node.y, 20, 0, 2 * Math.PI);
      ctx.fillStyle = '#2ecc71';
      ctx.fill();
      ctx.stroke();

      ctx.fillStyle = '#fff';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.font = '16px Arial';
      ctx.fillText(node.value, node.x, node.y);

      drawNodes(node.left);
      drawNodes(node.right);
    }
  </script>
</body>
</html>ID"><textarea id="6T1qC" style="display: none;">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
  &lt;meta charset="UTF-8"&gt;
  &lt;title&gt;AVL Tree Visualization&lt;/title&gt;
  &lt;style&gt;
    body { font-family: sans-serif; text-align: center; }
    canvas { border: 1px solid #ccc; background: #f9f9f9; }
    input, button { font-size: 16px; margin: 5px; padding: 5px 10px; }
  &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;h2&gt;AVL Tree Visualizer&lt;/h2&gt;
  &lt;input type="number" id="valueInput" placeholder="Enter number"&gt;
  &lt;button onclick="insertValue()"&gt;Insert&lt;/button&gt;
  &lt;canvas id="canvas" width="600" height="500"&gt;&lt;/canvas&gt;

  &lt;script&gt;
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');

    class AVLNode {
      constructor(value) {
        this.value = value;
        this.left = null;
        this.right = null;
        this.height = 1;
        this.x = 0;
        this.y = 0;
      }
    }

    let root = null;

    function height(node) {
      return node ? node.height : 0;
    }

    function updateHeight(node) {
      node.height = 1 + Math.max(height(node.left), height(node.right));
    }

    function getBalance(node) {
      return node ? height(node.left) - height(node.right) : 0;
    }

    function rotateRight(y) {
      const x = y.left;
      const T2 = x.right;
      x.right = y;
      y.left = T2;
      updateHeight(y);
      updateHeight(x);
      return x;
    }

    function rotateLeft(x) {
      const y = x.right;
      const T2 = y.left;
      y.left = x;
      x.right = T2;
      updateHeight(x);
      updateHeight(y);
      return y;
    }

    function insert(node, value) {
      if (!node) return new AVLNode(value);
      if (value &lt; node.value) node.left = insert(node.left, value);
      else if (value &gt; node.value) node.right = insert(node.right, value);
      else return node;

      updateHeight(node);
      const balance = getBalance(node);

      if (balance &gt; 1 &amp;&amp; value &lt; node.left.value) return rotateRight(node);
      if (balance &lt; -1 &amp;&amp; value &gt; node.right.value) return rotateLeft(node);
      if (balance &gt; 1 &amp;&amp; value &gt; node.left.value) {
        node.left = rotateLeft(node.left);
        return rotateRight(node);
      }
      if (balance &lt; -1 &amp;&amp; value &lt; node.right.value) {
        node.right = rotateRight(node.right);
        return rotateLeft(node);
      }

      return node;
    }

    function insertValue() {
      const val = parseInt(document.getElementById('valueInput').value);
      if (isNaN(val)) return;
      root = insert(root, val);
      layoutTree(root);
      drawTree();
      document.getElementById('valueInput').value = '';
    }

    function layoutTree(node, depth = 0, range = [50, canvas.width - 50]) {
      if (!node) return;
      const [start, end] = range;
      const mid = (start + end) / 2;
      node.x = mid;
      node.y = 50 + depth * 70;
      layoutTree(node.left, depth + 1, [start, mid - 20]);
      layoutTree(node.right, depth + 1, [mid + 20, end]);
    }

    function drawTree() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      drawEdges(root);
      drawNodes(root);
    }

    function drawEdges(node) {
      if (!node) return;
      if (node.left) {
        ctx.beginPath();
        ctx.moveTo(node.x, node.y);
        ctx.lineTo(node.left.x, node.left.y);
        ctx.stroke();
        drawEdges(node.left);
      }
      if (node.right) {
        ctx.beginPath();
        ctx.moveTo(node.x, node.y);
        ctx.lineTo(node.right.x, node.right.y);
        ctx.stroke();
        drawEdges(node.right);
      }
    }

    function drawNodes(node) {
      if (!node) return;
      ctx.beginPath();
      ctx.arc(node.x, node.y, 20, 0, 2 * Math.PI);
      ctx.fillStyle = '#2ecc71';
      ctx.fill();
      ctx.stroke();

      ctx.fillStyle = '#fff';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.font = '16px Arial';
      ctx.fillText(node.value, node.x, node.y);

      drawNodes(node.left);
      drawNodes(node.right);
    }
  &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</textarea> <iframe id="2uzEA" class="result_iframe" style="border:none;"></iframe>
 <script>{
const textarea = document.getElementById("6T1qC");
const iframe = document.getElementById("2uzEA");
const html = textarea.value;
const iframeHTML = `${html}`;
const doc = iframe.contentDocument || iframe.contentWindow.document;
doc.open();
doc.write(iframeHTML);
doc.close();
setTimeout(() => {
iframe.style.height = '0px';
const contentHeight = Math.max(
  doc.body.scrollHeight,
  doc.documentElement.scrollHeight
);
iframe.style.height = contentHeight + 'px';
}, 50);
}
		</script>
</div><h3 id="rotations-in-avl-trees">Rotations in AVL Trees</h3><p>Rotations are local tree restructuring operations that preserve the binary search property. Here's a simplified example of a <strong>right rotation</strong> for the LL case:</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-text">tree:

    C                  B
   /      →          / \
  B                A   C
 /
A</code></pre>
</div><p>After rotation, the subtree is rebalanced, and the height differences are corrected.</p><h3 id="avl-vs-red-black-trees">AVL vs. Red-Black Trees</h3><table>
 <thead>
  <tr>
   <th>Feature</th>
   <th>AVL Tree</th>
   <th>Red-Black Tree</th>
  </tr>
 </thead>
 <tbody>
  <tr>
   <td>Balance Strictness</td>
   <td>More strictly balanced</td>
   <td>Less strict (allows more imbalance)</td>
  </tr>
  <tr>
   <td>Rebalancing Cost</td>
   <td>More rotations</td>
   <td>Fewer rotations</td>
  </tr>
  <tr>
   <td>Lookup Performance</td>
   <td>Faster (shallower trees)</td>
   <td>Slightly slower</td>
  </tr>
  <tr>
   <td>Insertion/Deletion</td>
   <td>More costly (more rebalancing)</td>
   <td>Cheaper (fewer adjustments)</td>
  </tr>
 </tbody>
</table><p><strong>AVL trees</strong> are ideal when you have more <strong>read-heavy</strong> workloads (frequent lookups), while <strong>red-black trees</strong> perform better in <strong>write-heavy</strong> environments (frequent inserts/deletes).</p><h3 id="javascript-style-pseudocode-simplified">JavaScript-Style Pseudocode (Simplified)</h3><p>A simplified AVL insertion pseudocode might look like this:</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-js">function insert(node, value) {
  if (!node) return new AVLNode(value);

  if (value &lt; node.value) {
    node.left = insert(node.left, value);
  } else {
    node.right = insert(node.right, value);
  }

  updateHeight(node);
  const balance = getBalance(node);

  // Rotate if unbalanced
  if (balance &gt; 1 &amp;&amp; value &lt; node.left.value) {
    return rotateRight(node); // Left-Left
  }
  if (balance &lt; -1 &amp;&amp; value &gt; node.right.value) {
    return rotateLeft(node); // Right-Right
  }
  if (balance &gt; 1 &amp;&amp; value &gt; node.left.value) {
    node.left = rotateLeft(node.left);
    return rotateRight(node); // Left-Right
  }
  if (balance &lt; -1 &amp;&amp; value &lt; node.right.value) {
    node.right = rotateRight(node.right);
    return rotateLeft(node); // Right-Left
  }

  return node;
}</code></pre>
</div><p>This captures the essence of AVL insertion: insert recursively, update height, check balance, and rotate if needed.</p><h3 id="why-this-is-optional">Why This Is Optional</h3><p>In real-world JavaScript development, AVL trees are <strong>rarely implemented manually</strong>. Most JavaScript applications rely on native structures (<code>Map</code>, <code>Set</code>) or libraries that use red-black trees internally. AVL trees are more commonly studied for academic purposes or implemented in low-level systems (e.g., embedded, database internals).</p><p>That said, understanding AVL trees is a great way to <strong>deepen your grasp of tree balancing</strong> and rotations—useful if you’re working on performance-critical or memory-sensitive systems.</p><h3 id="summary">Summary</h3><p>AVL trees provide a stricter balancing approach than red-black trees by maintaining a tight control over subtree height differences. While more rotation-heavy, they offer slightly faster lookups in exchange. Due to their complexity and specialized use, AVL trees are considered an <strong>advanced and optional topic</strong> for most JavaScript developers, but they are foundational in understanding the broader world of balanced search trees.</p><div class = "chapter-navi-section">
<a href="#top" class="nav-button prev">↑</a>
<a href='javascript-algorithms.htm#balanced-search-trees' class="nav-button toc-link">Index</a>
<a href="#bottom" class="nav-button next">↓</a>
</div>
<h2 id='b-trees-and-their-real-world-relevance'>12.3 B-Trees and Their Real-World Relevance</h2><p><strong>B-trees</strong> are a class of self-balancing, multi-way search trees designed specifically for <strong>efficient storage and retrieval of large datasets</strong>, especially on <strong>disk-based systems</strong>. Unlike binary search trees (BSTs), where each node has at most two children, B-trees can have <strong>many children per node</strong>, dramatically reducing the tree's height and minimizing disk read/write operations. This makes them ideal for <strong>databases</strong>, <strong>file systems</strong>, and <strong>persistent key-value stores</strong>.</p><h3 id="what-makes-a-b-tree-different">What Makes a B-Tree Different?</h3><p>In a traditional BST, each node holds a single key and has at most two children. In contrast, a B-tree node:</p><ul>
 <li>Can hold <strong>multiple keys</strong> (not just one).</li>
 <li>Has <strong>multiple children</strong>, typically ranging from <em>m/2 to m</em>, where <em>m</em> is the maximum number of children.</li>
 <li>Keeps keys <strong>sorted</strong>, so binary search can be used within a node.</li>
 <li>Always stays <strong>balanced</strong> — all leaf nodes are at the same depth.</li>
</ul><h4 id="example-b-tree-of-order-4">Example: B-tree of Order 4</h4><ul>
 <li><p>Each node can have <strong>up to 3 keys</strong> and <strong>4 children</strong>.</p></li>
 <li><p>A node with keys <code>[10, 20, 30]</code> divides its children into ranges:</p>
  <div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
   <pre><code class="language-bash">[ &lt;10 ] — [10–20] — [20–30] — [ &gt;30 ]</code></pre>
  </div></li>
</ul><p>This organization allows the tree to store <strong>much more data per node</strong>, reducing the number of levels and therefore the number of disk accesses.</p><h3 id="why-b-trees-matter-for-storage">Why B-Trees Matter for Storage</h3><p>Disk and SSD operations are expensive compared to in-memory operations. B-trees optimize performance by:</p><ul>
 <li><strong>Minimizing tree height</strong>: Fewer levels mean fewer disk accesses.</li>
 <li><strong>Maximizing data per node</strong>: Entire blocks (pages) of data are loaded into memory at once.</li>
 <li><strong>Reducing traversal time</strong>: Because internal nodes can store many keys, a single node read can guide access to many elements.</li>
</ul><p>Databases like <strong>MySQL (InnoDB engine)</strong>, <strong>PostgreSQL</strong>, and even <strong>modern file systems</strong> (e.g., NTFS, HFS+) use <strong>B-trees or B+ trees</strong> internally.</p><h3 id="how-it-works-simplified">How It Works (Simplified)</h3><p>Inserting into a B-tree involves:</p><ol>
 <li>Finding the correct leaf node.</li>
 <li>Inserting the key into the node in sorted order.</li>
 <li>If the node becomes overfull (too many keys), it <strong>splits</strong>, and the middle key is promoted to the parent.</li>
</ol><p>This controlled promotion keeps the tree balanced without requiring complex rotations like in AVL or Red-Black trees.</p><h4 id="visual-example">Visual Example</h4><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-bash">Before insertion:
[20 | 40]

Children:
&lt;20   20–40   &gt;40

Inserting 25 → goes into 20–40 node

After split:
Parent becomes: [20 | 30 | 40]</code></pre>
</div><p>Each split pushes keys up, maintaining a balanced and shallow structure.</p><h3 id="b-trees-in-javascript">B-Trees in JavaScript?</h3><p>B-trees are <strong>not commonly used in in-memory JavaScript applications</strong> because:</p><ul>
 <li>JavaScript apps typically handle smaller datasets that fit comfortably in memory.</li>
 <li>Native structures like <code>Map</code> or <code>Set</code> (often backed by Red-Black trees) are optimized for general-purpose use.</li>
</ul><p>However, B-trees become relevant in:</p><ul>
 <li><strong>Browser databases</strong> like IndexedDB or LevelDB.</li>
 <li><strong>JavaScript-based databases</strong> (e.g., PouchDB, NeDB).</li>
 <li>Applications involving <strong>large local files</strong>, <strong>offline data syncing</strong>, or <strong>custom database engines</strong>.</li>
</ul><h3 id="summary">Summary</h3><p>B-trees are a foundational structure for building efficient, scalable storage systems. Their ability to store multiple keys per node and minimize tree height makes them perfect for <strong>disk-based or paged-memory environments</strong>, such as <strong>databases and file systems</strong>. While not often implemented manually in JavaScript, understanding B-trees reveals why certain database operations are fast and helps prepare you for backend or systems-level development where performance and scale matter most.</p><div class = "chapter-navi-section">
<a href="javascript-algorithms-heaps-and-priority-queues.htm" class="nav-button prev">←</a>
<a href='javascript-algorithms.htm#balanced-search-trees' class="nav-button toc-link">Index</a>
<a href="javascript-algorithms-graph-representations.htm" class="nav-button next">→</a>
</div>
<section class="download-section">
  <div class="book-cover" style="background-color: #f9f6f1;border: 1px solid #ccc;"> 
    <div class="book-cover-title" style="font-size: 18px;color: #333;top: 20px;">JavaScript Algorithms</div>
    <div class="book-cover-author">readbytes</div>
    <div class="book-cover-bottom-stripe" style="background-color: #333;"></div>
    <img class="book-cover-icon" style="width: 80px;height: 80px;top: 70px;" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFoAAABaCAYAAAA4qEECAAAErElEQVR4Xu2dPWgUQRiGo6BB8I+AlV3w9gzptLBWsLQ89O7ARrDXSivTCTaCnWhn7pQTxOoInpjCeEQQLC2CjVqoVSwMFpp1Jtzo7Luzs/Nd7uZ29r4HPpDsu7vPvIl7+SGTmRmGYRiGYZjCEzVacdnn9NX7+3DdXkGhMg+u3Su6SNztzsZvevH/efED8zrJbM+6EGJ2K5Hv9w9gRpHnXMyik2VsYVaHWJx7tt/bTOQ3urOYUch3QJ5z0YtOCeuQiqNlvybyto/ktbVDcG2jc5GLNgoriMW5Z/svPyfy693DmFHE71ePwrUznQta9ISeyViyKBIziri/Mpe8tt25kEXjMR1ScbQsPC5W5jCjMJT8DTM6MuO6vrHjIkIszj2LL3y2ktOPiy+Y0VE5l/V5IU+EVBwtm/wUzva4SL/wOZUsJ2993rCJEIujZJMl2174Up/C5T8u9LGtzyu6SNkH1+6VhUargkJlHVy7f5aW9qJUqeZy5zguufToBeAxZoRw0Z7goj3BRXuCi/YEF+0BvWQue0xgwfrMiy+aMM8QEUW+w2IHb8fC/+C5jCOGMhOPiqi+vG47zjiABVbr7XOYUWC2Um+fxwwDiKJeYXGYMYHniNnGDDPAUJZTyYph30nTg+G7f5VLj89gzBW8lu2xMzWIIt5iMZgZBrzmqK4bJFhENOLnatRsfcR7YKb0YAELF5+cwsyowHudrLcvYKZ0iIV+wIVjZhzgPaMR/+8pFIbFeilZUWm2Vyd5/5GxWOvsx4VkTbXROovn+wJdMqfevoHnFoKUaMbgeZMAnbIGzysEKGmZiX4DKKo/um5wMg6eWwhsgtVm62cRFoEOJg/xtltZxwqBTV4inuEHcZHztc4RzI0LvLeY15iRBF+0wrDgsX6qZXpUYEanNEVLROY3ZfHDgvdwuU+pipYs1h7OpUqI4z2YGxa8dqXefooZE6UrWoGFiMn8nRIXoubyTbymeLPzO7C0RUuiRvuXoRwyeI1hrlPqoiUnap1jWNLilU7mr0sgeK746rOFGRdKX7QCC4tyHiXi+DU8BzMUpqZoiSzXpTzMZOUoTFXROxh+xKV/gYPHqvVlp88q8pi+ogdgoabBc3bD1BYtEdfcxnLHeK/pLVoiHxvJktsPMDMKpr5oX3DRnuCiPcFFe4KL9gQX7Qku2hNctCe4aE94K1puD6mXNsmpOv74KUTnxEdmEQb9TOA5kx70M6KfcO/u8/j2nWffxb+XskZm9MHjw2YjgrTKygnFeUaF5cSEjZ4c9kJyz/Z7mxTpEJ0T0nhMhyRBy+5sTuXioAjR2UmaKEHJ/tsBLM9BJ0TnXGmiBCWb2GbN5oCE6GyVJkq4Z3FXxo3ubJaDiRCdM6VJErSscTtik0MWITobpYkS7lncKVfblREdbITonJImSVCyKAz7i1KkQ3ROSJMkaNnc7Ygp0iE6Z0pjTockjC8iBmEJRTpEZ6M0ZnRIwrhTrmU7Yop0iM4paTyusyvhnO2IKdIhOqdeWLLYlbDtL0oM/jaKi4MiRGcnaZIwPt8c/zZKnoNOiM4J6SIM+pnAcyY96GekYJtvf0I/EyE6MwzDMAzDjI+/5MPGam/zucIAAAAASUVORK5CYII="/>
  </div>
  <div class="download-info">
    <h2 id='bottom'>Download This Ebook</h2>
    <p class="format-label">Available formats:</p>
    <div class="download-buttons">
      <a href="javascript-algorithms.pdf" class="download-button">📄 PDF</a>
      <a href="javascript-algorithms.epub" class="download-button">📘 EPUB</a>
    </div>
  </div>
</section><div class='related-books'>
<h2>Java Introduction Books</h2>
<div class='related-book-list'>
<a href="javascript-algorithms.htm">
<div class="book-cover" style="background-color: #f9f6f1;border: 1px solid #ccc;"> 
    <div class="book-cover-title" style="font-size: 18px;color: #333;top: 20px;">JavaScript Algorithms</div>
    <div class="book-cover-author">readbytes</div>
    <div class="book-cover-bottom-stripe" style="background-color: #333;"></div>
    <img class="book-cover-icon" style="width: 80px;height: 80px;top: 70px;" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFoAAABaCAYAAAA4qEECAAAErElEQVR4Xu2dPWgUQRiGo6BB8I+AlV3w9gzptLBWsLQ89O7ARrDXSivTCTaCnWhn7pQTxOoInpjCeEQQLC2CjVqoVSwMFpp1Jtzo7Luzs/Nd7uZ29r4HPpDsu7vPvIl7+SGTmRmGYRiGYZjCEzVacdnn9NX7+3DdXkGhMg+u3Su6SNztzsZvevH/efED8zrJbM+6EGJ2K5Hv9w9gRpHnXMyik2VsYVaHWJx7tt/bTOQ3urOYUch3QJ5z0YtOCeuQiqNlvybyto/ktbVDcG2jc5GLNgoriMW5Z/svPyfy693DmFHE71ePwrUznQta9ISeyViyKBIziri/Mpe8tt25kEXjMR1ScbQsPC5W5jCjMJT8DTM6MuO6vrHjIkIszj2LL3y2ktOPiy+Y0VE5l/V5IU+EVBwtm/wUzva4SL/wOZUsJ2993rCJEIujZJMl2174Up/C5T8u9LGtzyu6SNkH1+6VhUargkJlHVy7f5aW9qJUqeZy5zguufToBeAxZoRw0Z7goj3BRXuCi/YEF+0BvWQue0xgwfrMiy+aMM8QEUW+w2IHb8fC/+C5jCOGMhOPiqi+vG47zjiABVbr7XOYUWC2Um+fxwwDiKJeYXGYMYHniNnGDDPAUJZTyYph30nTg+G7f5VLj89gzBW8lu2xMzWIIt5iMZgZBrzmqK4bJFhENOLnatRsfcR7YKb0YAELF5+cwsyowHudrLcvYKZ0iIV+wIVjZhzgPaMR/+8pFIbFeilZUWm2Vyd5/5GxWOvsx4VkTbXROovn+wJdMqfevoHnFoKUaMbgeZMAnbIGzysEKGmZiX4DKKo/um5wMg6eWwhsgtVm62cRFoEOJg/xtltZxwqBTV4inuEHcZHztc4RzI0LvLeY15iRBF+0wrDgsX6qZXpUYEanNEVLROY3ZfHDgvdwuU+pipYs1h7OpUqI4z2YGxa8dqXefooZE6UrWoGFiMn8nRIXoubyTbymeLPzO7C0RUuiRvuXoRwyeI1hrlPqoiUnap1jWNLilU7mr0sgeK746rOFGRdKX7QCC4tyHiXi+DU8BzMUpqZoiSzXpTzMZOUoTFXROxh+xKV/gYPHqvVlp88q8pi+ogdgoabBc3bD1BYtEdfcxnLHeK/pLVoiHxvJktsPMDMKpr5oX3DRnuCiPcFFe4KL9gQX7Qku2hNctCe4aE94K1puD6mXNsmpOv74KUTnxEdmEQb9TOA5kx70M6KfcO/u8/j2nWffxb+XskZm9MHjw2YjgrTKygnFeUaF5cSEjZ4c9kJyz/Z7mxTpEJ0T0nhMhyRBy+5sTuXioAjR2UmaKEHJ/tsBLM9BJ0TnXGmiBCWb2GbN5oCE6GyVJkq4Z3FXxo3ubJaDiRCdM6VJErSscTtik0MWITobpYkS7lncKVfblREdbITonJImSVCyKAz7i1KkQ3ROSJMkaNnc7Ygp0iE6Z0pjTockjC8iBmEJRTpEZ6M0ZnRIwrhTrmU7Yop0iM4paTyusyvhnO2IKdIhOqdeWLLYlbDtL0oM/jaKi4MiRGcnaZIwPt8c/zZKnoNOiM4J6SIM+pnAcyY96GekYJtvf0I/EyE6MwzDMAzDjI+/5MPGam/zucIAAAAASUVORK5CYII="/>
  </div>
</a>



<a href='java.htm'><div class='book-cover' style='background-color: #f9f6f1;color: #111111;border: 1px solid #ccc;display: flex;justify-content: center;align-items: center;text-align: center;'>More Java Books</div></a>
</div>
</div>
  </div>
  <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/prism.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
  
  <script>
    function copyCode(button) {
      const code = button.nextElementSibling.innerText;
      navigator.clipboard.writeText(code).then(() => {
        button.textContent = 'Copied!';
        setTimeout(() => { button.textContent = 'Copy'; }, 1500);
      });
    }
  </script>  
<div id="floatingLog" aria-live="polite" role="alert"></div>
<footer class="page-footer">
    <nav>
      <a href="https://readbytes.github.io">Home</a> | 
      Email:<script language="JavaScript" type="text/javascript">
var part1 = 'yinpeng';var part6 = '263';var part2 = Math.pow(2,6);var part3 = String.fromCharCode(part2);var part4 = 'hotmail dot com';var part5 = part1 + String.fromCharCode(part2) + part4;document.write(part1 + part6 + part3 + part4);
</script>
    </nav>
  <p>© 2025 — All rights reserved.</p>    
  </footer>

</body>
</html>