<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>JavaScript Algorithms Principles of Dynamic Programming Classic Problems</title>
<link rel='shortcut icon' href='https://java2s.com/style/favicon.ico'>
<link href="https://fonts.googleapis.com/css2?family=Merriweather&display=swap" rel="stylesheet" />
<link href="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet" />
<script type='text/javascript' async src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML'></script>

  <script>
  const mode = localStorage.getItem('mode') || 'light';
  document.documentElement.classList.add(`${mode}-mode`);
  </script>   
<style> 
html {
  scroll-behavior: smooth;
}

body {
  font-family: 'Merriweather', serif;
  margin: 0;
  padding: 2rem 1rem;
  font-size: 15px;
  line-height: 1.5;
  transition: background-color 0.3s, color 0.3s;
}

.container {
  max-width: 700px;
  margin: 0 auto;
  padding: 1rem 2rem;
  box-shadow: 0 0 15px rgba(0,0,0,0.1);
}

h1, h2, h3 {
  font-weight: 600;
  margin-top: 2.5rem;
  margin-bottom: 1rem;
  line-height: 1.2;
}

h1 { font-size: 1.8rem; }
h2 { font-size: 1.4rem; }
h3 { font-size: 1.2rem; }

table {
  width: 100%;
  border-collapse: collapse;
  font-family: sans-serif;
  font-size: 1em;
  margin: 1em 0;
}

th, td {
  padding: 0.6em 1em;
  text-align: left;
  border: 1px solid;
}

tr:nth-child(even) {
  background-color: inherit;
}

tr:hover {
  background-color: inherit;
}

a {
  text-decoration: none;
  transition: color 0.2s;
}

a:hover {
  text-decoration: underline;
}

code {
  color: #d35400;
}

.book-title-chapter {
  font-family: 'Merriweather', serif;
  font-size: 2rem;
  font-weight: bold;
  text-align: center;
  margin-bottom: 2rem;
  border-bottom: 2px solid;
  padding-bottom: 0.5rem;
}

.book-subtitle-chapter {
  text-align: center;
  font-size: 1rem;
  margin-top: -1rem;
  margin-bottom: 2rem;
}

.related-books {
  margin-top: 40px;
}

.related-book-list {
  display: flex;
  flex-wrap: wrap;
  gap: 20px;
}

    .book-cover {
      width: 130px;
      height: 180px;
      font-family: Arial, sans-serif;
      position: relative;
      overflow: hidden;      
      line-height: normal;
      box-shadow: 2px 2px 4px rgba(0,0,0,0.1);
    }
    .book-cover-bottom-stripe {
      position: absolute;
      bottom: 0;
      left: 0;
      height: 5px;
      width: 100%;
    }
    .book-cover-title {
      position: absolute;
      width: 100%;
      text-align: center;
      font-weight: bold;
    }
     
    .book-cover-icon {
      position: absolute;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      align-items: center;
      justify-content: center; 
    }

    .book-cover-author {
      position: absolute;
      bottom: 10px;
      width: 100%;
      text-align: center;
      font-size: 8px;
      color: #333;
    }

.page-footer {
  margin-top: 4rem;
  padding: 1rem 0;
  text-align: center;
  font-size: 0.85rem;
  border-top: 1px solid;
}

.chapter-navi-section {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding-bottom: 10px;
}

.nav-link {
  color: inherit;
  text-decoration: none;
  opacity: 0.5;
  transition: opacity 0.3s ease, text-decoration 0.3s ease;
}

.nav-link:hover {
  opacity: 0.9;
  text-decoration: underline;
}

.prev { text-align: left; }
.toc-link { text-align: center; }
.next { text-align: right; }

.download-section {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 2rem;
  padding: 2rem 1rem;
  max-width: 600px;
  margin: 3rem auto;
  border-radius: 12px;
  box-shadow: 0 4px 10px rgba(0,0,0,0.05);
}

.download-info h2 {
  margin: 0 0 0.5rem;
  font-size: 1.2rem;
}

.format-label {
  margin: 0 0 0.5rem;
  font-size: 0.95rem;
}

.download-buttons {
  display: flex;
  gap: 1rem;
}

.download-button {
  background-color: #4A90E2;
  color: white;
  padding: 0.5em 1.2em;
  border-radius: 25px;
  font-size: 0.95rem;
  text-decoration: none;
  transition: background-color 0.3s ease;
}

.download-button:hover {
  background-color: #357ABD;
}

.code-block {
  position: relative;
  margin-bottom: 1em;
}

.copy-button {
  background: transparent;
  color: white;
  position: absolute;
  top: 8px;
  right: 8px;
  border: none;
  padding: 4px 8px;
  font-size: 12px;
  border-radius: 4px;
  cursor: pointer;
  z-index: 1;
}

.copy-button:hover {
  background-color: #0056b3;
}

.snippet-container {
  overflow: hidden;
}

.snippet-header {
  padding: 0.75rem 1rem;
  cursor: pointer;
  font-size: 1rem;
    background-color: #eeeeee;
    color:  #111111; 
    border-radius: 8px;
    cursor: pointer;
    box-shadow: 0 4px 6px rgba(0,0,0,0.1);  
}

.snippet-body {
  display: none;
  font-family: monospace;
}

.snippet-container.open .snippet-body {
  display: block;
}

.CodeMirror {
  border: 2px solid #ccc;
  border-radius: 4px;
  resize: vertical;
}

/* === Light Mode === */
html.light-mode {
  background-color: #f8f7f5;
  color: #333;
}

html.light-mode .container {
  background: white;
}

html.light-mode .book-title-chapter {
  color: #2c3e50;
  border-color: #ccc;
}
html.light-mode .book-subtitle-chapter{
  color: #888;
}

html.light-mode .page-footer,
html.light-mode .series-name,
html.light-mode .book-subtitle,
html.light-mode .format-label {
  color: #888;
}

html.light-mode .related-books h2 {
  color: #333;
  border-bottom: 2px solid #eee;
}

html.light-mode .book-title {
  color: #fff;
}

html.light-mode .book-cover {
  border: 1px solid #ccc;
}

html.light-mode th {
  background-color: #f2f2f2;
}

html.light-mode tr:nth-child(even) {
  background-color: #fafafa;
}

html.light-mode tr:hover {
  background-color: #e6f7ff;
}

html.light-mode a,
html.light-mode .page-footer a {
  color: #000;
}

/* === Dark Mode === */
html.dark-mode {
  background-color: #181818;
  color: #e0e0e0;
}

html.dark-mode .container {
  background: #222;
}

html.dark-mode .book-title-chapter {
  color: #ddd;
  border-color: #444;
}

html.dark-mode .snippet-header {
    background-color: #333;
    color:  #ddd; 
}


html.dark-mode .book-subtitle-chapter,
html.dark-mode .page-footer,
html.dark-mode .series-name,
html.dark-mode .book-subtitle,
html.dark-mode .book-footer,
html.dark-mode .format-label {
  color: #aaa;
}

html.dark-mode .related-books h2 {
  color: #ddd;
  border-bottom: 2px solid #333;
}

html.dark-mode .book-title {
  color: #fff;
}

html.dark-mode .book-cover {
  border: 1px solid #555;
}

html.dark-mode th {
  background-color: #333;
  color: #fff;
}

html.dark-mode td {
  border-color: #444;
}

html.dark-mode tr:nth-child(even) {
  background-color: #2a2a2a;
}

html.dark-mode tr:hover {
  background-color: #2c3e50;
}

html.dark-mode a,
html.dark-mode .page-footer a {
  color: #eee;
}

    .dialog-backdrop {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: rgba(0,0,0,0.5);
      display: none;
      justify-content: center;
      align-items: center;
      z-index: 10;
    }

    .dialog {
      background: white;
      padding: 20px;
      width: 90vw;
      height: 80vh;
      border-radius: 8px;
      box-shadow: 0 0 20px rgba(0,0,0,0.3);
      display: flex;
      flex-direction: column;
    }
    .dialog-content {
      display: flex;
      flex: 1;
      gap: 20px;
      margin-top: 10px;
    }
    .dialog h2 {
      margin-top: 0;
    }

    .textarea_dialog {
      width: 50%;
      height: 100%;
      resize: none;
      font-family: monospace;
      font-size: 14px;
      padding: 10px;
      box-sizing: border-box;
      border: 1px solid #ccc;
    }

    .iframe_dialog {
      width: 50%;
      height: 100%;
      border: 1px solid #ccc;
    }
    .controls_dialog {
      display: flex;
      justify-content: space-between;
      margin-top: 10px;
    }    
    button { padding: 0.5em 1em; background: green; color: white; border: none; cursor: pointer; }
    button:hover { background: #1e7e34; }
    .result_iframe { width:99%; height:200px; margin-top: 1em;  resize: both;border:1px solid #ccc;}        
</style>
</head>
<body> 
  <div class="container">
    <div class = "chapter-navi-section">
<a href="javascript-algorithms-principles-of-dynamic-programming.htm" class="nav-button prev">←</a>
<a href='javascript-algorithms.htm#principles-of-dynamic-programming-classic-problems' class="nav-button toc-link">Index</a>
<a href="javascript-algorithms-greedy-algorithms.htm" class="nav-button next">→</a>
</div>

    <h1 class="book-title-chapter" id = 'top'>Principles of Dynamic Programming Classic Problems</h1>
    <h3 class="book-subtitle-chapter">JavaScript Algorithms</h3>   
    <!-- <h1 class ="chapter-title"></h1> -->
    <h2 id='fibonacci-variants'>18.1 Fibonacci Variants</h2><p>The Fibonacci sequence is a classic example often used to introduce dynamic programming (DP). Its basic form counts numbers defined by the sum of the two preceding ones. But beyond this simple definition, there are many interesting <strong>variants</strong> that share the same underlying principles of overlapping subproblems and optimal substructure, making them perfect DP candidates.</p><h3 id="classic-fibonacci-recap">Classic Fibonacci Recap</h3><p>The classic Fibonacci sequence is defined as:</p><p>$$ F(n) = F(n-1) + F(n-2), \quad F(0) = 0, \quad F(1) = 1 $$</p><p>A <strong>naive recursive</strong> implementation in JavaScript is straightforward but inefficient due to repeated calculations:</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-js">function fib(n) {
  if (n &lt;= 1) return n;
  return fib(n - 1) + fib(n - 2);
}</code></pre>
</div><p>This approach has exponential time complexity \( O(2^n) \).</p><h3 id="memoized-fibonacci">Memoized Fibonacci</h3><p>Applying <strong>memoization</strong> caches intermediate results to avoid redundant work:</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-js">function fibMemo(n, memo = {}) {
  if (n &lt;= 1) return n;
  if (memo[n]) return memo[n];

  memo[n] = fibMemo(n - 1, memo) + fibMemo(n - 2, memo);
  return memo[n];
}</code></pre>
</div><p>This reduces time complexity to linear \( O(n) \), since each subproblem is solved once.</p><h3 id="iterative-fibonacci-bottom-up">Iterative Fibonacci (Bottom-Up)</h3><p>The <strong>bottom-up</strong> approach iteratively builds the sequence:</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-js">function fibIter(n) {
  if (n &lt;= 1) return n;

  let prev = 0, curr = 1;
  for (let i = 2; i &lt;= n; i++) {
    [prev, curr] = [curr, prev + curr];
  }
  return curr;
}</code></pre>
</div><p>This approach also runs in \( O(n) \) but uses constant space \( O(1) \), making it efficient for large inputs.</p><h3 id="variant-counting-ways-to-climb-stairs">Variant: Counting Ways to Climb Stairs</h3><p>A popular Fibonacci variant is the problem of counting the number of ways to climb a staircase where you can take either <strong>1 or 2 steps at a time</strong>.</p><ul>
 <li><p>If the staircase has \( n \) steps, let \( W(n) \) be the number of ways to reach the top.</p></li>
 <li><p>Base cases:</p> <p>$$ W(0) = 1 \quad (\text{one way: do nothing}) $$</p> <p>$$ W(1) = 1 \quad (\text{one step}) $$</p></li>
 <li><p>Recurrence:</p> <p>$$ W(n) = W(n-1) + W(n-2) $$</p></li>
</ul><p>This mirrors Fibonacci logic but starts with different base cases.</p><h4 id="recursive-solution">Recursive solution:</h4><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-js">function climbStairs(n) {
  if (n &lt;= 1) return 1;
  return climbStairs(n - 1) + climbStairs(n - 2);
}</code></pre>
</div><h4 id="memoized">Memoized:</h4><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-js">function climbStairsMemo(n, memo = {}) {
  if (n &lt;= 1) return 1;
  if (memo[n]) return memo[n];

  memo[n] = climbStairsMemo(n - 1, memo) + climbStairsMemo(n - 2, memo);
  return memo[n];
}</code></pre>
</div><h4 id="iterative">Iterative:</h4><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-js">function climbStairsIter(n) {
  if (n &lt;= 1) return 1;

  let oneStepBefore = 1, twoStepsBefore = 1, allWays = 0;
  for (let i = 2; i &lt;= n; i++) {
    allWays = oneStepBefore + twoStepsBefore;
    twoStepsBefore = oneStepBefore;
    oneStepBefore = allWays;
  }
  return allWays;
}</code></pre>
</div><h3 id="underlying-dp-principles">Underlying DP Principles</h3><p>Each variant demonstrates key DP ideas:</p><ul>
 <li><strong>Overlapping subproblems:</strong> Many calls recompute the same values without caching.</li>
 <li><strong>Optimal substructure:</strong> The solution to a problem builds from solutions to smaller subproblems.</li>
 <li><strong>Memoization vs Tabulation:</strong> Memoization caches results top-down; tabulation builds from the bottom-up.</li>
 <li><strong>Performance improvements:</strong> Memoization and iteration change exponential recursive calls to linear-time solutions.</li>
</ul><h3 id="summary">Summary</h3><p>Fibonacci variants like the staircase problem highlight the power of dynamic programming in optimizing recursive problems with overlapping subproblems. Whether using naive recursion, memoization, or bottom-up iteration, understanding these implementations prepares you for tackling more complex DP challenges with confidence and efficiency in JavaScript.</p><div class = "chapter-navi-section">
<a href="#top" class="nav-button prev">↑</a>
<a href='javascript-algorithms.htm#principles-of-dynamic-programming-classic-problems' class="nav-button toc-link">Index</a>
<a href="#bottom" class="nav-button next">↓</a>
</div>
<h2 id='longest-common-subsequence-lcs'>18.2 Longest Common Subsequence (LCS)</h2><p>The <strong>Longest Common Subsequence (LCS)</strong> problem is a fundamental challenge in string comparison. Given two strings, the goal is to find the length of the longest subsequence common to both strings. A <strong>subsequence</strong> differs from a substring because its characters need not be contiguous, but they must appear in the same relative order.</p><h3 id="why-lcs-matters">Why LCS Matters</h3><p>LCS is widely used in:</p><ul>
 <li><strong>Diff tools:</strong> To highlight differences between text files by identifying common parts.</li>
 <li><strong>DNA sequence analysis:</strong> To compare genetic sequences and detect similarities.</li>
 <li><strong>Version control:</strong> To merge changes and detect conflicts.</li>
 <li><strong>Natural language processing:</strong> For text similarity and alignment.</li>
</ul><h3 id="recursive-formulation">Recursive Formulation</h3><p>Given two strings, <code>X</code> and <code>Y</code>, define:</p><ul>
 <li>\( LCS(i, j) \) = length of the LCS of prefixes \( X[0..i-1] \) and \( Y[0..j-1] \).</li>
</ul><p>The recursive relation is:</p><p>$$ LCS(i, j) = \begin{cases} 0 &amp; \text{if } i=0 \text{ or } j=0 \ 1 + LCS(i-1, j-1) &amp; \text{if } X[i-1] = Y[j-1] \ \max(LCS(i-1, j), LCS(i, j-1)) &amp; \text{if } X[i-1] \neq Y[j-1] \end{cases} $$</p><p>This means:</p><ul>
 <li>If either string is empty, LCS length is 0.</li>
 <li>If the current characters match, increment the LCS length by 1 and move diagonally.</li>
 <li>If they don't match, take the maximum LCS by either moving left or up in the table.</li>
</ul><h3 id="naive-recursive-implementation">Naive Recursive Implementation</h3><p>A straightforward recursive solution closely follows the formula but suffers from overlapping subproblems, leading to exponential time complexity:</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-js">function lcsRecursive(X, Y, i = X.length, j = Y.length) {
  if (i === 0 || j === 0) return 0;

  if (X[i - 1] === Y[j - 1]) {
    return 1 + lcsRecursive(X, Y, i - 1, j - 1);
  } else {
    return Math.max(
      lcsRecursive(X, Y, i - 1, j),
      lcsRecursive(X, Y, i, j - 1)
    );
  }
}</code></pre>
</div><h3 id="dynamic-programming-bottom-up-approach">Dynamic Programming: Bottom-Up Approach</h3><p>To optimize, use a <strong>2D table</strong> to store solutions for all prefix pairs, avoiding redundant calculations.</p><ul>
 <li><p>Create a table <code>dp</code> with dimensions <code>(m+1) x (n+1)</code> where <code>m = X.length</code> and <code>n = Y.length</code>.</p></li>
 <li><p>Initialize the first row and column with zeros (base cases).</p></li>
 <li><p>Fill the table row by row:</p>
  <ul>
   <li>If characters match, <code>dp[i][j] = 1 + dp[i-1][j-1]</code>.</li>
   <li>Otherwise, <code>dp[i][j] = max(dp[i-1][j], dp[i][j-1])</code>.</li>
  </ul></li>
</ul><p>At the end, <code>dp[m][n]</code> contains the length of the LCS.</p><h3 id="javascript-implementation-with-comments">JavaScript Implementation with Comments</h3><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-js">function lcs(X, Y) {
  const m = X.length;
  const n = Y.length;

  // Initialize DP table with zeros
  const dp = Array.from({ length: m + 1 }, () =&gt; Array(n + 1).fill(0));

  // Build the table from bottom up
  for (let i = 1; i &lt;= m; i++) {
    for (let j = 1; j &lt;= n; j++) {
      if (X[i - 1] === Y[j - 1]) {
        dp[i][j] = 1 + dp[i - 1][j - 1];
      } else {
        dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
      }
    }
  }

  // dp[m][n] is the length of LCS for X and Y
  return dp[m][n];
}</code></pre>
</div><h3 id="reconstructing-the-lcs-optional">Reconstructing the LCS (Optional)</h3><p>To find the actual subsequence, backtrack from <code>dp[m][n]</code>:</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-js">function getLCS(X, Y) {
  const m = X.length;
  const n = Y.length;
  const dp = Array.from({ length: m + 1 }, () =&gt; Array(n + 1).fill(0));

  // Fill dp table
  for (let i = 1; i &lt;= m; i++) {
    for (let j = 1; j &lt;= n; j++) {
      if (X[i - 1] === Y[j - 1]) {
        dp[i][j] = 1 + dp[i - 1][j - 1];
      } else {
        dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
      }
    }
  }

  // Backtrack to find the LCS string
  let i = m, j = n;
  let lcsStr = '';

  while (i &gt; 0 &amp;&amp; j &gt; 0) {
    if (X[i - 1] === Y[j - 1]) {
      lcsStr = X[i - 1] + lcsStr; // prepend matching char
      i--;
      j--;
    } else if (dp[i - 1][j] &gt; dp[i][j - 1]) {
      i--;
    } else {
      j--;
    }
  }

  return lcsStr;
}</code></pre>
</div><h3 id="practical-applications">Practical Applications</h3><ul>
 <li><strong>Diff Tools:</strong> Tools like Git’s <code>diff</code> use LCS algorithms to compare file versions, showing insertions, deletions, and modifications.</li>
 <li><strong>Bioinformatics:</strong> LCS is used to compare DNA, RNA, or protein sequences, aiding in gene identification and evolutionary analysis.</li>
 <li><strong>Text Processing:</strong> LCS helps detect plagiarism and find similar documents or sentences.</li>
 <li><strong>Version Control Systems:</strong> Understanding how code changes between commits relies on LCS-based algorithms.</li>
</ul><h3 id="summary">Summary</h3><p>The Longest Common Subsequence problem exemplifies dynamic programming’s power to optimize recursive solutions by using tabulation and memoization. Its applications span computer science, biology, and software engineering, making it a foundational algorithm to master. Implementing LCS in JavaScript through a 2D DP table not only improves efficiency but also provides a practical way to compare sequences effectively.</p><div class = "chapter-navi-section">
<a href="#top" class="nav-button prev">↑</a>
<a href='javascript-algorithms.htm#principles-of-dynamic-programming-classic-problems' class="nav-button toc-link">Index</a>
<a href="#bottom" class="nav-button next">↓</a>
</div>
<h2 id='knapsack-problem'>18.3 Knapsack Problem</h2><p>The <strong>0/1 Knapsack Problem</strong> is one of the most famous and fundamental problems in dynamic programming. It involves decision-making under constraints and showcases how DP can systematically explore subproblems to arrive at an optimal solution.</p><h3 id="problem-statement">Problem Statement</h3><p>Given:</p><ul>
 <li><p><code>n</code> items, each with:</p>
  <ul>
   <li>a <strong>weight</strong> <code>w[i]</code></li>
   <li>a <strong>value</strong> <code>v[i]</code></li>
  </ul></li>
 <li><p>A <strong>knapsack capacity</strong> <code>W</code></p></li>
</ul><p>Goal:</p><blockquote>
 <p>Choose a subset of items such that the <strong>total value is maximized</strong> without exceeding the weight limit <code>W</code>.</p>
</blockquote><p>Each item can either be <strong>included once or not at all</strong> — hence the name <strong>0/1 Knapsack</strong>.</p><h3 id="recursive-relation">Recursive Relation</h3><p>We define <code>dp[i][w]</code> as the maximum value that can be obtained using the first <code>i</code> items and capacity <code>w</code>.</p><p>The recurrence relation is:</p><p>$$ dp[i][w] = \begin{cases} dp[i-1][w] &amp; \text{if } w_i &gt; w \quad \text{(skip item)} \ \max(dp[i-1][w],\ v_i + dp[i-1][w - w_i]) &amp; \text{otherwise} \end{cases} $$</p><p>This means:</p><ul>
 <li><p>If the current item is too heavy, we can’t include it.</p></li>
 <li><p>Otherwise, we choose the better of:</p>
  <ul>
   <li>skipping the item</li>
   <li>including the item and adding its value</li>
  </ul></li>
</ul><h3 id="bottom-up-tabulation-javascript">Bottom-Up Tabulation (JavaScript)</h3><p>Let's write a bottom-up DP solution with a 2D table.</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-js">function knapsack(weights, values, capacity) {
  const n = weights.length;
  const dp = Array.from({ length: n + 1 }, () =&gt;
    Array(capacity + 1).fill(0)
  );

  for (let i = 1; i &lt;= n; i++) {
    for (let w = 0; w &lt;= capacity; w++) {
      if (weights[i - 1] &gt; w) {
        // Can't include item i-1
        dp[i][w] = dp[i - 1][w];
      } else {
        // Max of including or excluding the item
        dp[i][w] = Math.max(
          dp[i - 1][w],
          values[i - 1] + dp[i - 1][w - weights[i - 1]]
        );
      }
    }
  }

  return dp[n][capacity]; // Max value achievable
}</code></pre>
</div><h4 id="example">Example:</h4><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-js">const weights = [2, 1, 3];
const values = [4, 2, 5];
const capacity = 4;

console.log(knapsack(weights, values, capacity)); // Output: 7</code></pre>
</div><p>We can choose items 1 (weight 1, value 2) and 3 (weight 3, value 5) for a total value of 7.</p><h3 id="space-optimization">Space Optimization</h3><p>The DP table can be reduced to a 1D array, since each row only depends on the previous one. Iterate <strong>backwards</strong> over capacity to avoid overwriting results:</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-js">function knapsackOptimized(weights, values, capacity) {
  const dp = Array(capacity + 1).fill(0);
  const n = weights.length;

  for (let i = 0; i &lt; n; i++) {
    for (let w = capacity; w &gt;= weights[i]; w--) {
      dp[w] = Math.max(dp[w], values[i] + dp[w - weights[i]]);
    }
  }

  return dp[capacity];
}</code></pre>
</div><p>This reduces space complexity from \( O(nW) \) to \( O(W) \), which can be a major win in constrained environments.</p><h3 id="0-1-vs-fractional-knapsack">0/1 vs Fractional Knapsack</h3><p>The <strong>Fractional Knapsack Problem</strong> allows you to take partial items (e.g., 0.5 of an item). This variant can be solved greedily by selecting items based on their <strong>value-to-weight ratio</strong> and filling the knapsack accordingly.</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-js">function fractionalKnapsack(weights, values, capacity) {
  const items = values.map((v, i) =&gt; ({
    value: v,
    weight: weights[i],
    ratio: v / weights[i],
  }));

  // Sort by descending value/weight ratio
  items.sort((a, b) =&gt; b.ratio - a.ratio);

  let totalValue = 0;
  for (const item of items) {
    if (capacity &gt;= item.weight) {
      totalValue += item.value;
      capacity -= item.weight;
    } else {
      totalValue += item.ratio * capacity;
      break;
    }
  }

  return totalValue;
}</code></pre>
</div><p>Time complexity: \( O(n \log n) \) due to sorting.</p><blockquote>
 <p>Note: Fractional knapsack doesn't apply to 0/1 problems because taking parts of items isn’t allowed.</p>
</blockquote><h3 id="optimization-tips">Optimization Tips</h3><ul>
 <li>Use <strong>space-optimized 1D DP</strong> when only the final result is needed.</li>
 <li>If item values or weights are small integers, use <strong>value-based DP</strong>.</li>
 <li>Use <strong>bitmask DP</strong> or <strong>memoization with caching</strong> for very constrained variations (e.g., item limits or constraints).</li>
 <li>For large <code>n</code> or <code>W</code>, heuristic or approximate methods (like greedy) may be preferable.</li>
</ul><h3 id="real-world-applications">Real-World Applications</h3><ul>
 <li><strong>Budget allocation:</strong> Choose a subset of projects under a budget for maximum ROI.</li>
 <li><strong>Resource management:</strong> Decide which files to back up given storage limits.</li>
 <li><strong>Packing problems:</strong> E-commerce or shipping scenarios where space and value matter.</li>
 <li><strong>Cryptography &amp; security:</strong> Optimization under size and cost constraints.</li>
</ul><h3 id="summary">Summary</h3><p>The 0/1 Knapsack problem exemplifies dynamic programming’s strengths in solving optimization problems under constraints. Its recursive structure, combined with tabulation and space optimization, enables efficient solutions in JavaScript. Variants like fractional knapsack and real-world applications further emphasize its importance across domains such as logistics, resource planning, and finance. Understanding and implementing the knapsack problem equips developers with a vital tool for tackling complex optimization tasks.</p><div class = "chapter-navi-section">
<a href="#top" class="nav-button prev">↑</a>
<a href='javascript-algorithms.htm#principles-of-dynamic-programming-classic-problems' class="nav-button toc-link">Index</a>
<a href="#bottom" class="nav-button next">↓</a>
</div>
<h2 id='grid-based-pathfinding'>18.4 Grid-Based Pathfinding</h2><p>Grid-based pathfinding problems are a classic domain for applying dynamic programming (DP), particularly in 2D matrix scenarios. These problems simulate movement across a grid while optimizing for criteria like <strong>path count</strong>, <strong>minimum cost</strong>, or <strong>obstacle avoidance</strong>. They’re foundational for applications in <strong>robotics</strong>, <strong>game development</strong>, and <strong>logistics systems</strong>.</p><h3 id="problem-1-count-unique-paths">Problem 1: Count Unique Paths</h3><p><strong>Statement</strong>: Given an <code>m x n</code> grid, how many unique paths exist from the top-left corner to the bottom-right corner, moving only <strong>right</strong> or <strong>down</strong>?</p><h4 id="approach-bottom-up-dp">Approach: Bottom-Up DP</h4><p>We create a 2D DP table where <code>dp[i][j]</code> represents the number of ways to reach cell <code>(i, j)</code>.</p><ul>
 <li>Base case: <code>dp[0][j] = 1</code> and <code>dp[i][0] = 1</code> (only one way to reach cells in the first row or column).</li>
 <li>Transition: <code>dp[i][j] = dp[i - 1][j] + dp[i][j - 1]</code>.</li>
</ul><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-js">function countUniquePaths(m, n) {
  const dp = Array.from({ length: m }, () =&gt; Array(n).fill(1));

  for (let i = 1; i &lt; m; i++) {
    for (let j = 1; j &lt; n; j++) {
      dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
    }
  }

  return dp[m - 1][n - 1];
}</code></pre>
</div><h4 id="example">Example:</h4><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-js">countUniquePaths(3, 3); // Output: 6</code></pre>
</div><p>There are 6 distinct ways to reach the bottom-right corner in a 3×3 grid.</p><h3 id="problem-2-minimum-cost-path">Problem 2: Minimum Cost Path</h3><p><strong>Statement</strong>: Given a grid of costs, find the <strong>minimum cost</strong> to reach the bottom-right corner from the top-left, moving only right or down.</p><h4 id="approach-dp-table">Approach: DP Table</h4><p>Let <code>grid[i][j]</code> be the cost of cell <code>(i, j)</code>. We build a <code>dp[i][j]</code> table for minimum cumulative cost.</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-js">function minCostPath(grid) {
  const m = grid.length;
  const n = grid[0].length;
  const dp = Array.from({ length: m }, () =&gt; Array(n).fill(0));

  dp[0][0] = grid[0][0];

  // Initialize first row
  for (let j = 1; j &lt; n; j++) {
    dp[0][j] = dp[0][j - 1] + grid[0][j];
  }

  // Initialize first column
  for (let i = 1; i &lt; m; i++) {
    dp[i][0] = dp[i - 1][0] + grid[i][0];
  }

  // Fill rest of the table
  for (let i = 1; i &lt; m; i++) {
    for (let j = 1; j &lt; n; j++) {
      dp[i][j] = grid[i][j] + Math.min(dp[i - 1][j], dp[i][j - 1]);
    }
  }

  return dp[m - 1][n - 1];
}</code></pre>
</div><h4 id="example">Example:</h4><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-js">minCostPath([
  [1, 3, 1],
  [1, 5, 1],
  [4, 2, 1]
]); // Output: 7</code></pre>
</div><p>Path: 1 → 3 → 1 → 1 → 1 = total cost 7</p><h3 id="problem-3-paths-with-obstacles">Problem 3: Paths with Obstacles</h3><p><strong>Statement</strong>: Modify the unique paths problem: some grid cells contain obstacles (represented by <code>1</code>), and cannot be stepped on.</p><h4 id="approach">Approach:</h4><ul>
 <li>If a cell has an obstacle, <code>dp[i][j] = 0</code>.</li>
 <li>Otherwise, use the same logic as before.</li>
</ul><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-js">function uniquePathsWithObstacles(grid) {
  const m = grid.length;
  const n = grid[0].length;
  const dp = Array.from({ length: m }, () =&gt; Array(n).fill(0));

  // Starting point
  if (grid[0][0] === 0) dp[0][0] = 1;

  // First column
  for (let i = 1; i &lt; m; i++) {
    if (grid[i][0] === 0) dp[i][0] = dp[i - 1][0];
  }

  // First row
  for (let j = 1; j &lt; n; j++) {
    if (grid[0][j] === 0) dp[0][j] = dp[0][j - 1];
  }

  // Fill the rest
  for (let i = 1; i &lt; m; i++) {
    for (let j = 1; j &lt; n; j++) {
      if (grid[i][j] === 0) {
        dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
      }
    }
  }

  return dp[m - 1][n - 1];
}</code></pre>
</div><h3 id="real-world-use-cases">Real-World Use Cases</h3><ol>
 <li><p><strong>Robot Navigation</strong> A robot navigating a warehouse grid needs to avoid obstacles and find the shortest or safest route.</p></li>
 <li><p><strong>Game Development</strong> Grid-based maps in strategy or puzzle games often require players or AI to find optimal paths.</p></li>
 <li><p><strong>Route Planning in Logistics</strong> Delivery routes across a city grid with blocked roads or detours can be modeled as grid-based DP problems.</p></li>
</ol><h3 id="optimization-tips">Optimization Tips</h3><ul>
 <li>Use <strong>1D arrays</strong> to reduce space in problems like unique paths.</li>
 <li>For sparse grids or many obstacles, <strong>BFS or A</strong>* may be better than DP.</li>
 <li>When reconstructing paths, maintain a <strong>parent pointer grid</strong>.</li>
</ul><h3 id="summary">Summary</h3><p>Dynamic programming offers elegant and efficient solutions to a variety of grid-based pathfinding problems — from counting all possible routes to navigating around obstacles and minimizing costs. These techniques are not just theoretical; they power practical systems like automated robots, path planning tools, and interactive games. Mastering these grid-based DP patterns enables you to tackle many spatial and decision-based challenges effectively in JavaScript.</p><div class = "chapter-navi-section">
<a href="javascript-algorithms-principles-of-dynamic-programming.htm" class="nav-button prev">←</a>
<a href='javascript-algorithms.htm#principles-of-dynamic-programming-classic-problems' class="nav-button toc-link">Index</a>
<a href="javascript-algorithms-greedy-algorithms.htm" class="nav-button next">→</a>
</div>
<section class="download-section">
  <div class="book-cover" style="background-color: #f9f6f1;border: 1px solid #ccc;"> 
    <div class="book-cover-title" style="font-size: 18px;color: #333;top: 20px;">JavaScript Algorithms</div>
    <div class="book-cover-author">readbytes</div>
    <div class="book-cover-bottom-stripe" style="background-color: #333;"></div>
    <img class="book-cover-icon" style="width: 80px;height: 80px;top: 70px;" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFoAAABaCAYAAAA4qEECAAAErElEQVR4Xu2dPWgUQRiGo6BB8I+AlV3w9gzptLBWsLQ89O7ARrDXSivTCTaCnWhn7pQTxOoInpjCeEQQLC2CjVqoVSwMFpp1Jtzo7Luzs/Nd7uZ29r4HPpDsu7vPvIl7+SGTmRmGYRiGYZjCEzVacdnn9NX7+3DdXkGhMg+u3Su6SNztzsZvevH/efED8zrJbM+6EGJ2K5Hv9w9gRpHnXMyik2VsYVaHWJx7tt/bTOQ3urOYUch3QJ5z0YtOCeuQiqNlvybyto/ktbVDcG2jc5GLNgoriMW5Z/svPyfy693DmFHE71ePwrUznQta9ISeyViyKBIziri/Mpe8tt25kEXjMR1ScbQsPC5W5jCjMJT8DTM6MuO6vrHjIkIszj2LL3y2ktOPiy+Y0VE5l/V5IU+EVBwtm/wUzva4SL/wOZUsJ2993rCJEIujZJMl2174Up/C5T8u9LGtzyu6SNkH1+6VhUargkJlHVy7f5aW9qJUqeZy5zguufToBeAxZoRw0Z7goj3BRXuCi/YEF+0BvWQue0xgwfrMiy+aMM8QEUW+w2IHb8fC/+C5jCOGMhOPiqi+vG47zjiABVbr7XOYUWC2Um+fxwwDiKJeYXGYMYHniNnGDDPAUJZTyYph30nTg+G7f5VLj89gzBW8lu2xMzWIIt5iMZgZBrzmqK4bJFhENOLnatRsfcR7YKb0YAELF5+cwsyowHudrLcvYKZ0iIV+wIVjZhzgPaMR/+8pFIbFeilZUWm2Vyd5/5GxWOvsx4VkTbXROovn+wJdMqfevoHnFoKUaMbgeZMAnbIGzysEKGmZiX4DKKo/um5wMg6eWwhsgtVm62cRFoEOJg/xtltZxwqBTV4inuEHcZHztc4RzI0LvLeY15iRBF+0wrDgsX6qZXpUYEanNEVLROY3ZfHDgvdwuU+pipYs1h7OpUqI4z2YGxa8dqXefooZE6UrWoGFiMn8nRIXoubyTbymeLPzO7C0RUuiRvuXoRwyeI1hrlPqoiUnap1jWNLilU7mr0sgeK746rOFGRdKX7QCC4tyHiXi+DU8BzMUpqZoiSzXpTzMZOUoTFXROxh+xKV/gYPHqvVlp88q8pi+ogdgoabBc3bD1BYtEdfcxnLHeK/pLVoiHxvJktsPMDMKpr5oX3DRnuCiPcFFe4KL9gQX7Qku2hNctCe4aE94K1puD6mXNsmpOv74KUTnxEdmEQb9TOA5kx70M6KfcO/u8/j2nWffxb+XskZm9MHjw2YjgrTKygnFeUaF5cSEjZ4c9kJyz/Z7mxTpEJ0T0nhMhyRBy+5sTuXioAjR2UmaKEHJ/tsBLM9BJ0TnXGmiBCWb2GbN5oCE6GyVJkq4Z3FXxo3ubJaDiRCdM6VJErSscTtik0MWITobpYkS7lncKVfblREdbITonJImSVCyKAz7i1KkQ3ROSJMkaNnc7Ygp0iE6Z0pjTockjC8iBmEJRTpEZ6M0ZnRIwrhTrmU7Yop0iM4paTyusyvhnO2IKdIhOqdeWLLYlbDtL0oM/jaKi4MiRGcnaZIwPt8c/zZKnoNOiM4J6SIM+pnAcyY96GekYJtvf0I/EyE6MwzDMAzDjI+/5MPGam/zucIAAAAASUVORK5CYII="/>
  </div>
  <div class="download-info">
    <h2 id='bottom'>Download This Ebook</h2>
    <p class="format-label">Available formats:</p>
    <div class="download-buttons">
      <a href="javascript-algorithms.pdf" class="download-button">📄 PDF</a>
      <a href="javascript-algorithms.epub" class="download-button">📘 EPUB</a>
    </div>
  </div>
</section><div class='related-books'>
<h2>Java Introduction Books</h2>
<div class='related-book-list'>
<a href="javascript-algorithms.htm">
<div class="book-cover" style="background-color: #f9f6f1;border: 1px solid #ccc;"> 
    <div class="book-cover-title" style="font-size: 18px;color: #333;top: 20px;">JavaScript Algorithms</div>
    <div class="book-cover-author">readbytes</div>
    <div class="book-cover-bottom-stripe" style="background-color: #333;"></div>
    <img class="book-cover-icon" style="width: 80px;height: 80px;top: 70px;" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFoAAABaCAYAAAA4qEECAAAErElEQVR4Xu2dPWgUQRiGo6BB8I+AlV3w9gzptLBWsLQ89O7ARrDXSivTCTaCnWhn7pQTxOoInpjCeEQQLC2CjVqoVSwMFpp1Jtzo7Luzs/Nd7uZ29r4HPpDsu7vPvIl7+SGTmRmGYRiGYZjCEzVacdnn9NX7+3DdXkGhMg+u3Su6SNztzsZvevH/efED8zrJbM+6EGJ2K5Hv9w9gRpHnXMyik2VsYVaHWJx7tt/bTOQ3urOYUch3QJ5z0YtOCeuQiqNlvybyto/ktbVDcG2jc5GLNgoriMW5Z/svPyfy693DmFHE71ePwrUznQta9ISeyViyKBIziri/Mpe8tt25kEXjMR1ScbQsPC5W5jCjMJT8DTM6MuO6vrHjIkIszj2LL3y2ktOPiy+Y0VE5l/V5IU+EVBwtm/wUzva4SL/wOZUsJ2993rCJEIujZJMl2174Up/C5T8u9LGtzyu6SNkH1+6VhUargkJlHVy7f5aW9qJUqeZy5zguufToBeAxZoRw0Z7goj3BRXuCi/YEF+0BvWQue0xgwfrMiy+aMM8QEUW+w2IHb8fC/+C5jCOGMhOPiqi+vG47zjiABVbr7XOYUWC2Um+fxwwDiKJeYXGYMYHniNnGDDPAUJZTyYph30nTg+G7f5VLj89gzBW8lu2xMzWIIt5iMZgZBrzmqK4bJFhENOLnatRsfcR7YKb0YAELF5+cwsyowHudrLcvYKZ0iIV+wIVjZhzgPaMR/+8pFIbFeilZUWm2Vyd5/5GxWOvsx4VkTbXROovn+wJdMqfevoHnFoKUaMbgeZMAnbIGzysEKGmZiX4DKKo/um5wMg6eWwhsgtVm62cRFoEOJg/xtltZxwqBTV4inuEHcZHztc4RzI0LvLeY15iRBF+0wrDgsX6qZXpUYEanNEVLROY3ZfHDgvdwuU+pipYs1h7OpUqI4z2YGxa8dqXefooZE6UrWoGFiMn8nRIXoubyTbymeLPzO7C0RUuiRvuXoRwyeI1hrlPqoiUnap1jWNLilU7mr0sgeK746rOFGRdKX7QCC4tyHiXi+DU8BzMUpqZoiSzXpTzMZOUoTFXROxh+xKV/gYPHqvVlp88q8pi+ogdgoabBc3bD1BYtEdfcxnLHeK/pLVoiHxvJktsPMDMKpr5oX3DRnuCiPcFFe4KL9gQX7Qku2hNctCe4aE94K1puD6mXNsmpOv74KUTnxEdmEQb9TOA5kx70M6KfcO/u8/j2nWffxb+XskZm9MHjw2YjgrTKygnFeUaF5cSEjZ4c9kJyz/Z7mxTpEJ0T0nhMhyRBy+5sTuXioAjR2UmaKEHJ/tsBLM9BJ0TnXGmiBCWb2GbN5oCE6GyVJkq4Z3FXxo3ubJaDiRCdM6VJErSscTtik0MWITobpYkS7lncKVfblREdbITonJImSVCyKAz7i1KkQ3ROSJMkaNnc7Ygp0iE6Z0pjTockjC8iBmEJRTpEZ6M0ZnRIwrhTrmU7Yop0iM4paTyusyvhnO2IKdIhOqdeWLLYlbDtL0oM/jaKi4MiRGcnaZIwPt8c/zZKnoNOiM4J6SIM+pnAcyY96GekYJtvf0I/EyE6MwzDMAzDjI+/5MPGam/zucIAAAAASUVORK5CYII="/>
  </div>
</a>



<a href='java.htm'><div class='book-cover' style='background-color: #f9f6f1;color: #111111;border: 1px solid #ccc;display: flex;justify-content: center;align-items: center;text-align: center;'>More Java Books</div></a>
</div>
</div>
  </div>
  <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/prism.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
  
  <script>
    function copyCode(button) {
      const code = button.nextElementSibling.innerText;
      navigator.clipboard.writeText(code).then(() => {
        button.textContent = 'Copied!';
        setTimeout(() => { button.textContent = 'Copy'; }, 1500);
      });
    }
  </script>  
<div id="floatingLog" aria-live="polite" role="alert"></div>
<footer class="page-footer">
    <nav>
      <a href="https://readbytes.github.io">Home</a> | 
      Email:<script language="JavaScript" type="text/javascript">
var part1 = 'yinpeng';var part6 = '263';var part2 = Math.pow(2,6);var part3 = String.fromCharCode(part2);var part4 = 'hotmail dot com';var part5 = part1 + String.fromCharCode(part2) + part4;document.write(part1 + part6 + part3 + part4);
</script>
    </nav>
  <p>© 2025 — All rights reserved.</p>    
  </footer>

</body>
</html>