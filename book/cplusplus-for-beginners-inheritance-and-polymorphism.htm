<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>C++ for Beginners Inheritance and Polymorphism</title>
<link rel='shortcut icon' href='https://java2s.com/style/favicon.ico'>
<link href="https://fonts.googleapis.com/css2?family=Merriweather&display=swap" rel="stylesheet" />
<link href="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet" />


  <script>
  const mode = localStorage.getItem('mode') || 'light';
  document.documentElement.classList.add(`${mode}-mode`);
  </script>   
<style> 
html {
  scroll-behavior: smooth;
}

body {
  font-family: 'Merriweather', serif;
  margin: 0;
  padding: 2rem 1rem;
  font-size: 15px;
  line-height: 1.5;
  transition: background-color 0.3s, color 0.3s;
}

.container {
  max-width: 700px;
  margin: 0 auto;
  padding: 1rem 2rem;
  box-shadow: 0 0 15px rgba(0,0,0,0.1);
}

h1, h2, h3 {
  font-weight: 600;
  margin-top: 2.5rem;
  margin-bottom: 1rem;
  line-height: 1.2;
}

h1 { font-size: 1.8rem; }
h2 { font-size: 1.4rem; }
h3 { font-size: 1.2rem; }

table {
  width: 100%;
  border-collapse: collapse;
  font-family: sans-serif;
  font-size: 1em;
  margin: 1em 0;
}

th, td {
  padding: 0.6em 1em;
  text-align: left;
  border: 1px solid;
}

tr:nth-child(even) {
  background-color: inherit;
}

tr:hover {
  background-color: inherit;
}

a {
  text-decoration: none;
  transition: color 0.2s;
}

a:hover {
  text-decoration: underline;
}

code {
  color: #d35400;
}

.book-title-chapter {
  font-family: 'Merriweather', serif;
  font-size: 2rem;
  font-weight: bold;
  text-align: center;
  margin-bottom: 2rem;
  border-bottom: 2px solid;
  padding-bottom: 0.5rem;
}

.book-subtitle-chapter {
  text-align: center;
  font-size: 1rem;
  margin-top: -1rem;
  margin-bottom: 2rem;
}

.related-books {
  margin-top: 40px;
}

.related-book-list {
  display: flex;
  flex-wrap: wrap;
  gap: 20px;
}

    .book-cover {
      width: 130px;
      height: 180px;
      font-family: Arial, sans-serif;
      position: relative;
      overflow: hidden;      
      line-height: normal;
      box-shadow: 2px 2px 4px rgba(0,0,0,0.1);
    }
    .book-cover-bottom-stripe {
      position: absolute;
      bottom: 0;
      left: 0;
      height: 5px;
      width: 100%;
    }
    .book-cover-title {
      position: absolute;
      width: 100%;
      text-align: center;
      font-weight: bold;
    }
     
    .book-cover-icon {
      position: absolute;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      align-items: center;
      justify-content: center; 
    }

    .book-cover-author {
      position: absolute;
      bottom: 10px;
      width: 100%;
      text-align: center;
      font-size: 8px;
      color: #333;
    }

.page-footer {
  margin-top: 4rem;
  padding: 1rem 0;
  text-align: center;
  font-size: 0.85rem;
  border-top: 1px solid;
}

.chapter-navi-section {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding-bottom: 10px;
}

.nav-link {
  color: inherit;
  text-decoration: none;
  opacity: 0.5;
  transition: opacity 0.3s ease, text-decoration 0.3s ease;
}

.nav-link:hover {
  opacity: 0.9;
  text-decoration: underline;
}

.prev { text-align: left; }
.toc-link { text-align: center; }
.next { text-align: right; }

.download-section {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 2rem;
  padding: 2rem 1rem;
  max-width: 600px;
  margin: 3rem auto;
  border-radius: 12px;
  box-shadow: 0 4px 10px rgba(0,0,0,0.05);
}

.download-info h2 {
  margin: 0 0 0.5rem;
  font-size: 1.2rem;
}

.format-label {
  margin: 0 0 0.5rem;
  font-size: 0.95rem;
}

.download-buttons {
  display: flex;
  gap: 1rem;
}

.download-button {
  background-color: #4A90E2;
  color: white;
  padding: 0.5em 1.2em;
  border-radius: 25px;
  font-size: 0.95rem;
  text-decoration: none;
  transition: background-color 0.3s ease;
}

.download-button:hover {
  background-color: #357ABD;
}

.code-block {
  position: relative;
  margin-bottom: 1em;
}

.copy-button {
  background: transparent;
  color: white;
  position: absolute;
  top: 8px;
  right: 8px;
  border: none;
  padding: 4px 8px;
  font-size: 12px;
  border-radius: 4px;
  cursor: pointer;
  z-index: 1;
}

.copy-button:hover {
  background-color: #0056b3;
}

.snippet-container {
  overflow: hidden;
}

.snippet-header {
  padding: 0.75rem 1rem;
  cursor: pointer;
  font-size: 1rem;
    background-color: #eeeeee;
    color:  #111111; 
    border-radius: 8px;
    cursor: pointer;
    box-shadow: 0 4px 6px rgba(0,0,0,0.1);  
}

.snippet-body {
  display: none;
  font-family: monospace;
}

.snippet-container.open .snippet-body {
  display: block;
}

.CodeMirror {
  border: 2px solid #ccc;
  border-radius: 4px;
  resize: vertical;
}

/* === Light Mode === */
html.light-mode {
  background-color: #f8f7f5;
  color: #333;
}

html.light-mode .container {
  background: white;
}

html.light-mode .book-title-chapter {
  color: #2c3e50;
  border-color: #ccc;
}
html.light-mode .book-subtitle-chapter{
  color: #888;
}

html.light-mode .page-footer,
html.light-mode .series-name,
html.light-mode .book-subtitle,
html.light-mode .format-label {
  color: #888;
}

html.light-mode .related-books h2 {
  color: #333;
  border-bottom: 2px solid #eee;
}

html.light-mode .book-title {
  color: #fff;
}

html.light-mode .book-cover {
  border: 1px solid #ccc;
}

html.light-mode th {
  background-color: #f2f2f2;
}

html.light-mode tr:nth-child(even) {
  background-color: #fafafa;
}

html.light-mode tr:hover {
  background-color: #e6f7ff;
}

html.light-mode a,
html.light-mode .page-footer a {
  color: #000;
}

/* === Dark Mode === */
html.dark-mode {
  background-color: #181818;
  color: #e0e0e0;
}

html.dark-mode .container {
  background: #222;
}

html.dark-mode .book-title-chapter {
  color: #ddd;
  border-color: #444;
}

html.dark-mode .snippet-header {
    background-color: #333;
    color:  #ddd; 
}


html.dark-mode .book-subtitle-chapter,
html.dark-mode .page-footer,
html.dark-mode .series-name,
html.dark-mode .book-subtitle,
html.dark-mode .book-footer,
html.dark-mode .format-label {
  color: #aaa;
}

html.dark-mode .related-books h2 {
  color: #ddd;
  border-bottom: 2px solid #333;
}

html.dark-mode .book-title {
  color: #fff;
}

html.dark-mode .book-cover {
  border: 1px solid #555;
}

html.dark-mode th {
  background-color: #333;
  color: #fff;
}

html.dark-mode td {
  border-color: #444;
}

html.dark-mode tr:nth-child(even) {
  background-color: #2a2a2a;
}

html.dark-mode tr:hover {
  background-color: #2c3e50;
}

html.dark-mode a,
html.dark-mode .page-footer a {
  color: #eee;
}

    .dialog-backdrop {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: rgba(0,0,0,0.5);
      display: none;
      justify-content: center;
      align-items: center;
      z-index: 10;
    }

    .dialog {
      background: white;
      padding: 20px;
      width: 90vw;
      height: 80vh;
      border-radius: 8px;
      box-shadow: 0 0 20px rgba(0,0,0,0.3);
      display: flex;
      flex-direction: column;
    }
    .dialog-content {
      display: flex;
      flex: 1;
      gap: 20px;
      margin-top: 10px;
    }
    .dialog h2 {
      margin-top: 0;
    }

    .textarea_dialog {
      width: 50%;
      height: 100%;
      resize: none;
      font-family: monospace;
      font-size: 14px;
      padding: 10px;
      box-sizing: border-box;
      border: 1px solid #ccc;
    }

    .iframe_dialog {
      width: 50%;
      height: 100%;
      border: 1px solid #ccc;
    }
    .controls_dialog {
      display: flex;
      justify-content: space-between;
      margin-top: 10px;
    }    
    button { padding: 0.5em 1em; background: green; color: white; border: none; cursor: pointer; }
    button:hover { background: #1e7e34; }
    .result_iframe { width:99%; height:200px; margin-top: 1em;  resize: both;border:1px solid #ccc;}        
</style>
</head>
<body> 
  <div class="container">
    <div class = "chapter-navi-section">
<a href="cplusplus-for-beginners-operator-overloading.htm" class="nav-button prev">←</a>
<a href='cplusplus-for-beginners.htm#inheritance-and-polymorphism' class="nav-button toc-link">Index</a>
<a href="cplusplus-for-beginners-templates-and-generic-programming.htm" class="nav-button next">→</a>
</div>

    <h1 class="book-title-chapter" id = 'top'>Inheritance and Polymorphism</h1>
    <h3 class="book-subtitle-chapter">C++ for Beginners</h3>   
    <!-- <h1 class ="chapter-title"></h1> -->
    <h2 id='base-and-derived-classes'>11.1 Base and Derived Classes</h2><p>Inheritance is a cornerstone of object-oriented programming (OOP) and one of the most powerful features in C++. It allows you to create new classes—called <strong>derived classes</strong>—based on existing classes—called <strong>base classes</strong>. This mechanism promotes <strong>code reuse</strong>, improves organization, and models real-world relationships in a natural way.</p><p>In this section, you’ll learn what base and derived classes are, how to declare inheritance in C++, how data members and member functions are inherited, and the role of access specifiers in inheritance. We’ll also explore practical examples using a simple <code>Shape</code> base class and derived classes such as <code>Circle</code> and <code>Rectangle</code>.</p><h3 id="what-is-inheritance">What is Inheritance?</h3><p>Inheritance means that a new class automatically contains the properties (data members) and behaviors (member functions) of another class. The derived class can:</p><ul>
 <li>Use all accessible members of the base class.</li>
 <li>Add new members unique to itself.</li>
 <li>Override or extend the base class's behavior.</li>
</ul><p>Think of it like creating a specialized version of something more general. For example:</p><ul>
 <li>A <code>Shape</code> class might represent general properties like position and color.</li>
 <li><code>Circle</code> and <code>Rectangle</code> classes inherit from <code>Shape</code> and add their own specific details (radius, width, height).</li>
</ul><h3 id="declaring-derived-classes">Declaring Derived Classes</h3><p>In C++, inheritance is declared by specifying the base class name after a colon (<code>:</code>) in the derived class definition:</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-cpp">class BaseClass {
    // Base class members
};

class DerivedClass : access_specifier BaseClass {
    // Derived class members
};</code></pre>
</div><p>The <strong>access_specifier</strong> controls how the base class’s members are inherited by the derived class:</p><ul>
 <li><code>public</code> inheritance: Public and protected members of the base class keep their access levels in the derived class.</li>
 <li><code>protected</code> inheritance: Public and protected members become protected in the derived class.</li>
 <li><code>private</code> inheritance: Public and protected members become private in the derived class.</li>
</ul><p>Most inheritance is <strong>public</strong>, as it models "is-a" relationships clearly.</p><h3 id="example-base-class-shape">Example: Base Class <code>Shape</code></h3><p>Let’s create a simple base class <code>Shape</code>:</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;string&gt;

class Shape {
public:
    std::string color;

    Shape() : color("undefined") {}

    void setColor(const std::string&amp; c) {
        color = c;
    }

    void displayColor() const {
        std::cout &lt;&lt; "Color: " &lt;&lt; color &lt;&lt; std::endl;
    }
};</code></pre>
</div><p>This class has a public data member <code>color</code> and two public member functions.</p><h3 id="example-derived-classes-circle-and-rectangle">Example: Derived Classes <code>Circle</code> and <code>Rectangle</code></h3><p>Now, let's define <code>Circle</code> and <code>Rectangle</code> classes derived from <code>Shape</code>:</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-cpp">class Circle : public Shape {
public:
    double radius;

    Circle(double r) : radius(r) {}

    double area() const {
        return 3.14159 * radius * radius;
    }

    void display() const {
        std::cout &lt;&lt; "Circle with radius " &lt;&lt; radius &lt;&lt; " and ";
        displayColor();
    }
};

class Rectangle : public Shape {
public:
    double width, height;

    Rectangle(double w, double h) : width(w), height(h) {}

    double area() const {
        return width * height;
    }

    void display() const {
        std::cout &lt;&lt; "Rectangle " &lt;&lt; width &lt;&lt; "x" &lt;&lt; height &lt;&lt; " and ";
        displayColor();
    }
};</code></pre>
</div><p>Here, both <code>Circle</code> and <code>Rectangle</code> inherit <code>color</code> and the functions <code>setColor()</code> and <code>displayColor()</code> from <code>Shape</code>. They also add their own specific members and functions.</p><h3 id="using-the-derived-classes">Using the Derived Classes</h3><p>Here is how you can use these classes:</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-cpp">int main() {
    Circle c(5.0);
    c.setColor("Red");
    c.display();
    std::cout &lt;&lt; "Area: " &lt;&lt; c.area() &lt;&lt; std::endl;

    Rectangle r(4.0, 6.0);
    r.setColor("Blue");
    r.display();
    std::cout &lt;&lt; "Area: " &lt;&lt; r.area() &lt;&lt; std::endl;

    return 0;
}</code></pre>
</div><p>Output:</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-bash">Circle with radius 5 and Color: Red
Area: 78.5397
Rectangle 4x6 and Color: Blue
Area: 24</code></pre>
</div><h3 id="key-points-about-inheritance">Key Points About Inheritance</h3><h4 id="access-specifiers-and-inheritance">Access Specifiers and Inheritance</h4><p>The choice of access specifier affects what members the derived class inherits and their accessibility:</p><table>
 <thead>
  <tr>
   <th>Base Class Member</th>
   <th>Public Inheritance</th>
   <th>Protected Inheritance</th>
   <th>Private Inheritance</th>
  </tr>
 </thead>
 <tbody>
  <tr>
   <td><code>public</code></td>
   <td><code>public</code></td>
   <td><code>protected</code></td>
   <td><code>private</code></td>
  </tr>
  <tr>
   <td><code>protected</code></td>
   <td><code>protected</code></td>
   <td><code>protected</code></td>
   <td><code>private</code></td>
  </tr>
  <tr>
   <td><code>private</code></td>
   <td><strong>not inherited</strong></td>
   <td><strong>not inherited</strong></td>
   <td><strong>not inherited</strong></td>
  </tr>
 </tbody>
</table><ul>
 <li><strong>Private members</strong> of the base class are <strong>never accessible</strong> directly in derived classes.</li>
 <li>You can access private members indirectly through public or protected member functions of the base class.</li>
</ul><h4 id="constructors-and-inheritance">Constructors and Inheritance</h4><ul>
 <li>Base class constructors are <strong>not inherited</strong> by derived classes.</li>
 <li>The derived class constructor can call the base class constructor explicitly to initialize base members.</li>
</ul><p>Example:</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-cpp">class Circle : public Shape {
public:
    double radius;

    Circle(double r, const std::string&amp; c) : Shape() {  // call base constructor
        radius = r;
        setColor(c);
    }
};</code></pre>
</div><h3 id="benefits-of-inheritance">Benefits of Inheritance</h3><ul>
 <li><strong>Code Reuse</strong>: You don’t rewrite common code; just add what’s unique to each derived class.</li>
 <li><strong>Logical Organization</strong>: Models real-world hierarchies naturally.</li>
 <li><strong>Maintainability</strong>: Changes in the base class automatically reflect in derived classes.</li>
</ul><h3 id="summary">Summary</h3><ul>
 <li><strong>Inheritance</strong> creates a new class (derived) based on an existing class (base).</li>
 <li>The derived class inherits accessible data members and member functions from the base.</li>
 <li>Use the syntax <code>class Derived : public Base {}</code> for public inheritance.</li>
 <li>Access specifiers (<code>public</code>, <code>protected</code>, <code>private</code>) control member accessibility during inheritance.</li>
 <li>Derived classes can add new members and functions, enhancing the base functionality.</li>
 <li>Constructors of the base class are called explicitly or implicitly during derived class instantiation.</li>
 <li>Inheritance promotes <strong>code reuse</strong>, better <strong>organization</strong>, and models hierarchical relationships in your programs.</li>
</ul><p>By understanding base and derived classes, you lay the foundation for more advanced concepts like method overriding, polymorphism, and abstract classes — all of which you will explore in the following sections.</p><div class = "chapter-navi-section">
<a href="#top" class="nav-button prev">↑</a>
<a href='cplusplus-for-beginners.htm#inheritance-and-polymorphism' class="nav-button toc-link">Index</a>
<a href="#bottom" class="nav-button next">↓</a>
</div>
<h2 id='method-overriding-and-virtual-functions'>11.2 Method Overriding and Virtual Functions</h2><p>One of the core strengths of object-oriented programming is the ability of derived classes to <strong>customize or extend</strong> the behavior defined in their base classes. This is achieved through <strong>method overriding</strong>, where a derived class provides its own implementation of a function that is already declared in the base class. C++ adds a powerful feature called <strong>virtual functions</strong> to support <strong>dynamic dispatch</strong>, allowing the program to decide at runtime which function to invoke based on the actual object type, rather than the pointer or reference type.</p><p>In this section, you will learn how method overriding works in C++, the difference between <strong>static binding</strong> and <strong>dynamic binding</strong>, the role of <strong>virtual functions</strong>, and how to declare and use virtual functions to enable polymorphism.</p><h3 id="method-overriding-specialized-behavior-in-derived-classes">Method Overriding: Specialized Behavior in Derived Classes</h3><p>When a derived class declares a function with the same name, return type, and parameter list as a base class function, it <strong>overrides</strong> the base class version. This allows the derived class to provide specialized behavior while maintaining a consistent interface.</p><p>For example:</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-cpp">class Shape {
public:
    void draw() {
        std::cout &lt;&lt; "Drawing a generic shape." &lt;&lt; std::endl;
    }
};

class Circle : public Shape {
public:
    void draw() {  // Overrides Shape::draw
        std::cout &lt;&lt; "Drawing a circle." &lt;&lt; std::endl;
    }
};</code></pre>
</div><p>In this example, <code>Circle</code> overrides the <code>draw()</code> method of <code>Shape</code> to print a more specific message.</p><h3 id="static-binding-vs-dynamic-binding">Static Binding vs. Dynamic Binding</h3><p>To understand why <strong>virtual functions</strong> are essential, you need to grasp the difference between <strong>static binding</strong> and <strong>dynamic binding</strong>.</p><ul>
 <li><strong>Static binding</strong> (also called compile-time binding) means the function to call is determined at compile time based on the type of the pointer or reference.</li>
 <li><strong>Dynamic binding</strong> (also called runtime binding) means the function to call is determined at runtime based on the actual type of the object pointed to.</li>
</ul><p>Consider the following example:</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-cpp">Shape* shapePtr = new Circle();
shapePtr-&gt;draw();</code></pre>
</div><p>If <code>draw()</code> is not declared as <code>virtual</code>, the call <code>shapePtr-&gt;draw()</code> will invoke <code>Shape::draw()</code> because the compiler binds the call to the <code>draw()</code> function of the pointer type <code>Shape*</code>. This is <strong>static binding</strong>.</p><p>If <code>draw()</code> <strong>is</strong> declared as <code>virtual</code> in the base class, then <code>shapePtr-&gt;draw()</code> will invoke <code>Circle::draw()</code>, which is the overridden version in the actual object. This is <strong>dynamic binding</strong>, allowing polymorphic behavior.</p><h3 id="declaring-virtual-functions">Declaring Virtual Functions</h3><p>To enable dynamic binding, you declare a base class function as <code>virtual</code> by prefixing its declaration with the <code>virtual</code> keyword:</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-cpp">class Shape {
public:
    virtual void draw() {
        std::cout &lt;&lt; "Drawing a generic shape." &lt;&lt; std::endl;
    }
};</code></pre>
</div><p>When a function is virtual:</p><ul>
 <li>The compiler creates a <strong>vtable</strong> (virtual method table) for the class.</li>
 <li>Each object stores a pointer to the vtable.</li>
 <li>At runtime, the program uses the vtable pointer to look up the correct function to call based on the actual type of the object.</li>
</ul><p>Derived classes override the virtual function by providing their own definition with the same signature:</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-cpp">class Circle : public Shape {
public:
    void draw() override {  // 'override' is optional but recommended
        std::cout &lt;&lt; "Drawing a circle." &lt;&lt; std::endl;
    }
};</code></pre>
</div><p>Using the <code>override</code> keyword is good practice because it tells the compiler you intend to override a base class virtual function, and it will generate an error if no such function exists in the base class.</p><h3 id="example-demonstrating-virtual-functions-and-overriding">Example: Demonstrating Virtual Functions and Overriding</h3><p>Here is a complete example demonstrating method overriding and virtual functions:</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">📋</button>
 <pre><code class="language-cpp">#include &lt;iostream&gt;

class Shape {
public:
    virtual void draw() {
        std::cout &lt;&lt; "Drawing a generic shape." &lt;&lt; std::endl;
    }
};

class Circle : public Shape {
public:
    void draw() override {
        std::cout &lt;&lt; "Drawing a circle." &lt;&lt; std::endl;
    }
};

class Rectangle : public Shape {
public:
    void draw() override {
        std::cout &lt;&lt; "Drawing a rectangle." &lt;&lt; std::endl;
    }
};

int main() {
    Shape* shapes[3];
    shapes[0] = new Shape();
    shapes[1] = new Circle();
    shapes[2] = new Rectangle();

    for (int i = 0; i &lt; 3; i++) {
        shapes[i]-&gt;draw();  // Calls the appropriate draw() dynamically
    }

    // Clean up
    for (int i = 0; i &lt; 3; i++) {
        delete shapes[i];
    }

    return 0;
}</code></pre>
</div><p>Output:</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-bash">Drawing a generic shape.
Drawing a circle.
Drawing a rectangle.</code></pre>
</div><p>Each call to <code>draw()</code> is dynamically dispatched to the correct overridden function, even though the pointers are all of type <code>Shape*</code>.</p><h3 id="what-happens-without-virtual">What Happens Without <code>virtual</code>?</h3><p>If you remove the <code>virtual</code> keyword from the base class's <code>draw()</code> function, the output would be:</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-bash">Drawing a generic shape.
Drawing a generic shape.
Drawing a generic shape.</code></pre>
</div><p>This is because static binding occurs, and the compiler calls the <code>Shape::draw()</code> version based on the pointer type, ignoring the actual object type.</p><h3 id="why-use-virtual-functions">Why Use Virtual Functions?</h3><ul>
 <li><strong>Polymorphism</strong>: Virtual functions enable <strong>runtime polymorphism</strong>, allowing your program to decide which method to call based on the object's actual type, even when accessed through base class pointers or references.</li>
 <li><strong>Extensibility</strong>: Derived classes can modify or extend behavior without altering the base class interface.</li>
 <li><strong>Maintainability</strong>: Code can work generically with base class types, yet behave correctly for all derived types.</li>
</ul><h3 id="virtual-destructors">Virtual Destructors</h3><p>If a class has any virtual functions, it’s a good practice to declare the destructor as virtual too:</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-cpp">class Shape {
public:
    virtual ~Shape() {
        std::cout &lt;&lt; "Shape destructor called." &lt;&lt; std::endl;
    }
};</code></pre>
</div><p>This ensures that when a derived object is deleted through a base class pointer, the derived class destructor is called correctly, preventing resource leaks.</p><h3 id="summary">Summary</h3><ul>
 <li><strong>Method overriding</strong> allows derived classes to provide specialized implementations of base class functions.</li>
 <li><strong>Virtual functions</strong> enable <strong>dynamic dispatch</strong>, where the function to call is determined at runtime based on the actual object type.</li>
 <li>Without <code>virtual</code>, C++ uses <strong>static binding</strong>, which calls functions based on pointer or reference type, not the actual object.</li>
 <li>Declare base class methods as <code>virtual</code> to support polymorphism.</li>
 <li>Use the <code>override</code> keyword in derived classes to improve code safety and readability.</li>
 <li>Always consider declaring destructors <code>virtual</code> when your class has virtual functions.</li>
 <li>Virtual functions enable flexible and extensible code, fundamental to many advanced C++ designs.</li>
</ul><p>Understanding method overriding and virtual functions sets the stage for exploring <strong>abstract classes</strong>, <strong>pure virtual functions</strong>, and the rich world of <strong>polymorphism</strong>, which you will learn about in the next sections.</p><div class = "chapter-navi-section">
<a href="#top" class="nav-button prev">↑</a>
<a href='cplusplus-for-beginners.htm#inheritance-and-polymorphism' class="nav-button toc-link">Index</a>
<a href="#bottom" class="nav-button next">↓</a>
</div>
<h2 id='abstract-classes-and-pure-virtual-functions'>11.3 Abstract Classes and Pure Virtual Functions</h2><p>In C++, <strong>abstract classes</strong> and <strong>pure virtual functions</strong> provide powerful mechanisms to define interfaces and enforce certain behaviors in derived classes. They are fundamental to designing extensible and flexible software architectures based on inheritance and polymorphism.</p><p>In this section, you will learn what abstract classes are, how to declare pure virtual functions, why abstract classes cannot be instantiated, and how derived classes implement these interfaces. Practical examples will help you understand how to use abstract classes effectively.</p><h3 id="what-are-abstract-classes">What Are Abstract Classes?</h3><p>An <strong>abstract class</strong> is a class that <strong>cannot be instantiated directly</strong>. You cannot create objects of an abstract class type because it is incomplete by design. Instead, abstract classes serve as <strong>blueprints</strong> or <strong>interfaces</strong> for derived classes, defining a common set of functions that all subclasses must implement.</p><p>Abstract classes typically contain at least one <strong>pure virtual function</strong>, which is a function declared in the base class but left without an implementation. This forces any non-abstract derived class to provide its own implementation of that function.</p><h3 id="pure-virtual-functions">Pure Virtual Functions</h3><p>A <strong>pure virtual function</strong> is declared by assigning <code>= 0</code> in the function declaration inside a class. For example:</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-cpp">class Shape {
public:
    virtual void draw() = 0;  // Pure virtual function
};</code></pre>
</div><p>Here, <code>draw()</code> is a pure virtual function, making <code>Shape</code> an abstract class. This means:</p><ul>
 <li><code>Shape</code> cannot be instantiated directly: <code>Shape s;</code> will cause a compilation error.</li>
 <li>Any concrete class deriving from <code>Shape</code> <strong>must</strong> implement <code>draw()</code> to become instantiable.</li>
 <li>The pure virtual function serves as a <strong>contract</strong> that derived classes promise to fulfill.</li>
</ul><h3 id="why-use-abstract-classes">Why Use Abstract Classes?</h3><p>Abstract classes and pure virtual functions are useful when:</p><ul>
 <li>You want to define a common interface for a family of classes.</li>
 <li>You want to enforce that certain functions must be implemented by all subclasses.</li>
 <li>You want to allow polymorphic behavior through base class pointers or references.</li>
</ul><p>They promote <strong>design by contract</strong>, ensuring that derived classes provide specific functionality.</p><h3 id="example-abstract-class-with-pure-virtual-function">Example: Abstract Class with Pure Virtual Function</h3><p>Let's revisit the example of a <code>Shape</code> class hierarchy, this time making <code>Shape</code> abstract:</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">📋</button>
 <pre><code class="language-cpp">#include &lt;iostream&gt;

class Shape {
public:
    virtual void draw() = 0;  // Pure virtual function makes Shape abstract

    // Virtual destructor for proper cleanup
    virtual ~Shape() {}
};

class Circle : public Shape {
public:
    void draw() override {
        std::cout &lt;&lt; "Drawing a circle." &lt;&lt; std::endl;
    }
};

class Rectangle : public Shape {
public:
    void draw() override {
        std::cout &lt;&lt; "Drawing a rectangle." &lt;&lt; std::endl;
    }
};

int main() {
    // Shape s;  // Error: Cannot instantiate abstract class

    Shape* shapes[2];
    shapes[0] = new Circle();
    shapes[1] = new Rectangle();

    for (int i = 0; i &lt; 2; ++i) {
        shapes[i]-&gt;draw();  // Calls appropriate overridden method
    }

    for (int i = 0; i &lt; 2; ++i) {
        delete shapes[i];
    }

    return 0;
}</code></pre>
</div><p>Output:</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-bash">Drawing a circle.
Drawing a rectangle.</code></pre>
</div><h3 id="explanation">Explanation</h3><ul>
 <li>The <code>Shape</code> class cannot be instantiated because it has the pure virtual function <code>draw()</code>.</li>
 <li><code>Circle</code> and <code>Rectangle</code> provide their own implementation of <code>draw()</code>.</li>
 <li>Polymorphism allows the program to call the appropriate <code>draw()</code> method at runtime.</li>
 <li>This design guarantees that all shapes know how to <code>draw()</code> themselves, satisfying the contract defined by the abstract base class.</li>
</ul><h3 id="implementing-multiple-pure-virtual-functions">Implementing Multiple Pure Virtual Functions</h3><p>Abstract classes can have multiple pure virtual functions, requiring derived classes to implement them all. For example:</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-cpp">class Animal {
public:
    virtual void speak() = 0;
    virtual void move() = 0;

    virtual ~Animal() {}
};

class Dog : public Animal {
public:
    void speak() override {
        std::cout &lt;&lt; "Woof!" &lt;&lt; std::endl;
    }
    void move() override {
        std::cout &lt;&lt; "Dog runs." &lt;&lt; std::endl;
    }
};</code></pre>
</div><p>Any concrete subclass must implement <strong>all</strong> pure virtual functions, or it will also be abstract.</p><h3 id="abstract-classes-without-data-members">Abstract Classes Without Data Members</h3><p>Often, abstract classes are designed as <strong>interfaces</strong>, containing only pure virtual functions and no data members. This usage mimics the concept of interfaces in other languages, defining a strict API without implementation details.</p><p>For example:</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-cpp">class Printable {
public:
    virtual void print() const = 0;
    virtual ~Printable() {}
};</code></pre>
</div><p>Any class that inherits <code>Printable</code> must implement <code>print()</code>, allowing objects of different types to be printed uniformly.</p><h3 id="can-abstract-classes-have-implementations">Can Abstract Classes Have Implementations?</h3><p>Yes! Abstract classes can provide implementations for some or all member functions, except pure virtual functions must be overridden. Even pure virtual functions can have a body if needed, but derived classes still must override them to be instantiable.</p><p>Example:</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-cpp">class Base {
public:
    virtual void f() = 0;  // Pure virtual

    void g() {
        std::cout &lt;&lt; "Implemented in base class." &lt;&lt; std::endl;
    }
};</code></pre>
</div><p>Derived classes must implement <code>f()</code>, but they can inherit or override <code>g()</code>.</p><h3 id="summary">Summary</h3><ul>
 <li><strong>Abstract classes</strong> cannot be instantiated; they are designed to be base classes.</li>
 <li>Declaring a function as <strong>pure virtual</strong> (<code>= 0</code>) makes the class abstract.</li>
 <li>Pure virtual functions enforce that derived classes implement specific behavior.</li>
 <li>Abstract classes are essential for defining interfaces and enabling polymorphism.</li>
 <li>Derived classes must implement <strong>all</strong> pure virtual functions to become concrete.</li>
 <li>Abstract classes can contain implementations for non-pure virtual or regular functions.</li>
 <li>Using abstract classes promotes a clean and extensible class hierarchy.</li>
</ul><p>Understanding abstract classes and pure virtual functions equips you to design flexible, reusable, and maintainable code using the full power of C++’s object-oriented features. The next section will build upon this knowledge by exploring <strong>polymorphism</strong> and <strong>dynamic binding</strong> in greater detail.</p><div class = "chapter-navi-section">
<a href="#top" class="nav-button prev">↑</a>
<a href='cplusplus-for-beginners.htm#inheritance-and-polymorphism' class="nav-button toc-link">Index</a>
<a href="#bottom" class="nav-button next">↓</a>
</div>
<h2 id='polymorphism-and-dynamic-binding'>11.4 Polymorphism and Dynamic Binding</h2><p>Polymorphism is one of the core principles of object-oriented programming (OOP) and plays a crucial role in writing flexible, maintainable, and reusable code. In C++, <strong>polymorphism</strong> allows objects of different derived classes to be treated uniformly through pointers or references to a common base class, while still invoking the correct overridden methods specific to their actual types.</p><p>This section explains how polymorphism works in C++, focusing on <strong>dynamic binding</strong> enabled by virtual functions and virtual tables (vtables). We will explore the concept step-by-step, with practical examples illustrating polymorphic behavior.</p><h3 id="what-is-polymorphism">What is Polymorphism?</h3><p>The word <em>polymorphism</em> literally means "many forms." In programming, it refers to the ability of different types (usually related by inheritance) to be accessed through a common interface, where the correct implementation is selected dynamically at runtime.</p><p>In C++, polymorphism primarily occurs when you use <strong>base class pointers or references</strong> to refer to objects of <strong>derived classes</strong>. Thanks to <strong>virtual functions</strong>, the program calls the appropriate overridden function corresponding to the actual object type, not just the type of the pointer or reference.</p><h3 id="why-is-polymorphism-important">Why is Polymorphism Important?</h3><p>Polymorphism lets you:</p><ul>
 <li>Write code that works with base class pointers or references without needing to know the exact derived type.</li>
 <li>Extend functionality by adding new derived classes without modifying existing code.</li>
 <li>Implement generic algorithms or data structures (like containers) that operate on a variety of object types uniformly.</li>
 <li>Reduce code duplication by sharing interfaces and leveraging inheritance.</li>
</ul><h3 id="static-binding-vs-dynamic-binding">Static Binding vs. Dynamic Binding</h3><p>Before diving deeper, it’s important to understand the difference between <strong>static (compile-time) binding</strong> and <strong>dynamic (run-time) binding</strong>.</p><ul>
 <li><p><strong>Static binding</strong>: The compiler determines which function to call based on the <strong>type of the pointer or object at compile time</strong>. This is the default for all non-virtual functions.</p></li>
 <li><p><strong>Dynamic binding</strong>: The function to call is determined <strong>at runtime</strong> based on the <strong>actual type of the object</strong> being pointed to. This happens only with <strong>virtual functions</strong>.</p></li>
</ul><h3 id="example-static-binding">Example: Static Binding</h3><div class="code-block"><button class="copy-button" onclick="copyCode(this)">📋</button>
 <pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;string&gt;
class Base {
public:
    void greet() {
        std::cout &lt;&lt; "Hello from Base" &lt;&lt; std::endl;
    }
};

class Derived : public Base {
public:
    void greet() {
        std::cout &lt;&lt; "Hello from Derived" &lt;&lt; std::endl;
    }
};

int main() {
    Base* ptr = new Derived();
    ptr-&gt;greet();  // Calls Base::greet(), not Derived::greet()
    delete ptr;
    return 0;
}</code></pre>
</div><p><strong>Output:</strong></p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-bash">Hello from Base</code></pre>
</div><p>Since <code>greet()</code> is not virtual, the function call is bound at compile time to <code>Base::greet()</code>, even though <code>ptr</code> points to a <code>Derived</code> object.</p><h3 id="example-dynamic-binding-with-virtual-functions">Example: Dynamic Binding with Virtual Functions</h3><div class="code-block"><button class="copy-button" onclick="copyCode(this)">📋</button>
 <pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;string&gt;
class Base {
public:
    virtual void greet() {
        std::cout &lt;&lt; "Hello from Base" &lt;&lt; std::endl;
    }
};

class Derived : public Base {
public:
    void greet() override {
        std::cout &lt;&lt; "Hello from Derived" &lt;&lt; std::endl;
    }
};

int main() {
    Base* ptr = new Derived();
    ptr-&gt;greet();  // Calls Derived::greet() due to dynamic binding
    delete ptr;
    return 0;
}</code></pre>
</div><p><strong>Output:</strong></p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-bash">Hello from Derived</code></pre>
</div><p>The <code>virtual</code> keyword tells the compiler to perform <strong>dynamic binding</strong> using a mechanism called the <strong>virtual table (vtable)</strong>, so the call is dispatched to the correct derived class method at runtime.</p><h3 id="how-dynamic-binding-works-virtual-tables-vtables">How Dynamic Binding Works: Virtual Tables (Vtables)</h3><p>Behind the scenes, when a class declares virtual functions, the compiler generates a <strong>virtual table (vtable)</strong> — a lookup table that stores pointers to the virtual functions of the class.</p><p>Each object of a class with virtual functions contains a hidden pointer (called the <strong>vptr</strong>) to its class’s vtable. When a virtual function is called through a base class pointer or reference, the program uses the vptr to look up the appropriate function address and calls the overridden function in the derived class.</p><p>This mechanism enables polymorphic behavior without requiring the compiler to know the exact type of the object at compile time.</p><h3 id="polymorphic-collections-example">Polymorphic Collections Example</h3><p>Consider a collection of shapes where we want to treat all shapes uniformly but allow each to implement their own <code>draw()</code> behavior.</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;

class Shape {
public:
    virtual void draw() const = 0;  // Pure virtual, making Shape abstract
    virtual ~Shape() {}
};

class Circle : public Shape {
public:
    void draw() const override {
        std::cout &lt;&lt; "Drawing a Circle" &lt;&lt; std::endl;
    }
};

class Rectangle : public Shape {
public:
    void draw() const override {
        std::cout &lt;&lt; "Drawing a Rectangle" &lt;&lt; std::endl;
    }
};

int main() {
    std::vector&lt;Shape*&gt; shapes;
    shapes.push_back(new Circle());
    shapes.push_back(new Rectangle());

    for (const auto&amp; shape : shapes) {
        shape-&gt;draw();  // Dynamic binding calls correct draw()
    }

    for (auto&amp; shape : shapes) {
        delete shape;  // Clean up memory
    }

    return 0;
}</code></pre>
</div><p><strong>Output:</strong></p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-bash">Drawing a Circle
Drawing a Rectangle</code></pre>
</div><h3 id="explanation">Explanation</h3><ul>
 <li>The vector holds pointers to <code>Shape</code>, but the actual objects are <code>Circle</code> and <code>Rectangle</code>.</li>
 <li>When <code>draw()</code> is called, dynamic binding ensures the correct overridden version is executed.</li>
 <li>This design allows you to add new shapes without changing the code that manages or draws shapes.</li>
</ul><h3 id="polymorphism-in-function-calls">Polymorphism in Function Calls</h3><p>Polymorphism can also simplify functions that operate on various derived objects via base class references or pointers.</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-cpp">void renderShape(const Shape&amp; shape) {
    shape.draw();  // Calls the correct overridden draw()
}

int main() {
    Circle c;
    Rectangle r;

    renderShape(c);  // Draws Circle
    renderShape(r);  // Draws Rectangle

    return 0;
}</code></pre>
</div><p>This function <code>renderShape</code> can handle any <code>Shape</code>-derived object, promoting code reuse and extensibility.</p><h3 id="summary-of-key-points">Summary of Key Points</h3><ul>
 <li><strong>Polymorphism</strong> allows treating objects of different derived classes uniformly through base class pointers or references.</li>
 <li>The magic behind polymorphism is <strong>dynamic binding</strong> enabled by <strong>virtual functions</strong>.</li>
 <li>The <strong>vtable mechanism</strong> helps the program call the correct overridden function at runtime.</li>
 <li>Without virtual functions, C++ uses static binding, and base class function implementations are called regardless of the actual object type.</li>
 <li>Polymorphism simplifies design by enabling <strong>extensible and maintainable</strong> code structures.</li>
 <li>Polymorphic collections and function calls are common practical use cases.</li>
 <li>Always declare destructors as virtual in base classes to ensure proper cleanup of derived objects through base pointers.</li>
</ul><h3 id="best-practices">Best Practices</h3><ul>
 <li>Mark base class methods as <code>virtual</code> if you expect them to be overridden.</li>
 <li>Use <code>override</code> in derived classes for clarity and to catch mistakes.</li>
 <li>Make base class destructors <code>virtual</code> if you use polymorphism.</li>
 <li>Avoid slicing by always using pointers or references when working with polymorphic types.</li>
</ul><p>By mastering polymorphism and dynamic binding, you unlock the full potential of C++’s object-oriented features, enabling elegant solutions to complex problems while writing flexible, reusable code. The next chapters will build on these concepts to explore more advanced topics in C++ programming.</p><div class = "chapter-navi-section">
<a href="cplusplus-for-beginners-operator-overloading.htm" class="nav-button prev">←</a>
<a href='cplusplus-for-beginners.htm#inheritance-and-polymorphism' class="nav-button toc-link">Index</a>
<a href="cplusplus-for-beginners-templates-and-generic-programming.htm" class="nav-button next">→</a>
</div>
<section class="download-section">
  <div class="book-cover" style="background-color: #f9f6f1;border: 1px solid #ccc;"> 
    <div class="book-cover-title" style="font-size: 18px;color: #333;top: 20px;">C++ for Beginners</div>
    <div class="book-cover-author">readbytes</div>
    <div class="book-cover-bottom-stripe" style="background-color: #333;"></div>
    <img class="book-cover-icon" style="width: 90px;height: 90px;top: 70px;" src="data:image/png;base64,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"/>
  </div>
  <div class="download-info">
    <h2 id='bottom'>Download This Ebook</h2>
    <p class="format-label">Available formats:</p>
    <div class="download-buttons">
      <a href="cplusplus-for-beginners.pdf" class="download-button">📄 PDF</a>
      <a href="cplusplus-for-beginners.epub" class="download-button">📘 EPUB</a>
    </div>
  </div>
</section><div class='related-books'>
<h2>C++ Introduction Books</h2>
<div class='related-book-list'>
<a href="cplusplus-for-beginners.htm">
<div class="book-cover" style="background-color: #f9f6f1;border: 1px solid #ccc;"> 
    <div class="book-cover-title" style="font-size: 18px;color: #333;top: 20px;">C++ for Beginners</div>
    <div class="book-cover-author">readbytes</div>
    <div class="book-cover-bottom-stripe" style="background-color: #333;"></div>
    <img class="book-cover-icon" style="width: 90px;height: 90px;top: 70px;" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFoAAABaCAYAAAA4qEECAAAKvUlEQVR4Xu1de3BUVx2OOjqjo+Mo2ezmnc2DvNoGjBSKgAIm0EIKRShQaFINhaQ8QiFSsIhBKUlrqUKthNaURyUpj0yLLU3Fos447TiMCvIPVnnMdNpCYRApJGFIwnp/d++5nP3Ouffu3Wz2cZNv5hvY3/mdc77fd8+93NcuCQkxDq/b1a3QZ8Qsd9K72GcIQQLNLMxI8TWvr/W1Nq1W+XLDct/SOfcKpivswrGGIAFv2r5nfmiLW9csUvvtbVybjeMOQYNiUF+oBsvIxsr1eFw416BFOA3mOa98nN/wZNcEnHPQYaBMZqybP10zOzkT5x40GGiTGSunfUedB+cfFFAKPxYJkxnZRkUdjgcV/dKGpYIhA0nN7GrU4lgoxd6K5GpmnDVxzOBa1VRsm3LRgUb0h6sWzhBiMtLcDQkJn0VNjkOW21UX7tVMV43BjjlojtVUZE6yWzAgVM4r086VFU4bWyq0yzhojMbCzZifbrxap4weobZdunjRd8+IuwzzkENGA2nls9WKbSx+7dNPfQyyPBnVvkmuXajNMVAKfMqWGRo3LV2gx3duXKHHERQbU5wnjIXU+t9CfY6B0epE8kay/B3rH9PjdJiQYXfLb4IaP9uTpOahPseAihue6hEKNzKZwD4T8zPSOFvloDwyEsfl+dDU8c43etsTjwqFG5kcKmiMvY2rhPEZf7JknvON/u1muQHhMpnQ/Kvn1bFefVqch/iL+mrnGy27IgynyQxzZ96vjrmmapYw344f+4/3qM8x8K+yet1Y4tmTx3z/u3IFfQoLzp4+rc8z/Vul+t/rK2c632h+9dKf61avAntuY/XypRgyBF203LhxA8MqclM86lwtzdt9D33vAV0D6nMMeJOtgBvFDN3d3UHnEoaM5mDH6Mq5DwadS1g4Z/aQ0Qx5af57HHW1S7BJCjtjlwzPHTI6GIzIz8OQLTAdqM8xYAUWZKZj7bZAY3R3dWE4aAwKo/dsWhmwqjs7r3MWWOPq1au2DhMI1tfxRvMXKOzmjl08cO9UDJni5InjAQYzDVlu11zU6AiwIomPTJ/Ur5VpB2gyt7F7UWPcI9Pt9vKF8gX/6Z0/oDdhhWxex75U4zV4xWBUfk5Qq3pOxTQ1jy5OCDu0G0dWGFkwXGo028ioM+5BReUZ3IumthP/+Dt6JEDb3XX+dP2TmCKA8uhdapyTM/ozqDWuYbSqiJX3+XfjcINtEJyPN9pxq9qsYL7ocMHKZOKMCaOcZXROcmKpVdHhNHtx1cOWJvNzot64RTCriy+8P2bffWex2p8ujHBsGSk3NTV1GGqOS1AxhRmpQpFGZGZPGjsGfTQF69fWVC+MaUStTx9qjktQMbMnjxWKNGPFuNtPRKxWOJ+H41iR9UPNcQkqZPuPaoQizTi+pFA3+EjHW2CtHKEY7ah3PKiQ0YXWbxDxNFvJ/AomXvzkgh5vbRQf/prRaSt6q53VVv+w/+GpDFO+7X/55dYfa32zxhUIphNftPFNAseYzMBMwEJ5NtTM1806eeIEeqyC2grTParRLJfhxV+/IJhObDG5MnSc0QRWGL1ygMUy3pWXw9kqgnLIZGb0fy9fxhQd+1tbhfGJ9BKPY01mwKKJXR1vBHw2A7XzRtvB7w8fFubWzHbW/Q4CX+CNt98UiCYsrqrUjXpwRoVu9PPL+n9/5M9HjwrzEXM9Xy9G3XEDK4OR5w+0CQYQv5mXJj0+hwNHOjoC5sIaYh52DDYjjcEfNvBVMjbP1i3PBsRDQdwZTYLpKxJoWihEo3msXeV/6Cvj9m1bA3KtsE3ZUHFlNIml997QsFBYVeZ/xkgm71lXLhhNn4sy/Kd9jD3v1PiyJca3NDcH9EVoeTexnpgEKwoNC5U01j2FGYbHZ7YRzNh3tFbZu/yX3DwRFMN6YhIpKSlfCqfJRN5IdWx4czQYo5Fdby+Ob6NJ6N35uYJZ/SEazWPlYzUhGS1b0VuamrR44mWsK6ZQXFz8hXCv5uqpZbqRBxvuE8yhz3QXDo20IvWjc2kcixFriykwkWhWf0jjjc5P183JVs5i0Bw6/qKRVsQNxsbqfOt3sW92uE0m0phW5kws8QpGmvHia983HIufF+uLCXg9SaujYXRF2Xf1Fcg4aUS2YC5PlsejcWODYLTCHqwz6mDi0SjG52oeFWJWrCqfrBvdvlE8Psswe7o/j+f4OzIFow+1twf0Q/3n9u5WP2OdUQeJ6u54QzCL2KUd9zBuRepT4k3RzaGrTLuYPd3/OhkSQbErh9qF+bHOqMPKSKt2GamP2WEjFNxf7j/UIGT6KJbtcR3GWqOGLLerVyYURZ9RdkeMm3EgjJYBj8/8/DG1qpkgFCoTjXEZWS6SBx8/euRIQJtdGGk7G2vHaRJz/fAhQSjPC9o9Zozz5M3bsO4J3Yje3l7BaEJXV5ewMYjt+/dhqimozyft+wQ9TBPWGzVYGciLxhgjrZ5zZ86gByrKJ/iffluBvkGLphN3vrQDUwNgpitmjC52ub5sJhRFH/pZgzQuM5I3a7NyHLWLjz/6UDA9Pz01IGdL4+b4MFoR8p6ZUJ652u8k8bHTr+wUTH7z9dd1Y3avFe8/h4oL58/7bmjfGmBg86BWRrU9MTEf6444SAjd1EGBRsSi1FUGvy5ToHxmBjCGA7Ix6c+P9rcKOnl93iTXFaw74iAhy2dWCAKNKDNahkuXLvmKs7MCjKGvF4cK3tyD+14NGPcvv9wi6OT1EbHuiAONs8PnauU332V4/9SpALPswqhvhXYBY1RHkbZ3Yd0Rh5HAYEh9i7yZWLsKatu7exeG1XhPTw+GgwIzdMkjVdhkaHZL/ePOMNoIrHAZ7WBUcZHQn3H+rJkBuexHVGQ6se6IQybMjCXKCqY/L792IGjT+vr6dHNu3ryJzaagPv/59/u+l3c0C0YT6R9yzEfNcWc0K47/uwys7ZmnNgkxO6CNYrcP5Y8uyBN0Y90RBZ1fBmP0D6b4n/vxuWYGVC9coOcbMTc1GbtJwfLpQoUu5a2AOmPDaJdrPIpCMuF0YYKxYND2yh6h8C01/rMVnnSv+pZyiOFB8XGlI9Wb/JhPbHhyXUA+64Pz0WesPaJQBFSjKBQoa6fYmpV1WKOK2mr/8zwkjsGzaZG8D/Gfx4/jFKanihQbruwtqFcp93NYf8TgdScusjJBRqMiGaiNXa6PzPEK/a24sWqhYPiGtbfvBpqBcj8+0CbojerrvFkeV1UoRjPxsrt1H37wgdqG+f0hms6IuH7tmnRuimUlu6Zi/RFDbmLiN2TCguGzS/z/idhI7seo2PO9ny+uFvL7Q5mpq1csw5CaN/6OImn/LLdrBdYfUYRqNF8ET6sHCKGQjd3Z2Yneqvjre+/qOdiX9c9yu+uw9ojCSFysETco8nHlKhH78H2z3cMmY+0RRbwYzZNe+/rXrhbfudY9QpuMVGNCtL9URCIK0lIEcU6iZnR04U1KKovHVR0sh2s3mrDuqICEVE8tF0Ra8dgL24RYrJFqy8j46tew5qggNfUrw0hQsGcMf9vu/5WvaO0JNO/BhvVCHMk0Yr1RhSLoFIlaNsP8sRYT31C5QGiLFJkGRn7PovcH+TasMyaQlpb2RV4k/SM5seROoTAsHElnBbR3hEJ6UdGKzMDS0oTPo7aYNlgGr/ajgrFK1DvQ+D8MyloZgHbpRwAAAABJRU5ErkJggg=="/>
  </div>
</a>


<a href="cplusplus-syntax.htm">
<div class="book-cover" style="background-color: #f9f6f1;border: 1px solid #ccc;"> 
    <div class="book-cover-title" style="font-size: 20px;color: #333;top: 20px;">C++ Syntax</div>
    <div class="book-cover-author">readbytes</div>
    <div class="book-cover-bottom-stripe" style="background-color: #333;"></div>
    <img class="book-cover-icon" style="width: 90px;height: 90px;top: 70px;" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFoAAABaCAYAAAA4qEECAAAFZ0lEQVR4Xu2dy4scVRSH8ye0iYtkERcmzgjT2OYBuhNREMVXBh/TgsYQx5ULDYTgVl3EFyg6uFJBV76IEXdKXAVBJCgISSTRGRmZiZlADBo6M5kp+3ZbnXt/p7q6btWtc++pqQPfpu/p7vP7UnSqi+m6GzbkrMbYO50u0Tqjgx5Kqe4brSa8+XplFf0UroQ3GbDltqNRs70Y3Tw5G22//2SXU0Fyy5MXc6GyqYyYWwd9WdfGbW9uxRe9vvlBtOvZKLrpwTOiUDO7QjlALxu3zWxFf5mq++RF/YU27/40au39lwSQAspygXICwhfRY2rhv5Z6URxcEuoAQUkuQV/oM7HwSN45vUoGlwaKKQOrI1t9zuhPaD19mQwtEZRSFrq71M/sqh3JMSikTHSH6LdXeoN6Ag4rlV3Ta0RG2aTKjhfU/6Q4rGRQAgf62QhKHnzjk3wKlwRK4EI7qq99g4wf3NR8nwwqmfE9s0QAF8olOarjB1QDDisZDM+NIbqhXYXDQaWDwbnRPj46xtkGDiodDM6N7nYgWl2hwkEl09r7DwnOzZbbr131G4iemFokw0oGQ/ug2XVKRI9PzpJhJYOhfdB66m8qevsDp8iwksHQPqi8aAzsi1o0E7VoJioteuzh30lgX1RaNIb1SS2aiVo0E5UVPTH1Fwnrk8qKxqC+qUUzUYtmwovoL49dioYV9uZhx/4VEjRmWM2fp70uYRc9qrA/DxhSZ1RhvyuCEL1wfiU6PXulB/bnAUPqnJnv8+cSTtEv7HeFd9G4XpyzJGQaWLjuisqJxoCjeOVjc572y7THBayim4+cNUKdONkhPUXBgKO495AxUrTvVdrjAq+ij//k/i9UMeAo7jlojFSLzsLE4/ZfuyspuvXYb0Yo16IxXBZQ9DOv0x4XsIqeOjRvhPri20ukpwgYLgt3HTBGir75kfa4gFU01h373f5ZA4bLChauu4BNdPtF82hWhT1FuHVfh4TLCtbR47SnKKWKTqu5hWXSXwQMZsOBGZzOLOzPA7voNz66QPpcgMHy8Py7OG2/sC8P7KLjurK8RvqLgMFsmDmC05mF/XkoVbTOjinz1E4V9uSl6I+AsF6YoT1FYROtwLpzeo705AFD2YKF6y5gFf3oQfPM48h3w8+jD3+4ZIDrOnGYtz7vgyHTuBvOo7/+nva4gFW0zTdDLFyPGdN+BBQXhkyDfDN8jfa4gFW0zbWOH365bIDrMXqYE7/2wZBpoOhKXOuwEZ0VDGTLuhD98+kO6bEFA9lyXxWvRyuwcN0GdccFDGTLe1+Z87Rfoj0uEC0aw+QBC9dd4V10XMsraz2wPw0Mk4WVq33WcID/C/tdwS766uqwiP3C/jQwTBZGFfa7gl204rnDC5hvUNg7DAySlWH1yTHa6xIvol2AQUKnFs2ESNHjk3MkSOiIFI0hJFCLZqIWzYQ40c0nLpAQEhAnGgNIoRbNRC2aCVGid6b8CCh0RInG4SVRi2YiUXSIN68ae8juR0ChkSg6xNux4eDSSLwdW4g3GMTBpZF4g0EFBvUNDi4N3a0SHeRNYCfaS2RwaWii+1s/xQ+oRQzsCxxaIoOjGe8fHdKNunFoaWzSdh/SRQd363kcXBrax4a5eVm8EMJmCmn33pDA5t2f0aMZRStUM4bnBAeXhu4SPfdKb/C54Q0OLomRklWFsoUTDi8F3d11N759A/o1quF5UzIcXgq6sy7n0GtiwZN6L4RCygIDSAB9oc/UwiOba+NIDBEy+tmF1ZGMhZ/ZijK3Qh3f8wcJEyJOt0LVC19UR12harbPOdncFzfWDQGVTb8KlwT6KlyNertqHffbVSdVo96A3ar+A5kzbYSE7G+UAAAAAElFTkSuQmCC"/>
  </div>
</a>


<a href="cplusplus-stl.htm">
<div class="book-cover" style="background-color: #f9f6f1;border: 1px solid #ccc;"> 
    <div class="book-cover-title" style="font-size: 20px;color: #333;top: 20px;">C++ STL</div>
    <div class="book-cover-author">readbytes</div>
    <div class="book-cover-bottom-stripe" style="background-color: #333;"></div>
    <img class="book-cover-icon" style="width: 90px;height: 90px;top: 70px;" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFoAAABaCAYAAAA4qEECAAADK0lEQVR4Xu2cvWsTcRjHo+DkIKiTjiJugqTJ0cG/QcRZ/wJXQTd3ByeHDiLJnS84dHMVBHUSRQUH90pNfmfb6CKi8fqSaj93ae4lzzV3+X7gS9vkeZ7f7/lwEDq0jYYQQgghxFzQ9t0wbTzf3WO/SAllpg3niAlQYJa0uu4W54kxeA96ZykwU4JwnTPFGGLyMqd3nTNFAnFx2cOZIiee//UK5TLsEQWg3D1ZHpxgvShATLCeajsoWKKNaAfuDyVvZuGhu8paURBK1lNtBAVLtBEULNFGULBEG0HBlRfNRUrMqwW/f473GZFQvxXWVQbPD5e4zEGlcXt4eHQvvrdbU2W4zEGn5Yd3+NoovHul4DKzHN69UnCZWQ7vXim8IHzJhWY1vLtIQSRujSInhTNEBppL345R6LiwV+SAUpPCHpETimVYLwpAuRJtBOVKtBHNR4OTFCzRRlCwRBtBwRJtBAVLtBEULNFGeN3wPiVvp/+OtVmJ5qzvmdl1z1kzV8Ql53+q0/6az765gBLyConqN9i/X9hfeyiAYX0S7cCtsi9NOKf2UADDesL6LOGsWsPlx+V8d/Vo3t5x4bzyGA4P8TK1TuBeU0FpxC5T83D/0uBF6h7uXxq8SN3D/Utj80OHl6ltgvAX9y+V2IUm53eUQZQvUT4nvJ8x/e/R14+RiBeeHz4bZfPn6PW3bT908Z7s4d6Vgwsxix13mj15iGb94Ows4bxKwWUY1heF89OGcyoHFypjOZ4zKV7gVjijUjSfrJ/hUqOwdtrwvH2yzN7KkbDUTsKfrLWgufTmSPzsf2F9ZeFitVtwVqBgiTaCgiXaCAqWaCMoWKKNoGCJNoKCJdoICpZoIyhYoo2gYIk2goIl2ggKlmgjKFiijaBgiTaCgiXagLbfu0jBW+m6NdaKAsQEj9Jxl1krChATvBPWiQJ4fviJgiV6yiw+3ThOuRI9ZbzA3aRYSZ4iFx73T1FqUtg3l1DKbrr9960gvBt9f207/Rst332I1U0Iz5tbKGaa4VlzTSQk8X84Fw3PEY3p/70KTxA7UFTeeB13ibPFf1BY1nCeEEIIIYQowl8t5mhjJHw+fQAAAABJRU5ErkJggg=="/>
  </div>
</a>



<a href='cplusplus.htm'><div class='book-cover' style='background-color: #f9f6f1;color: #111111;border: 1px solid #ccc;display: flex;justify-content: center;align-items: center;text-align: center;'>More C++ Books</div></a>
</div>
</div>
  </div>
  <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/prism.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
  
  <script>
    function copyCode(button) {
      const code = button.nextElementSibling.innerText;
      navigator.clipboard.writeText(code).then(() => {
        button.textContent = 'Copied!';
        setTimeout(() => { button.textContent = 'Copy'; }, 1500);
      });
    }
  </script>  
<div id="floatingLog" aria-live="polite" role="alert"></div>
<footer class="page-footer">
    <nav>
      <a href="https://readbytes.github.io">Home</a> | 
      Email:<script language="JavaScript" type="text/javascript">
var part1 = 'yinpeng';var part6 = '263';var part2 = Math.pow(2,6);var part3 = String.fromCharCode(part2);var part4 = 'hotmail dot com';var part5 = part1 + String.fromCharCode(part2) + part4;document.write(part1 + part6 + part3 + part4);
</script>
    </nav>
  <p>© 2025 — All rights reserved.</p>    
  </footer>

</body>
</html>