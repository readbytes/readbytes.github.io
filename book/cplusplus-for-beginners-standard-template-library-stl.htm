<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>C++ for Beginners Standard Template Library (STL)</title>
<link rel='shortcut icon' href='https://readbytes.github.io/images/favicon.ico'>
<link href="https://fonts.googleapis.com/css2?family=Merriweather&display=swap" rel="stylesheet" />
<link href="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet" />
<script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/prism.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/codemirror.min.css" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/codemirror.min.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/theme/dracula.min.css"><style>
html {scroll-behavior: smooth;}  
body {font-family: 'Merriweather', serif;;margin: 0;padding: 2rem 1rem;font-size: 15px;line-height: 1.5;transition: background-color 0.3s, color 0.3s;}
.container {max-width: 750px;margin: 0 auto;padding: 1rem 2rem;}
.light-mode {background-color: #f8f7f5;color: #333;} 
.dark-mode {background-color: #121212;color: #e0e0e0;}
a { text-decoration: none;transition: color 0.2s;}
a:hover {text-decoration: underline;}
.light-mode a {color: #555;}
.dark-mode a {color: #aaa;}
</style><style>
.related-book-list {display: flex;flex-wrap: wrap;gap: 20px;}
.related-books {margin-top: 40px;}
.related-books h2 {font-size: 22px;margin-bottom: 20px;border-bottom: 2px solid #eee;padding-bottom: 8px;}
.light-mode .related-books h2 {color: #333;border-color: #eee;}
.dark-mode .related-books h2 {color: #ddd;border-color: #333;}
</style><style>
.book-cover {width: 130px;height: 180px;font-family: Arial, sans-serif;position: relative;overflow: hidden;box-shadow: 2px 2px 4px rgba(0,0,0,0.1);}
.book-cover-bottom-stripe {position: absolute;bottom: 0;left: 0;height: 5px;width: 100%;}
.book-cover-title {position: absolute;width: 100%;text-align: center;font-weight: bold;}
.book-cover-icon {position: absolute;left: 50%;transform: translateX(-50%);display: flex;align-items: center;justify-content: center;}
.book-cover-author {position: absolute;bottom: 10px;width: 100%;text-align: center;font-size: 8px;color: #333;}
</style><style>
.book-title-toc {font-size: 32px;font-weight: bold; }
.book-subtitle-toc {font-size: 18px;margin-top: 8px;font-style: italic;}
.book-header {text-align: center;margin-bottom: 40px;}

.toc-container {border-radius: 10px;padding: 30px;margin-bottom: 40px;box-shadow: 0 8px 20px rgba(0,0,0,0.05);}
h1 {font-size: 24px;text-align: center;margin-bottom: 30px;letter-spacing: 1px;padding-bottom: 10px;}
.toc-list,.toc-section-list {list-style: none;padding: 0;margin: 0;}
.toc-section-list {padding-left: 18px;margin-top: 6px;margin-bottom: 20px; }
.toc-chapter {padding: 20px 0;}
.chapter-title,.toc-section {display: flex;justify-content: space-between;padding-top: 4px;}
.chapter-title {font-size: 17px;font-weight: bold;}
.chapter-page,.section-page {font-style: italic;}
 
 
.light-mode .book-title-toc,.light-mode .chapter-title,.light-mode .book-name {color: #222;}
.light-mode .book-subtitle-toc,.light-mode .book-sub,.light-mode .chapter-page,.light-mode .section-page {color: #666;}
.light-mode .toc-container { background: #fff;border: 1px solid #ddd;}
.light-mode h1 {border-bottom: 2px solid #eee;color: #222;}
.light-mode .toc-section {  color: #444;}

.light-mode .book-cover { border: 1px solid #ccc;box-shadow: 0 6px 12px rgba(0, 0, 0, 0.15);}
.light-mode .book-title,.light-mode .series-name {color: #fff;}
.light-mode .book-subtitle,.light-mode .book-footer {color: #aaa;}

.dark-mode .book-title-toc,.dark-mode .chapter-title,.dark-mode .book-name {color: #f5f5f5;}
.dark-mode .book-subtitle-toc,.dark-mode .book-sub,.dark-mode .chapter-page,.dark-mode .section-page {color: #aaa;}
.dark-mode .toc-container {background: #1e1e1e;border: 1px solid #444;}

.dark-mode h1 {border-bottom: 2px solid #333;color: #eee;}
.dark-mode .toc-section {color: #bbb;}

.dark-mode .related-books h2 {color: #ddd;border-bottom: 2px solid #333;}
.dark-mode .book-title,.dark-mode .series-name {color: #fff;}
.dark-mode .book-subtitle,.dark-mode .book-footer {color: #bbb;}
.dark-mode .toc-section {color: #ddd;}

@media (max-width: 600px) {
  .chapter-title,
  .toc-section {
    flex-direction: column;
    align-items: flex-start;
  }

  .chapter-page,
  .section-page {
    margin-top: 4px;
  }
}

</style><style>
.light-mode .container {box-shadow: 0 0 15px rgba(0,0,0,0.1);}
.dark-mode .container {box-shadow: 0 0 15px rgba(255, 255, 255, 0.05);}

h1, h2, h3 {font-weight: 600;margin-top: 2.5rem;margin-bottom: 1rem;line-height: 1.2;}
h1 { font-size: 1.8rem; }
h2 { font-size: 1.4rem; }
h3 { font-size: 1.2rem; }

table {width: 100%;border-collapse: collapse;font-family: sans-serif;font-size: 1em;margin: 1em 0;}
th, td {padding: 0.6em 1em;text-align: left;border: 1px solid;}
tr:nth-child(even) {  background-color: inherit;}
tr:hover { background-color: inherit;}

code {color: #d35400;}

.chapter-navi-section {display: flex;justify-content: space-between;align-items: center;padding-bottom: 10px;padding-top: 10px;}
.nav-link {color: inherit;text-decoration: none;opacity: 0.5;transition: opacity 0.3s ease, text-decoration 0.3s ease;}
.nav-link:hover {opacity: 0.9;text-decoration: underline;}
.prev { text-align: left; }
.toc-link { text-align: center; }
.next { text-align: right; }

.download-section {display: flex;align-items: center;justify-content: center;gap: 2rem;padding: 2rem 1rem;max-width: 600px;margin: 3rem auto;border-radius: 12px;box-shadow: 0 4px 10px rgba(0,0,0,0.05);}
.download-info h2 {margin: 0 0 0.5rem;font-size: 1.2rem;}
.format-label {margin: 0 0 0.5rem;font-size: 0.95rem;}
.download-buttons {display: flex;gap: 1rem;}
.download-button {background-color: #4A90E2;color: white;padding: 0.5em 1.2em;border-radius: 25px;font-size: 0.95rem;text-decoration: none;transition: background-color 0.3s ease;}
.download-button:hover {background-color: #357ABD;}

.code-block {position: relative;margin-bottom: 1em;}
.copy-button {background: transparent;color: white;position: absolute;top: 8px;right: 8px;border: none;padding: 4px 8px;font-size: 12px;border-radius: 4px;cursor: pointer;z-index: 1;}
.copy-button:hover {background-color: #0056b3;}

.snippet-container {overflow: hidden;}
.snippet-header {padding: 0.75rem 1rem;cursor: pointer;font-size: 1rem;background-color: #eeeeee;color:  #111111; border-radius: 8px;cursor: pointer;box-shadow: 0 4px 6px rgba(0,0,0,0.1); }
.snippet-body {display: none;font-family: monospace;}
.snippet-container.open .snippet-body {display: block;}

.CodeMirror {border: 2px solid #ccc;border-radius: 4px;resize: vertical;}

.light-mode .format-label {color: #888;}
.light-mode th {background-color: #f2f2f2;}
.light-mode tr:nth-child(even) {background-color: #fafafa;}
.light-mode tr:hover {background-color: #e6f7ff;}

.dark-mode .snippet-header {background-color: #333;color:  #ddd; }
.dark-mode .format-label {color: #aaa;}
.dark-mode th {background-color: #333;color: #fff;}
.dark-mode td {border-color: #444;}
.dark-mode tr:nth-child(even) {background-color: #2a2a2a;}
.dark-mode tr:hover {background-color: #2c3e50;}


.button-group-run-edit {display: flex;width: 100%;gap: 1rem;}
.button-run-edit {flex: 1;padding: 1rem;font-size: 1rem;font-weight: 600;border: none;border-radius: 8px;cursor: pointer;transition: background 0.3s, color 0.3s;}

.light-mode .button-run-edit {background-color: #f0f0f0;color: #222;box-shadow: 0 0 10px rgba(0, 0, 0, 0.05);}
.light-mode .button-run-edit:hover {background-color: #e0e0e0;}

.dark-mode .button-run-edit {background-color: #2a2a2a;color: #f5f5f5;box-shadow: 0 0 10px rgba(255, 255, 255, 0.05);}
.dark-mode .button-run-edit:hover {background-color: #3a3a3a;}

button { padding: 0.5em 1em; background: green; color: white; border: none; cursor: pointer; }
button:hover { background: #1e7e34; }
.result_iframe { width:99%; margin-top: 1em;  resize: both;background-color: #515b63;border:1px solid #ccc;}   

.dialog-backdrop {position: fixed;top: 0;left: 0;width: 100vw;height: 100vh;background: rgba(0,0,0,0.5);display: none;justify-content: center;align-items: center;z-index: 10;}
.dialog {background: #90979e;padding: 20px;width: 90vw;height: 80vh;border-radius: 8px;box-shadow: 0 0 20px rgba(0,0,0,0.3);display: flex;flex-direction: column;}
.dialog-content {display: flex;gap: 20px;margin-top: 10px;height: calc(100% - 40px);}
.editor-container, .preview-container {flex: 1;height: 100%;max-height: 100%;overflow: hidden; }
.result_iframe_dialog {width: 100%;height: 100%;resize: both;border:1px solid #ccc;overflow: auto; }   
.CodeMirror {width: 100% !important;height: 100% !important;}
</style>
</head>
<body>
<script>const mode = localStorage.getItem('mode') || 'light';document.documentElement.classList.add(`${mode}-mode`);</script>  
<div class="container"><div class = "chapter-navi-section">
<a href="cplusplus-for-beginners-exception-handling.htm" class="nav-button prev">←</a>
<a href='cplusplus-for-beginners.htm#standard-template-library-stl' class="nav-button toc-link">Index</a>
<a href="cplusplus-for-beginners-file-input-and-output.htm" class="nav-button next">→</a>
</div>
<div class='book-header'><h1 class='book-title-toc' id = 'top'>Standard Template Library (STL)</h1><h3 class='book-subtitle-toc'>C++ for Beginners</h3></div><h2 id='containers-vector-list-deque-map-set'>14.1 Containers: <code>vector</code>, <code>list</code>, <code>deque</code>, <code>map</code>, <code>set</code></h2><p>The Standard Template Library (STL) is a cornerstone of modern C++ programming, offering powerful, generic data structures called <strong>containers</strong> that allow you to store and organize collections of data efficiently. Understanding the core STL containers, their characteristics, and use cases is essential for writing clean, efficient, and maintainable code.</p><p>This section introduces the most commonly used STL containers:</p><ul>
 <li>Sequence Containers: <code>vector</code>, <code>list</code>, <code>deque</code></li>
 <li>Associative Containers: <code>map</code>, <code>set</code></li>
</ul><p>We'll explain their differences and provide examples illustrating how to declare, insert into, access, and traverse these containers.</p><h3 id="sequence-containers">Sequence Containers</h3><p>Sequence containers store elements in a linear order. The main sequence containers are:</p><ul>
 <li><strong><code>vector</code></strong></li>
 <li><strong><code>list</code></strong></li>
 <li><strong><code>deque</code></strong></li>
</ul><p>Each offers different performance characteristics for inserting, deleting, and accessing elements.</p><h3 id="vector"><code>vector</code></h3><ul>
 <li><p><strong>Description:</strong> A dynamic array that stores elements contiguously in memory.</p></li>
 <li><p><strong>Use case:</strong> Ideal for fast random access and situations where elements are primarily added or removed at the end.</p></li>
 <li><p><strong>Performance:</strong></p>
  <ul>
   <li>Random access: O(1)</li>
   <li>Insertion/removal at end: Amortized O(1)</li>
   <li>Insertion/removal in middle or front: O(n) because elements must be shifted</li>
  </ul></li>
</ul><p><strong>Example:</strong></p><div class="code-block">
 <button class="copy-button" onclick="copyCode(this)">📋</button>
 <pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;

int main() {
    std::vector&lt;int&gt; numbers;       // Declare an empty vector of integers

    // Insert elements
    numbers.push_back(10);
    numbers.push_back(20);
    numbers.push_back(30);

    // Access elements by index
    std::cout &lt;&lt; "First element: " &lt;&lt; numbers[0] &lt;&lt; "\n";

    // Traverse using range-based for loop
    std::cout &lt;&lt; "All elements: ";
    for (int num : numbers) {
        std::cout &lt;&lt; num &lt;&lt; " ";
    }
    std::cout &lt;&lt; "\n";

    return 0;
}</code></pre>
</div><h3 id="list"><code>list</code></h3><ul>
 <li><p><strong>Description:</strong> A doubly-linked list storing elements non-contiguously.</p></li>
 <li><p><strong>Use case:</strong> When frequent insertions and removals occur anywhere in the sequence.</p></li>
 <li><p><strong>Performance:</strong></p>
  <ul>
   <li>Insertion/removal anywhere: O(1) if iterator is known</li>
   <li>Random access: O(n) (no direct indexing)</li>
  </ul></li>
</ul><p><strong>Example:</strong></p><div class="code-block">
 <button class="copy-button" onclick="copyCode(this)">📋</button>
 <pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;list&gt;

int main() {
    std::list&lt;std::string&gt; names = {"Alice", "Bob", "Charlie"};

    // Insert at front
    names.push_front("Zara");

    // Insert at back
    names.push_back("David");

    // Traverse using iterator
    std::cout &lt;&lt; "Names: ";
    for (auto it = names.begin(); it != names.end(); ++it) {
        std::cout &lt;&lt; *it &lt;&lt; " ";
    }
    std::cout &lt;&lt; "\n";

    return 0;
}</code></pre>
</div><h3 id="deque-double-ended-queue"><code>deque</code> (Double-Ended Queue)</h3><ul>
 <li><p><strong>Description:</strong> A sequence container that supports fast insertion/removal at both front and back.</p></li>
 <li><p><strong>Use case:</strong> When you need dynamic arrays but also efficient insertions/removals at both ends.</p></li>
 <li><p><strong>Performance:</strong></p>
  <ul>
   <li>Random access: O(1)</li>
   <li>Insertion/removal at front or back: O(1)</li>
   <li>Insertion/removal in middle: O(n)</li>
  </ul></li>
</ul><p><strong>Example:</strong></p><div class="code-block">
 <button class="copy-button" onclick="copyCode(this)">📋</button>
 <pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;deque&gt;

int main() {
    std::deque&lt;int&gt; dq;

    dq.push_back(100);
    dq.push_front(50);

    std::cout &lt;&lt; "Deque elements: ";
    for (int val : dq) {
        std::cout &lt;&lt; val &lt;&lt; " ";
    }
    std::cout &lt;&lt; "\n";

    return 0;
}</code></pre>
</div><h3 id="associative-containers">Associative Containers</h3><p>Associative containers organize data using keys for efficient retrieval based on those keys. The most common are:</p><ul>
 <li><strong><code>map</code></strong></li>
 <li><strong><code>set</code></strong></li>
</ul><p>These containers use balanced binary search trees internally, providing efficient lookup, insertion, and removal.</p><h3 id="map"><code>map</code></h3><ul>
 <li><p><strong>Description:</strong> A collection of key-value pairs (associative array), where each key is unique.</p></li>
 <li><p><strong>Use case:</strong> When you need to associate data with unique keys and look up values efficiently.</p></li>
 <li><p><strong>Performance:</strong></p>
  <ul>
   <li>Lookup, insertion, removal: O(log n)</li>
  </ul></li>
</ul><p><strong>Example:</strong></p><div class="code-block">
 <button class="copy-button" onclick="copyCode(this)">📋</button>
 <pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;map&gt;

int main() {
    std::map&lt;std::string, int&gt; ageMap;

    // Insert key-value pairs
    ageMap["Alice"] = 30;
    ageMap["Bob"] = 25;
    ageMap["Charlie"] = 35;

    // Access value by key
    std::cout &lt;&lt; "Alice's age: " &lt;&lt; ageMap["Alice"] &lt;&lt; "\n";

    // Traverse map
    std::cout &lt;&lt; "All entries:\n";
    for (const auto&amp; pair : ageMap) {
        std::cout &lt;&lt; pair.first &lt;&lt; ": " &lt;&lt; pair.second &lt;&lt; "\n";
    }

    return 0;
}</code></pre>
</div><h3 id="set"><code>set</code></h3><ul>
 <li><p><strong>Description:</strong> A collection of unique keys, sorted by default.</p></li>
 <li><p><strong>Use case:</strong> When you need to store unique items and quickly check for membership.</p></li>
 <li><p><strong>Performance:</strong></p>
  <ul>
   <li>Insertion, removal, lookup: O(log n)</li>
  </ul></li>
</ul><p><strong>Example:</strong></p><div class="code-block">
 <button class="copy-button" onclick="copyCode(this)">📋</button>
 <pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;set&gt;

int main() {
    std::set&lt;int&gt; numbers = {3, 1, 4, 1, 5};

    // Insert element
    numbers.insert(2);

    // Attempt to insert duplicate
    numbers.insert(3);  // Ignored because 3 is already present

    // Traverse set (sorted order)
    std::cout &lt;&lt; "Numbers: ";
    for (int num : numbers) {
        std::cout &lt;&lt; num &lt;&lt; " ";
    }
    std::cout &lt;&lt; "\n";

    // Check membership
    if (numbers.find(4) != numbers.end()) {
        std::cout &lt;&lt; "4 is in the set\n";
    }

    return 0;
}</code></pre>
</div><h3 id="key-differences-between-containers">Key Differences Between Containers</h3><table>
 <thead>
  <tr>
   <th>Container</th>
   <th>Memory Layout</th>
   <th>Access Time</th>
   <th>Insert/Remove Efficiency</th>
   <th>Use Case</th>
  </tr>
 </thead>
 <tbody>
  <tr>
   <td><code>vector</code></td>
   <td>Contiguous</td>
   <td>O(1) random access</td>
   <td>Fast insert/remove at end, slow at front/middle</td>
   <td>Dynamic arrays, fast access</td>
  </tr>
  <tr>
   <td><code>list</code></td>
   <td>Non-contiguous (linked list)</td>
   <td>O(n) random access</td>
   <td>Fast insert/remove anywhere (if iterator known)</td>
   <td>Frequent insertion/removal</td>
  </tr>
  <tr>
   <td><code>deque</code></td>
   <td>Multiple contiguous blocks</td>
   <td>O(1) random access</td>
   <td>Fast insert/remove at front and back</td>
   <td>Double-ended queue operations</td>
  </tr>
  <tr>
   <td><code>map</code></td>
   <td>Balanced binary tree</td>
   <td>O(log n)</td>
   <td>O(log n) insert/remove</td>
   <td>Key-value storage with sorted keys</td>
  </tr>
  <tr>
   <td><code>set</code></td>
   <td>Balanced binary tree</td>
   <td>O(log n)</td>
   <td>O(log n) insert/remove</td>
   <td>Unique elements, sorted collection</td>
  </tr>
 </tbody>
</table><h3 id="summary">Summary</h3><ul>
 <li><strong>Sequence containers</strong> store data in linear order with different trade-offs between access speed and insertion/removal efficiency.</li>
 <li><strong>Associative containers</strong> store unique keys and provide fast lookup, insertion, and removal using tree-based data structures.</li>
 <li>Choosing the right container depends on your application's requirements for access speed, insertion/removal frequency, and data organization.</li>
 <li>STL containers come with a rich set of member functions that make common operations intuitive and efficient.</li>
</ul><p>Mastering these containers will help you write clear, efficient, and scalable C++ programs by leveraging the power of the STL. In the next section, we'll explore <strong>Iterators and Algorithms</strong>, the tools that allow you to traverse and manipulate containers in a generic and powerful way.</p><div class = "chapter-navi-section">
<a href="#top" class="nav-button prev">↑</a>
<a href='cplusplus-for-beginners.htm#standard-template-library-stl' class="nav-button toc-link">Index</a>
<a href="#bottom" class="nav-button next">↓</a>
</div>
<h2 id='iterators-and-algorithms'>14.2 Iterators and Algorithms</h2><p>The Standard Template Library (STL) is built on two fundamental concepts that work hand-in-hand to provide powerful, reusable, and efficient code: <strong>iterators</strong> and <strong>algorithms</strong>. Together, they allow you to traverse, access, and manipulate data stored in STL containers in a generic way.</p><p>This section introduces <strong>iterators</strong> as generalized pointers used to navigate container elements, explains different iterator categories, and showcases how common STL <strong>algorithms</strong> leverage iterators to perform operations like searching, sorting, and applying functions.</p><h3 id="what-are-iterators">What Are Iterators?</h3><p>Think of <strong>iterators</strong> as generalized pointers that point to elements inside containers like <code>vector</code>, <code>list</code>, or <code>map</code>. They provide a standardized way to move through the elements regardless of the container type.</p><p>Unlike raw pointers, iterators work with all STL containers uniformly, allowing algorithms to operate generically.</p><h3 id="why-use-iterators">Why Use Iterators?</h3><ul>
 <li><strong>Abstraction:</strong> Iterators abstract away container details.</li>
 <li><strong>Generality:</strong> Algorithms work on any container supporting the required iterator type.</li>
 <li><strong>Safety:</strong> Iterator interfaces prevent invalid memory access and enable safe traversal.</li>
</ul><h3 id="iterator-categories">Iterator Categories</h3><p>Not all iterators are created equal. STL defines five main iterator categories that describe their capabilities:</p><table>
 <thead>
  <tr>
   <th>Iterator Category</th>
   <th>Capabilities</th>
   <th>Typical Containers</th>
  </tr>
 </thead>
 <tbody>
  <tr>
   <td><strong>Input Iterator</strong></td>
   <td>Read elements sequentially</td>
   <td>Streams, single-pass input</td>
  </tr>
  <tr>
   <td><strong>Output Iterator</strong></td>
   <td>Write elements sequentially</td>
   <td>Streams, output iterators</td>
  </tr>
  <tr>
   <td><strong>Forward Iterator</strong></td>
   <td>Read/write, multi-pass, increment only</td>
   <td><code>forward_list</code>, <code>unordered_map</code></td>
  </tr>
  <tr>
   <td><strong>Bidirectional Iterator</strong></td>
   <td>Forward + backward movement</td>
   <td><code>list</code>, <code>set</code>, <code>map</code></td>
  </tr>
  <tr>
   <td><strong>Random Access Iterator</strong></td>
   <td>All above + direct access by offset</td>
   <td><code>vector</code>, <code>deque</code>, native pointers</td>
  </tr>
 </tbody>
</table><h3 id="summary-of-key-operations-per-category">Summary of Key Operations per Category</h3><table>
 <thead>
  <tr>
   <th>Operation</th>
   <th>Input</th>
   <th>Output</th>
   <th>Forward</th>
   <th>Bidirectional</th>
   <th>Random Access</th>
  </tr>
 </thead>
 <tbody>
  <tr>
   <td>Read <code>*it</code></td>
   <td>Yes</td>
   <td>No</td>
   <td>Yes</td>
   <td>Yes</td>
   <td>Yes</td>
  </tr>
  <tr>
   <td>Write <code>*it</code></td>
   <td>No</td>
   <td>Yes</td>
   <td>Yes</td>
   <td>Yes</td>
   <td>Yes</td>
  </tr>
  <tr>
   <td>Increment <code>++it</code></td>
   <td>Yes</td>
   <td>Yes</td>
   <td>Yes</td>
   <td>Yes</td>
   <td>Yes</td>
  </tr>
  <tr>
   <td>Decrement <code>--it</code></td>
   <td>No</td>
   <td>No</td>
   <td>No</td>
   <td>Yes</td>
   <td>Yes</td>
  </tr>
  <tr>
   <td>Random access (<code>it + n</code>)</td>
   <td>No</td>
   <td>No</td>
   <td>No</td>
   <td>No</td>
   <td>Yes</td>
  </tr>
 </tbody>
</table><h3 id="using-iterators-basic-syntax">Using Iterators: Basic Syntax</h3><p>Iterators behave much like pointers:</p><div class="code-block">
 <button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-cpp">std::vector&lt;int&gt; vec = {10, 20, 30};
auto it = vec.begin();  // Get iterator to first element

std::cout &lt;&lt; *it &lt;&lt; "\n"; // Dereference to access element (outputs 10)

++it;                    // Move iterator to next element
std::cout &lt;&lt; *it &lt;&lt; "\n"; // Outputs 20</code></pre>
</div><p>You can get iterators using:</p><ul>
 <li><code>.begin()</code> — points to the first element</li>
 <li><code>.end()</code> — points just past the last element (not dereferenceable)</li>
</ul><p>When looping over containers, the standard pattern is:</p><div class="code-block">
 <button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-cpp">for (auto it = container.begin(); it != container.end(); ++it) {
    // Access *it
}</code></pre>
</div><h3 id="stl-algorithms-operating-on-iterator-ranges">STL Algorithms: Operating on Iterator Ranges</h3><p>The true power of iterators is unlocked by STL <strong>algorithms</strong>. These are template functions that operate on ranges defined by pairs of iterators: <code>[first, last)</code>.</p><p>For example, many algorithms expect two iterators specifying the start and end positions, allowing them to work generically on any container or sequence that supports those iterators.</p><p>Let's explore some of the most common algorithms.</p><h3 id="std-find"><code>std::find</code></h3><p>Searches for a value in a range and returns an iterator to it or the end iterator if not found.</p><div class="code-block">
 <button class="copy-button" onclick="copyCode(this)">📋</button>
 <pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt; // for std::find

int main() {
    std::vector&lt;int&gt; numbers = {1, 3, 5, 7, 9};
    int target = 5;

    auto it = std::find(numbers.begin(), numbers.end(), target);

    if (it != numbers.end()) {
        std::cout &lt;&lt; "Found " &lt;&lt; *it &lt;&lt; " at index " &lt;&lt; (it - numbers.begin()) &lt;&lt; "\n";
    } else {
        std::cout &lt;&lt; target &lt;&lt; " not found\n";
    }

    return 0;
}</code></pre>
</div><h3 id="std-sort"><code>std::sort</code></h3><p>Sorts elements in a range. Requires <strong>random access iterators</strong> like those from <code>vector</code> or <code>deque</code>.</p><div class="code-block">
 <button class="copy-button" onclick="copyCode(this)">📋</button>
 <pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt; // for std::sort

int main() {
    std::vector&lt;int&gt; nums = {5, 2, 9, 1, 7};

    std::sort(nums.begin(), nums.end());

    std::cout &lt;&lt; "Sorted numbers: ";
    for (int n : nums) {
        std::cout &lt;&lt; n &lt;&lt; " ";
    }
    std::cout &lt;&lt; "\n";

    return 0;
}</code></pre>
</div><h3 id="std-for-each"><code>std::for_each</code></h3><p>Applies a function to every element in a range.</p><div class="code-block">
 <button class="copy-button" onclick="copyCode(this)">📋</button>
 <pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt; // for std::for_each

void print(int n) {
    std::cout &lt;&lt; n &lt;&lt; " ";
}

int main() {
    std::vector&lt;int&gt; nums = {1, 2, 3, 4, 5};

    std::for_each(nums.begin(), nums.end(), print);
    std::cout &lt;&lt; "\n";

    return 0;
}</code></pre>
</div><p>You can also use lambdas with <code>std::for_each</code>:</p><div class="code-block">
 <button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-cpp">std::for_each(nums.begin(), nums.end(), [](int n) {
    std::cout &lt;&lt; n * 2 &lt;&lt; " ";
});</code></pre>
</div><h3 id="std-copy"><code>std::copy</code></h3><p>Copies elements from one range to another, useful for containers and raw arrays.</p><div class="code-block">
 <button class="copy-button" onclick="copyCode(this)">📋</button>
 <pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt; // for std::copy

int main() {
    std::vector&lt;int&gt; source = {10, 20, 30};
    std::vector&lt;int&gt; dest(source.size());

    std::copy(source.begin(), source.end(), dest.begin());

    for (int n : dest) {
        std::cout &lt;&lt; n &lt;&lt; " ";
    }
    std::cout &lt;&lt; "\n";

    return 0;
}</code></pre>
</div><h3 id="practical-example-combining-iterators-and-algorithms">Practical Example: Combining Iterators and Algorithms</h3><p>Suppose we want to find all even numbers in a list and print them.</p><div class="code-block">
 <button class="copy-button" onclick="copyCode(this)">📋</button>
 <pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;iterator&gt; 

int main() {
    std::vector&lt;int&gt; data = {3, 4, 7, 8, 10, 13};

    // Use std::copy_if and ostream_iterator to print even numbers
    std::cout &lt;&lt; "Even numbers: ";
    std::copy_if(data.begin(), data.end(),
                 std::ostream_iterator&lt;int&gt;(std::cout, " "),
                 [](int x) { return x % 2 == 0; });

    std::cout &lt;&lt; "\n";

    return 0;
}</code></pre>
</div><p>This example combines:</p><ul>
 <li>Iterators (<code>data.begin()</code>, <code>data.end()</code>)</li>
 <li>Algorithms (<code>copy_if</code>)</li>
 <li>Lambda expression (predicate to check if number is even)</li>
 <li>Output iterator (<code>ostream_iterator</code>)</li>
</ul><h3 id="summary-and-best-practices">Summary and Best Practices</h3><ul>
 <li><strong>Iterators</strong> are the bridge between containers and algorithms, providing a uniform way to access container elements.</li>
 <li>Different <strong>iterator categories</strong> provide different capabilities; understanding them helps choose appropriate algorithms and containers.</li>
 <li>STL <strong>algorithms</strong> like <code>sort</code>, <code>find</code>, and <code>for_each</code> operate on iterator ranges, enabling code reuse and abstraction.</li>
 <li>Use <strong>range-based for loops</strong> for simple iteration, but leverage algorithms for more complex tasks.</li>
 <li>Combining iterators and algorithms with <strong>lambda expressions</strong> leads to concise, expressive code.</li>
</ul><p>Mastering iterators and algorithms will greatly increase your productivity and code quality in C++. The next chapter section will explore <strong>Functors and Lambda Expressions</strong>, which help customize algorithm behavior further and enhance functional programming styles in C++.</p><div class = "chapter-navi-section">
<a href="#top" class="nav-button prev">↑</a>
<a href='cplusplus-for-beginners.htm#standard-template-library-stl' class="nav-button toc-link">Index</a>
<a href="#bottom" class="nav-button next">↓</a>
</div>
<h2 id='functors-and-lambda-expressions'>14.3 Functors and Lambda Expressions</h2><p>In C++, the Standard Template Library (STL) offers a rich collection of algorithms that work with containers via iterators. To customize the behavior of these algorithms, such as specifying sorting criteria or filtering conditions, you need to supply callable objects. Two powerful tools for this are <strong>functors</strong> (function objects) and <strong>lambda expressions</strong>.</p><p>This section introduces functors and lambda expressions, explains their syntax and uses, and demonstrates how they simplify writing expressive, reusable code with STL algorithms.</p><h3 id="what-are-functors">What Are Functors?</h3><p>A <strong>functor</strong>, or function object, is any object that can be called like a function. This is achieved by defining the function call operator <code>operator()</code> in a class or struct. Functors behave like functions but can also hold state (data) and be passed around like objects.</p><h3 id="why-use-functors">Why Use Functors?</h3><ul>
 <li><strong>Stateful behavior:</strong> Unlike plain functions, functors can keep internal state.</li>
 <li><strong>Reusability:</strong> You can configure functors once and reuse them.</li>
 <li><strong>Performance:</strong> Functors are often inlined by the compiler, resulting in efficient code.</li>
</ul><h3 id="example-a-simple-functor">Example: A Simple Functor</h3><div class="code-block">
 <button class="copy-button" onclick="copyCode(this)">📋</button>
 <pre><code class="language-cpp">#include &lt;iostream&gt;

struct MultiplyBy {
    int factor;

    MultiplyBy(int f) : factor(f) {}

    int operator()(int x) const {
        return x * factor;
    }
};

int main() {
    MultiplyBy timesThree(3);
    std::cout &lt;&lt; timesThree(5);  // Outputs 15
}</code></pre>
</div><p>Here, <code>MultiplyBy</code> is a functor that multiplies its argument by a fixed factor.</p><h3 id="functors-in-stl-algorithms">Functors in STL Algorithms</h3><p>STL algorithms accept functors as parameters to customize their behavior. For example, <code>std::sort</code> lets you provide a comparison functor:</p><div class="code-block">
 <button class="copy-button" onclick="copyCode(this)">📋</button>
 <pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

struct Descending {
    bool operator()(int a, int b) const {
        return a &gt; b;  // Reverse order
    }
};

int main() {
    std::vector&lt;int&gt; nums = {5, 2, 9, 1, 7};
    std::sort(nums.begin(), nums.end(), Descending());

    for (int n : nums) {
        std::cout &lt;&lt; n &lt;&lt; " ";  // Outputs: 9 7 5 2 1
    }
}</code></pre>
</div><h3 id="introducing-lambda-expressions">Introducing Lambda Expressions</h3><p>While functors are flexible, they require boilerplate code to define a class or struct. <strong>Lambda expressions</strong>, introduced in C++11, offer a more concise way to write inline, anonymous function objects without explicit classes.</p><h3 id="lambda-syntax">Lambda Syntax</h3><p>Basic syntax of a lambda:</p><div class="code-block">
 <button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-cpp">[capture](parameters) -&gt; return_type {
    // function body
};</code></pre>
</div><ul>
 <li><strong>Capture:</strong> Specifies variables from the surrounding scope that the lambda can access.</li>
 <li><strong>Parameters:</strong> Arguments the lambda accepts.</li>
 <li><strong>Return type:</strong> Optional; can often be omitted if the compiler can infer it.</li>
 <li><strong>Function body:</strong> The code executed when the lambda is called.</li>
</ul><h3 id="example-simple-lambda">Example: Simple Lambda</h3><div class="code-block">
 <button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-cpp">auto add = [](int a, int b) {
    return a + b;
};

std::cout &lt;&lt; add(3, 4);  // Outputs 7</code></pre>
</div><h3 id="lambdas-with-stl-algorithms">Lambdas with STL Algorithms</h3><p>Lambdas integrate smoothly with STL algorithms, making code compact and readable.</p><h3 id="example-1-sorting-with-lambda">Example 1: Sorting with Lambda</h3><p>Sort numbers in descending order:</p><div class="code-block">
 <button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-cpp">std::vector&lt;int&gt; nums = {5, 2, 9, 1, 7};

std::sort(nums.begin(), nums.end(), [](int a, int b) {
    return a &gt; b;  // Descending order
});

for (int n : nums) std::cout &lt;&lt; n &lt;&lt; " ";  // 9 7 5 2 1</code></pre>
</div><h3 id="example-2-filtering-with-std-copy-if">Example 2: Filtering with <code>std::copy_if</code></h3><p>Copy only even numbers to another container:</p><div class="code-block">
 <button class="copy-button" onclick="copyCode(this)">📋</button>
 <pre><code class="language-cpp">#include &lt;algorithm&gt;
#include &lt;vector&gt;
#include &lt;iostream&gt;

int main() {
    std::vector&lt;int&gt; data = {1, 2, 3, 4, 5, 6};
    std::vector&lt;int&gt; evens;

    std::copy_if(data.begin(), data.end(), std::back_inserter(evens), [](int x) {
        return x % 2 == 0;
    });

    for (int n : evens) std::cout &lt;&lt; n &lt;&lt; " ";  // 2 4 6
}</code></pre>
</div><h3 id="example-3-transforming-with-std-transform">Example 3: Transforming with <code>std::transform</code></h3><p>Multiply each element by 10:</p><div class="code-block">
 <button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-cpp">std::vector&lt;int&gt; numbers = {1, 2, 3, 4};
std::vector&lt;int&gt; result(numbers.size());

std::transform(numbers.begin(), numbers.end(), result.begin(), [](int x) {
    return x * 10;
});

for (int n : result) std::cout &lt;&lt; n &lt;&lt; " ";  // 10 20 30 40</code></pre>
</div><h3 id="capturing-variables-in-lambdas">Capturing Variables in Lambdas</h3><p>Lambda expressions can access variables from their surrounding scope by <strong>capture</strong>:</p><ul>
 <li><code>[ ]</code> — no captures.</li>
 <li><code>[=]</code> — capture all variables by value.</li>
 <li><code>[&amp;]</code> — capture all variables by reference.</li>
 <li><code>[x, &amp;y]</code> — capture <code>x</code> by value and <code>y</code> by reference explicitly.</li>
</ul><p>Example showing captures:</p><div class="code-block">
 <button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-cpp">int factor = 3;
auto multiply = [factor](int x) {
    return x * factor;  // factor captured by value
};

std::cout &lt;&lt; multiply(5);  // Outputs 15</code></pre>
</div><h3 id="when-to-use-functors-vs-lambdas">When to Use Functors vs. Lambdas?</h3><table>
 <thead>
  <tr>
   <th>Feature</th>
   <th>Functors</th>
   <th>Lambdas</th>
  </tr>
 </thead>
 <tbody>
  <tr>
   <td>Definition</td>
   <td>Named class or struct with <code>operator()</code></td>
   <td>Anonymous inline function object</td>
  </tr>
  <tr>
   <td>State (data members)</td>
   <td>Can store data</td>
   <td>Can capture variables from scope</td>
  </tr>
  <tr>
   <td>Reusability</td>
   <td>Reusable and can have complex logic</td>
   <td>Usually short and used inline</td>
  </tr>
  <tr>
   <td>Syntax</td>
   <td>Verbose (class/struct definition)</td>
   <td>Concise and expressive</td>
  </tr>
  <tr>
   <td>Performance</td>
   <td>Efficient, often inlined</td>
   <td>Same as functors, equally efficient</td>
  </tr>
 </tbody>
</table><h3 id="summary">Summary</h3><ul>
 <li><strong>Functors</strong> are function objects with customizable behavior and state, ideal for reusable logic in STL algorithms.</li>
 <li><strong>Lambda expressions</strong> are concise, inline anonymous functions that simplify passing custom behavior, especially for short or one-off uses.</li>
 <li>Both functors and lambdas are fundamental tools for customizing and extending STL algorithms like <code>sort</code>, <code>copy_if</code>, and <code>transform</code>.</li>
 <li>Understanding when and how to use each leads to cleaner, more expressive, and maintainable C++ code.</li>
</ul><p>Mastering functors and lambda expressions will empower you to write elegant and efficient code that leverages the full power of the STL.</p><div class = "chapter-navi-section">
<a href="#top" class="nav-button prev">↑</a>
<a href='cplusplus-for-beginners.htm#standard-template-library-stl' class="nav-button toc-link">Index</a>
<a href="#bottom" class="nav-button next">↓</a>
</div>
<h2 id='string-and-stream-classes'>14.4 String and Stream Classes</h2><p>C++ provides powerful classes for handling text and formatted input/output through its Standard Template Library (STL). In this section, we explore the versatile <code>std::string</code> class and stream classes such as <code>stringstream</code>, <code>istringstream</code>, and <code>ostringstream</code>. These classes make working with text data easier, safer, and more efficient than using traditional C-style strings and manual parsing.</p><h3 id="the-std-string-class-flexible-and-safe-strings">The <code>std::string</code> Class: Flexible and Safe Strings</h3><p><code>std::string</code> is part of the C++ Standard Library and represents a dynamic, mutable string of characters. Unlike C-style strings (which are arrays of characters terminated by a null <code>'\0'</code>), <code>std::string</code> manages memory automatically, offers convenient operations, and reduces errors.</p><h3 id="key-features-of-std-string">Key Features of <code>std::string</code></h3><ul>
 <li><strong>Dynamic size:</strong> The string grows or shrinks as needed.</li>
 <li><strong>Safe memory management:</strong> No manual buffer handling.</li>
 <li><strong>Rich member functions:</strong> For searching, modifying, and extracting substrings.</li>
 <li><strong>Interoperability:</strong> Easily convert to/from C-style strings if needed.</li>
</ul><h3 id="basic-usage-example">Basic Usage Example</h3><div class="code-block">
 <button class="copy-button" onclick="copyCode(this)">📋</button>
 <pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;string&gt;

int main() {
    std::string greeting = "Hello";
    greeting += ", world!";  // Concatenate strings

    std::cout &lt;&lt; greeting &lt;&lt; std::endl;  // Output: Hello, world!

    std::cout &lt;&lt; "Length: " &lt;&lt; greeting.length() &lt;&lt; std::endl;  // Length: 13

    std::string sub = greeting.substr(7, 5);  // Extract substring "world"
    std::cout &lt;&lt; sub &lt;&lt; std::endl;
}</code></pre>
</div><h3 id="stream-classes-flexible-text-parsing-and-formatting">Stream Classes: Flexible Text Parsing and Formatting</h3><p>C++ provides several stream classes for reading from and writing to different sources. Beyond <code>std::cin</code> and <code>std::cout</code>, the <strong>string stream classes</strong> enable reading and writing data directly to and from strings.</p><h3 id="types-of-string-streams">Types of String Streams</h3><ul>
 <li><strong><code>std::stringstream</code></strong> — a bidirectional stream allowing both input and output.</li>
 <li><strong><code>std::istringstream</code></strong> — input-only stream from a string.</li>
 <li><strong><code>std::ostringstream</code></strong> — output-only stream writing into a string.</li>
</ul><p>These classes are defined in the <code>&lt;sstream&gt;</code> header and behave similarly to file or console streams but operate on strings.</p><h3 id="practical-uses-of-string-streams">Practical Uses of String Streams</h3><ul>
 <li>Parsing complex strings into multiple data types.</li>
 <li>Formatting data into strings.</li>
 <li>Converting between strings and numbers.</li>
</ul><h3 id="example-1-parsing-a-string-using-istringstream">Example 1: Parsing a String Using <code>istringstream</code></h3><p>Suppose you have a string with multiple values separated by spaces and want to extract them:</p><div class="code-block">
 <button class="copy-button" onclick="copyCode(this)">📋</button>
 <pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;sstream&gt;
#include &lt;string&gt;

int main() {
    std::string input = "2025 6 26 13 45";
    std::istringstream iss(input);

    int year, month, day, hour, minute;
    iss &gt;&gt; year &gt;&gt; month &gt;&gt; day &gt;&gt; hour &gt;&gt; minute;

    std::cout &lt;&lt; "Parsed date/time: "
              &lt;&lt; year &lt;&lt; "-" &lt;&lt; month &lt;&lt; "-" &lt;&lt; day &lt;&lt; " "
              &lt;&lt; hour &lt;&lt; ":" &lt;&lt; minute &lt;&lt; std::endl;
}</code></pre>
</div><p>This outputs:</p><div class="code-block">
 <button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-bash">Parsed date/time: 2025-6-26 13:45</code></pre>
</div><p>The stream extracts individual integers from the string as if reading from user input.</p><h3 id="example-2-formatting-data-with-ostringstream">Example 2: Formatting Data with <code>ostringstream</code></h3><p>You can build formatted strings by inserting values into an <code>ostringstream</code>:</p><div class="code-block">
 <button class="copy-button" onclick="copyCode(this)">📋</button>
 <pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;sstream&gt;

int main() {
    int score = 95;
    std::string player = "Alice";

    std::ostringstream oss;
    oss &lt;&lt; "Player " &lt;&lt; player &lt;&lt; " scored " &lt;&lt; score &lt;&lt; " points.";

    std::string result = oss.str();
    std::cout &lt;&lt; result &lt;&lt; std::endl;
}</code></pre>
</div><p>Output:</p><div class="code-block">
 <button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-bash">Player Alice scored 95 points.</code></pre>
</div><p>Using <code>ostringstream</code> helps avoid complex string concatenations and type conversions.</p><h3 id="example-3-converting-strings-to-numbers-and-vice-versa">Example 3: Converting Strings to Numbers and Vice Versa</h3><p>Conversion between strings and numeric types is a common task. While C++11 introduced <code>std::stoi</code>, <code>std::stod</code>, etc., string streams remain useful for more complex or formatted conversions.</p><h3 id="string-to-number">String to Number</h3><div class="code-block">
 <button class="copy-button" onclick="copyCode(this)">📋</button>
 <pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;sstream&gt;
#include &lt;string&gt;

int main() {
    std::string str = "12345";
    int number;

    std::istringstream iss(str);
    iss &gt;&gt; number;

    std::cout &lt;&lt; "Number is: " &lt;&lt; number &lt;&lt; std::endl;
}</code></pre>
</div><h3 id="number-to-string">Number to String</h3><div class="code-block">
 <button class="copy-button" onclick="copyCode(this)">📋</button>
 <pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;sstream&gt;

int main() {
    double pi = 3.14159;

    std::ostringstream oss;
    oss &lt;&lt; pi;

    std::string pi_str = oss.str();
    std::cout &lt;&lt; "Pi as string: " &lt;&lt; pi_str &lt;&lt; std::endl;
}</code></pre>
</div><h3 id="combining-string-and-stream-classes">Combining String and Stream Classes</h3><p>String streams make it easier to handle structured data stored as text. For example, consider parsing CSV (comma-separated values) or formatting log messages with timestamps.</p><h3 id="example-simple-csv-parsing">Example: Simple CSV Parsing</h3><div class="code-block">
 <button class="copy-button" onclick="copyCode(this)">📋</button>
 <pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;sstream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;

int main() {
    std::string csv = "John,25,3.75";
    std::istringstream ss(csv);

    std::string name;
    int age;
    double gpa;

    std::getline(ss, name, ',');  // Extract until comma
    std::string age_str, gpa_str;

    std::getline(ss, age_str, ',');
    std::getline(ss, gpa_str, ',');

    std::istringstream(age_str) &gt;&gt; age;
    std::istringstream(gpa_str) &gt;&gt; gpa;

    std::cout &lt;&lt; "Name: " &lt;&lt; name &lt;&lt; "\nAge: " &lt;&lt; age &lt;&lt; "\nGPA: " &lt;&lt; gpa &lt;&lt; std::endl;
}</code></pre>
</div><p>Output:</p><div class="code-block">
 <button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-bash">Name: John
Age: 25
GPA: 3.75</code></pre>
</div><h3 id="benefits-of-using-std-string-and-stream-classes">Benefits of Using <code>std::string</code> and Stream Classes</h3><ul>
 <li><strong>Safety:</strong> Avoids buffer overflows and manual memory management errors common with C-style strings.</li>
 <li><strong>Flexibility:</strong> Easy to concatenate, compare, and manipulate strings.</li>
 <li><strong>Convenience:</strong> Stream classes let you parse and format text cleanly without tedious code.</li>
 <li><strong>Integration:</strong> Work seamlessly with other STL components and algorithms.</li>
</ul><h3 id="summary">Summary</h3><ul>
 <li><code>std::string</code> is the modern C++ string class providing dynamic, easy-to-use string manipulation.</li>
 <li>Stream classes such as <code>stringstream</code>, <code>istringstream</code>, and <code>ostringstream</code> allow parsing and formatting strings conveniently.</li>
 <li>Together, these tools simplify tasks like input parsing, data conversion, and formatted output.</li>
 <li>Using these classes leads to cleaner, safer, and more maintainable code than manual C-style string operations.</li>
</ul><p>Mastering these classes will empower you to handle text and data efficiently in your C++ programs, a crucial skill in software development.</p><div class = "chapter-navi-section">
<a href="cplusplus-for-beginners-exception-handling.htm" class="nav-button prev">←</a>
<a href='cplusplus-for-beginners.htm#standard-template-library-stl' class="nav-button toc-link">Index</a>
<a href="cplusplus-for-beginners-file-input-and-output.htm" class="nav-button next">→</a>
</div>
<section class="download-section">
  <div class="book-cover" style="background-color: #f9f6f1;border: 1px solid #ccc;"> 
    <div class="book-cover-title" style="font-size: 18px;color: #333;top: 20px;">C++ for Beginners</div>
    <div class="book-cover-author">readbytes</div>
    <div class="book-cover-bottom-stripe" style="background-color: #333;"></div>
    <img class="book-cover-icon" style="width: 90px;height: 90px;top: 70px;" src="data:image/png;base64,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"/>
  </div>
  <div class="download-info">
    <h2 id='bottom'>Download This Ebook</h2>
    <p class="format-label">Available formats:</p>
    <div class="download-buttons">
      <a href="cplusplus-for-beginners.pdf" class="download-button">📄 PDF</a>
      <a href="cplusplus-for-beginners.epub" class="download-button">📘 EPUB</a>
    </div>
  </div>
</section><div class='related-books'>
<h2>C++ Introduction Books</h2>
<div class='related-book-list'>
<a href="cplusplus-for-beginners.htm">
<div class="book-cover" style="background-color: #f9f6f1;border: 1px solid #ccc;"> 
    <div class="book-cover-title" style="font-size: 18px;color: #333;top: 20px;">C++ for Beginners</div>
    <div class="book-cover-author">readbytes</div>
    <div class="book-cover-bottom-stripe" style="background-color: #333;"></div>
    <img class="book-cover-icon" style="width: 90px;height: 90px;top: 70px;" src="data:image/png;base64,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"/>
  </div>
</a>


<a href="cplusplus-syntax.htm">
<div class="book-cover" style="background-color: #f9f6f1;border: 1px solid #ccc;"> 
    <div class="book-cover-title" style="font-size: 20px;color: #333;top: 20px;">C++ Syntax</div>
    <div class="book-cover-author">readbytes</div>
    <div class="book-cover-bottom-stripe" style="background-color: #333;"></div>
    <img class="book-cover-icon" style="width: 90px;height: 90px;top: 70px;" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFoAAABaCAYAAAA4qEECAAAFZ0lEQVR4Xu2dy4scVRSH8ye0iYtkERcmzgjT2OYBuhNREMVXBh/TgsYQx5ULDYTgVl3EFyg6uFJBV76IEXdKXAVBJCgISSTRGRmZiZlADBo6M5kp+3ZbnXt/p7q6btWtc++pqQPfpu/p7vP7UnSqi+m6GzbkrMbYO50u0Tqjgx5Kqe4brSa8+XplFf0UroQ3GbDltqNRs70Y3Tw5G22//2SXU0Fyy5MXc6GyqYyYWwd9WdfGbW9uxRe9vvlBtOvZKLrpwTOiUDO7QjlALxu3zWxFf5mq++RF/YU27/40au39lwSQAspygXICwhfRY2rhv5Z6URxcEuoAQUkuQV/oM7HwSN45vUoGlwaKKQOrI1t9zuhPaD19mQwtEZRSFrq71M/sqh3JMSikTHSH6LdXeoN6Ag4rlV3Ta0RG2aTKjhfU/6Q4rGRQAgf62QhKHnzjk3wKlwRK4EI7qq99g4wf3NR8nwwqmfE9s0QAF8olOarjB1QDDisZDM+NIbqhXYXDQaWDwbnRPj46xtkGDiodDM6N7nYgWl2hwkEl09r7DwnOzZbbr131G4iemFokw0oGQ/ug2XVKRI9PzpJhJYOhfdB66m8qevsDp8iwksHQPqi8aAzsi1o0E7VoJioteuzh30lgX1RaNIb1SS2aiVo0E5UVPTH1Fwnrk8qKxqC+qUUzUYtmwovoL49dioYV9uZhx/4VEjRmWM2fp70uYRc9qrA/DxhSZ1RhvyuCEL1wfiU6PXulB/bnAUPqnJnv8+cSTtEv7HeFd9G4XpyzJGQaWLjuisqJxoCjeOVjc572y7THBayim4+cNUKdONkhPUXBgKO495AxUrTvVdrjAq+ij//k/i9UMeAo7jlojFSLzsLE4/ZfuyspuvXYb0Yo16IxXBZQ9DOv0x4XsIqeOjRvhPri20ukpwgYLgt3HTBGir75kfa4gFU01h373f5ZA4bLChauu4BNdPtF82hWhT1FuHVfh4TLCtbR47SnKKWKTqu5hWXSXwQMZsOBGZzOLOzPA7voNz66QPpcgMHy8Py7OG2/sC8P7KLjurK8RvqLgMFsmDmC05mF/XkoVbTOjinz1E4V9uSl6I+AsF6YoT1FYROtwLpzeo705AFD2YKF6y5gFf3oQfPM48h3w8+jD3+4ZIDrOnGYtz7vgyHTuBvOo7/+nva4gFW0zTdDLFyPGdN+BBQXhkyDfDN8jfa4gFW0zbWOH365bIDrMXqYE7/2wZBpoOhKXOuwEZ0VDGTLuhD98+kO6bEFA9lyXxWvRyuwcN0GdccFDGTLe1+Z87Rfoj0uEC0aw+QBC9dd4V10XMsraz2wPw0Mk4WVq33WcID/C/tdwS766uqwiP3C/jQwTBZGFfa7gl204rnDC5hvUNg7DAySlWH1yTHa6xIvol2AQUKnFs2ESNHjk3MkSOiIFI0hJFCLZqIWzYQ40c0nLpAQEhAnGgNIoRbNRC2aCVGid6b8CCh0RInG4SVRi2YiUXSIN68ae8juR0ChkSg6xNux4eDSSLwdW4g3GMTBpZF4g0EFBvUNDi4N3a0SHeRNYCfaS2RwaWii+1s/xQ+oRQzsCxxaIoOjGe8fHdKNunFoaWzSdh/SRQd363kcXBrax4a5eVm8EMJmCmn33pDA5t2f0aMZRStUM4bnBAeXhu4SPfdKb/C54Q0OLomRklWFsoUTDi8F3d11N759A/o1quF5UzIcXgq6sy7n0GtiwZN6L4RCygIDSAB9oc/UwiOba+NIDBEy+tmF1ZGMhZ/ZijK3Qh3f8wcJEyJOt0LVC19UR12harbPOdncFzfWDQGVTb8KlwT6KlyNertqHffbVSdVo96A3ar+A5kzbYSE7G+UAAAAAElFTkSuQmCC"/>
  </div>
</a>


<a href="cplusplus-stl.htm">
<div class="book-cover" style="background-color: #f9f6f1;border: 1px solid #ccc;"> 
    <div class="book-cover-title" style="font-size: 20px;color: #333;top: 20px;">C++ STL</div>
    <div class="book-cover-author">readbytes</div>
    <div class="book-cover-bottom-stripe" style="background-color: #333;"></div>
    <img class="book-cover-icon" style="width: 90px;height: 90px;top: 70px;" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFoAAABaCAYAAAA4qEECAAADK0lEQVR4Xu2cvWsTcRjHo+DkIKiTjiJugqTJ0cG/QcRZ/wJXQTd3ByeHDiLJnS84dHMVBHUSRQUH90pNfmfb6CKi8fqSaj93ae4lzzV3+X7gS9vkeZ7f7/lwEDq0jYYQQgghxFzQ9t0wbTzf3WO/SAllpg3niAlQYJa0uu4W54kxeA96ZykwU4JwnTPFGGLyMqd3nTNFAnFx2cOZIiee//UK5TLsEQWg3D1ZHpxgvShATLCeajsoWKKNaAfuDyVvZuGhu8paURBK1lNtBAVLtBEULNFGULBEG0HBlRfNRUrMqwW/f473GZFQvxXWVQbPD5e4zEGlcXt4eHQvvrdbU2W4zEGn5Yd3+NoovHul4DKzHN69UnCZWQ7vXim8IHzJhWY1vLtIQSRujSInhTNEBppL345R6LiwV+SAUpPCHpETimVYLwpAuRJtBOVKtBHNR4OTFCzRRlCwRBtBwRJtBAVLtBEULNFGeN3wPiVvp/+OtVmJ5qzvmdl1z1kzV8Ql53+q0/6az765gBLyConqN9i/X9hfeyiAYX0S7cCtsi9NOKf2UADDesL6LOGsWsPlx+V8d/Vo3t5x4bzyGA4P8TK1TuBeU0FpxC5T83D/0uBF6h7uXxq8SN3D/Utj80OHl6ltgvAX9y+V2IUm53eUQZQvUT4nvJ8x/e/R14+RiBeeHz4bZfPn6PW3bT908Z7s4d6Vgwsxix13mj15iGb94Ows4bxKwWUY1heF89OGcyoHFypjOZ4zKV7gVjijUjSfrJ/hUqOwdtrwvH2yzN7KkbDUTsKfrLWgufTmSPzsf2F9ZeFitVtwVqBgiTaCgiXaCAqWaCMoWKKNoGCJNoKCJdoICpZoIyhYoo2gYIk2goIl2ggKlmgjKFiijaBgiTaCgiXagLbfu0jBW+m6NdaKAsQEj9Jxl1krChATvBPWiQJ4fviJgiV6yiw+3ThOuRI9ZbzA3aRYSZ4iFx73T1FqUtg3l1DKbrr9960gvBt9f207/Rst332I1U0Iz5tbKGaa4VlzTSQk8X84Fw3PEY3p/70KTxA7UFTeeB13ibPFf1BY1nCeEEIIIYQowl8t5mhjJHw+fQAAAABJRU5ErkJggg=="/>
  </div>
</a>



<a href='cplusplus.htm'><div class='book-cover' style='background-color: #f9f6f1;color: #111111;border: 1px solid #ccc;display: flex;justify-content: center;align-items: center;text-align: center;'>More C++ Books</div></a>
</div>
</div><script>
function copyCode(button) {const code = button.nextElementSibling.innerText;navigator.clipboard.writeText(code).then(() => {button.textContent = 'Copied!';setTimeout(() => { button.textContent = 'Copy'; }, 1500);});}
</script></div>
<style>
.site-footer {margin-top: 60px;padding: 20px 0;border-top: 1px solid #eee;text-align: center;font-size: 14px;}
.site-footer a {text-decoration: none;}
.light-mode .site-footer {color: #777;border-color: #eee;}
.dark-mode .site-footer {color: #888;border-color: #333;}
.light-mode .site-footer a {color: #555;}
.dark-mode .site-footer a {color: #aaa;}
.site-footer a:hover {text-decoration: underline;}    
</style>
<footer class="site-footer">
<nav><a href="https://readbytes.github.io">Home</a> |Email:<script type="text/javascript">
var part1 = 'yinpeng';var part6 = '263';var part2 = Math.pow(2,6);var part3 = String.fromCharCode(part2);var part4 = 'hotmail dot com';var part5 = part1 + String.fromCharCode(part2) + part4;document.write(part1 + part6 + part3 + part4);
</script>
| <a id="mode-toggle" href="#">Toggle Dark Mode</a>
</nav><p>© 2025 — All rights reserved.</p></footer>
<script>
const toggleButton = document.getElementById('mode-toggle');
const body = document.body;
const savedMode = localStorage.getItem('mode') || 'light';
body.classList.add(savedMode + '-mode');
toggleButton.addEventListener('click', () => {
      const isDark = body.classList.contains('dark-mode');
      body.classList.toggle('dark-mode', !isDark);
      body.classList.toggle('light-mode', isDark);
      localStorage.setItem('mode', isDark ? 'light' : 'dark');
});
function copyCode(button) {const code = button.nextElementSibling.innerText;navigator.clipboard.writeText(code).then(() => {button.textContent = 'Copied!';setTimeout(() => { button.textContent = 'Copy'; }, 1500);});}
</script>
</body>
</html>