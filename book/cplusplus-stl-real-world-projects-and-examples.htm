<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>C++ STL Real-World Projects and Examples</title>
<link rel='shortcut icon' href='https://java2s.com/style/favicon.ico'>
<link href="https://fonts.googleapis.com/css2?family=Merriweather&display=swap" rel="stylesheet" />
<link href="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet" />


  <script>
  const mode = localStorage.getItem('mode') || 'light';
  document.documentElement.classList.add(`${mode}-mode`);
  </script>   
<style> 
html {
  scroll-behavior: smooth;
}

body {
  font-family: 'Merriweather', serif;
  margin: 0;
  padding: 2rem 1rem;
  font-size: 15px;
  line-height: 1.5;
  transition: background-color 0.3s, color 0.3s;
}

.container {
  max-width: 700px;
  margin: 0 auto;
  padding: 1rem 2rem;
  box-shadow: 0 0 15px rgba(0,0,0,0.1);
}

h1, h2, h3 {
  font-weight: 600;
  margin-top: 2.5rem;
  margin-bottom: 1rem;
  line-height: 1.2;
}

h1 { font-size: 1.8rem; }
h2 { font-size: 1.4rem; }
h3 { font-size: 1.2rem; }

table {
  width: 100%;
  border-collapse: collapse;
  font-family: sans-serif;
  font-size: 1em;
  margin: 1em 0;
}

th, td {
  padding: 0.6em 1em;
  text-align: left;
  border: 1px solid;
}

tr:nth-child(even) {
  background-color: inherit;
}

tr:hover {
  background-color: inherit;
}

a {
  text-decoration: none;
  transition: color 0.2s;
}

a:hover {
  text-decoration: underline;
}

code {
  color: #d35400;
}

.book-title-chapter {
  font-family: 'Merriweather', serif;
  font-size: 2rem;
  font-weight: bold;
  text-align: center;
  margin-bottom: 2rem;
  border-bottom: 2px solid;
  padding-bottom: 0.5rem;
}

.book-subtitle-chapter {
  text-align: center;
  font-size: 1rem;
  margin-top: -1rem;
  margin-bottom: 2rem;
}

.related-books {
  margin-top: 40px;
}

.related-book-list {
  display: flex;
  flex-wrap: wrap;
  gap: 20px;
}

    .book-cover {
      width: 130px;
      height: 180px;
      font-family: Arial, sans-serif;
      position: relative;
      overflow: hidden;      
      line-height: normal;
      box-shadow: 2px 2px 4px rgba(0,0,0,0.1);
    }
    .book-cover-bottom-stripe {
      position: absolute;
      bottom: 0;
      left: 0;
      height: 5px;
      width: 100%;
    }
    .book-cover-title {
      position: absolute;
      width: 100%;
      text-align: center;
      font-weight: bold;
    }
     
    .book-cover-icon {
      position: absolute;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      align-items: center;
      justify-content: center; 
    }

    .book-cover-author {
      position: absolute;
      bottom: 10px;
      width: 100%;
      text-align: center;
      font-size: 8px;
      color: #333;
    }

.page-footer {
  margin-top: 4rem;
  padding: 1rem 0;
  text-align: center;
  font-size: 0.85rem;
  border-top: 1px solid;
}

.chapter-navi-section {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding-bottom: 10px;
}

.nav-link {
  color: inherit;
  text-decoration: none;
  opacity: 0.5;
  transition: opacity 0.3s ease, text-decoration 0.3s ease;
}

.nav-link:hover {
  opacity: 0.9;
  text-decoration: underline;
}

.prev { text-align: left; }
.toc-link { text-align: center; }
.next { text-align: right; }

.download-section {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 2rem;
  padding: 2rem 1rem;
  max-width: 600px;
  margin: 3rem auto;
  border-radius: 12px;
  box-shadow: 0 4px 10px rgba(0,0,0,0.05);
}

.download-info h2 {
  margin: 0 0 0.5rem;
  font-size: 1.2rem;
}

.format-label {
  margin: 0 0 0.5rem;
  font-size: 0.95rem;
}

.download-buttons {
  display: flex;
  gap: 1rem;
}

.download-button {
  background-color: #4A90E2;
  color: white;
  padding: 0.5em 1.2em;
  border-radius: 25px;
  font-size: 0.95rem;
  text-decoration: none;
  transition: background-color 0.3s ease;
}

.download-button:hover {
  background-color: #357ABD;
}

.code-block {
  position: relative;
  margin-bottom: 1em;
}

.copy-button {
  background: transparent;
  color: white;
  position: absolute;
  top: 8px;
  right: 8px;
  border: none;
  padding: 4px 8px;
  font-size: 12px;
  border-radius: 4px;
  cursor: pointer;
  z-index: 1;
}

.copy-button:hover {
  background-color: #0056b3;
}

.snippet-container {
  overflow: hidden;
}

.snippet-header {
  padding: 0.75rem 1rem;
  cursor: pointer;
  font-size: 1rem;
    background-color: #eeeeee;
    color:  #111111; 
    border-radius: 8px;
    cursor: pointer;
    box-shadow: 0 4px 6px rgba(0,0,0,0.1);  
}

.snippet-body {
  display: none;
  font-family: monospace;
}

.snippet-container.open .snippet-body {
  display: block;
}

.CodeMirror {
  border: 2px solid #ccc;
  border-radius: 4px;
  resize: vertical;
}

/* === Light Mode === */
html.light-mode {
  background-color: #f8f7f5;
  color: #333;
}

html.light-mode .container {
  background: white;
}

html.light-mode .book-title-chapter {
  color: #2c3e50;
  border-color: #ccc;
}
html.light-mode .book-subtitle-chapter{
  color: #888;
}

html.light-mode .page-footer,
html.light-mode .series-name,
html.light-mode .book-subtitle,
html.light-mode .format-label {
  color: #888;
}

html.light-mode .related-books h2 {
  color: #333;
  border-bottom: 2px solid #eee;
}

html.light-mode .book-title {
  color: #fff;
}

html.light-mode .book-cover {
  border: 1px solid #ccc;
}

html.light-mode th {
  background-color: #f2f2f2;
}

html.light-mode tr:nth-child(even) {
  background-color: #fafafa;
}

html.light-mode tr:hover {
  background-color: #e6f7ff;
}

html.light-mode a,
html.light-mode .page-footer a {
  color: #000;
}

/* === Dark Mode === */
html.dark-mode {
  background-color: #181818;
  color: #e0e0e0;
}

html.dark-mode .container {
  background: #222;
}

html.dark-mode .book-title-chapter {
  color: #ddd;
  border-color: #444;
}

html.dark-mode .snippet-header {
    background-color: #333;
    color:  #ddd; 
}


html.dark-mode .book-subtitle-chapter,
html.dark-mode .page-footer,
html.dark-mode .series-name,
html.dark-mode .book-subtitle,
html.dark-mode .book-footer,
html.dark-mode .format-label {
  color: #aaa;
}

html.dark-mode .related-books h2 {
  color: #ddd;
  border-bottom: 2px solid #333;
}

html.dark-mode .book-title {
  color: #fff;
}

html.dark-mode .book-cover {
  border: 1px solid #555;
}

html.dark-mode th {
  background-color: #333;
  color: #fff;
}

html.dark-mode td {
  border-color: #444;
}

html.dark-mode tr:nth-child(even) {
  background-color: #2a2a2a;
}

html.dark-mode tr:hover {
  background-color: #2c3e50;
}

html.dark-mode a,
html.dark-mode .page-footer a {
  color: #eee;
}

    .dialog-backdrop {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: rgba(0,0,0,0.5);
      display: none;
      justify-content: center;
      align-items: center;
      z-index: 10;
    }

    .dialog {
      background: white;
      padding: 20px;
      width: 90vw;
      height: 80vh;
      border-radius: 8px;
      box-shadow: 0 0 20px rgba(0,0,0,0.3);
      display: flex;
      flex-direction: column;
    }
    .dialog-content {
      display: flex;
      flex: 1;
      gap: 20px;
      margin-top: 10px;
    }
    .dialog h2 {
      margin-top: 0;
    }

    .textarea_dialog {
      width: 50%;
      height: 100%;
      resize: none;
      font-family: monospace;
      font-size: 14px;
      padding: 10px;
      box-sizing: border-box;
      border: 1px solid #ccc;
    }

    .iframe_dialog {
      width: 50%;
      height: 100%;
      border: 1px solid #ccc;
    }
    .controls_dialog {
      display: flex;
      justify-content: space-between;
      margin-top: 10px;
    }    
    button { padding: 0.5em 1em; background: green; color: white; border: none; cursor: pointer; }
    button:hover { background: #1e7e34; }
    .result_iframe { width:99%; height:200px; margin-top: 1em;  resize: both;border:1px solid #ccc;}        
</style>
</head>
<body> 
  <div class="container">
    <div class = "chapter-navi-section">
<a href="cplusplus-stl-performance-considerations-and-best-practices.htm" class="nav-button prev">←</a>
<a href='cplusplus-stl.htm#real-world-projects-and-examples' class="nav-button toc-link">Index</a>
<a href="" class="nav-button next"></a>
</div>

    <h1 class="book-title-chapter" id = 'top'>Real-World Projects and Examples</h1>
    <h3 class="book-subtitle-chapter">C++ STL</h3>   
    <!-- <h1 class ="chapter-title"></h1> -->
    <h2 id='building-a-contact-manager-using-stl-containers-and-algorithms'>16.1 Building a Contact Manager Using STL Containers and Algorithms</h2><p>In this section, we’ll build a simple contact manager using STL containers and algorithms. This project demonstrates practical use of <code>std::vector</code>, <code>std::map</code>, and STL algorithms for storing, managing, and querying contact data.</p><h4 id="overview">Overview</h4><p>The application maintains a list of contacts, each with a name, phone number, and email. It supports CRUD (Create, Read, Update, Delete) operations, along with search and sort functionality. The primary data structure will be a <code>std::vector&lt;Contact&gt;</code>, which allows efficient iteration and manipulation.</p><h4 id="contact-structure">Contact Structure</h4><p>We define a simple <code>Contact</code> struct:</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;algorithm&gt;

struct Contact {
    std::string name;
    std::string phone;
    std::string email;
};

void printContact(const Contact&amp; c) {
    std::cout &lt;&lt; "Name: " &lt;&lt; c.name
              &lt;&lt; ", Phone: " &lt;&lt; c.phone
              &lt;&lt; ", Email: " &lt;&lt; c.email &lt;&lt; "\n";
}</code></pre>
</div><h4 id="crud-and-utility-functions">CRUD and Utility Functions</h4><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-cpp">void addContact(std::vector&lt;Contact&gt;&amp; contacts, const Contact&amp; newContact) {
    contacts.push_back(newContact);
}

void listContacts(const std::vector&lt;Contact&gt;&amp; contacts) {
    std::cout &lt;&lt; "--- Contact List ---\n";
    for (const auto&amp; c : contacts)
        printContact(c);
}

void deleteContact(std::vector&lt;Contact&gt;&amp; contacts, const std::string&amp; name) {
    contacts.erase(std::remove_if(contacts.begin(), contacts.end(),
        [&amp;name](const Contact&amp; c) {
            return c.name == name;
        }), contacts.end());
}

void searchContacts(const std::vector&lt;Contact&gt;&amp; contacts, const std::string&amp; query) {
    std::cout &lt;&lt; "--- Search Results ---\n";
    for (const auto&amp; c : contacts) {
        if (c.name.find(query) != std::string::npos ||
            c.email.find(query) != std::string::npos) {
            printContact(c);
        }
    }
}

void sortContactsByName(std::vector&lt;Contact&gt;&amp; contacts) {
    std::sort(contacts.begin(), contacts.end(),
        [](const Contact&amp; a, const Contact&amp; b) {
            return a.name &lt; b.name;
        });
}</code></pre>
</div><h4 id="interactive-cli-driver">Interactive CLI Driver</h4><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-cpp">int main() {
    std::vector&lt;Contact&gt; contacts;
    int choice;

    while (true) {
        std::cout &lt;&lt; "\nContact Manager\n"
                  &lt;&lt; "1. Add Contact\n"
                  &lt;&lt; "2. List Contacts\n"
                  &lt;&lt; "3. Delete Contact\n"
                  &lt;&lt; "4. Search Contacts\n"
                  &lt;&lt; "5. Sort Contacts by Name\n"
                  &lt;&lt; "0. Exit\n"
                  &lt;&lt; "Enter choice: ";
        std::cin &gt;&gt; choice;
        std::cin.ignore();

        if (choice == 0) break;

        if (choice == 1) {
            Contact c;
            std::cout &lt;&lt; "Name: "; std::getline(std::cin, c.name);
            std::cout &lt;&lt; "Phone: "; std::getline(std::cin, c.phone);
            std::cout &lt;&lt; "Email: "; std::getline(std::cin, c.email);
            addContact(contacts, c);
        } else if (choice == 2) {
            listContacts(contacts);
        } else if (choice == 3) {
            std::string name;
            std::cout &lt;&lt; "Enter name to delete: ";
            std::getline(std::cin, name);
            deleteContact(contacts, name);
        } else if (choice == 4) {
            std::string query;
            std::cout &lt;&lt; "Search by name or email: ";
            std::getline(std::cin, query);
            searchContacts(contacts, query);
        } else if (choice == 5) {
            sortContactsByName(contacts);
            std::cout &lt;&lt; "Contacts sorted by name.\n";
        } else {
            std::cout &lt;&lt; "Invalid choice.\n";
        }
    }

    return 0;
}</code></pre>
</div><h4 id="summary">Summary</h4><p>This example illustrates how STL containers (<code>std::vector</code>) and algorithms (<code>std::sort</code>, <code>std::remove_if</code>, and lambda expressions) can be effectively combined to build a functional contact manager. It demonstrates core STL principles—efficiency, clarity, and expressive code—while remaining extensible for future enhancements such as file I/O, duplicate checking, or GUI integration.</p><div class = "chapter-navi-section">
<a href="#top" class="nav-button prev">↑</a>
<a href='cplusplus-stl.htm#real-world-projects-and-examples' class="nav-button toc-link">Index</a>
<a href="#bottom" class="nav-button next">↓</a>
</div>
<h2 id='implementing-a-simple-cache-with-std-unordered-map'>16.2 Implementing a Simple Cache with <code>std::unordered_map</code></h2><p>A cache is a data structure that temporarily stores frequently accessed data to speed up retrieval. The Standard Template Library (STL) provides <code>std::unordered_map</code>, a hash table that offers average constant-time complexity for insertions and lookups—ideal for implementing a simple cache.</p><p>In this section, we’ll design a lightweight key-value cache supporting fast access, insertion, and a basic Least Recently Used (LRU) eviction policy.</p><h4 id="design-overview">Design Overview</h4><p>We use <code>std::unordered_map</code> to map keys to values for fast access. To implement an eviction strategy such as LRU, we also use a <code>std::list</code> to track access order and a second map from keys to list iterators for constant-time updates.</p><h4 id="cache-implementation">Cache Implementation</h4><div class="code-block"><button class="copy-button" onclick="copyCode(this)">📋</button>
 <pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;unordered_map&gt;
#include &lt;list&gt;
#include &lt;string&gt;

template&lt;typename Key, typename Value&gt;
class LRUCache {
    using ListIt = typename std::list&lt;Key&gt;::iterator;

    size_t capacity;
    std::unordered_map&lt;Key, std::pair&lt;Value, ListIt&gt;&gt; cache;
    std::list&lt;Key&gt; usage;

public:
    LRUCache(size_t cap) : capacity(cap) {}

    void put(const Key&amp; key, const Value&amp; value) {
        auto it = cache.find(key);
        if (it != cache.end()) {
            // Key exists: update value and usage
            it-&gt;second.first = value;
            usage.erase(it-&gt;second.second);
            usage.push_front(key);
            it-&gt;second.second = usage.begin();
        } else {
            // Evict if full
            if (cache.size() &gt;= capacity) {
                Key lru = usage.back();
                usage.pop_back();
                cache.erase(lru);
            }
            usage.push_front(key);
            cache[key] = { value, usage.begin() };
        }
    }

    bool get(const Key&amp; key, Value&amp; value) {
        auto it = cache.find(key);
        if (it == cache.end()) return false;

        // Move accessed key to front
        usage.erase(it-&gt;second.second);
        usage.push_front(key);
        it-&gt;second.second = usage.begin();
        value = it-&gt;second.first;
        return true;
    }

    void display() const {
        std::cout &lt;&lt; "Cache content (most recent first): ";
        for (const auto&amp; k : usage)
            std::cout &lt;&lt; k &lt;&lt; " ";
        std::cout &lt;&lt; "\n";
    }
};
 
int main() {
    LRUCache&lt;std::string, std::string&gt; cache(3);

    cache.put("a", "apple");
    cache.put("b", "banana");
    cache.put("c", "cherry");
    cache.display();

    std::string result;
    if (cache.get("a", result)) {
        std::cout &lt;&lt; "Got: " &lt;&lt; result &lt;&lt; "\n";
    }

    cache.put("d", "date");  // Evicts "b"
    cache.display();

    return 0;
}</code></pre>
</div><h4 id="conclusion">Conclusion</h4><p>Using <code>std::unordered_map</code> enables efficient key-value access in constant average time. Combined with a <code>std::list</code>, we implement an LRU eviction policy while maintaining performance. This cache structure is useful in applications such as memoization, image processing, and database query optimization. It also demonstrates how STL containers can be composed for practical, real-world systems.</p><div class = "chapter-navi-section">
<a href="#top" class="nav-button prev">↑</a>
<a href='cplusplus-stl.htm#real-world-projects-and-examples' class="nav-button toc-link">Index</a>
<a href="#bottom" class="nav-button next">↓</a>
</div>
<h2 id='text-processing-and-analysis-using-stl-algorithms'>16.3 Text Processing and Analysis Using STL Algorithms</h2><p>Text processing is a common task in many real-world applications such as search engines, log analyzers, and natural language processing tools. The C++ Standard Template Library (STL) offers powerful containers and algorithms that make parsing, tokenizing, and analyzing text efficient and expressive.</p><p>This section walks through a practical example that reads a block of text, splits it into words (tokenization), and performs frequency analysis using STL tools such as <code>std::map</code>, <code>std::istringstream</code>, <code>std::for_each</code>, and <code>std::accumulate</code>.</p><h4 id="tokenization-and-word-counting">Tokenization and Word Counting</h4><p>We’ll write a program that processes an input text and counts the frequency of each word.</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">📋</button>
 <pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;sstream&gt;
#include &lt;map&gt;
#include &lt;string&gt;
#include &lt;algorithm&gt;
#include &lt;cctype&gt;

// Helper to convert string to lowercase
std::string to_lower(const std::string&amp; word) {
    std::string result = word;
    std::transform(result.begin(), result.end(), result.begin(),
                   [](unsigned char c) { return std::tolower(c); });
    return result;
}

// Helper to remove punctuation from a word
std::string strip_punctuation(const std::string&amp; word) {
    std::string result;
    std::copy_if(word.begin(), word.end(), std::back_inserter(result),
                 [](unsigned char c) { return std::isalnum(c); });
    return result;
}

int main() {
    std::string text =
        "The quick brown fox jumps over the lazy dog. "
        "The dog, surprised, barked loudly!";

    std::istringstream iss(text);
    std::map&lt;std::string, int&gt; word_count;
    std::string word;

    while (iss &gt;&gt; word) {
        word = strip_punctuation(to_lower(word));
        ++word_count[word];
    }

    std::cout &lt;&lt; "Word Frequencies:\n";
    for (const auto&amp; [key, count] : word_count) {
        std::cout &lt;&lt; key &lt;&lt; ": " &lt;&lt; count &lt;&lt; "\n";
    }

    return 0;
}</code></pre>
</div><h4 id="explanation">Explanation</h4><ul>
 <li><strong><code>std::istringstream</code></strong> is used for splitting the string into whitespace-separated words.</li>
 <li><strong><code>std::map</code></strong> is used to associate each unique word (key) with its count (value).</li>
 <li><strong><code>std::transform</code></strong> and <strong><code>std::copy_if</code></strong> help normalize words (convert to lowercase and remove punctuation).</li>
 <li><strong>Structured bindings</strong> (C++17) are used in the <code>for</code> loop for concise iteration over map entries.</li>
</ul><h4 id="enhancing-with-std-accumulate-optional-insight">Enhancing with <code>std::accumulate</code> (Optional Insight)</h4><p>If the word counts were stored in a <code>std::vector&lt;std::pair&lt;std::string, int&gt;&gt;</code>, we could use <code>std::accumulate</code> to sum total word counts:</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-cpp">#include &lt;numeric&gt;
#include &lt;vector&gt;

int total_words = std::accumulate(
    word_count.begin(), word_count.end(), 0,
    [](int sum, const auto&amp; pair) { return sum + pair.second; });

std::cout &lt;&lt; "Total words: " &lt;&lt; total_words &lt;&lt; "\n";</code></pre>
</div><p>This demonstrates how STL algorithms allow elegant expression of complex logic.</p><h4 id="conclusion">Conclusion</h4><p>Text analysis with STL is efficient and modular. By combining <code>std::map</code>, <code>std::transform</code>, and <code>std::accumulate</code>, developers can perform non-trivial tasks like word frequency analysis with concise and maintainable code. These patterns are widely applicable in building tools for data analysis, indexing, and report generation.</p><div class = "chapter-navi-section">
<a href="#top" class="nav-button prev">↑</a>
<a href='cplusplus-stl.htm#real-world-projects-and-examples' class="nav-button toc-link">Index</a>
<a href="#bottom" class="nav-button next">↓</a>
</div>
<h2 id='interactive-cli-to-do-list-application-using-stl'>16.4 Interactive CLI To-Do List Application Using STL</h2><p>In this section, we'll build a simple command-line To-Do List application using standard STL components like <code>std::vector</code>, <code>std::string</code>, and <code>std::algorithm</code>. The app will allow users to add tasks, list them, mark them as done, remove them, and sort them. This example demonstrates how STL containers and algorithms can be combined to manage state and user interaction in a lightweight yet powerful way.</p><h4 id="features-and-design">Features and Design</h4><p>The application supports:</p><ul>
 <li>Adding a task</li>
 <li>Listing all tasks</li>
 <li>Marking tasks as complete</li>
 <li>Removing tasks</li>
 <li>Sorting tasks alphabetically</li>
</ul><p>We'll define a <code>Task</code> struct and store the task list in a <code>std::vector</code>. We'll use <code>std::getline</code> for input parsing and <code>std::sort</code>, <code>std::remove_if</code>, and <code>std::for_each</code> to manipulate the task list.</p><h4 id="complete-code-example">Complete Code Example</h4><div class="code-block"><button class="copy-button" onclick="copyCode(this)">📋</button>
 <pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;string&gt;
#include &lt;iomanip&gt;

struct Task {
    std::string description;
    bool completed = false;
};

void add_task(std::vector&lt;Task&gt;&amp; tasks, const std::string&amp; desc) {
    tasks.push_back({desc, false});
}

void list_tasks(const std::vector&lt;Task&gt;&amp; tasks) {
    std::cout &lt;&lt; "\nTo-Do List:\n";
    for (size_t i = 0; i &lt; tasks.size(); ++i) {
        std::cout &lt;&lt; std::setw(2) &lt;&lt; i + 1 &lt;&lt; ". ["
                  &lt;&lt; (tasks[i].completed ? 'x' : ' ') &lt;&lt; "] "
                  &lt;&lt; tasks[i].description &lt;&lt; "\n";
    }
}

void mark_done(std::vector&lt;Task&gt;&amp; tasks, size_t index) {
    if (index &lt; 1 || index &gt; tasks.size()) {
        std::cout &lt;&lt; "Invalid task number.\n";
        return;
    }
    tasks[index - 1].completed = true;
}

void remove_task(std::vector&lt;Task&gt;&amp; tasks, size_t index) {
    if (index &lt; 1 || index &gt; tasks.size()) {
        std::cout &lt;&lt; "Invalid task number.\n";
        return;
    }
    tasks.erase(tasks.begin() + index - 1);
}

void sort_tasks(std::vector&lt;Task&gt;&amp; tasks) {
    std::sort(tasks.begin(), tasks.end(), [](const Task&amp; a, const Task&amp; b) {
        return a.description &lt; b.description;
    });
}

int main() {
    std::vector&lt;Task&gt; tasks;
    std::string command;

    std::cout &lt;&lt; "Simple CLI To-Do List\nType 'help' for commands.\n";

    while (true) {
        std::cout &lt;&lt; "\n&gt; ";
        std::getline(std::cin, command);

        if (command == "exit") break;
        else if (command == "help") {
            std::cout &lt;&lt; "Commands:\n"
                      &lt;&lt; "  add &lt;task description&gt;\n"
                      &lt;&lt; "  list\n"
                      &lt;&lt; "  done &lt;task number&gt;\n"
                      &lt;&lt; "  remove &lt;task number&gt;\n"
                      &lt;&lt; "  sort\n"
                      &lt;&lt; "  exit\n";
        } else if (command.rfind("add ", 0) == 0) {
            add_task(tasks, command.substr(4));
        } else if (command == "list") {
            list_tasks(tasks);
        } else if (command.rfind("done ", 0) == 0) {
            mark_done(tasks, std::stoi(command.substr(5)));
        } else if (command.rfind("remove ", 0) == 0) {
            remove_task(tasks, std::stoi(command.substr(7)));
        } else if (command == "sort") {
            sort_tasks(tasks);
            std::cout &lt;&lt; "Tasks sorted.\n";
        } else {
            std::cout &lt;&lt; "Unknown command.\n";
        }
    }

    std::cout &lt;&lt; "Goodbye!\n";
    return 0;
}</code></pre>
</div><h4 id="explanation">Explanation</h4><ul>
 <li><strong><code>std::vector&lt;Task&gt;</code></strong> is used for dynamic task storage.</li>
 <li><strong><code>std::sort</code></strong> helps alphabetically organize tasks.</li>
 <li><strong><code>std::getline</code></strong> and <code>std::stoi</code> handle basic command parsing.</li>
 <li>Input is matched against command strings to dispatch corresponding functions.</li>
 <li>Index validation ensures safety when modifying the task list.</li>
</ul><h4 id="conclusion">Conclusion</h4><p>This to-do list project illustrates how STL containers and algorithms can be effectively used to build a real, interactive application. With minimal code and maximum clarity, STL enables developers to manage state, process input, and manipulate data efficiently — essential skills in modern C++ programming.</p><div class = "chapter-navi-section">
<a href="#top" class="nav-button prev">↑</a>
<a href='cplusplus-stl.htm#real-world-projects-and-examples' class="nav-button toc-link">Index</a>
<a href="#bottom" class="nav-button next">↓</a>
</div>
<h2 id='advanced-custom-container-implementation'>16.5 Advanced: Custom Container Implementation</h2><p>Creating a custom container compatible with the C++ Standard Template Library (STL) is a powerful exercise in understanding how STL algorithms and iterators work. In this section, we’ll build a minimal custom container that supports <code>insert</code>, <code>erase</code>, and iteration, and is compatible with standard STL algorithms like <code>std::for_each</code> and <code>std::find</code>.</p><p>To be STL-compatible, a custom container should:</p><ul>
 <li>Provide a nested <code>iterator</code> type or an external iterator class.</li>
 <li>Implement <code>begin()</code> and <code>end()</code> member functions.</li>
 <li>Follow the iterator traits and category conventions if interoperability with STL algorithms is desired.</li>
</ul><h3 id="key-components-of-an-stl-compatible-container">Key Components of an STL-Compatible Container</h3><ol>
 <li><strong>Container Interface</strong>: Functions like <code>insert()</code>, <code>erase()</code>, <code>size()</code>, <code>operator[]</code>, etc.</li>
 <li><strong>Iterator Implementation</strong>: Typically a nested class that defines standard iterator operations.</li>
 <li><strong>Traits and Type Aliases</strong>: Such as <code>value_type</code>, <code>iterator</code>, and <code>const_iterator</code>.</li>
</ol><h3 id="example-customvector-a-minimal-dynamic-array">Example: CustomVector A Minimal Dynamic Array</h3><div class="code-block"><button class="copy-button" onclick="copyCode(this)">📋</button>
 <pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;iterator&gt;

template&lt;typename T&gt;
class CustomVector {
private:
    T* data;
    size_t cap;
    size_t len;

public:
    CustomVector() : data(nullptr), cap(0), len(0) {}

    ~CustomVector() { delete[] data; }

    void insert(const T&amp; value) {
        if (len &gt;= cap) {
            size_t new_cap = cap == 0 ? 1 : cap * 2;
            T* new_data = new T[new_cap];
            std::copy(data, data + len, new_data);
            delete[] data;
            data = new_data;
            cap = new_cap;
        }
        data[len++] = value;
    }

    void erase(size_t index) {
        if (index &gt;= len) return;
        for (size_t i = index; i + 1 &lt; len; ++i)
            data[i] = data[i + 1];
        --len;
    }

    T&amp; operator[](size_t index) { return data[index]; }
    const T&amp; operator[](size_t index) const { return data[index]; }

    size_t size() const { return len; }

    // Iterator definition
    class iterator {
    private:
        T* ptr;
    public:
        using iterator_category = std::forward_iterator_tag;
        using value_type = T;
        using reference = T&amp;;
        using pointer = T*;
        using difference_type = std::ptrdiff_t;

        iterator(T* p) : ptr(p) {}

        T&amp; operator*() const { return *ptr; }
        T* operator-&gt;() const { return ptr; }

        iterator&amp; operator++() { ++ptr; return *this; }
        iterator operator++(int) { iterator tmp = *this; ++ptr; return tmp; }

        bool operator==(const iterator&amp; other) const { return ptr == other.ptr; }
        bool operator!=(const iterator&amp; other) const { return ptr != other.ptr; }
    };

    iterator begin() { return iterator(data); }
    iterator end() { return iterator(data + len); }
};

int main() {
    CustomVector&lt;int&gt; vec;
    vec.insert(5);
    vec.insert(10);
    vec.insert(15);

    std::cout &lt;&lt; "Values:";
    std::for_each(vec.begin(), vec.end(), [](int x) {
        std::cout &lt;&lt; " " &lt;&lt; x;
    });
    std::cout &lt;&lt; "\n";

    auto it = std::find(vec.begin(), vec.end(), 10);
    if (it != vec.end())
        std::cout &lt;&lt; "Found value: " &lt;&lt; *it &lt;&lt; "\n";

    vec.erase(1);
    std::cout &lt;&lt; "After erase:";
    for (auto v : vec) {
        std::cout &lt;&lt; " " &lt;&lt; v;
    }
}</code></pre>
</div><h3 id="explanation">Explanation</h3><ul>
 <li><strong>Dynamic Buffer Management</strong>: <code>insert()</code> reallocates memory when needed, mimicking <code>std::vector</code> growth.</li>
 <li><strong>Custom Iterator</strong>: Implements basic forward iterator operations and traits, enabling use with STL algorithms.</li>
 <li><strong>Iterator Category</strong>: Declared as <code>std::forward_iterator_tag</code>, so it's compatible with a wide range of STL functions.</li>
 <li><strong>STL Compatibility</strong>: <code>std::for_each</code> and <code>std::find</code> work seamlessly with our container.</li>
</ul><h3 id="conclusion">Conclusion</h3><p>This example demonstrates how to implement a custom container that integrates smoothly with the STL ecosystem. While production-grade containers require more features (exception safety, const-iterators, move semantics), this minimal example highlights the core components required for compatibility. Building such containers deepens understanding of how STL components interact and offers powerful customization opportunities for advanced use cases.</p><div class = "chapter-navi-section">
<a href="cplusplus-stl-performance-considerations-and-best-practices.htm" class="nav-button prev">←</a>
<a href='cplusplus-stl.htm#real-world-projects-and-examples' class="nav-button toc-link">Index</a>
<a href="" class="nav-button next"></a>
</div>
<section class="download-section">
  <div class="book-cover" style="background-color: #f9f6f1;border: 1px solid #ccc;"> 
    <div class="book-cover-title" style="font-size: 20px;color: #333;top: 20px;">C++ STL</div>
    <div class="book-cover-author">readbytes</div>
    <div class="book-cover-bottom-stripe" style="background-color: #333;"></div>
    <img class="book-cover-icon" style="width: 90px;height: 90px;top: 70px;" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFoAAABaCAYAAAA4qEECAAADK0lEQVR4Xu2cvWsTcRjHo+DkIKiTjiJugqTJ0cG/QcRZ/wJXQTd3ByeHDiLJnS84dHMVBHUSRQUH90pNfmfb6CKi8fqSaj93ae4lzzV3+X7gS9vkeZ7f7/lwEDq0jYYQQgghxFzQ9t0wbTzf3WO/SAllpg3niAlQYJa0uu4W54kxeA96ZykwU4JwnTPFGGLyMqd3nTNFAnFx2cOZIiee//UK5TLsEQWg3D1ZHpxgvShATLCeajsoWKKNaAfuDyVvZuGhu8paURBK1lNtBAVLtBEULNFGULBEG0HBlRfNRUrMqwW/f473GZFQvxXWVQbPD5e4zEGlcXt4eHQvvrdbU2W4zEGn5Yd3+NoovHul4DKzHN69UnCZWQ7vXim8IHzJhWY1vLtIQSRujSInhTNEBppL345R6LiwV+SAUpPCHpETimVYLwpAuRJtBOVKtBHNR4OTFCzRRlCwRBtBwRJtBAVLtBEULNFGeN3wPiVvp/+OtVmJ5qzvmdl1z1kzV8Ql53+q0/6az765gBLyConqN9i/X9hfeyiAYX0S7cCtsi9NOKf2UADDesL6LOGsWsPlx+V8d/Vo3t5x4bzyGA4P8TK1TuBeU0FpxC5T83D/0uBF6h7uXxq8SN3D/Utj80OHl6ltgvAX9y+V2IUm53eUQZQvUT4nvJ8x/e/R14+RiBeeHz4bZfPn6PW3bT908Z7s4d6Vgwsxix13mj15iGb94Ows4bxKwWUY1heF89OGcyoHFypjOZ4zKV7gVjijUjSfrJ/hUqOwdtrwvH2yzN7KkbDUTsKfrLWgufTmSPzsf2F9ZeFitVtwVqBgiTaCgiXaCAqWaCMoWKKNoGCJNoKCJdoICpZoIyhYoo2gYIk2goIl2ggKlmgjKFiijaBgiTaCgiXagLbfu0jBW+m6NdaKAsQEj9Jxl1krChATvBPWiQJ4fviJgiV6yiw+3ThOuRI9ZbzA3aRYSZ4iFx73T1FqUtg3l1DKbrr9960gvBt9f207/Rst332I1U0Iz5tbKGaa4VlzTSQk8X84Fw3PEY3p/70KTxA7UFTeeB13ibPFf1BY1nCeEEIIIYQowl8t5mhjJHw+fQAAAABJRU5ErkJggg=="/>
  </div>
  <div class="download-info">
    <h2 id='bottom'>Download This Ebook</h2>
    <p class="format-label">Available formats:</p>
    <div class="download-buttons">
      <a href="cplusplus-stl.pdf" class="download-button">📄 PDF</a>
      <a href="cplusplus-stl.epub" class="download-button">📘 EPUB</a>
    </div>
  </div>
</section><div class='related-books'>
<h2>C++ Introduction Books</h2>
<div class='related-book-list'>
<a href="cplusplus-for-beginners.htm">
<div class="book-cover" style="background-color: #f9f6f1;border: 1px solid #ccc;"> 
    <div class="book-cover-title" style="font-size: 18px;color: #333;top: 20px;">C++ for Beginners</div>
    <div class="book-cover-author">readbytes</div>
    <div class="book-cover-bottom-stripe" style="background-color: #333;"></div>
    <img class="book-cover-icon" style="width: 90px;height: 90px;top: 70px;" src="data:image/png;base64,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"/>
  </div>
</a>


<a href="cplusplus-syntax.htm">
<div class="book-cover" style="background-color: #f9f6f1;border: 1px solid #ccc;"> 
    <div class="book-cover-title" style="font-size: 20px;color: #333;top: 20px;">C++ Syntax</div>
    <div class="book-cover-author">readbytes</div>
    <div class="book-cover-bottom-stripe" style="background-color: #333;"></div>
    <img class="book-cover-icon" style="width: 90px;height: 90px;top: 70px;" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFoAAABaCAYAAAA4qEECAAAFZ0lEQVR4Xu2dy4scVRSH8ye0iYtkERcmzgjT2OYBuhNREMVXBh/TgsYQx5ULDYTgVl3EFyg6uFJBV76IEXdKXAVBJCgISSTRGRmZiZlADBo6M5kp+3ZbnXt/p7q6btWtc++pqQPfpu/p7vP7UnSqi+m6GzbkrMbYO50u0Tqjgx5Kqe4brSa8+XplFf0UroQ3GbDltqNRs70Y3Tw5G22//2SXU0Fyy5MXc6GyqYyYWwd9WdfGbW9uxRe9vvlBtOvZKLrpwTOiUDO7QjlALxu3zWxFf5mq++RF/YU27/40au39lwSQAspygXICwhfRY2rhv5Z6URxcEuoAQUkuQV/oM7HwSN45vUoGlwaKKQOrI1t9zuhPaD19mQwtEZRSFrq71M/sqh3JMSikTHSH6LdXeoN6Ag4rlV3Ta0RG2aTKjhfU/6Q4rGRQAgf62QhKHnzjk3wKlwRK4EI7qq99g4wf3NR8nwwqmfE9s0QAF8olOarjB1QDDisZDM+NIbqhXYXDQaWDwbnRPj46xtkGDiodDM6N7nYgWl2hwkEl09r7DwnOzZbbr131G4iemFokw0oGQ/ug2XVKRI9PzpJhJYOhfdB66m8qevsDp8iwksHQPqi8aAzsi1o0E7VoJioteuzh30lgX1RaNIb1SS2aiVo0E5UVPTH1Fwnrk8qKxqC+qUUzUYtmwovoL49dioYV9uZhx/4VEjRmWM2fp70uYRc9qrA/DxhSZ1RhvyuCEL1wfiU6PXulB/bnAUPqnJnv8+cSTtEv7HeFd9G4XpyzJGQaWLjuisqJxoCjeOVjc572y7THBayim4+cNUKdONkhPUXBgKO495AxUrTvVdrjAq+ij//k/i9UMeAo7jlojFSLzsLE4/ZfuyspuvXYb0Yo16IxXBZQ9DOv0x4XsIqeOjRvhPri20ukpwgYLgt3HTBGir75kfa4gFU01h373f5ZA4bLChauu4BNdPtF82hWhT1FuHVfh4TLCtbR47SnKKWKTqu5hWXSXwQMZsOBGZzOLOzPA7voNz66QPpcgMHy8Py7OG2/sC8P7KLjurK8RvqLgMFsmDmC05mF/XkoVbTOjinz1E4V9uSl6I+AsF6YoT1FYROtwLpzeo705AFD2YKF6y5gFf3oQfPM48h3w8+jD3+4ZIDrOnGYtz7vgyHTuBvOo7/+nva4gFW0zTdDLFyPGdN+BBQXhkyDfDN8jfa4gFW0zbWOH365bIDrMXqYE7/2wZBpoOhKXOuwEZ0VDGTLuhD98+kO6bEFA9lyXxWvRyuwcN0GdccFDGTLe1+Z87Rfoj0uEC0aw+QBC9dd4V10XMsraz2wPw0Mk4WVq33WcID/C/tdwS766uqwiP3C/jQwTBZGFfa7gl204rnDC5hvUNg7DAySlWH1yTHa6xIvol2AQUKnFs2ESNHjk3MkSOiIFI0hJFCLZqIWzYQ40c0nLpAQEhAnGgNIoRbNRC2aCVGid6b8CCh0RInG4SVRi2YiUXSIN68ae8juR0ChkSg6xNux4eDSSLwdW4g3GMTBpZF4g0EFBvUNDi4N3a0SHeRNYCfaS2RwaWii+1s/xQ+oRQzsCxxaIoOjGe8fHdKNunFoaWzSdh/SRQd363kcXBrax4a5eVm8EMJmCmn33pDA5t2f0aMZRStUM4bnBAeXhu4SPfdKb/C54Q0OLomRklWFsoUTDi8F3d11N759A/o1quF5UzIcXgq6sy7n0GtiwZN6L4RCygIDSAB9oc/UwiOba+NIDBEy+tmF1ZGMhZ/ZijK3Qh3f8wcJEyJOt0LVC19UR12harbPOdncFzfWDQGVTb8KlwT6KlyNertqHffbVSdVo96A3ar+A5kzbYSE7G+UAAAAAElFTkSuQmCC"/>
  </div>
</a>


<a href="cplusplus-stl.htm">
<div class="book-cover" style="background-color: #f9f6f1;border: 1px solid #ccc;"> 
    <div class="book-cover-title" style="font-size: 20px;color: #333;top: 20px;">C++ STL</div>
    <div class="book-cover-author">readbytes</div>
    <div class="book-cover-bottom-stripe" style="background-color: #333;"></div>
    <img class="book-cover-icon" style="width: 90px;height: 90px;top: 70px;" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFoAAABaCAYAAAA4qEECAAADK0lEQVR4Xu2cvWsTcRjHo+DkIKiTjiJugqTJ0cG/QcRZ/wJXQTd3ByeHDiLJnS84dHMVBHUSRQUH90pNfmfb6CKi8fqSaj93ae4lzzV3+X7gS9vkeZ7f7/lwEDq0jYYQQgghxFzQ9t0wbTzf3WO/SAllpg3niAlQYJa0uu4W54kxeA96ZykwU4JwnTPFGGLyMqd3nTNFAnFx2cOZIiee//UK5TLsEQWg3D1ZHpxgvShATLCeajsoWKKNaAfuDyVvZuGhu8paURBK1lNtBAVLtBEULNFGULBEG0HBlRfNRUrMqwW/f473GZFQvxXWVQbPD5e4zEGlcXt4eHQvvrdbU2W4zEGn5Yd3+NoovHul4DKzHN69UnCZWQ7vXim8IHzJhWY1vLtIQSRujSInhTNEBppL345R6LiwV+SAUpPCHpETimVYLwpAuRJtBOVKtBHNR4OTFCzRRlCwRBtBwRJtBAVLtBEULNFGeN3wPiVvp/+OtVmJ5qzvmdl1z1kzV8Ql53+q0/6az765gBLyConqN9i/X9hfeyiAYX0S7cCtsi9NOKf2UADDesL6LOGsWsPlx+V8d/Vo3t5x4bzyGA4P8TK1TuBeU0FpxC5T83D/0uBF6h7uXxq8SN3D/Utj80OHl6ltgvAX9y+V2IUm53eUQZQvUT4nvJ8x/e/R14+RiBeeHz4bZfPn6PW3bT908Z7s4d6Vgwsxix13mj15iGb94Ows4bxKwWUY1heF89OGcyoHFypjOZ4zKV7gVjijUjSfrJ/hUqOwdtrwvH2yzN7KkbDUTsKfrLWgufTmSPzsf2F9ZeFitVtwVqBgiTaCgiXaCAqWaCMoWKKNoGCJNoKCJdoICpZoIyhYoo2gYIk2goIl2ggKlmgjKFiijaBgiTaCgiXagLbfu0jBW+m6NdaKAsQEj9Jxl1krChATvBPWiQJ4fviJgiV6yiw+3ThOuRI9ZbzA3aRYSZ4iFx73T1FqUtg3l1DKbrr9960gvBt9f207/Rst332I1U0Iz5tbKGaa4VlzTSQk8X84Fw3PEY3p/70KTxA7UFTeeB13ibPFf1BY1nCeEEIIIYQowl8t5mhjJHw+fQAAAABJRU5ErkJggg=="/>
  </div>
</a>



<a href='cplusplus.htm'><div class='book-cover' style='background-color: #f9f6f1;color: #111111;border: 1px solid #ccc;display: flex;justify-content: center;align-items: center;text-align: center;'>More C++ Books</div></a>
</div>
</div>
  </div>
  <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/prism.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
  
  <script>
    function copyCode(button) {
      const code = button.nextElementSibling.innerText;
      navigator.clipboard.writeText(code).then(() => {
        button.textContent = 'Copied!';
        setTimeout(() => { button.textContent = 'Copy'; }, 1500);
      });
    }
  </script>  
<div id="floatingLog" aria-live="polite" role="alert"></div>
<footer class="page-footer">
    <nav>
      <a href="https://readbytes.github.io">Home</a> | 
      Email:<script language="JavaScript" type="text/javascript">
var part1 = 'yinpeng';var part6 = '263';var part2 = Math.pow(2,6);var part3 = String.fromCharCode(part2);var part4 = 'hotmail dot com';var part5 = part1 + String.fromCharCode(part2) + part4;document.write(part1 + part6 + part3 + part4);
</script>
    </nav>
  <p>© 2025 — All rights reserved.</p>    
  </footer>

</body>
</html>