<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>C for Beginners Data Structures in C</title>
<link rel='shortcut icon' href='https://java2s.com/style/favicon.ico'>
<link href="https://fonts.googleapis.com/css2?family=Merriweather&display=swap" rel="stylesheet" />
<link href="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet" />


  <script>
  const mode = localStorage.getItem('mode') || 'light';
  document.documentElement.classList.add(`${mode}-mode`);
  </script>   
<style> 
html {
  scroll-behavior: smooth;
}

body {
  font-family: 'Merriweather', serif;
  margin: 0;
  padding: 2rem 1rem;
  font-size: 15px;
  line-height: 1.5;
  transition: background-color 0.3s, color 0.3s;
}

.container {
  max-width: 700px;
  margin: 0 auto;
  padding: 1rem 2rem;
  box-shadow: 0 0 15px rgba(0,0,0,0.1);
}

h1, h2, h3 {
  font-weight: 600;
  margin-top: 2.5rem;
  margin-bottom: 1rem;
  line-height: 1.2;
}

h1 { font-size: 1.8rem; }
h2 { font-size: 1.4rem; }
h3 { font-size: 1.2rem; }

table {
  width: 100%;
  border-collapse: collapse;
  font-family: sans-serif;
  font-size: 1em;
  margin: 1em 0;
}

th, td {
  padding: 0.6em 1em;
  text-align: left;
  border: 1px solid;
}

tr:nth-child(even) {
  background-color: inherit;
}

tr:hover {
  background-color: inherit;
}

a {
  text-decoration: none;
  transition: color 0.2s;
}

a:hover {
  text-decoration: underline;
}

code {
  color: #d35400;
}

.book-title-chapter {
  font-family: 'Merriweather', serif;
  font-size: 2rem;
  font-weight: bold;
  text-align: center;
  margin-bottom: 2rem;
  border-bottom: 2px solid;
  padding-bottom: 0.5rem;
}

.book-subtitle-chapter {
  text-align: center;
  font-size: 1rem;
  margin-top: -1rem;
  margin-bottom: 2rem;
}

.related-books {
  margin-top: 40px;
}

.related-book-list {
  display: flex;
  flex-wrap: wrap;
  gap: 20px;
}

    .book-cover {
      width: 130px;
      height: 180px;
      font-family: Arial, sans-serif;
      position: relative;
      overflow: hidden;      
      line-height: normal;
      box-shadow: 2px 2px 4px rgba(0,0,0,0.1);
    }
    .book-cover-bottom-stripe {
      position: absolute;
      bottom: 0;
      left: 0;
      height: 5px;
      width: 100%;
    }
    .book-cover-title {
      position: absolute;
      width: 100%;
      text-align: center;
      font-weight: bold;
    }
     
    .book-cover-icon {
      position: absolute;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      align-items: center;
      justify-content: center; 
    }

    .book-cover-author {
      position: absolute;
      bottom: 10px;
      width: 100%;
      text-align: center;
      font-size: 8px;
      color: #333;
    }

.page-footer {
  margin-top: 4rem;
  padding: 1rem 0;
  text-align: center;
  font-size: 0.85rem;
  border-top: 1px solid;
}

.chapter-navi-section {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding-bottom: 10px;
}

.nav-link {
  color: inherit;
  text-decoration: none;
  opacity: 0.5;
  transition: opacity 0.3s ease, text-decoration 0.3s ease;
}

.nav-link:hover {
  opacity: 0.9;
  text-decoration: underline;
}

.prev { text-align: left; }
.toc-link { text-align: center; }
.next { text-align: right; }

.download-section {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 2rem;
  padding: 2rem 1rem;
  max-width: 600px;
  margin: 3rem auto;
  border-radius: 12px;
  box-shadow: 0 4px 10px rgba(0,0,0,0.05);
}

.download-info h2 {
  margin: 0 0 0.5rem;
  font-size: 1.2rem;
}

.format-label {
  margin: 0 0 0.5rem;
  font-size: 0.95rem;
}

.download-buttons {
  display: flex;
  gap: 1rem;
}

.download-button {
  background-color: #4A90E2;
  color: white;
  padding: 0.5em 1.2em;
  border-radius: 25px;
  font-size: 0.95rem;
  text-decoration: none;
  transition: background-color 0.3s ease;
}

.download-button:hover {
  background-color: #357ABD;
}

.code-block {
  position: relative;
  margin-bottom: 1em;
}

.copy-button {
  background: transparent;
  color: white;
  position: absolute;
  top: 8px;
  right: 8px;
  border: none;
  padding: 4px 8px;
  font-size: 12px;
  border-radius: 4px;
  cursor: pointer;
  z-index: 1;
}

.copy-button:hover {
  background-color: #0056b3;
}

.snippet-container {
  overflow: hidden;
}

.snippet-header {
  padding: 0.75rem 1rem;
  cursor: pointer;
  font-size: 1rem;
    background-color: #eeeeee;
    color:  #111111; 
    border-radius: 8px;
    cursor: pointer;
    box-shadow: 0 4px 6px rgba(0,0,0,0.1);  
}

.snippet-body {
  display: none;
  font-family: monospace;
}

.snippet-container.open .snippet-body {
  display: block;
}

.CodeMirror {
  border: 2px solid #ccc;
  border-radius: 4px;
  resize: vertical;
}

/* === Light Mode === */
html.light-mode {
  background-color: #f8f7f5;
  color: #333;
}

html.light-mode .container {
  background: white;
}

html.light-mode .book-title-chapter {
  color: #2c3e50;
  border-color: #ccc;
}
html.light-mode .book-subtitle-chapter{
  color: #888;
}

html.light-mode .page-footer,
html.light-mode .series-name,
html.light-mode .book-subtitle,
html.light-mode .format-label {
  color: #888;
}

html.light-mode .related-books h2 {
  color: #333;
  border-bottom: 2px solid #eee;
}

html.light-mode .book-title {
  color: #fff;
}

html.light-mode .book-cover {
  border: 1px solid #ccc;
}

html.light-mode th {
  background-color: #f2f2f2;
}

html.light-mode tr:nth-child(even) {
  background-color: #fafafa;
}

html.light-mode tr:hover {
  background-color: #e6f7ff;
}

html.light-mode a,
html.light-mode .page-footer a {
  color: #000;
}

/* === Dark Mode === */
html.dark-mode {
  background-color: #181818;
  color: #e0e0e0;
}

html.dark-mode .container {
  background: #222;
}

html.dark-mode .book-title-chapter {
  color: #ddd;
  border-color: #444;
}

html.dark-mode .snippet-header {
    background-color: #333;
    color:  #ddd; 
}


html.dark-mode .book-subtitle-chapter,
html.dark-mode .page-footer,
html.dark-mode .series-name,
html.dark-mode .book-subtitle,
html.dark-mode .book-footer,
html.dark-mode .format-label {
  color: #aaa;
}

html.dark-mode .related-books h2 {
  color: #ddd;
  border-bottom: 2px solid #333;
}

html.dark-mode .book-title {
  color: #fff;
}

html.dark-mode .book-cover {
  border: 1px solid #555;
}

html.dark-mode th {
  background-color: #333;
  color: #fff;
}

html.dark-mode td {
  border-color: #444;
}

html.dark-mode tr:nth-child(even) {
  background-color: #2a2a2a;
}

html.dark-mode tr:hover {
  background-color: #2c3e50;
}

html.dark-mode a,
html.dark-mode .page-footer a {
  color: #eee;
}

    .dialog-backdrop {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: rgba(0,0,0,0.5);
      display: none;
      justify-content: center;
      align-items: center;
      z-index: 10;
    }

    .dialog {
      background: white;
      padding: 20px;
      width: 90vw;
      height: 80vh;
      border-radius: 8px;
      box-shadow: 0 0 20px rgba(0,0,0,0.3);
      display: flex;
      flex-direction: column;
    }
    .dialog-content {
      display: flex;
      flex: 1;
      gap: 20px;
      margin-top: 10px;
    }
    .dialog h2 {
      margin-top: 0;
    }

    .textarea_dialog {
      width: 50%;
      height: 100%;
      resize: none;
      font-family: monospace;
      font-size: 14px;
      padding: 10px;
      box-sizing: border-box;
      border: 1px solid #ccc;
    }

    .iframe_dialog {
      width: 50%;
      height: 100%;
      border: 1px solid #ccc;
    }
    .controls_dialog {
      display: flex;
      justify-content: space-between;
      margin-top: 10px;
    }    
    button { padding: 0.5em 1em; background: green; color: white; border: none; cursor: pointer; }
    button:hover { background: #1e7e34; }
    .result_iframe { width:99%; height:200px; margin-top: 1em;  resize: both;border:1px solid #ccc;}        
</style>
</head>
<body> 
  <div class="container">
    <div class = "chapter-navi-section">
<a href="c-for-beginners-modular-programming-in-c.htm" class="nav-button prev">←</a>
<a href='c-for-beginners.htm#data-structures-in-c' class="nav-button toc-link">Index</a>
<a href="c-for-beginners-working-with-the-c-standard-library.htm" class="nav-button next">→</a>
</div>

    <h1 class="book-title-chapter" id = 'top'>Data Structures in C</h1>
    <h3 class="book-subtitle-chapter">C for Beginners</h3>   
    <!-- <h1 class ="chapter-title"></h1> -->
    <h2 id='linked-lists-singly-doubly'>16.1 Linked Lists (Singly, Doubly)</h2><p>A <strong>linked list</strong> is a fundamental dynamic data structure in C used to store collections of elements called <strong>nodes</strong>. Unlike arrays, linked lists do not require a fixed size at compile time. Instead, nodes are dynamically allocated in memory, and each node contains data along with pointers that link it to other nodes in the sequence.</p><p>There are two main types of linked lists:</p><ul>
 <li><strong>Singly Linked List</strong>: Each node points only to the next node.</li>
 <li><strong>Doubly Linked List</strong>: Each node points both to the next and the previous node.</li>
</ul><h3 id="singly-linked-lists">Singly Linked Lists</h3><h4 id="structure-definition">Structure Definition</h4><p>A singly linked list node is typically defined like this:</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-c">struct Node {
    int data;
    struct Node* next;
};</code></pre>
</div><p>Each node contains an integer value (<code>data</code>) and a pointer to the next node (<code>next</code>).</p><h4 id="creating-and-inserting-nodes">Creating and Inserting Nodes</h4><p>You can dynamically allocate a new node using <code>malloc</code> and link it to other nodes:</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

struct Node {
    int data;
    struct Node* next;
};

// Function to create a new node
struct Node* createNode(int value) {
    struct Node* newNode = (struct Node*) malloc(sizeof(struct Node));
    newNode-&gt;data = value;
    newNode-&gt;next = NULL;
    return newNode;
}</code></pre>
</div><p>To insert a node at the beginning:</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-c">void insertAtHead(struct Node** head, int value) {
    struct Node* newNode = createNode(value);
    newNode-&gt;next = *head;
    *head = newNode;
}</code></pre>
</div><p>To insert at the end:</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-c">void insertAtEnd(struct Node** head, int value) {
    struct Node* newNode = createNode(value);
    if (*head == NULL) {
        *head = newNode;
        return;
    }
    struct Node* temp = *head;
    while (temp-&gt;next != NULL) {
        temp = temp-&gt;next;
    }
    temp-&gt;next = newNode;
}</code></pre>
</div><h4 id="traversing-the-list">Traversing the List</h4><p>Traversal involves walking through each node:</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-c">void printList(struct Node* head) {
    while (head != NULL) {
        printf("%d -&gt; ", head-&gt;data);
        head = head-&gt;next;
    }
    printf("NULL\n");
}</code></pre>
</div><h4 id="deleting-a-node">Deleting a Node</h4><p>To delete the first occurrence of a value:</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-c">void deleteNode(struct Node** head, int key) {
    struct Node* temp = *head;
    struct Node* prev = NULL;

    if (temp != NULL &amp;&amp; temp-&gt;data == key) {
        *head = temp-&gt;next;
        free(temp);
        return;
    }

    while (temp != NULL &amp;&amp; temp-&gt;data != key) {
        prev = temp;
        temp = temp-&gt;next;
    }

    if (temp == NULL) return;

    prev-&gt;next = temp-&gt;next;
    free(temp);
}</code></pre>
</div><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

// Node structure
struct Node {
    int data;
    struct Node* next;
};

// Create a new node
struct Node* createNode(int value) {
    struct Node* newNode = (struct Node*) malloc(sizeof(struct Node));
    if (!newNode) {
        printf("Memory allocation failed\n");
        exit(1);
    }
    newNode-&gt;data = value;
    newNode-&gt;next = NULL;
    return newNode;
}

// Insert at the head
void insertAtHead(struct Node** head, int value) {
    struct Node* newNode = createNode(value);
    newNode-&gt;next = *head;
    *head = newNode;
}

// Insert at the end
void insertAtEnd(struct Node** head, int value) {
    struct Node* newNode = createNode(value);
    if (*head == NULL) {
        *head = newNode;
        return;
    }
    struct Node* temp = *head;
    while (temp-&gt;next != NULL) {
        temp = temp-&gt;next;
    }
    temp-&gt;next = newNode;
}

// Print the list
void printList(struct Node* head) {
    while (head != NULL) {
        printf("%d -&gt; ", head-&gt;data);
        head = head-&gt;next;
    }
    printf("NULL\n");
}

// Delete first occurrence of a value
void deleteNode(struct Node** head, int key) {
    struct Node* temp = *head;
    struct Node* prev = NULL;

    if (temp != NULL &amp;&amp; temp-&gt;data == key) {
        *head = temp-&gt;next;
        free(temp);
        return;
    }

    while (temp != NULL &amp;&amp; temp-&gt;data != key) {
        prev = temp;
        temp = temp-&gt;next;
    }

    if (temp == NULL) return;

    prev-&gt;next = temp-&gt;next;
    free(temp);
}

// Demo usage
int main() {
    struct Node* head = NULL;

    // Insert values
    insertAtEnd(&amp;head, 10);
    insertAtEnd(&amp;head, 20);
    insertAtHead(&amp;head, 5);
    insertAtEnd(&amp;head, 30);

    printf("List after insertions:\n");
    printList(head);

    // Delete a node
    deleteNode(&amp;head, 20);

    printf("List after deleting 20:\n");
    printList(head);

    // Cleanup
    while (head != NULL) {
        deleteNode(&amp;head, head-&gt;data);
    }

    return 0;
}</code></pre>
</div><h3 id="doubly-linked-lists">Doubly Linked Lists</h3><p>A <strong>doubly linked list</strong> provides more flexibility, as each node contains pointers to both the next and previous nodes.</p><h4 id="structure-definition">Structure Definition</h4><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-c">struct DNode {
    int data;
    struct DNode* prev;
    struct DNode* next;
};</code></pre>
</div><h4 id="inserting-at-the-beginning">Inserting at the Beginning</h4><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-c">void insertAtHead(struct DNode** head, int value) {
    struct DNode* newNode = (struct DNode*) malloc(sizeof(struct DNode));
    newNode-&gt;data = value;
    newNode-&gt;prev = NULL;
    newNode-&gt;next = *head;

    if (*head != NULL)
        (*head)-&gt;prev = newNode;

    *head = newNode;
}</code></pre>
</div><h4 id="inserting-at-the-end">Inserting at the End</h4><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-c">void insertAtEnd(struct DNode** head, int value) {
    struct DNode* newNode = (struct DNode*) malloc(sizeof(struct DNode));
    newNode-&gt;data = value;
    newNode-&gt;next = NULL;

    if (*head == NULL) {
        newNode-&gt;prev = NULL;
        *head = newNode;
        return;
    }

    struct DNode* temp = *head;
    while (temp-&gt;next != NULL)
        temp = temp-&gt;next;

    temp-&gt;next = newNode;
    newNode-&gt;prev = temp;
}</code></pre>
</div><h4 id="traversing-the-doubly-linked-list">Traversing the Doubly Linked List</h4><p>Forward traversal:</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-c">void printForward(struct DNode* head) {
    while (head != NULL) {
        printf("%d &lt;-&gt; ", head-&gt;data);
        head = head-&gt;next;
    }
    printf("NULL\n");
}</code></pre>
</div><p>Backward traversal:</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-c">void printBackward(struct DNode* tail) {
    while (tail != NULL) {
        printf("%d &lt;-&gt; ", tail-&gt;data);
        tail = tail-&gt;prev;
    }
    printf("NULL\n");
}</code></pre>
</div><h4 id="deleting-a-node">Deleting a Node</h4><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-c">void deleteNode(struct DNode** head, int key) {
    struct DNode* temp = *head;

    while (temp != NULL &amp;&amp; temp-&gt;data != key)
        temp = temp-&gt;next;

    if (temp == NULL) return;

    if (temp-&gt;prev != NULL)
        temp-&gt;prev-&gt;next = temp-&gt;next;
    else
        *head = temp-&gt;next;

    if (temp-&gt;next != NULL)
        temp-&gt;next-&gt;prev = temp-&gt;prev;

    free(temp);
}</code></pre>
</div><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

struct DNode {
    int data;
    struct DNode* prev;
    struct DNode* next;
};

// Function declarations
void printBackward(struct DNode* tail);

// Insert at head
void insertAtHead(struct DNode** head, int value) {
    struct DNode* newNode = (struct DNode*) malloc(sizeof(struct DNode));
    newNode-&gt;data = value;
    newNode-&gt;prev = NULL;
    newNode-&gt;next = *head;

    if (*head != NULL)
        (*head)-&gt;prev = newNode;

    *head = newNode;
}

// Insert at end
void insertAtEnd(struct DNode** head, int value) {
    struct DNode* newNode = (struct DNode*) malloc(sizeof(struct DNode));
    newNode-&gt;data = value;
    newNode-&gt;next = NULL;

    if (*head == NULL) {
        newNode-&gt;prev = NULL;
        *head = newNode;
        return;
    }

    struct DNode* temp = *head;
    while (temp-&gt;next != NULL)
        temp = temp-&gt;next;

    temp-&gt;next = newNode;
    newNode-&gt;prev = temp;
}

// Print forward
void printForward(struct DNode* head) {
    printf("Forward: ");
    struct DNode* last = NULL;
    while (head != NULL) {
        printf("%d &lt;-&gt; ", head-&gt;data);
        last = head;
        head = head-&gt;next;
    }
    printf("NULL\n");

    printf("Backward: ");
    printBackward(last);
}

// Print backward
void printBackward(struct DNode* tail) {
    while (tail != NULL) {
        printf("%d &lt;-&gt; ", tail-&gt;data);
        tail = tail-&gt;prev;
    }
    printf("NULL\n");
}

// Delete node by value
void deleteNode(struct DNode** head, int key) {
    struct DNode* temp = *head;

    while (temp != NULL &amp;&amp; temp-&gt;data != key)
        temp = temp-&gt;next;

    if (temp == NULL) return;

    if (temp-&gt;prev != NULL)
        temp-&gt;prev-&gt;next = temp-&gt;next;
    else
        *head = temp-&gt;next;

    if (temp-&gt;next != NULL)
        temp-&gt;next-&gt;prev = temp-&gt;prev;

    free(temp);
}

// Free entire list
void freeList(struct DNode* head) {
    while (head != NULL) {
        struct DNode* next = head-&gt;next;
        free(head);
        head = next;
    }
}

int main() {
    struct DNode* head = NULL;

    insertAtEnd(&amp;head, 10);
    insertAtEnd(&amp;head, 20);
    insertAtHead(&amp;head, 5);
    insertAtEnd(&amp;head, 30);

    printForward(head);

    deleteNode(&amp;head, 20);
    printf("\nAfter deleting 20:\n");
    printForward(head);

    freeList(head);

    return 0;
}</code></pre>
</div><h3 id="comparing-linked-lists-and-arrays">Comparing Linked Lists and Arrays</h3><table>
 <thead>
  <tr>
   <th>Feature</th>
   <th>Arrays</th>
   <th>Linked Lists</th>
  </tr>
 </thead>
 <tbody>
  <tr>
   <td>Size</td>
   <td>Fixed</td>
   <td>Dynamic</td>
  </tr>
  <tr>
   <td>Memory</td>
   <td>Contiguous</td>
   <td>Non-contiguous</td>
  </tr>
  <tr>
   <td>Insertion</td>
   <td>Costly (O(n))</td>
   <td>Efficient at ends (O(1))</td>
  </tr>
  <tr>
   <td>Deletion</td>
   <td>Costly (O(n))</td>
   <td>Efficient at ends (O(1))</td>
  </tr>
  <tr>
   <td>Access</td>
   <td>Fast (O(1)) by index</td>
   <td>Sequential (O(n))</td>
  </tr>
  <tr>
   <td>Overhead</td>
   <td>Minimal</td>
   <td>Extra memory for pointers</td>
  </tr>
 </tbody>
</table><p>Linked lists are useful when:</p><ul>
 <li>You need a dynamic collection with frequent insertions/deletions.</li>
 <li>You want to avoid resizing issues with arrays.</li>
</ul><p>However, arrays are preferred when:</p><ul>
 <li>You need fast random access.</li>
 <li>Memory is tight and predictable.</li>
</ul><h3 id="conclusion">Conclusion</h3><p>Linked lists are an essential data structure that provide dynamic memory management and efficient insertion and deletion operations. Mastering both singly and doubly linked lists helps you understand how memory and pointers work in C. While arrays are simpler and faster for access, linked lists shine when flexibility and scalability are key.</p><p>In the next section, you’ll learn about <strong>stacks and queues</strong>, two powerful abstract data types often implemented using linked lists or arrays.</p><div class = "chapter-navi-section">
<a href="#top" class="nav-button prev">↑</a>
<a href='c-for-beginners.htm#data-structures-in-c' class="nav-button toc-link">Index</a>
<a href="#bottom" class="nav-button next">↓</a>
</div>
<h2 id='stacks-and-queues'>16.2 Stacks and Queues</h2><p><strong>Stacks</strong> and <strong>queues</strong> are two essential abstract data types (ADTs) used in computer science. Though they differ in behavior, both are linear data structures that can be implemented using arrays or linked lists in C. Understanding them helps you build logic for applications like compilers, task schedulers, operating systems, and more.</p><h3 id="stack-last-in-first-out-lifo">Stack: Last-In, First-Out (LIFO)</h3><p>A <strong>stack</strong> is a linear data structure that follows the <strong>Last-In, First-Out</strong> principle. The last element added (pushed) is the first one to be removed (popped). Imagine a stack of plates—new plates are added on top and removed from the top.</p><h4 id="stack-operations">Stack Operations</h4><ul>
 <li><strong>Push</strong>: Add an element to the top.</li>
 <li><strong>Pop</strong>: Remove the top element.</li>
 <li><strong>Peek/Top</strong>: View the top element without removing it.</li>
 <li><strong>isEmpty</strong>: Check if the stack is empty.</li>
</ul><h3 id="stack-implementation-using-arrays">Stack Implementation Using Arrays</h3><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-c">#include &lt;stdio.h&gt;
#define MAX 100

int stack[MAX];
int top = -1;

void push(int value) {
    if (top &gt;= MAX - 1) {
        printf("Stack Overflow\n");
        return;
    }
    stack[++top] = value;
}

int pop() {
    if (top &lt; 0) {
        printf("Stack Underflow\n");
        return -1;
    }
    return stack[top--];
}

int peek() {
    if (top &lt; 0) {
        printf("Stack is empty\n");
        return -1;
    }
    return stack[top];
}
 
int main() {
    push(10);
    push(20);
    printf("Top: %d\n", peek());
    printf("Popped: %d\n", pop());
    printf("Top after pop: %d\n", peek());
    return 0;
}</code></pre>
</div><h3 id="stack-implementation-using-linked-list">Stack Implementation Using Linked List</h3><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

struct Node {
    int data;
    struct Node* next;
};

struct Node* top = NULL;

void push(int value) {
    struct Node* newNode = (struct Node*) malloc(sizeof(struct Node));
    newNode-&gt;data = value;
    newNode-&gt;next = top;
    top = newNode;
}

int pop() {
    if (top == NULL) {
        printf("Stack Underflow\n");
        return -1;
    }
    int val = top-&gt;data;
    struct Node* temp = top;
    top = top-&gt;next;
    free(temp);
    return val;
}</code></pre>
</div><h3 id="applications-of-stacks">Applications of Stacks</h3><ul>
 <li>Expression evaluation (postfix/infix)</li>
 <li>Function call management (recursion)</li>
 <li>Undo functionality in editors</li>
 <li>Syntax parsing</li>
</ul><h3 id="queue-first-in-first-out-fifo">Queue: First-In, First-Out (FIFO)</h3><p>A <strong>queue</strong> follows the <strong>First-In, First-Out</strong> principle. Think of a line at a bank: the first person to arrive is the first to be served.</p><h4 id="queue-operations">Queue Operations</h4><ul>
 <li><strong>Enqueue</strong>: Add an element to the rear.</li>
 <li><strong>Dequeue</strong>: Remove the element at the front.</li>
 <li><strong>Peek/Front</strong>: View the front element.</li>
 <li><strong>isEmpty</strong>: Check if the queue is empty.</li>
</ul><h3 id="queue-implementation-using-arrays">Queue Implementation Using Arrays</h3><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-c">#include &lt;stdio.h&gt;
#define SIZE 100

int queue[SIZE];
int front = -1, rear = -1;

void enqueue(int value) {
    if (rear == SIZE - 1) {
        printf("Queue Overflow\n");
        return;
    }
    if (front == -1) front = 0;
    queue[++rear] = value;
}

int dequeue() {
    if (front == -1 || front &gt; rear) {
        printf("Queue Underflow\n");
        return -1;
    }
    return queue[front++];
}
 
int main() {
    enqueue(5);
    enqueue(10);
    printf("Dequeued: %d\n", dequeue());
    enqueue(15);
    printf("Dequeued: %d\n", dequeue());
    return 0;
}</code></pre>
</div><h3 id="queue-implementation-using-linked-list">Queue Implementation Using Linked List</h3><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

struct Node {
    int data;
    struct Node* next;
};

struct Node *front = NULL, *rear = NULL;

void enqueue(int value) {
    struct Node* newNode = (struct Node*) malloc(sizeof(struct Node));
    newNode-&gt;data = value;
    newNode-&gt;next = NULL;
    if (rear == NULL) {
        front = rear = newNode;
    } else {
        rear-&gt;next = newNode;
        rear = newNode;
    }
}

int dequeue() {
    if (front == NULL) {
        printf("Queue Underflow\n");
        return -1;
    }
    int val = front-&gt;data;
    struct Node* temp = front;
    front = front-&gt;next;
    if (front == NULL) rear = NULL;
    free(temp);
    return val;
}</code></pre>
</div><h3 id="applications-of-queues">Applications of Queues</h3><ul>
 <li>Task scheduling (OS job queues)</li>
 <li>Breadth-first search (BFS) in graphs</li>
 <li>Print queues and IO buffers</li>
 <li>Data stream management</li>
</ul><h3 id="comparison-stack-vs-queue">Comparison: Stack vs Queue</h3><table>
 <thead>
  <tr>
   <th>Feature</th>
   <th>Stack</th>
   <th>Queue</th>
  </tr>
 </thead>
 <tbody>
  <tr>
   <td>Order</td>
   <td>LIFO</td>
   <td>FIFO</td>
  </tr>
  <tr>
   <td>Insertion</td>
   <td>At the top</td>
   <td>At the rear</td>
  </tr>
  <tr>
   <td>Deletion</td>
   <td>From the top</td>
   <td>From the front</td>
  </tr>
  <tr>
   <td>Common Use</td>
   <td>Function calls</td>
   <td>Scheduling, BFS</td>
  </tr>
 </tbody>
</table><h3 id="conclusion">Conclusion</h3><p>Stacks and queues are vital tools in your data structure toolkit. Stacks work well for backtracking and nested problems, while queues are ideal for managing ordered tasks and sequential processing. By learning to implement them using arrays and linked lists, you gain flexibility in how you manage data and build more efficient C programs.</p><p>In the next section, we’ll dive into <strong>trees</strong>, another foundational data structure with powerful hierarchical applications.</p><div class = "chapter-navi-section">
<a href="#top" class="nav-button prev">↑</a>
<a href='c-for-beginners.htm#data-structures-in-c' class="nav-button toc-link">Index</a>
<a href="#bottom" class="nav-button next">↓</a>
</div>
<h2 id='trees-binary-trees-traversals'>16.3 Trees (Binary Trees, Traversals)</h2><p>A <strong>binary tree</strong> is a hierarchical data structure in which each node has at most two children: a <strong>left</strong> child and a <strong>right</strong> child. This structure is widely used in programming for organizing, storing, and retrieving hierarchical or sorted data efficiently.</p><p>Binary trees are the foundation for many advanced data structures, such as binary search trees (BSTs), heaps, and syntax trees used in compilers. Understanding their structure and how to traverse them is crucial for building efficient algorithms.</p><h3 id="structure-of-a-binary-tree-node">Structure of a Binary Tree Node</h3><p>In C, a binary tree node is commonly represented using a <code>struct</code> with three members: the data stored in the node, a pointer to the left child, and a pointer to the right child.</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

struct Node {
    int data;
    struct Node* left;
    struct Node* right;
};</code></pre>
</div><p>To create a new node:</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-c">struct Node* createNode(int value) {
    struct Node* newNode = (struct Node*) malloc(sizeof(struct Node));
    newNode-&gt;data = value;
    newNode-&gt;left = newNode-&gt;right = NULL;
    return newNode;
}</code></pre>
</div><h3 id="binary-tree-traversals">Binary Tree Traversals</h3><p>Traversal refers to the process of visiting all the nodes in a tree in a particular order. The three most common types of depth-first traversal are:</p><ol>
 <li><strong>Inorder</strong> (Left, Root, Right)</li>
 <li><strong>Preorder</strong> (Root, Left, Right)</li>
 <li><strong>Postorder</strong> (Left, Right, Root)</li>
</ol><p>These can be implemented recursively or iteratively.</p><h4 id="inorder-traversal-recursive">Inorder Traversal (Recursive)</h4><p>In an inorder traversal, we visit the left subtree, then the root node, and finally the right subtree.</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-c">void inorder(struct Node* root) {
    if (root != NULL) {
        inorder(root-&gt;left);
        printf("%d ", root-&gt;data);
        inorder(root-&gt;right);
    }
}</code></pre>
</div><p><strong>Example Output</strong>: For a tree with root <code>10</code>, left child <code>5</code>, and right child <code>15</code>, the output is: <code>5 10 15</code></p><p>This traversal is particularly useful in <strong>binary search trees (BSTs)</strong>, as it visits the nodes in ascending order.</p><h4 id="preorder-traversal-recursive">Preorder Traversal (Recursive)</h4><p>In preorder traversal, we visit the root node first, then the left subtree, and then the right subtree.</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-c">void preorder(struct Node* root) {
    if (root != NULL) {
        printf("%d ", root-&gt;data);
        preorder(root-&gt;left);
        preorder(root-&gt;right);
    }
}</code></pre>
</div><p><strong>Use case</strong>: Preorder is useful for copying a tree or expressing tree structures (e.g., for printing).</p><h4 id="postorder-traversal-recursive">Postorder Traversal (Recursive)</h4><p>In postorder traversal, we visit the left and right subtrees before visiting the root node.</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-c">void postorder(struct Node* root) {
    if (root != NULL) {
        postorder(root-&gt;left);
        postorder(root-&gt;right);
        printf("%d ", root-&gt;data);
    }
}</code></pre>
</div><p><strong>Use case</strong>: Postorder is often used to <strong>delete or free memory</strong> in a tree from the leaves up.</p><h3 id="iterative-traversals-inorder-example">Iterative Traversals (Inorder Example)</h3><p>Recursive methods are elegant but rely on the system's call stack. For large trees, it may be better to use iterative solutions with an explicit stack.</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-c">#include &lt;stdbool.h&gt;

#define MAX 100
struct Node* stack[MAX];
int top = -1;

void push(struct Node* node) {
    stack[++top] = node;
}

struct Node* pop() {
    return stack[top--];
}

bool isEmpty() {
    return top == -1;
}

void inorderIterative(struct Node* root) {
    struct Node* current = root;
    while (current != NULL || !isEmpty()) {
        while (current != NULL) {
            push(current);
            current = current-&gt;left;
        }
        current = pop();
        printf("%d ", current-&gt;data);
        current = current-&gt;right;
    }
}</code></pre>
</div><h3 id="building-a-simple-binary-tree">Building a Simple Binary Tree</h3><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-c">int main() {
    struct Node* root = createNode(10);
    root-&gt;left = createNode(5);
    root-&gt;right = createNode(15);
    root-&gt;left-&gt;left = createNode(2);
    root-&gt;left-&gt;right = createNode(7);

    printf("Inorder: ");
    inorder(root);
    printf("\nPreorder: ");
    preorder(root);
    printf("\nPostorder: ");
    postorder(root);
    return 0;
}</code></pre>
</div><p><strong>Output</strong>:</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-bash">Inorder: 2 5 7 10 15
Preorder: 10 5 2 7 15
Postorder: 2 7 5 15 10</code></pre>
</div><h3 id="practical-applications-of-trees">Practical Applications of Trees</h3><ul>
 <li><strong>Binary Search Trees (BSTs)</strong>: Allow efficient searching, insertion, and deletion in O(log n) time (on average).</li>
 <li><strong>Expression Trees</strong>: Used to evaluate mathematical expressions.</li>
 <li><strong>Hierarchical Databases</strong>: Represent file systems or organizational charts.</li>
 <li><strong>Huffman Trees</strong>: Used in data compression algorithms.</li>
</ul><h3 id="benefits-and-drawbacks">Benefits and Drawbacks</h3><p><strong>Advantages:</strong></p><ul>
 <li>Efficient for representing hierarchical relationships.</li>
 <li>BSTs offer fast lookups for sorted data.</li>
 <li>Dynamic structure that grows or shrinks as needed.</li>
</ul><p><strong>Disadvantages:</strong></p><ul>
 <li>Not cache-friendly (nodes are dynamically allocated).</li>
 <li>Can become unbalanced without additional logic (e.g., AVL or Red-Black trees).</li>
 <li>Harder to implement compared to arrays or linked lists.</li>
</ul><h3 id="summary">Summary</h3><p>Binary trees provide a flexible and powerful way to organize hierarchical data. By understanding node structure and traversal techniques (inorder, preorder, postorder), you can effectively use trees in a variety of programming scenarios—from searching and sorting to parsing expressions and managing complex data.</p><p>Next, we’ll explore <strong>hash tables</strong>, a key-value data structure that enables fast access and storage based on computed indices.</p><div class = "chapter-navi-section">
<a href="#top" class="nav-button prev">↑</a>
<a href='c-for-beginners.htm#data-structures-in-c' class="nav-button toc-link">Index</a>
<a href="#bottom" class="nav-button next">↓</a>
</div>
<h2 id='hash-tables-basic-implementation'>16.4 Hash Tables (Basic Implementation)</h2><p>A <strong>hash table</strong> is a powerful data structure that allows for fast storage and retrieval of key-value pairs. Hash tables are commonly used for implementing dictionaries, symbol tables, caches, and indexing systems. The main idea is to use a <strong>hash function</strong> to map keys to specific locations in a <strong>table (array)</strong>, allowing for <strong>average-case constant-time</strong> (<code>O(1)</code>) lookups, insertions, and deletions.</p><h3 id="how-a-hash-table-works">How a Hash Table Works</h3><p>At the core of a hash table is a <strong>hash function</strong>, which takes a key (usually a string or integer) and converts it into an index within the bounds of an array. Each element of the array is called a <strong>bucket</strong>. If multiple keys hash to the same index (called a <strong>collision</strong>), the table needs a strategy to handle it. The most common strategy is <strong>separate chaining</strong>, where each bucket holds a <strong>linked list</strong> of entries.</p><h3 id="hash-function">Hash Function</h3><p>A good hash function distributes keys uniformly across the buckets. For integers, the modulo operation is often used:</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-c">int hash(int key, int tableSize) {
    return key % tableSize;
}</code></pre>
</div><p>For strings, a more complex function is needed to convert the character data into an integer hash code.</p><h3 id="defining-the-hash-table">Defining the Hash Table</h3><p>Let’s build a simple hash table in C that stores integer keys using <strong>separate chaining</strong> to resolve collisions.</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

#define TABLE_SIZE 10

// Node structure for chaining
struct Node {
    int key;
    struct Node* next;
};

// Hash table: array of pointers to Node
struct Node* hashTable[TABLE_SIZE];</code></pre>
</div><h3 id="hash-function">Hash Function</h3><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-c">int hash(int key) {
    return key % TABLE_SIZE;
}</code></pre>
</div><h3 id="insert-operation">Insert Operation</h3><p>To insert a key, compute the hash index and add the key to the front of the linked list at that bucket.</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-c">void insert(int key) {
    int index = hash(key);
    struct Node* newNode = (struct Node*) malloc(sizeof(struct Node));
    newNode-&gt;key = key;
    newNode-&gt;next = hashTable[index];
    hashTable[index] = newNode;
}</code></pre>
</div><h3 id="search-operation">Search Operation</h3><p>To search for a key, compute the index and traverse the linked list at that bucket.</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-c">int search(int key) {
    int index = hash(key);
    struct Node* current = hashTable[index];
    while (current != NULL) {
        if (current-&gt;key == key) return 1;
        current = current-&gt;next;
    }
    return 0;
}</code></pre>
</div><h3 id="delete-operation">Delete Operation</h3><p>To delete a key, traverse the linked list at the bucket and remove the matching node.</p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-c">void delete(int key) {
    int index = hash(key);
    struct Node* current = hashTable[index];
    struct Node* prev = NULL;

    while (current != NULL) {
        if (current-&gt;key == key) {
            if (prev == NULL) {
                hashTable[index] = current-&gt;next;
            } else {
                prev-&gt;next = current-&gt;next;
            }
            free(current);
            printf("Key %d deleted.\n", key);
            return;
        }
        prev = current;
        current = current-&gt;next;
    }
    printf("Key %d not found.\n", key);
}</code></pre>
</div><h3 id="display-the-hash-table">Display the Hash Table</h3><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-c">void display() {
    for (int i = 0; i &lt; TABLE_SIZE; i++) {
        printf("[%d]:", i);
        struct Node* current = hashTable[i];
        while (current != NULL) {
            printf(" %d -&gt;", current-&gt;key);
            current = current-&gt;next;
        }
        printf(" NULL\n");
    }
}</code></pre>
</div><h3 id="example-usage">Example Usage</h3><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-c">int main() {
    insert(15);
    insert(25);
    insert(35);
    insert(5);
    display();

    printf("Search 25: %s\n", search(25) ? "Found" : "Not Found");
    delete(25);
    display();
    return 0;
}</code></pre>
</div><p><strong>Output:</strong></p><div class="code-block"><button class="copy-button" onclick="copyCode(this)">▯</button>
 <pre><code class="language-bash">[0]: NULL
[1]: 1 -&gt; NULL
[2]: 2 -&gt; NULL
[3]: 3 -&gt; NULL
[4]: 4 -&gt; NULL
[5]: 35 -&gt; 25 -&gt; 15 -&gt; 5 -&gt; NULL
...
Search 25: Found
Key 25 deleted.
...</code></pre>
</div><h3 id="limitations-and-considerations">Limitations and Considerations</h3><ol>
 <li><p><strong>Fixed Size</strong>: In our example, the table size is fixed. If too many elements are inserted, collisions become more frequent, reducing performance.</p></li>
 <li><p><strong>Load Factor</strong>: The <strong>load factor</strong> is the ratio of the number of elements to the number of buckets. A high load factor increases the number of collisions. Typical practice is to keep the load factor below <code>0.75</code>.</p></li>
 <li><p><strong>Resizing</strong>: To handle more data efficiently, hash tables should support <strong>dynamic resizing</strong>, which involves creating a larger table and <strong>rehashing</strong> existing keys into the new table.</p></li>
 <li><p><strong>Choice of Hash Function</strong>: A poor hash function can lead to clustering or uneven distribution, degrading performance.</p></li>
 <li><p><strong>Memory Overhead</strong>: Chaining adds memory overhead due to linked list nodes. An alternative is <strong>open addressing</strong>, which stores entries directly in the table and probes for empty slots.</p></li>
</ol><h3 id="summary">Summary</h3><p>Hash tables provide <strong>fast and efficient</strong> access to data using keys. In this section, you learned how to implement a basic hash table using separate chaining in C, including functions for insertion, search, and deletion. While this is a simplified version, it demonstrates the core mechanics that underpin more sophisticated hash table implementations.</p><p>By understanding hashing and collision resolution strategies, you are well-equipped to build and use hash tables in practical applications such as symbol tables, caches, and indexing systems.</p><div class = "chapter-navi-section">
<a href="c-for-beginners-modular-programming-in-c.htm" class="nav-button prev">←</a>
<a href='c-for-beginners.htm#data-structures-in-c' class="nav-button toc-link">Index</a>
<a href="c-for-beginners-working-with-the-c-standard-library.htm" class="nav-button next">→</a>
</div>
<section class="download-section">
  <div class="book-cover" style="background-color: #f9f6f1;border: 1px solid #ccc;"> 
    <div class="book-cover-title" style="font-size: 18px;color: #333;top: 20px;">C for Beginners</div>
    <div class="book-cover-author">readbytes</div>
    <div class="book-cover-bottom-stripe" style="background-color: #333;"></div>
    <img class="book-cover-icon" style="width: 90px;height: 90px;top: 70px;" src="data:image/png;base64,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"/>
  </div>
  <div class="download-info">
    <h2 id='bottom'>Download This Ebook</h2>
    <p class="format-label">Available formats:</p>
    <div class="download-buttons">
      <a href="c-for-beginners.pdf" class="download-button">📄 PDF</a>
      <a href="c-for-beginners.epub" class="download-button">📘 EPUB</a>
    </div>
  </div>
</section><div class='related-books'>
<h2>C Introduction Books</h2>
<div class='related-book-list'>
<a href="c-for-beginners.htm">
<div class="book-cover" style="background-color: #f9f6f1;border: 1px solid #ccc;"> 
    <div class="book-cover-title" style="font-size: 18px;color: #333;top: 20px;">C for Beginners</div>
    <div class="book-cover-author">readbytes</div>
    <div class="book-cover-bottom-stripe" style="background-color: #333;"></div>
    <img class="book-cover-icon" style="width: 90px;height: 90px;top: 70px;" src="data:image/png;base64,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"/>
  </div>
</a>


<a href="c-pointers.htm">
<div class="book-cover" style="background-color: #f9f6f1;border: 1px solid #ccc;"> 
    <div class="book-cover-title" style="font-size: 22px;color: #333;top: 20px;">C Pointers</div>
    <div class="book-cover-author">readbytes</div>
    <div class="book-cover-bottom-stripe" style="background-color: #333;"></div>
    <img class="book-cover-icon" style="width: 90px;height: 90px;top: 70px;" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFoAAABaCAYAAAA4qEECAAAD5ElEQVR4Xu2dwYoUVxhGr7hQn0F8AyH4Cq5cCwFxk2cQ3GXR1TK+QN5AssnWrRsfwWR0LbhJxKXoIhBQK2Olb5/v1tdV0/fHOPwHDtj/PbdudYHOuKpSkiRJkovFUP744qevvuSyZSin1d5TLlvGs85/7re553OzO3DfJXDPRd97bobylxy49HC2tZvylvkem/Je9uz8wHyPTfmzsWeng23toXs+Ch5GHWypgy11sKUOtjQMHkQdbKmDLXWwpQ62NAweRB1sqYMtdbClDrY0DB5EHWypgy11sKUOtjQMHkQdbKmDLXWwpQ62NAweRB1sqYMtdbClDrY0DB5EHWypgy11sKUOtjQMHkQdbKmDLXWwpQ62NAweRB1sqYMtdbClDrY0SZIkSZI18CdpGqMM0hhlkMYogzRGGaQxyiCNUQZpjDJIY5RBGqMM0hhlkMYogzRGGaQxyiCNUQZpjDJIY5RBT5fAPfO+W7xvabe2PUYZ9HQpQ7kjeynh+lzLNbqmPUYZ9NR/iYcH1uevdagnXJ/8pVxZ1PVQBj1d8iUmfi7XZW3ns+pKO7TTc3t0PZRBT5d8ibVNDTvXsxnKr0waTT9l0NMlX2Ji/GvMNTZDeYrP/0hbr9ecp+mpDHp66EscWh/dlgfS1LCv14fypPrz3ar5u5rXvV6rlzLo6Rq4t3WNafZjuSyz1p6zB31J2pr9Xq/VSxn0dAlDuSr7WtfYltfN+fj79dye8UHvf/4dn9nr+b2UQU9rlszpo/LDbFczt8YHTbTXe+ilDHpaU8+35adq/lj2tfY75vZND7p1raF8lDVep6cy6GnNmrVW4xjK8+Y+/6Bbvd5DL2XQ0xqujb8FTGzKfVl/UK5Ve180rWmdWz/oobz5b74p92Z63mM/ZdDTGq4dWndrkyflRrPZzeoHPf6bf+tfeZ3WNXorg57WcO3M29X6zebeuf+UaHfSmO0/6Dl3va71UgY9reGaa1qzOVvtxKb8Jn1L7o9QBmmMMkhjlEEaowzSGGWQxiiDNEYZpDHKII1RBmmMMkhjlEEaowzSGGWQxiiDNEYZpDHKII0xSZIkSZI18CcpdbClDrbUwZY62NIweBB1sKUOttTBljrY0jB4EHWwpQ621MGWOtjSMHgQdbClDrbUwZY62NIweBB1sKUOttTBljrY0jB4EHWwpQ621MGWOtjSMHgQdbClDrbUwZY62NIweBB1sKUOttTBljrY0jB4EHWwpQ621MGWOtjSMKJeSjZe13HMS8m23+NLyUZ44JIbnuCei773aPZfpLjuJYzbI17CeNyLI+tzX3HZsn/uuntOkiRJ/vd8BnnbnC2TD9qmAAAAAElFTkSuQmCC"/>
  </div>
</a>



<a href='c.htm'><div class='book-cover' style='background-color: #f9f6f1;color: #111111;border: 1px solid #ccc;display: flex;justify-content: center;align-items: center;text-align: center;'>More C Books</div></a>
</div>
</div>
  </div>
  <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/prism.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
  
  <script>
    function copyCode(button) {
      const code = button.nextElementSibling.innerText;
      navigator.clipboard.writeText(code).then(() => {
        button.textContent = 'Copied!';
        setTimeout(() => { button.textContent = 'Copy'; }, 1500);
      });
    }
  </script>  
<div id="floatingLog" aria-live="polite" role="alert"></div>
<footer class="page-footer">
    <nav>
      <a href="https://readbytes.github.io">Home</a> | 
      Email:<script language="JavaScript" type="text/javascript">
var part1 = 'yinpeng';var part6 = '263';var part2 = Math.pow(2,6);var part3 = String.fromCharCode(part2);var part4 = 'hotmail dot com';var part5 = part1 + String.fromCharCode(part2) + part4;document.write(part1 + part6 + part3 + part4);
</script>
    </nav>
  <p>© 2025 — All rights reserved.</p>    
  </footer>

</body>
</html>